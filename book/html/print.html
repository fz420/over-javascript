<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Over javascript</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="javascript 笔记 https://github.com/overnote/over-javascript">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-JavaScript基础语法/index.html"><strong aria-hidden="true">1.</strong> 01-JavaScript 基础语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-JavaScript基础语法/01.1-JavaScript简介.html"><strong aria-hidden="true">1.1.</strong> 01.1-JavaScript 简介</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/02.1-标识符.html"><strong aria-hidden="true">1.2.</strong> 02.1-标识符</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/03.1-数据类型-数据类型的分类.html"><strong aria-hidden="true">1.3.</strong> 03.1-数据类型-数据类型的分类</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/03.2-数据类型-数据类型的转换.html"><strong aria-hidden="true">1.4.</strong> 03.2-数据类型-数据类型的转换</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/04.1-运算符.html"><strong aria-hidden="true">1.5.</strong> 04.1-运算符</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/05.1-流程控制.html"><strong aria-hidden="true">1.6.</strong> 05.1-流程控制</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/06.1-数组-数组的基本使用.html"><strong aria-hidden="true">1.7.</strong> 06.1-数组-数组的基本使用</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/07.1-函数-函数的基本使用.html"><strong aria-hidden="true">1.8.</strong> 07.1-函数-函数的基本使用</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/07.2-函数-递归与尾调用优化.html"><strong aria-hidden="true">1.9.</strong> 07.2-函数-递归与尾调用优化</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/08.1-作用域-作用域链.html"><strong aria-hidden="true">1.10.</strong> 08.1-作用域-作用域链</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/08.2-作用域-变量提升.html"><strong aria-hidden="true">1.11.</strong> 08.2-作用域-变量提升</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/08.3-作用域-匿名函数与闭包.html"><strong aria-hidden="true">1.12.</strong> 08.3-作用域-匿名函数与闭包</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/09.1-面向对象-思想概念.html"><strong aria-hidden="true">1.13.</strong> 09.1-面向对象-思想概念</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/09.2-面向对象-对象的创建方式.html"><strong aria-hidden="true">1.14.</strong> 09.2-面向对象-对象的创建方式</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/09.3-面向对象-ES6新增class关键字.html"><strong aria-hidden="true">1.15.</strong> 09.3-面向对象-ES6 新增 class 关键字</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/09.4-面向对象-原型与原型链.html"><strong aria-hidden="true">1.16.</strong> 09.4-面向对象-原型与原型链</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/09.5-面向对象-三大特性之封装.html"><strong aria-hidden="true">1.17.</strong> 09.5-面向对象-三大特性之封装</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/09.6-面向对象-三大特性之继承.html"><strong aria-hidden="true">1.18.</strong> 09.6-面向对象-三大特性之继承</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/09.7-面向对象-三大特性之-多态.html"><strong aria-hidden="true">1.19.</strong> 09.7-面向对象-三大特性之-多态</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/10.1-常用内置对象-基本包装类的使用.html"><strong aria-hidden="true">1.20.</strong> 10.1-常用内置对象-基本包装类的使用</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/10.2-常用内置对象-基本包装类String.html"><strong aria-hidden="true">1.21.</strong> 10.2-常用内置对象-基本包装类 String</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/10.3-常用内置对象-Date、Math、Global.html"><strong aria-hidden="true">1.22.</strong> 10.3-常用内置对象-Date、Math、Global</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/10.4-常用内置对象-Function.html"><strong aria-hidden="true">1.23.</strong> 10.4-常用内置对象-Function</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/10.5-常用内置对象-错误对象.html"><strong aria-hidden="true">1.24.</strong> 10.5-常用内置对象-错误对象</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/10.6-常用内置对象-正则表达式.html"><strong aria-hidden="true">1.25.</strong> 10.6-常用内置对象-正则表达式</a></li><li class="chapter-item expanded "><a href="01-JavaScript基础语法/11.1-基本类型-Symbol.html"><strong aria-hidden="true">1.26.</strong> 11.1-基本类型-Symbol</a></li></ol></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/index.html"><strong aria-hidden="true">2.</strong> 02-JavaScript 语法进阶</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/01.1-语法更迭-JS设计缺陷.html"><strong aria-hidden="true">2.1.</strong> 01.1-语法更迭-JS 设计缺陷</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/01.2-语法更迭-严格模式.html"><strong aria-hidden="true">2.2.</strong> 01.2-语法更迭-严格模式</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/01.3-语法更迭-ES6的改进.html"><strong aria-hidden="true">2.3.</strong> 01.3-语法更迭-ES6 的改进</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/02.1-基类Object-基本使用.html"><strong aria-hidden="true">2.4.</strong> 02.1-基类 Object-基本使用</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/02.2-基类Object-限制对象成员.html"><strong aria-hidden="true">2.5.</strong> 02.2-基类 Object-限制对象成员</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/03.1-对象操作-对象的检测.html"><strong aria-hidden="true">2.6.</strong> 03.1-对象操作-对象的检测</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/03.2-对象操作-对象的迭代合并与扩展.html"><strong aria-hidden="true">2.7.</strong> 03.2-对象操作-对象的迭代合并与扩展</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/03.3-对象操作-对象的拷贝.html"><strong aria-hidden="true">2.8.</strong> 03.3-对象操作-对象的拷贝</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/03.4-对象操作-对象的使用细节优化.html"><strong aria-hidden="true">2.9.</strong> 03.4-对象操作-对象的使用细节优化</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/04.1-容器对象-Array.html"><strong aria-hidden="true">2.10.</strong> 04.1-容器对象-Array</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/04.2-容器对象-Map与WeakMap.html"><strong aria-hidden="true">2.11.</strong> 04.2-容器对象-Map 与 WeakMap</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/04.3-容器对象-Set与WeakSet.html"><strong aria-hidden="true">2.12.</strong> 04.3-容器对象-Set 与 WeakSet</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/04.4-容器对象-定型数组.html"><strong aria-hidden="true">2.13.</strong> 04.4-容器对象-定型数组</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/05.1-迭代器与生成器-Iterator.html"><strong aria-hidden="true">2.14.</strong> 05.1-迭代器与生成器-Iterator</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/05.2-迭代器与生成器-Generator.html"><strong aria-hidden="true">2.15.</strong> 05.2-迭代器与生成器-Generator</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/06.1-异步编程-Promise基础.html"><strong aria-hidden="true">2.16.</strong> 06.1-异步编程-Promise 基础</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/06.2-异步编程-Promise其他设置.html"><strong aria-hidden="true">2.17.</strong> 06.2-异步编程-Promise 其他设置</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/06.3-异步编程-async与await.html"><strong aria-hidden="true">2.18.</strong> 06.3-异步编程-async 与 await</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/06.4-异步编程-异步迭代.html"><strong aria-hidden="true">2.19.</strong> 06.4-异步编程-异步迭代</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/07.1-代理与反射-代理.html"><strong aria-hidden="true">2.20.</strong> 07.1-代理与反射-代理</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/07.2-代理与反射-反射.html"><strong aria-hidden="true">2.21.</strong> 07.2-代理与反射-反射</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/07.3-代理与反射-捕获器API.html"><strong aria-hidden="true">2.22.</strong> 07.3-代理与反射-捕获器 API</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/07.4-代理与反射-代理的常见使用场景.html"><strong aria-hidden="true">2.23.</strong> 07.4-代理与反射-代理的常见使用场景</a></li><li class="chapter-item expanded "><a href="02-JavaScript语法进阶/附-ES规范.html"><strong aria-hidden="true">2.24.</strong> 附-ES 规范</a></li></ol></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/index.html"><strong aria-hidden="true">3.</strong> 03-BOM 与 DOM 编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-BOM与DOM编程/01.1-JavaScript在HTML中的使用.html"><strong aria-hidden="true">3.1.</strong> 01.1-JavaScript 在 HTML 中的使用</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/02.1-DOM与BOM概述.html"><strong aria-hidden="true">3.2.</strong> 02.1-DOM 与 BOM 概述</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/03.1-BOM-核心对象window.html"><strong aria-hidden="true">3.3.</strong> 03.1-BOM-核心对象 window</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/03.2-BOM-BOM的常见对象.html"><strong aria-hidden="true">3.4.</strong> 03.2-BOM-BOM 的常见对象</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/04.1-客户端检测.html"><strong aria-hidden="true">3.5.</strong> 04.1-客户端检测</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/05.1-DOM基础-DOM节点.html"><strong aria-hidden="true">3.6.</strong> 05.1-DOM 基础-DOM 节点</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/05.2-DOM基础-元素的增删改查.html"><strong aria-hidden="true">3.7.</strong> 05.2-DOM 基础-元素的增删改查</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/05.3-DOM基础-DOM事件.html"><strong aria-hidden="true">3.8.</strong> 05.3-DOM 基础-DOM 事件</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/05.4-DOM基础-事件流.html"><strong aria-hidden="true">3.9.</strong> 05.4-DOM 基础-事件流</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/05.5-DOM基础-坐标操作.html"><strong aria-hidden="true">3.10.</strong> 05.5-DOM 基础-坐标操作</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/05.6-DOM基础-范围操作.html"><strong aria-hidden="true">3.11.</strong> 05.6-DOM 基础-范围操作</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/05.7-DOM基础-MutationObserver.html"><strong aria-hidden="true">3.12.</strong> 05.7-DOM 基础-MutationObserver</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/06.1-表单-表单基础操作.html"><strong aria-hidden="true">3.13.</strong> 06.1-表单-表单基础操作</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/06.2-表单-文本框input与textarea.html"><strong aria-hidden="true">3.14.</strong> 06.2-表单-文本框 input 与 textarea</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/06.3-表单-选择框select.html"><strong aria-hidden="true">3.15.</strong> 06.3-表单-选择框 select</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/06.4-表单-表单提交操作.html"><strong aria-hidden="true">3.16.</strong> 06.4-表单-表单提交操作</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/06.5-表单-富文本编辑.html"><strong aria-hidden="true">3.17.</strong> 06.5-表单-富文本编辑</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/07.1-H5新功能-DOM操作变化.html"><strong aria-hidden="true">3.18.</strong> 07.1-H5 新功能-DOM 操作变化</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/07.2-H5新功能-跨文档通信与通知.html"><strong aria-hidden="true">3.19.</strong> 07.2-H5 新功能-跨文档通信与通知</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/07.3-H5新功能-媒体元素.html"><strong aria-hidden="true">3.20.</strong> 07.3-H5 新功能-媒体元素</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/07.4-H5新功能-原生拖放.html"><strong aria-hidden="true">3.21.</strong> 07.4-H5 新功能-原生拖放</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/07.5-H5新功能-动画.html"><strong aria-hidden="true">3.22.</strong> 07.5-H5 新功能-动画</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/07.6-H5新功能-计时 API.html"><strong aria-hidden="true">3.23.</strong> 07.6-H5 新功能-计时 API</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/08.1-H5组件化开发-HTML模板.html"><strong aria-hidden="true">3.24.</strong> 08.1-H5 组件化开发-HTML 模板</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/08.2-H5组件化开发-ShawdowDOM.html"><strong aria-hidden="true">3.25.</strong> 08.2-H5 组件化开发-ShawdowDOM</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/08.3-H5组件化开发-自定义元素.html"><strong aria-hidden="true">3.26.</strong> 08.3-H5 组件化开发-自定义元素</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/附录1-jQuery的基础使用.html"><strong aria-hidden="true">3.27.</strong> 附录 1-jQuery 的基础使用</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/附录2-jQuery的开发思想与技巧.html"><strong aria-hidden="true">3.28.</strong> 附录 2-jQuery 的开发思想与技巧</a></li><li class="chapter-item expanded "><a href="03-BOM与DOM编程/附录3-DOM事件汇总.html"><strong aria-hidden="true">3.29.</strong> 附录 3-DOM 事件汇总</a></li></ol></li><li class="chapter-item expanded "><a href="04-网络编程/index.html"><strong aria-hidden="true">4.</strong> 04-网络编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-网络编程/01.1-计算机网络简介.html"><strong aria-hidden="true">4.1.</strong> 01.1-计算机网络简介</a></li><li class="chapter-item expanded "><a href="04-网络编程/02.1-Http协议.html"><strong aria-hidden="true">4.2.</strong> 02.1-Http 协议</a></li><li class="chapter-item expanded "><a href="04-网络编程/03.1-Web开发介绍.html"><strong aria-hidden="true">4.3.</strong> 03.1-Web 开发介绍</a></li><li class="chapter-item expanded "><a href="04-网络编程/04.1-数据交互协议-JSON.html"><strong aria-hidden="true">4.4.</strong> 04.1-数据交互协议-JSON</a></li><li class="chapter-item expanded "><a href="04-网络编程/04.2-数据交互协议-XML.html"><strong aria-hidden="true">4.5.</strong> 04.2-数据交互协议-XML</a></li><li class="chapter-item expanded "><a href="04-网络编程/05.1-Ajax的XHR API-XHR对象.html"><strong aria-hidden="true">4.6.</strong> 05.1-Ajax 的 XHR API-XHR 对象</a></li><li class="chapter-item expanded "><a href="04-网络编程/05.2-Ajax的XHR_API-XHR_Level_2.html"><strong aria-hidden="true">4.7.</strong> 05.2-Ajax 的 XHR API-XHR Level 2</a></li><li class="chapter-item expanded "><a href="04-网络编程/06.1-Ajax的fetch API-fetch用法.html"><strong aria-hidden="true">4.8.</strong> 06.1-Ajax 的 fetch API-fetch 用法</a></li><li class="chapter-item expanded "><a href="04-网络编程/06.2-Ajax的fetch API-三大对象.html"><strong aria-hidden="true">4.9.</strong> 06.2-Ajax 的 fetch API-三大对象</a></li><li class="chapter-item expanded "><a href="04-网络编程/06.3-Ajax的fetch API-fetch的Body混入.html"><strong aria-hidden="true">4.10.</strong> 06.3-Ajax 的 fetch API-fetch 的 Body 混入</a></li><li class="chapter-item expanded "><a href="04-网络编程/07.1-跨域问题-跨域资源共享.html"><strong aria-hidden="true">4.11.</strong> 07.1-跨域问题-跨域资源共享</a></li><li class="chapter-item expanded "><a href="04-网络编程/07.2-跨域问题-替代性跨源技术.html"><strong aria-hidden="true">4.12.</strong> 07.2-跨域问题-替代性跨源技术</a></li><li class="chapter-item expanded "><a href="04-网络编程/08.1-WebSocket.html"><strong aria-hidden="true">4.13.</strong> 08.1-WebSocket</a></li><li class="chapter-item expanded "><a href="04-网络编程/09.1-客户端存储-cookie.html"><strong aria-hidden="true">4.14.</strong> 09.1-客户端存储-cookie</a></li><li class="chapter-item expanded "><a href="04-网络编程/09.2-客户端存储-WebStorage.html"><strong aria-hidden="true">4.15.</strong> 09.2-客户端存储-WebStorage</a></li><li class="chapter-item expanded "><a href="04-网络编程/09.3-客户端存储-IndexedDB.html"><strong aria-hidden="true">4.16.</strong> 09.3-客户端存储-IndexedDB</a></li><li class="chapter-item expanded "><a href="04-网络编程/10.1-JavaScriptAPI-Encoding编码解码.html"><strong aria-hidden="true">4.17.</strong> 10.1-JavaScriptAPI-Encoding 编码解码</a></li><li class="chapter-item expanded "><a href="04-网络编程/10.2-JavaScriptAPI-文件对象.html"><strong aria-hidden="true">4.18.</strong> 10.2-JavaScriptAPI-文件对象</a></li><li class="chapter-item expanded "><a href="04-网络编程/10.3-JavaScriptAPI-Stream流对象.html"><strong aria-hidden="true">4.19.</strong> 10.3-JavaScriptAPI-Stream 流对象</a></li><li class="chapter-item expanded "><a href="04-网络编程/10.4-JavaScriptAPI-Web加密对象.html"><strong aria-hidden="true">4.20.</strong> 10.4-JavaScriptAPI-Web 加密对象</a></li><li class="chapter-item expanded "><a href="04-网络编程/附录-网络开发常见问题.html"><strong aria-hidden="true">4.21.</strong> 附录-网络开发常见问题</a></li></ol></li><li class="chapter-item expanded "><a href="05-Node.js/index.html"><strong aria-hidden="true">5.</strong> 05-Node.js</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-Node.js/01.1-Node简介.html"><strong aria-hidden="true">5.1.</strong> 01.1-Node 简介</a></li><li class="chapter-item expanded "><a href="05-Node.js/02.1-常见核心模块.html"><strong aria-hidden="true">5.2.</strong> 02.1-常见核心模块</a></li><li class="chapter-item expanded "><a href="05-Node.js/03.1-使用机制-模块机制.html"><strong aria-hidden="true">5.3.</strong> 03.1-使用机制-模块机制</a></li><li class="chapter-item expanded "><a href="05-Node.js/03.2-使用机制-包管理机制.html"><strong aria-hidden="true">5.4.</strong> 03.2-使用机制-包管理机制</a></li><li class="chapter-item expanded "><a href="05-Node.js/04.1-新增对象-Buffer.html"><strong aria-hidden="true">5.5.</strong> 04.1-新增对象-Buffer</a></li><li class="chapter-item expanded "><a href="05-Node.js/04.2-新增对象-Stream.html"><strong aria-hidden="true">5.6.</strong> 04.2-新增对象-Stream</a></li><li class="chapter-item expanded "><a href="05-Node.js/05.1-网络编程.html"><strong aria-hidden="true">5.7.</strong> 05.1-网络编程</a></li><li class="chapter-item expanded "><a href="05-Node.js/06.1-Web功能-http服务.html"><strong aria-hidden="true">5.8.</strong> 06.1-Web 功能-http 服务</a></li><li class="chapter-item expanded "><a href="05-Node.js/06.2-Web功能-路由解析.html"><strong aria-hidden="true">5.9.</strong> 06.2-Web 功能-路由解析</a></li><li class="chapter-item expanded "><a href="05-Node.js/06.3-Web功能-静态服务.html"><strong aria-hidden="true">5.10.</strong> 06.3-Web 功能-静态服务</a></li><li class="chapter-item expanded "><a href="05-Node.js/06.4-Web功能-视图渲染.html"><strong aria-hidden="true">5.11.</strong> 06.4-Web 功能-视图渲染</a></li><li class="chapter-item expanded "><a href="05-Node.js/06.5-Web功能-文件上传.html"><strong aria-hidden="true">5.12.</strong> 06.5-Web 功能-文件上传</a></li><li class="chapter-item expanded "><a href="05-Node.js/07.1-Web框架-Express.html"><strong aria-hidden="true">5.13.</strong> 07.1-Web 框架-Express</a></li><li class="chapter-item expanded "><a href="05-Node.js/07.2-Web框架-Koa.html"><strong aria-hidden="true">5.14.</strong> 07.2-Web 框架-Koa</a></li><li class="chapter-item expanded "><a href="05-Node.js/08.1-鉴权-Cookie.html"><strong aria-hidden="true">5.15.</strong> 08.1-鉴权-Cookie</a></li><li class="chapter-item expanded "><a href="05-Node.js/08.2-鉴权-Session.html"><strong aria-hidden="true">5.16.</strong> 08.2-鉴权-Session</a></li><li class="chapter-item expanded "><a href="05-Node.js/08.3-鉴权-JWT.html"><strong aria-hidden="true">5.17.</strong> 08.3-鉴权-JWT</a></li><li class="chapter-item expanded "><a href="05-Node.js/09.1-Node连接数据库.html"><strong aria-hidden="true">5.18.</strong> 09.1-Node 连接数据库</a></li><li class="chapter-item expanded "><a href="05-Node.js/10.1-异常机制-错误处理.html"><strong aria-hidden="true">5.19.</strong> 10.1-异常机制-错误处理</a></li><li class="chapter-item expanded "><a href="05-Node.js/10.2-异常机制-日志功能.html"><strong aria-hidden="true">5.20.</strong> 10.2-异常机制-日志功能</a></li><li class="chapter-item expanded "><a href="05-Node.js/11.1-WebSocket.html"><strong aria-hidden="true">5.21.</strong> 11.1-WebSocket</a></li><li class="chapter-item expanded "><a href="05-Node.js/12.1-Node与加密-密码学.html"><strong aria-hidden="true">5.22.</strong> 12.1-Node 与加密-密码学</a></li><li class="chapter-item expanded "><a href="05-Node.js/12.2-Node与加密-加密通信.html"><strong aria-hidden="true">5.23.</strong> 12.2-Node 与加密-加密通信</a></li></ol></li><li class="chapter-item expanded "><a href="06-并发编程/index.html"><strong aria-hidden="true">6.</strong> 06-并发编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06-并发编程/01.1-并发的概念.html"><strong aria-hidden="true">6.1.</strong> 01.1-并发的概念</a></li><li class="chapter-item expanded "><a href="06-并发编程/02.1-并发模型-多进程.html"><strong aria-hidden="true">6.2.</strong> 02.1-并发模型-多进程</a></li><li class="chapter-item expanded "><a href="06-并发编程/02.2-并发模型-多线程.html"><strong aria-hidden="true">6.3.</strong> 02.2-并发模型-多线程</a></li><li class="chapter-item expanded "><a href="06-并发编程/02.3-并发模型-非阻塞IO.html"><strong aria-hidden="true">6.4.</strong> 02.3-并发模型-非阻塞 IO</a></li><li class="chapter-item expanded "><a href="06-并发编程/02.4-并发模型-协程.html"><strong aria-hidden="true">6.5.</strong> 02.4-并发模型-协程</a></li><li class="chapter-item expanded "><a href="06-并发编程/02.5-并发模型-模型对比.html"><strong aria-hidden="true">6.6.</strong> 02.5-并发模型-模型对比</a></li><li class="chapter-item expanded "><a href="06-并发编程/03.1-事件循环-浏览器事件循环.html"><strong aria-hidden="true">6.7.</strong> 03.1-事件循环-浏览器事件循环</a></li><li class="chapter-item expanded "><a href="06-并发编程/03.2-事件循环-Node事件循环.html"><strong aria-hidden="true">6.8.</strong> 03.2-事件循环-Node 事件循环</a></li><li class="chapter-item expanded "><a href="06-并发编程/03.3-事件循环-Node的事件模块.html"><strong aria-hidden="true">6.9.</strong> 03.3-事件循环-Node 的事件模块</a></li><li class="chapter-item expanded "><a href="06-并发编程/04.1-Node的多进程-进程对象process.html"><strong aria-hidden="true">6.10.</strong> 04.1-Node 的多进程-进程对象 process</a></li><li class="chapter-item expanded "><a href="06-并发编程/04.2-Node的多进程-创建进程.html"><strong aria-hidden="true">6.11.</strong> 04.2-Node 的多进程-创建进程</a></li><li class="chapter-item expanded "><a href="06-并发编程/04.3-Node的多进程-进程间通信.html"><strong aria-hidden="true">6.12.</strong> 04.3-Node 的多进程-进程间通信</a></li><li class="chapter-item expanded "><a href="06-并发编程/04.4-Node的多进程-多进程服务部署.html"><strong aria-hidden="true">6.13.</strong> 04.4-Node 的多进程-多进程服务部署</a></li><li class="chapter-item expanded "><a href="06-并发编程/04.5-Node的多进程-集群模块cluster.html"><strong aria-hidden="true">6.14.</strong> 04.5-Node 的多进程-集群模块 cluster</a></li><li class="chapter-item expanded "><a href="06-并发编程/05.1-JS的多线程-工作者线程概念.html"><strong aria-hidden="true">6.15.</strong> 05.1-JS 的多线程-工作者线程概念</a></li><li class="chapter-item expanded "><a href="06-并发编程/05.2-JS的多线程-专用工作者线程的基本使用.html"><strong aria-hidden="true">6.16.</strong> 05.2-JS 的多线程-专用工作者线程的基本使用</a></li><li class="chapter-item expanded "><a href="06-并发编程/05.3-JS的多线程-专用工作者线程的通信.html"><strong aria-hidden="true">6.17.</strong> 05.3-JS 的多线程-专用工作者线程的通信</a></li><li class="chapter-item expanded "><a href="06-并发编程/05.4-JS的多线程-共享工作者线程.html"><strong aria-hidden="true">6.18.</strong> 05.4-JS 的多线程-共享工作者线程</a></li><li class="chapter-item expanded "><a href="06-并发编程/05.5-JS的多线程-服务工作者线程的基本使用.html"><strong aria-hidden="true">6.19.</strong> 05.5-JS 的多线程-服务工作者线程的基本使用</a></li><li class="chapter-item expanded "><a href="06-并发编程/05.6-JS的多线程-服务工作者线程的线程缓存.html"><strong aria-hidden="true">6.20.</strong> 05.6-JS 的多线程-服务工作者线程的线程缓存</a></li><li class="chapter-item expanded "><a href="06-并发编程/05.7-JS的多线程-服务工作者线程的生命周期.html"><strong aria-hidden="true">6.21.</strong> 05.7-JS 的多线程-服务工作者线程的生命周期</a></li><li class="chapter-item expanded "><a href="06-并发编程/05.8-JS的多线程-服务工作者线程的补充.html"><strong aria-hidden="true">6.22.</strong> 05.8-JS 的多线程-服务工作者线程的补充</a></li><li class="chapter-item expanded "><a href="06-并发编程/05.9-JS的多线程-竞争锁.html"><strong aria-hidden="true">6.23.</strong> 05.9-JS 的多线程-竞争锁</a></li></ol></li><li class="chapter-item expanded "><a href="07-前端工程化/index.html"><strong aria-hidden="true">7.</strong> 07-前端工程化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07-前端工程化/01.1-模块系统-理解模块系统.html"><strong aria-hidden="true">7.1.</strong> 01.1-模块系统-理解模块系统</a></li><li class="chapter-item expanded "><a href="07-前端工程化/01.2-模块系统-模块化方案.html"><strong aria-hidden="true">7.2.</strong> 01.2-模块系统-模块化方案</a></li><li class="chapter-item expanded "><a href="07-前端工程化/01.3-模块系统-ESModule.html"><strong aria-hidden="true">7.3.</strong> 01.3-模块系统-ESModule</a></li><li class="chapter-item expanded "><a href="07-前端工程化/02.1-工作流工具-Gulp.html"><strong aria-hidden="true">7.4.</strong> 02.1-工作流工具-Gulp</a></li><li class="chapter-item expanded "><a href="07-前端工程化/03.1-Webpack简介.html"><strong aria-hidden="true">7.5.</strong> 03.1-Webpack 简介</a></li><li class="chapter-item expanded "><a href="07-前端工程化/03.2-Webpack基础-基础配置.html"><strong aria-hidden="true">7.6.</strong> 03.2-Webpack 基础-基础配置</a></li><li class="chapter-item expanded "><a href="07-前端工程化/03.3-Webpack基础-模块加载器loader.html"><strong aria-hidden="true">7.7.</strong> 03.3-Webpack 基础-模块加载器 loader</a></li><li class="chapter-item expanded "><a href="07-前端工程化/03.4-Webpack基础-插件plugin.html"><strong aria-hidden="true">7.8.</strong> 03.4-Webpack 基础-插件 plugin</a></li><li class="chapter-item expanded "><a href="07-前端工程化/03.5-Webpack基础-babel配置.html"><strong aria-hidden="true">7.9.</strong> 03.5-Webpack 基础-babel 配置</a></li><li class="chapter-item expanded "><a href="07-前端工程化/04.1-Webpack优化-开发环境优化.html"><strong aria-hidden="true">7.10.</strong> 04.1-Webpack 优化-开发环境优化</a></li><li class="chapter-item expanded "><a href="07-前端工程化/04.2-Webpack优化-生产环境优化.html"><strong aria-hidden="true">7.11.</strong> 04.2-Webpack 优化-生产环境优化</a></li><li class="chapter-item expanded "><a href="07-前端工程化/04.3-Webpack优化-代码分割.html"><strong aria-hidden="true">7.12.</strong> 04.3-Webpack 优化-代码分割</a></li><li class="chapter-item expanded "><a href="07-前端工程化/04.4-Webpack优化-其他打包配置.html"><strong aria-hidden="true">7.13.</strong> 04.4-Webpack 优化-其他打包配置</a></li><li class="chapter-item expanded "><a href="07-前端工程化/05.1-环境配置示例-格式化配置.html"><strong aria-hidden="true">7.14.</strong> 05.1-环境配置示例-格式化配置</a></li><li class="chapter-item expanded "><a href="07-前端工程化/05.2-环境配置示例-env配置.html"><strong aria-hidden="true">7.15.</strong> 05.2-环境配置示例-env 配置</a></li></ol></li><li class="chapter-item expanded "><a href="08-TypeScript/index.html"><strong aria-hidden="true">8.</strong> 08 Type Script</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08-TypeScript/01.1-TypeScript简介.html"><strong aria-hidden="true">8.1.</strong> 01.1-TypeScript 简介</a></li><li class="chapter-item expanded "><a href="08-TypeScript/02.1-数据类型.html"><strong aria-hidden="true">8.2.</strong> 02.1-数据类型</a></li><li class="chapter-item expanded "><a href="08-TypeScript/03.1-函数.html"><strong aria-hidden="true">8.3.</strong> 03.1-函数</a></li><li class="chapter-item expanded "><a href="08-TypeScript/04.1-面向对象.html"><strong aria-hidden="true">8.4.</strong> 04.1-面向对象</a></li><li class="chapter-item expanded "><a href="08-TypeScript/05.1-接口.html"><strong aria-hidden="true">8.5.</strong> 05.1-接口</a></li><li class="chapter-item expanded "><a href="08-TypeScript/06.1-命名空间.html"><strong aria-hidden="true">8.6.</strong> 06.1-命名空间</a></li><li class="chapter-item expanded "><a href="08-TypeScript/07.1-泛型.html"><strong aria-hidden="true">8.7.</strong> 07.1-泛型</a></li><li class="chapter-item expanded "><a href="08-TypeScript/08.1-类型增强.html"><strong aria-hidden="true">8.8.</strong> 08.1-类型增强</a></li><li class="chapter-item expanded "><a href="08-TypeScript/09.1-装饰器.html"><strong aria-hidden="true">8.9.</strong> 09.1-装饰器</a></li><li class="chapter-item expanded "><a href="08-TypeScript/11.1-错误处理.html"><strong aria-hidden="true">8.10.</strong> 11.1-错误处理</a></li><li class="chapter-item expanded "><a href="08-TypeScript/12.1-并发中的类型设计.html"><strong aria-hidden="true">8.11.</strong> 12.1-并发中的类型设计</a></li><li class="chapter-item expanded "><a href="08-TypeScript/13.1-TS与JS的互操作.html"><strong aria-hidden="true">8.12.</strong> 13.1-TS 与 JS 的互操作</a></li><li class="chapter-item expanded "><a href="08-TypeScript/附录-实用类型.html"><strong aria-hidden="true">8.13.</strong> 附录-实用类型</a></li></ol></li><li class="chapter-item expanded "><a href="09-前端框架-React/index.html"><strong aria-hidden="true">9.</strong> 09-前端框架-React</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="09-前端框架-React/01.1-React简介.html"><strong aria-hidden="true">9.1.</strong> 01.1-React 简介</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/02.1-JSX-语法规范.html"><strong aria-hidden="true">9.2.</strong> 02.1-JSX-语法规范</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/02.2-JSX-渲染React元素.html"><strong aria-hidden="true">9.3.</strong> 02.2-JSX-渲染 React 元素</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/03.1-组件化开发-组件化思想.html"><strong aria-hidden="true">9.4.</strong> 03.1-组件化开发-组件化思想</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/03.2-组件化开发-state组件状态.html"><strong aria-hidden="true">9.5.</strong> 03.2-组件化开发-state 组件状态</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/03.3-组件化开发-props接受参数.html"><strong aria-hidden="true">9.6.</strong> 03.3-组件化开发-props 接受参数</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/03.4-组件化开发-refs获取原生DOM.html"><strong aria-hidden="true">9.7.</strong> 03.4-组件化开发-refs 获取原生 DOM</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/04.1-常见操作-事件处理.html"><strong aria-hidden="true">9.8.</strong> 04.1-常见操作-事件处理</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/04.2-常见操作-条件渲染.html"><strong aria-hidden="true">9.9.</strong> 04.2-常见操作-条件渲染</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/04.3-常见操作-列表渲染.html"><strong aria-hidden="true">9.10.</strong> 04.3-常见操作-列表渲染</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/04.4-常见操作-表单与受控组件.html"><strong aria-hidden="true">9.11.</strong> 04.4-常见操作-表单与受控组件</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/04.5-常见操作-组合模式.html"><strong aria-hidden="true">9.12.</strong> 04.5-常见操作-组合模式</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/05.1-组件数据传递-父子传值.html"><strong aria-hidden="true">9.13.</strong> 05.1-组件数据传递-父子传值</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/05.2-组件数据传递-Context.html"><strong aria-hidden="true">9.14.</strong> 05.2-组件数据传递-Context</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/06.1-React路由-基础使用.html"><strong aria-hidden="true">9.15.</strong> 06.1-React 路由-基础使用</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/06.2-React路由-路由嵌套懒加载与编程式导航.html"><strong aria-hidden="true">9.16.</strong> 06.2-React 路由-路由嵌套懒加载与编程式导航</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/07.1-React生命周期-钩子方法.html"><strong aria-hidden="true">9.17.</strong> 07.1-React 生命周期-钩子方法</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/07.2-React生命周期-常用操作.html"><strong aria-hidden="true">9.18.</strong> 07.2-React 生命周期-常用操作</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/08.1-深入HooksAPI-使用规范.html"><strong aria-hidden="true">9.19.</strong> 08.1-深入 HooksAPI-使用规范</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/08.2-深入HooksAPI-自定义Hook.html"><strong aria-hidden="true">9.20.</strong> 08.2-深入 HooksAPI-自定义 Hook</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/08.3-深入HooksAPI-其他常用Hooks.html"><strong aria-hidden="true">9.21.</strong> 08.3-深入 HooksAPI-其他常用 Hooks</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/09.1-状态管理Redux.html"><strong aria-hidden="true">9.22.</strong> 09.1-状态管理 Redux</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/10.1-React进阶-高阶组件.html"><strong aria-hidden="true">9.23.</strong> 10.1-React 进阶-高阶组件</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/10.2-React进阶-RenderProps.html"><strong aria-hidden="true">9.24.</strong> 10.2-React 进阶-RenderProps</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/10.3-React进阶-Diffing算法.html"><strong aria-hidden="true">9.25.</strong> 10.3-React 进阶-Diffing 算法</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/10.4-React进阶-性能优化.html"><strong aria-hidden="true">9.26.</strong> 10.4-React 进阶-性能优化</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/10.5-React进阶-派生state.html"><strong aria-hidden="true">9.27.</strong> 10.5-React 进阶-派生 state</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/10.6-React进阶-代码分割与Suspense.html"><strong aria-hidden="true">9.28.</strong> 10.6-React 进阶-代码分割与 Suspense</a></li><li class="chapter-item expanded "><a href="09-前端框架-React/11.1-React项目测试.html"><strong aria-hidden="true">9.29.</strong> 11.1-React 项目测试</a></li></ol></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/index.html"><strong aria-hidden="true">10.</strong> 09-前端框架-Vue</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="09-前端框架-Vue/01.1-Vue简介.html"><strong aria-hidden="true">10.1.</strong> 01.1-Vue 简介</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/02.1-模板语法-常用指令.html"><strong aria-hidden="true">10.2.</strong> 02.1-模板语法-常用指令</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/02.2-模板语法-双向绑定与自定义指令.html"><strong aria-hidden="true">10.3.</strong> 02.2-模板语法-双向绑定与自定义指令</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/02.3-模板语法-自定义指令.html"><strong aria-hidden="true">10.4.</strong> 02.3-模板语法-自定义指令</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/03.1-组件基础-组件注册.html"><strong aria-hidden="true">10.5.</strong> 03.1-组件基础-组件注册</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/03.2-组件基础-Vue实例.html"><strong aria-hidden="true">10.6.</strong> 03.2-组件基础-Vue 实例</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/03.3-组件基础-响应式基础.html"><strong aria-hidden="true">10.7.</strong> 03.3-组件基础-响应式基础</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/03.4-组件基础-组件参数Props.html"><strong aria-hidden="true">10.8.</strong> 03.4-组件基础-组件参数 Props</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/03.5-组件基础-模板引用ref.html"><strong aria-hidden="true">10.9.</strong> 03.5-组件基础-模板引用 ref</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/03.6-组件基础-计算属性.html"><strong aria-hidden="true">10.10.</strong> 03.6-组件基础-计算属性</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/03.7-组件基础-侦听器.html"><strong aria-hidden="true">10.11.</strong> 03.7-组件基础-侦听器</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/04.1-常见操作-事件操作.html"><strong aria-hidden="true">10.12.</strong> 04.1-常见操作-事件操作</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/04.2-常见操作-绑定样式.html"><strong aria-hidden="true">10.13.</strong> 04.2-常见操作-绑定样式</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/04.3-常见操作-列表渲染.html"><strong aria-hidden="true">10.14.</strong> 04.3-常见操作-列表渲染</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/04.4-常见操作-透传Attributes.html"><strong aria-hidden="true">10.15.</strong> 04.4-常见操作-透传 Attributes</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/04.5-常见操作-组件v-model.html"><strong aria-hidden="true">10.16.</strong> 04.5-常见操作-组件 v-model</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/05.1-组件通信-基础通信方式.html"><strong aria-hidden="true">10.17.</strong> 05.1-组件通信-基础通信方式</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/05.2-组件通信-依赖注入.html"><strong aria-hidden="true">10.18.</strong> 05.2-组件通信-依赖注入</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/06.1-Vue生命周期.html"><strong aria-hidden="true">10.19.</strong> 06.1-Vue 生命周期</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/07.1-Vue插槽slot.html"><strong aria-hidden="true">10.20.</strong> 07.1-Vue 插槽 slot</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/08.1-组合式API-Vue3与组合式API.html"><strong aria-hidden="true">10.21.</strong> 08.1-组合式 API-Vue3 与组合式 API</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/08.2-组合式API-最佳实践.html"><strong aria-hidden="true">10.22.</strong> 08.2-组合式 API-最佳实践</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/08.3-组合式API-常见组合式API原理.html"><strong aria-hidden="true">10.23.</strong> 08.3-组合式 API-常见组合式 API 原理</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/08.4-组合式API-组合式API的利弊.html"><strong aria-hidden="true">10.24.</strong> 08.4-组合式 API-组合式 API 的利弊</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/09.1-路由-前端路由.html"><strong aria-hidden="true">10.25.</strong> 09.1-路由-前端路由</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/09.2-路由-VueRouter.html"><strong aria-hidden="true">10.26.</strong> 09.2-路由-VueRouter</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/09.3-路由-路由守卫.html"><strong aria-hidden="true">10.27.</strong> 09.3-路由-路由守卫</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/10.1-内置组件-异步组件与Suspense.html"><strong aria-hidden="true">10.28.</strong> 10.1-内置组件-异步组件与 Suspense</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/10.2-内置组件-KeepAlive.html"><strong aria-hidden="true">10.29.</strong> 10.2-内置组件-KeepAlive</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/10.3-内置组件-Teleport.html"><strong aria-hidden="true">10.30.</strong> 10.3-内置组件-Teleport</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/11.1-状态管理-状态与Pinia.html"><strong aria-hidden="true">10.31.</strong> 11.1-状态管理-状态与 Pinia</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/11.2-状态管理-Vuex.html"><strong aria-hidden="true">10.32.</strong> 11.2-状态管理-Vuex</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/12.1-Vue插件编写.html"><strong aria-hidden="true">10.33.</strong> 12.1-Vue 插件编写</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/13.1-Vue动画.html"><strong aria-hidden="true">10.34.</strong> 13.1-Vue 动画</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/14.1-Vue服务端渲染.html"><strong aria-hidden="true">10.35.</strong> 14.1-Vue 服务端渲染</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/15.1-Vue测试.html"><strong aria-hidden="true">10.36.</strong> 15.1-Vue 测试</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/16.1-Vue性能优化.html"><strong aria-hidden="true">10.37.</strong> 16.1-Vue 性能优化</a></li><li class="chapter-item expanded "><a href="09-前端框架-Vue/17.1-TypeScript与Vue结合.html"><strong aria-hidden="true">10.38.</strong> 17.1-TypeScript 与 Vue 结合</a></li></ol></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/index.html"><strong aria-hidden="true">11.</strong> 09-后端框架-Nest</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="09-后端框架-Nest/01.1-Nestjs框架基础.html"><strong aria-hidden="true">11.1.</strong> 01.1-Nestjs 框架基础</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/02.1-Nestjs设计思想-控制反转与切面编程.html"><strong aria-hidden="true">11.2.</strong> 02.1-Nestjs 设计思想-控制反转与切面编程</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/02.2-Nestjs设计思想-核心概念.html"><strong aria-hidden="true">11.3.</strong> 02.2-Nestjs 设计思想-核心概念</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/03.1-Nestjs主要功能-中间件.html"><strong aria-hidden="true">11.4.</strong> 03.1-Nestjs 主要功能-中间件</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/03.2-Nestjs主要功能-异常过滤器.html"><strong aria-hidden="true">11.5.</strong> 03.2-Nestjs 主要功能-异常过滤器</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/03.3-Nestjs主要功能-管道.html"><strong aria-hidden="true">11.6.</strong> 03.3-Nestjs 主要功能-管道</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/03.4-Nestjs主要功能-守卫.html"><strong aria-hidden="true">11.7.</strong> 03.4-Nestjs 主要功能-守卫</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/03.5-Nestjs主要功能-拦截器.html"><strong aria-hidden="true">11.8.</strong> 03.5-Nestjs 主要功能-拦截器</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/04.1-Nestjs业务扩展-配置管理.html"><strong aria-hidden="true">11.9.</strong> 04.1-Nestjs 业务扩展-配置管理</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/04.2-Nestjs业务扩展-日志.html"><strong aria-hidden="true">11.10.</strong> 04.2-Nestjs 业务扩展-日志</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/04.3-Nestjs业务扩展-校验与认证.html"><strong aria-hidden="true">11.11.</strong> 04.3-Nestjs 业务扩展-校验与认证</a></li><li class="chapter-item expanded "><a href="09-后端框架-Nest/05.1-Nestjs项目优化.html"><strong aria-hidden="true">11.12.</strong> 05.1-Nestjs 项目优化</a></li></ol></li><li class="chapter-item expanded "><a href="10-前端之禅/index.html"><strong aria-hidden="true">12.</strong> 10-前端之禅</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10-前端之禅/01.1-内存管理-垃圾回收算法.html"><strong aria-hidden="true">12.1.</strong> 01.1-内存管理-垃圾回收算法</a></li><li class="chapter-item expanded "><a href="10-前端之禅/01.2-内存管理-内存泄露与管理.html"><strong aria-hidden="true">12.2.</strong> 01.2-内存管理-内存泄露与管理</a></li><li class="chapter-item expanded "><a href="10-前端之禅/01.3-内存管理-V8引擎与分代回收.html"><strong aria-hidden="true">12.3.</strong> 01.3-内存管理-V8 引擎与分代回收</a></li><li class="chapter-item expanded "><a href="10-前端之禅/02.1-浏览器-渲染流程.html"><strong aria-hidden="true">12.4.</strong> 02.1-浏览器-渲染流程</a></li><li class="chapter-item expanded "><a href="10-前端之禅/02.2-浏览器-缓存机制.html"><strong aria-hidden="true">12.5.</strong> 02.2-浏览器-缓存机制</a></li><li class="chapter-item expanded "><a href="10-前端之禅/03.1-性能优化-优化汇总.html"><strong aria-hidden="true">12.6.</strong> 03.1-性能优化-优化汇总</a></li><li class="chapter-item expanded "><a href="10-前端之禅/03.2-性能优化-代码优化示例.html"><strong aria-hidden="true">12.7.</strong> 03.2-性能优化-代码优化示例</a></li><li class="chapter-item expanded "><a href="10-前端之禅/04.1-前后分离-SEO.html"><strong aria-hidden="true">12.8.</strong> 04.1-前后分离-SEO</a></li><li class="chapter-item expanded "><a href="10-前端之禅/04.2-前后分离-CSR与SSR.html"><strong aria-hidden="true">12.9.</strong> 04.2-前后分离-CSR 与 SSR</a></li><li class="chapter-item expanded "><a href="10-前端之禅/05.1-接口规范-REST.html"><strong aria-hidden="true">12.10.</strong> 05.1-接口规范-REST</a></li><li class="chapter-item expanded "><a href="10-前端之禅/05.2-接口规范-GraphQL.html"><strong aria-hidden="true">12.11.</strong> 05.2-接口规范-GraphQL</a></li><li class="chapter-item expanded "><a href="10-前端之禅/06.1-编程思想-函数式编程.html"><strong aria-hidden="true">12.12.</strong> 06.1-编程思想-函数式编程</a></li><li class="chapter-item expanded "><a href="10-前端之禅/06.2-编程思想-依赖注入与控制反转.html"><strong aria-hidden="true">12.13.</strong> 06.2-编程思想-依赖注入与控制反转</a></li><li class="chapter-item expanded "><a href="10-前端之禅/06.3-编程思想-可维护性.html"><strong aria-hidden="true">12.14.</strong> 06.3-编程思想-可维护性</a></li><li class="chapter-item expanded "><a href="10-前端之禅/07.1-Web安全.html"><strong aria-hidden="true">12.15.</strong> 07.1-Web 安全</a></li><li class="chapter-item expanded "><a href="10-前端之禅/08.1-常见服务-OAuth2授权.html"><strong aria-hidden="true">12.16.</strong> 08.1-常见服务-OAuth2 授权</a></li><li class="chapter-item expanded "><a href="10-前端之禅/09.1-微前端架构.html"><strong aria-hidden="true">12.17.</strong> 09.1-微前端架构</a></li><li class="chapter-item expanded "><a href="10-前端之禅/10.1-软件测试.html"><strong aria-hidden="true">12.18.</strong> 10.1-软件测试</a></li><li class="chapter-item expanded "><a href="10-前端之禅/11.1-持续集成.html"><strong aria-hidden="true">12.19.</strong> 11.1-持续集成</a></li></ol></li><li class="chapter-item expanded "><a href="附录-Canvas/index.html"><strong aria-hidden="true">13.</strong> 附录-Canvas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="附录-Canvas/01.1-Canvas简单使用.html"><strong aria-hidden="true">13.1.</strong> 01.1-Canvas 简单使用</a></li><li class="chapter-item expanded "><a href="附录-Canvas/02.1-2d绘图环境-基本图形绘制.html"><strong aria-hidden="true">13.2.</strong> 02.1-2d 绘图环境-基本图形绘制</a></li><li class="chapter-item expanded "><a href="附录-Canvas/02.2-2d绘图环境-变换、阴影、渐变.html"><strong aria-hidden="true">13.3.</strong> 02.2-2d 绘图环境-变换、阴影、渐变</a></li><li class="chapter-item expanded "><a href="附录-Canvas/02.3-2d绘图环境-图片基础操作.html"><strong aria-hidden="true">13.4.</strong> 02.3-2d 绘图环境-图片基础操作</a></li><li class="chapter-item expanded "><a href="附录-Canvas/03.1-图形绘制-线段绘制.html"><strong aria-hidden="true">13.5.</strong> 03.1-图形绘制-线段绘制</a></li><li class="chapter-item expanded "><a href="附录-Canvas/03.2-图形绘制-圆形绘制.html"><strong aria-hidden="true">13.6.</strong> 03.2-图形绘制-圆形绘制</a></li><li class="chapter-item expanded "><a href="附录-Canvas/03.3-图形绘制-贝塞尔曲线.html"><strong aria-hidden="true">13.7.</strong> 03.3-图形绘制-贝塞尔曲线</a></li><li class="chapter-item expanded "><a href="附录-Canvas/03.4-图形绘制-多边形绘制.html"><strong aria-hidden="true">13.8.</strong> 03.4-图形绘制-多边形绘制</a></li><li class="chapter-item expanded "><a href="附录-Canvas/03.5-图形绘制-坐标变换.html"><strong aria-hidden="true">13.9.</strong> 03.5-图形绘制-坐标变换</a></li><li class="chapter-item expanded "><a href="附录-Canvas/03.5-图形绘制-高级路径操作.html"><strong aria-hidden="true">13.10.</strong> 03.5-图形绘制-高级路径操作</a></li><li class="chapter-item expanded "><a href="附录-Canvas/04.1-图片操作-绘制图片.html"><strong aria-hidden="true">13.11.</strong> 04.1-图片操作-绘制图片</a></li><li class="chapter-item expanded "><a href="附录-Canvas/04.2-图片操作-离屏canvas.html"><strong aria-hidden="true">13.12.</strong> 04.2-图片操作-离屏 canvas</a></li><li class="chapter-item expanded "><a href="附录-Canvas/04.3-图片操作-操作像素.html"><strong aria-hidden="true">13.13.</strong> 04.3-图片操作-操作像素</a></li><li class="chapter-item expanded "><a href="附录-Canvas/04.4-图片操作-滤镜操作.html"><strong aria-hidden="true">13.14.</strong> 04.4-图片操作-滤镜操作</a></li><li class="chapter-item expanded "><a href="附录-Canvas/04.5-图片操作-图像制作动画.html"><strong aria-hidden="true">13.15.</strong> 04.5-图片操作-图像制作动画</a></li><li class="chapter-item expanded "><a href="附录-Canvas/04.6-图片操作-安全与性能.html"><strong aria-hidden="true">13.16.</strong> 04.6-图片操作-安全与性能</a></li><li class="chapter-item expanded "><a href="附录-Canvas/05.1-视频处理.md.html"><strong aria-hidden="true">13.17.</strong> 05.1-视频处理.md</a></li></ol></li><li class="chapter-item expanded "><a href="附录-Electron/index.html"><strong aria-hidden="true">14.</strong> 附录-Electron</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="附录-Electron/01.1-Elecron简介.html"><strong aria-hidden="true">14.1.</strong> 01.1-Elecron 简介</a></li><li class="chapter-item expanded "><a href="附录-Electron/02.1-Electron进程.html"><strong aria-hidden="true">14.2.</strong> 02.1-Electron 进程</a></li><li class="chapter-item expanded "><a href="附录-Electron/03.1-Electron数据存储.html"><strong aria-hidden="true">14.3.</strong> 03.1-Electron 数据存储</a></li><li class="chapter-item expanded "><a href="附录-Electron/04.1-Electron通信.html"><strong aria-hidden="true">14.4.</strong> 04.1-Electron 通信</a></li><li class="chapter-item expanded "><a href="附录-Electron/05.1-Electron界面.html"><strong aria-hidden="true">14.5.</strong> 05.1-Electron 界面</a></li><li class="chapter-item expanded "><a href="附录-Electron/06.1-Electron窗口.html"><strong aria-hidden="true">14.6.</strong> 06.1-Electron 窗口</a></li><li class="chapter-item expanded "><a href="附录-Electron/07.1-Electron交互-与系统交互.html"><strong aria-hidden="true">14.7.</strong> 07.1-Electron 交互-与系统交互</a></li><li class="chapter-item expanded "><a href="附录-Electron/07.2-Electron交互-与硬件交互.html"><strong aria-hidden="true">14.8.</strong> 07.2-Electron 交互-与硬件交互</a></li><li class="chapter-item expanded "><a href="附录-Electron/08.1-Electron安全问题.html"><strong aria-hidden="true">14.9.</strong> 08.1-Electron 安全问题</a></li><li class="chapter-item expanded "><a href="附录-Electron/09.1-Electron测试.html"><strong aria-hidden="true">14.10.</strong> 09.1-Electron 测试</a></li><li class="chapter-item expanded "><a href="附录-Electron/10.1-Electron应用发版.html"><strong aria-hidden="true">14.11.</strong> 10.1-Electron 应用发版</a></li><li class="chapter-item expanded "><a href="附录-Electron/11.1-Electron优化.html"><strong aria-hidden="true">14.12.</strong> 11.1-Electron 优化</a></li></ol></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/index.html"><strong aria-hidden="true">15.</strong> 附录-HTML 与 CSS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="附录-HTML与CSS/01.1-HTML-HTML概念.html"><strong aria-hidden="true">15.1.</strong> 01.1-HTML-HTML 概念</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/01.2-HTML-H5的变化.html"><strong aria-hidden="true">15.2.</strong> 01.2-HTML-H5 的变化</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/01.3-HTML-常见标签.html"><strong aria-hidden="true">15.3.</strong> 01.3-HTML-常见标签</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/01.4-HTML-表单标签.html"><strong aria-hidden="true">15.4.</strong> 01.4-HTML-表单标签</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/02.1-CSS基础-CSS基本使用.html"><strong aria-hidden="true">15.5.</strong> 02.1-CSS 基础-CSS 基本使用</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/02.2-CSS基础-选择器.html"><strong aria-hidden="true">15.6.</strong> 02.2-CSS 基础-选择器</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/02.3-CSS基础-文字与文本.html"><strong aria-hidden="true">15.7.</strong> 02.3-CSS 基础-文字与文本</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/02.4-CSS基础-背景与颜色.html"><strong aria-hidden="true">15.8.</strong> 02.4-CSS 基础-背景与颜色</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/02.5-CSS基础-层叠性与继承性.html"><strong aria-hidden="true">15.9.</strong> 02.5-CSS 基础-层叠性与继承性</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/03.1-盒模型-盒模型使用.html"><strong aria-hidden="true">15.10.</strong> 03.1-盒模型-盒模型使用</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/03.2-盒模型-元素转换.html"><strong aria-hidden="true">15.11.</strong> 03.2-盒模型-元素转换</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/04.1-布局技术-浮动与BFC.html"><strong aria-hidden="true">15.12.</strong> 04.1-布局技术-浮动与 BFC</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/04.2-布局技术-定位与层级.html"><strong aria-hidden="true">15.13.</strong> 04.2-布局技术-定位与层级</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/04.3-布局技术-弹性布局.html"><strong aria-hidden="true">15.14.</strong> 04.3-布局技术-弹性布局</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/04.4-布局技术-网格布局.html"><strong aria-hidden="true">15.15.</strong> 04.4-布局技术-网格布局</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/05.1-移动Web-移动Web问题.html"><strong aria-hidden="true">15.16.</strong> 05.1-移动 Web-移动 Web 问题</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/05.2-移动Web-移动端布局方案.html"><strong aria-hidden="true">15.17.</strong> 05.2-移动 Web-移动端布局方案</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/05.3-移动Web-rem适配.html"><strong aria-hidden="true">15.18.</strong> 05.3-移动 Web-rem 适配</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/05.4-移动Web-流式布局.html"><strong aria-hidden="true">15.19.</strong> 05.4-移动 Web-流式布局</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/05.5-移动Web-栅格布局.html"><strong aria-hidden="true">15.20.</strong> 05.5-移动 Web-栅格布局</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/05.6-移动Web-移动网页示例.html"><strong aria-hidden="true">15.21.</strong> 05.6-移动 Web-移动网页示例</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/06.1-基础效果-渐变.html"><strong aria-hidden="true">15.22.</strong> 06.1-基础效果-渐变</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/06.2-基础效果-阴影.html"><strong aria-hidden="true">15.23.</strong> 06.2-基础效果-阴影</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/07.1-CSS3特效-过渡.html"><strong aria-hidden="true">15.24.</strong> 07.1-CSS3 特效-过渡</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/07.2-CSS3特效-2D转换.html"><strong aria-hidden="true">15.25.</strong> 07.2-CSS3 特效-2D 转换</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/07.3-CSS3特效-3D转换.html"><strong aria-hidden="true">15.26.</strong> 07.3-CSS3 特效-3D 转换</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/07.4-CSS3特效-动画.html"><strong aria-hidden="true">15.27.</strong> 07.4-CSS3 特效-动画</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/07.5-CSS3特效-性能问题.html"><strong aria-hidden="true">15.28.</strong> 07.5-CSS3 特效-性能问题</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/08.1-CSS实践-规范与实践.html"><strong aria-hidden="true">15.29.</strong> 08.1-CSS 实践-规范与实践</a></li><li class="chapter-item expanded "><a href="附录-HTML与CSS/08.2-CSS实践-2-可见性与居中.html"><strong aria-hidden="true">15.30.</strong> 08.2-CSS 实践-2-可见性与居中</a></li></ol></li><li class="chapter-item expanded "><a href="附录-函数式编程/index.html"><strong aria-hidden="true">16.</strong> 附录-函数式编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="附录-函数式编程/01.1-编程思想-声明式与命令式.html"><strong aria-hidden="true">16.1.</strong> 01.1-编程思想-声明式与命令式</a></li><li class="chapter-item expanded "><a href="附录-函数式编程/01.2-编程思想-函数式编程范式.html"><strong aria-hidden="true">16.2.</strong> 01.2-编程思想-函数式编程范式</a></li><li class="chapter-item expanded "><a href="附录-函数式编程/02.1-函数式实现-lambda.html"><strong aria-hidden="true">16.3.</strong> 02.1-函数式实现-lambda</a></li><li class="chapter-item expanded "><a href="附录-函数式编程/02.2-函数式实现-柯里化函数.html"><strong aria-hidden="true">16.4.</strong> 02.2-函数式实现-柯里化函数</a></li><li class="chapter-item expanded "><a href="附录-函数式编程/02.3-函数式实现-偏函数.html"><strong aria-hidden="true">16.5.</strong> 02.3-函数式实现-偏函数</a></li><li class="chapter-item expanded "><a href="附录-函数式编程/02.4-函数式实现-组合函数.html"><strong aria-hidden="true">16.6.</strong> 02.4-函数式实现-组合函数</a></li><li class="chapter-item expanded "><a href="附录-函数式编程/02.5-函数式实现-管道.html"><strong aria-hidden="true">16.7.</strong> 02.5-函数式实现-管道</a></li><li class="chapter-item expanded "><a href="附录-函数式编程/02.6-函数式实现-函子.html"><strong aria-hidden="true">16.8.</strong> 02.6-函数式实现-函子</a></li><li class="chapter-item expanded "><a href="附录-函数式编程/02.7-函数式实现-Monad函子.html"><strong aria-hidden="true">16.9.</strong> 02.7-函数式实现-Monad 函子</a></li></ol></li><li class="chapter-item expanded "><a href="附录-设计模式/index.html"><strong aria-hidden="true">17.</strong> 附录-设计模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="附录-设计模式/01.1-单例模式.html"><strong aria-hidden="true">17.1.</strong> 01.1-单例模式</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Over javascript</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="011-javascript-简介"><a class="header" href="#011-javascript-简介">01.1-JavaScript 简介</a></h1>
<h2 id="一-javascript-概述"><a class="header" href="#一-javascript-概述">一 JavaScript 概述</a></h2>
<h3 id="11-javascript-的历史"><a class="header" href="#11-javascript-的历史">1.1 JavaScript 的历史</a></h3>
<p>JavaScript 诞生于 1995 年，由网景公司的 Brendan Eich 在十天内开发完成，诞生之初用于代替 Perl 语言来处理一些输入验证。</p>
<p>虽然该语言名字中带有 Java，但是其与另一个流行语言 Java 并没有多大关系，JavaScript 原名为 LiveScript，为了迎合 Java 的热潮而改名。</p>
<p>由于浏览器的兴起，JavaScript 成为了 Web 前端领域不可替代的核心语言，没有之一！然而浏览器厂商众多，不同浏览器之间始终存在规范差异，如早期微软 IE 的 JScript 等。为了应对该问题，推出了 ECAMS-262，也即 ECMAScript，这是欧洲计算机制造商协会制定的该脚本语言的语法规范，也被采纳入了 ISO 规范中。此后，各浏览器厂商都要以此标准在自家浏览器中实现 JavaScript。</p>
<p>如果不涉及浏览器的话， ECMA-262 仅仅描述了这门语言的如下部分：</p>
<ul>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>全局对象</li>
</ul>
<p>ECMAScript 现在的流行版本是：ES5、ES6，其主要版本有：</p>
<ul>
<li>ECMAScript3：1999 年标准规范，火狐的 js1.5 和 1.8 都是基于 3 规范</li>
<li>ECMAScript4：为了适应互联网发展出来的激进版本，由于存在大量分歧，该版本被放弃！</li>
<li>ECMAScript5：2009 年发布，包含了 ES4 中的一些常见功能，其本质是 ES3.1，是当前的主流版本</li>
<li>ECMAScript6：诞生于 2015 年，也称为 ES2015，是 js 划时代意义的版本。添加了开发大型项目所需要的功能，JS 终于不再是一门<code>玩具语言</code>。</li>
<li>ES2016：诞生于 2016 年，即 ES7，后续版本均以年为名称，如 ES2017、ES2018。ES2016 最出色的地方是引入了<code>async await</code>异步解决方案。</li>
</ul>
<h3 id="12-javascript-的-api-组成"><a class="header" href="#12-javascript-的-api-组成">1.2 JavaScript 的 API 组成</a></h3>
<p>ECMAScript 是 JavaScript 的语法核心，但是仅仅有语法，没有一些具体的 API 帮助，JS 也只是一个玩具。在浏览器环境中，浏览器为 JavaScript 提供了两大对象 DOM、BOM，让 JavaScript 能够游刃有余的操作浏览器相关特性。</p>
<p>如图所示：</p>
<p><img src="01-JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/../images/javascript/02-1-01-01.svg" alt="JavaScript 组成" /></p>
<p>所以 JavaScript 包含三个方面：</p>
<ul>
<li>ECMAScript：JavaScript 语法标准，如：类型、关键字、基本对象等，有 ES5、ES6(即 ES2015)、ES7(即 ES2016)，后续皆以年代为规范的名称</li>
<li>DOM：<code>Document Object Model</code>，JavaScript 操作网页元素的 API</li>
<li>BOM：<code>Browser Object Model</code>，JavaScript 操作浏览器部分功能的 API</li>
</ul>
<blockquote>
<p>API：Application Programming Interface，即应用程序编程接口，是包装好后提供给开发人员使用的工具</p>
</blockquote>
<h3 id="13-javascript-的引擎"><a class="header" href="#13-javascript-的引擎">1.3 JavaScript 的引擎</a></h3>
<p>JavaScript 是一种解释性编程语言，依赖于解释引擎，常见的引擎有：</p>
<ul>
<li>v8 引擎：js 最著名的引擎，以高性能著称，被应用于 Chrome 浏览器与 Node.js</li>
<li>SpiderMonkey：火狐浏览器中的 js 引擎</li>
</ul>
<p>编程语言有解释型和编译型两种：</p>
<blockquote>
<p>解释型：源代码无需经过编译，一行一行地直接解析执行，比如 javascript、python
编译型：源码先编译为可执行文件，再运行该可执行文件，比如 C、C++
贴士：这里只是初步的总结，编译型也并不是说不能按照解释的方式执行：C 语言的解释型引擎：cling</p>
</blockquote>
<p>在语言引擎基础上，第三方会为编程语言开发一些独立的库，对编程语言进行功能上的包装，这些最终包装出来的编程环境，我们称之为运行时！常见的 JavaScript 运行时有：</p>
<div class="table-wrapper"><table><thead><tr><th>运行时名称</th><th>内置 JS 引擎</th><th>内置排版引擎</th><th>内置 API</th></tr></thead><tbody>
<tr><td>Chrome 浏览器</td><td>V8</td><td>Webkit-&gt;Blink</td><td>DOM、BOM 等 HTML API</td></tr>
<tr><td>FireFox 浏览器</td><td>Monkey 系列</td><td>Gecko</td><td>DOM、BOM 等 HTML API</td></tr>
<tr><td>IE 浏览器</td><td>Jscript-&gt;Chakra(9+)</td><td>Trident</td><td>DOM、BOM 等 HTML API</td></tr>
<tr><td>Safari 浏览器</td><td>Nitro</td><td>Webkit</td><td>DOM、BOM 等 HTML API</td></tr>
<tr><td>Edg 浏览器</td><td>Chakra</td><td>EdgeHTML-&gt;Webkit</td><td>DOM、BOM 等 HTML API</td></tr>
<tr><td>Node.js</td><td>V8</td><td>无</td><td>网络、文件等 系统 API</td></tr>
</tbody></table>
</div>
<h2 id="二-hello-world"><a class="header" href="#二-hello-world">二 Hello World</a></h2>
<h3 id="21-程序说明"><a class="header" href="#21-程序说明">2.1 程序说明</a></h3>
<p><code>Hello World</code>程序是 1974 年<code>Brian Kernighan</code>撰写的<code>《Programming in C: A Tutorial》</code>中首次面向大众介绍 C 语言时使用的最简单程序示例，后来该习惯相继被大量编程语言书籍沿用。</p>
<p>本笔记中的 JavaScript 代码大多都依赖于 Chrome 运行时，故而我们需要使用 Chrome 浏览器来运行 HTML。</p>
<h3 id="22-hello-world-代码"><a class="header" href="#22-hello-world-代码">2.2 Hello World 代码</a></h3>
<p>新建 helloworld.html 文件，代码如下：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
      // 这里开始书写 js 代码
      console.log('Hello World!')
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>用浏览器打开该网页，按 F12 打开控制台，控制台将会输出：<code>Hello World!</code>。</p>
<h2 id="三-javascript-的基本书写规范"><a class="header" href="#三-javascript-的基本书写规范">三 JavaScript 的基本书写规范</a></h2>
<h3 id="31-大小写"><a class="header" href="#31-大小写">3.1 大小写</a></h3>
<p>JavaScript 语言区分大小写！</p>
<h3 id="32-注释"><a class="header" href="#32-注释">3.2 注释</a></h3>
<p>js 中的注释：</p>
<pre><code class="language-js">//  单行注释

/*
 *   多行注释
 *   多行注释
 *   多行注释
 */
</code></pre>
<p>贴士：多行注释中每行开头都有一个星号是推荐的写法，每行开头的星号是可以省略的，但是不推荐！</p>
<h3 id="33-分号"><a class="header" href="#33-分号">3.3 分号</a></h3>
<p>js 语句末尾的分号可以写也可以不写，不写的时候要保证每行代码都具备完整的语义！</p>
<p><strong>笔者推荐：书写代码时，尽量保证每行代码都有自己的独立意义，不能在一行代码中添加多个功能！</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-标识符"><a class="header" href="#021-标识符">02.1-标识符</a></h1>
<h2 id="一-标识符"><a class="header" href="#一-标识符">一 标识符</a></h2>
<p>在计算机编程语言中，标识符是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名。JavaScript 中的标识符要求：</p>
<ul>
<li>只能以<code>字母</code>、<code>_</code>、<code>$</code>三种形式开头</li>
<li>其他字符可以是<code>字母</code>、<code>数字</code>、<code>_</code>、<code>$</code></li>
<li>不能是关键字、保留字</li>
</ul>
<p>贴士：ECMAScript 标识符一般采用驼峰写法，即首字母小写，剩下每个单词首字母大写，如：<code>myCar</code>、<code>doSomething</code></p>
<h2 id="二-关键字与保留字"><a class="header" href="#二-关键字与保留字">二 关键字与保留字</a></h2>
<p>关键字与保留字是 ECMAScript 中规定的一些具备特定用途的名词，不能作为标识符来使用：</p>
<ul>
<li>关键字：编程语言官方已经定义并使用的一些特殊名称单词</li>
<li>保留字：编程语言并未使用，但是预留的一些特殊名称单词</li>
</ul>
<p>ECMA-262 第 6 版中的关键字：</p>
<pre><code class="language-txt">break       do          in              typeof
case        else        instanceof      var
catch       export      new             void
class       extends     return          while
const       finally     super           with
continue    for         switch          yield
debugger    function    this
default     if          throw
delete      import      try
</code></pre>
<p>规范中描述了一组未来的保留字，如：<code>enum implements package public private protected static interface let await</code> 等。</p>
<h2 id="三-变量"><a class="header" href="#三-变量">三 变量</a></h2>
<h3 id="31-变量的声明"><a class="header" href="#31-变量的声明">3.1 变量的声明</a></h3>
<p>在 JS 中，变量可以保存任何类型的数据，每个变量仅仅是一个保存任意值的占位符。</p>
<p>JS 中声明一个变量有三种方式：</p>
<ul>
<li><code>var</code>：ES5 及其之前规范</li>
<li><code>let</code>：ES6 规范</li>
<li><code>const</code>：ES6 规范，用来声明一个不可变变量。</li>
</ul>
<p>声明方式如下所示：</p>
<pre><code class="language-js">// 单个变量定义并初始化
var i = 3

// 多个变量定义并初始化
var a = 3,
  b = 4

// 单个变量定义
var num // 此时其值是 undefined
num = 3

// 多个变量定义
var num1, num2
num1 = 4
num2 = 6
</code></pre>
<p>let、const 的声明方式与上述示例中的 var 一致，只不过他们的作用域有很大区别，如果开发环境支持 ES6，推荐抛弃 var，只使用 let、const。</p>
<h3 id="12-let-与-const-的简单使用"><a class="header" href="#12-let-与-const-的简单使用">1.2 let 与 const 的简单使用</a></h3>
<p>ES6 带来了 2 个新的变量声明关键字：let、const：</p>
<pre><code class="language-js">let num1 = 1
console.log(num1) // 1
num1 = 11
console.log(num1) // 11

const num2 = 2
console.log(num2) // 2
num2 = 22 // 报错：const 定义的数据无法再更改
console.log(num2)
</code></pre>
<p>对于引用类型的数据，const 只是不会改变引用地址，具体的引用数据是可以改变的：</p>
<pre><code class="language-js">const a = []
a.push(1) // 改变 a 是可以的

// 如果想让对象不能改变，可以采用如下方式：
const b = Object.freeze({})
b.name = 'Jake'
console.log(b.name) // undefined
</code></pre>
<p>let/const 在同一个作用域内不能重复声明：</p>
<pre><code class="language-js">var num = 10
var num = 100 // 不会报错，而 let/const 这里报错
</code></pre>
<h3 id="13-varletconst-在作用域中的区别"><a class="header" href="#13-varletconst-在作用域中的区别">1.3 var/let/const 在作用域中的区别</a></h3>
<p>作用域涉及到函数，请查阅函数章节：09.3-函数-作用域</p>
<h2 id="二-声明风格推荐"><a class="header" href="#二-声明风格推荐">二 声明风格推荐</a></h2>
<p>优先使用 const，let 次之，不推荐使用 var。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-数据类型-数据类型的分类"><a class="header" href="#031-数据类型-数据类型的分类">03.1-数据类型-数据类型的分类</a></h1>
<h2 id="一-数据类型概念"><a class="header" href="#一-数据类型概念">一 数据类型概念</a></h2>
<h3 id="11-数据类型的作用"><a class="header" href="#11-数据类型的作用">1.1 数据类型的作用</a></h3>
<p>计算机在为变量申请内存时，必须先了解需要申请多大的内存，同一类型的变量申请统一大小的内存，才能避免资源的浪费，这就是数据类型产生的原因。</p>
<p>数据类型可以分为两大类：基本类型、引用类型。</p>
<p><strong>基本类型</strong>，也即值类型或者原始类型（primitive type），他们的特点是：</p>
<ul>
<li>数据更改：基本类型创建后即不可更改原有数据，比如字符串在更改时其实是内部进行字符串拷贝后返回的一个全新的字符串</li>
<li>存储位置：由于数据大小确定，基本类型的数据占据空间一般也较小，所以基本类型在内存中存储于<code>栈区</code></li>
<li>数据访问：基本类型数据由于栈中，可以按值存放，按值访问！</li>
<li>数据拷贝：是将栈中的一个值本身复制给了另外一个值</li>
<li>生命周期：栈中的数据随着方法的结束就会销毁</li>
</ul>
<p><strong>引用类型</strong>，也即对象类型（object type），值可以修改（注意：修改的其实是对象的引用，而不是真实的数据被修改！），一般可以使用<code>new</code>创建的数据都是引用类型，其特点是：</p>
<ul>
<li>数据更改：通过修改对象引用的指向来修改数据</li>
<li>存储位置：因为其数据大小不确定，需要保存在运行时数据区，所以引用类型在内存中存储于<code>堆区</code></li>
<li>数据访问：通过类指针的方式进行访问</li>
<li>数据拷贝：引用类型的数据拷贝，是拷贝该数据的引用指针</li>
<li>生命周期：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）</li>
</ul>
<h3 id="12-javascipt-中的基本类型和引用类型"><a class="header" href="#12-javascipt-中的基本类型和引用类型">1.2 JavaScipt 中的基本类型和引用类型</a></h3>
<p>JavaScript 包含 7 种数据类型（6 个基础类型，1 个复杂类型 Object）：</p>
<p><strong>基本类型</strong>：</p>
<ul>
<li>Number 数字类型：js 中整数和实数共用一种数据类型</li>
<li>String 字符串类型：由双引号内的文本构成，当然单引号在 JS 中也可以用来表示字符串！</li>
<li>Boolean 布尔类型：包含两个值：true、false</li>
<li>Undefined 未定义类型：<code>var a = undefined;</code>表示该 a 的值未定义</li>
<li>Null 类型：null 较为特殊，是个空值，表示一个空对象的引用</li>
<li>Symbol 类型：ES6 中新增数据类型</li>
</ul>
<p><strong>引用类型</strong>：</p>
<ul>
<li>Object 对象类型：表示值为对象或者 null(非 function)</li>
</ul>
<p>使用 typeof 关键字可以初步识别数据的类型，但是 <code>typeof null === 'object'</code>，这是因为 JS 认为 null 是一个空对象的引用。</p>
<p>注意：严格意义上来说，函数也是一种对象，并不是一种数据类型，但是函数拥有自己的属性，使用 typeof 可以区分，获得的结果为 <code>function</code>。</p>
<p>基本类型和引用类型的数据类型的值分别对应了原始值（primitive value）和引用值（reference value），其中引用值是由多个值构成的对象。在执行赋值操作时，JS 引擎必须确定值是原始值还是引用值。因为：引用值是保存在内存中的对象，JS 不允许直接访问内存，在操作对象时，实际操作的是该对象的引用，而不是对象本身！</p>
<h2 id="二-基本类型的基础使用"><a class="header" href="#二-基本类型的基础使用">二 基本类型的基础使用</a></h2>
<h3 id="21-null-类型"><a class="header" href="#21-null-类型">2.1 Null 类型</a></h3>
<p>Null 类型只有一个值：<code>null</code>，用来表示一个空对象指针，所以在使用 typeof 判断其类型时返回 object。</p>
<pre><code class="language-js">let car = null
console.log(typeof car) // object
if (car != null) {
}
</code></pre>
<p>在声名一个引用类型变量时，推荐使用 null 来初始化，这时候就可以判断该变量是否已经被赋予了引用：</p>
<pre><code class="language-js">if (car != null) {
  // 此时 car 已经有引用了
}
</code></pre>
<h3 id="22-undefined-类型"><a class="header" href="#22-undefined-类型">2.2 Undefined 类型</a></h3>
<p>Undefined 类型也只有一个值：<code>undefined</code>，表示未初始化的变量值：</p>
<pre><code class="language-js">let message // 或者 let message = undefined
console.log(message == undefined) // true
console.log(typeof message) // undefined
</code></pre>
<p>undefined 这个值是由 null 派生而来，所以二者使用 <code>==</code> 判断时为 true，增加 undefined 的目的只是为了明确空指针对象与未初始化变量并不是一回事！</p>
<p>注意：未初始化与未定义也是两个概念，下面是未定义的变量，使用后会报错：</p>
<pre><code class="language-js">let msg
console.log(msg) // undefined
console.log(age) // 报错。但是这里崩溃的地方是对未声明变量进行：typeof(age) 的值为 undefined
</code></pre>
<p>使用推荐：</p>
<ul>
<li>无需为变量的值显式的设置为 undefined，直接定义即可：<code>let num</code></li>
<li>但是对象变量若没有真正保存变量，需要明确让其保存 null 值：<code>let obj = null</code></li>
</ul>
<h3 id="23-boolean-类型"><a class="header" href="#23-boolean-类型">2.3 Boolean 类型</a></h3>
<p>Boolean 类型有两个字面量：<code>true</code>、<code>false</code>，只能用小写。</p>
<pre><code class="language-js">let flag = true
</code></pre>
<p>JS 中很多值可以直接作为 false 处理：<code>false</code>、<code>null</code>、<code>undefined</code>、<code>''</code>、<code>0</code>、<code>NaN</code>。</p>
<h3 id="24-number-类型"><a class="header" href="#24-number-类型">2.4 Number 类型</a></h3>
<p>常见的整数表示：</p>
<pre><code class="language-js">//十进制
let n1 = 12
//八进制：0 开头，必须是 0~7 之间的数据，在严格模式下，八进制也是被禁止的！
let n2 = 012 // 如果是 08 则当成 8 处理，079 当成 79 处理
//十六进制：0x 开头，0-F 之间
let n3 = 0xacf
</code></pre>
<p>常见的浮点型数表示：</p>
<pre><code class="language-js">let n1 = 3.14
let n2 = 6.02e23 // 科学计数法，打印时程序会输出：6.02e+23，即：6.02 * 10 的 23 次方
let n3 = 0.1 // 写法有效，但是不推荐
</code></pre>
<p>贴士：保存浮点数的内存空间是整数内存空间的两倍，所以 JS 会将能够转换为整数的浮点转换为整数存储，如：<code>1.0</code>，<code>1.</code>，这些数字都会被解析为<code>1</code>。</p>
<p><strong>浮点数的运算不可靠</strong>，比如 <code>0.1+0.2</code>其值其实是<code>0.300 000 000 000 000 04</code>，浮点数的运算只能精确到 17 位小数，这是 IEEE754 数值标准所导致的，不是 JS 语法问题。</p>
<p>由于内存的限制，ECMAScript 并不能保存世界上所有的数值，运算的结果超出范围则返回无穷大或无穷小，表示不能再进行进一步计算：</p>
<ul>
<li>能表示的最大值获取方式：<code>Number.MAX_VALUE</code></li>
<li>能表示的最小值获取方式：<code>Number.MIN_VALUE</code></li>
<li>无穷大：<code>Infinity</code></li>
<li>无穷小：<code>-Infinity</code></li>
</ul>
<p><strong>NaN（Not a Number）是一个数值，表示本应该产生数值的运算操作失败了</strong>，如除 0 操作，所以 NaN 不等于任何值，包括自己，只能使用函数 isNaN(num) 来检查：</p>
<pre><code class="language-js">console.log(isNaN(NaN)) //true
console.log(isNaN(10)) //false（10 是一个数值）
console.log(isNaN('10')) //false（可以被转换成数值 10）
console.log(isNaN('blue')) //true（不能转换成数值）
console.log(isNaN(true)) //false（可以被转换成数值 1）
console.log(Nan == Nan) //false
</code></pre>
<h3 id="25-string-类型"><a class="header" href="#25-string-类型">2.5 String 类型</a></h3>
<p>String 在 JavaSctipt 中是基本类型！在很多别的语言中，String 是引用类型！</p>
<p>字符串类型（String）示例：</p>
<pre><code class="language-js">// 直接创建
let str = 'lisi' //也可以使用双引号
let name = `lisi` // ES6 中的字符串模板
// ES6 的模板字符串支持插值表达式
console.log(`他的名字是：${name}`)

// 使用构造函数创建字符串对象
let str2 = new String('字符串 2')
</code></pre>
<p>字符串中包含一些特殊字符字面量，即转义字符，用于表示一些特殊的用途，常见转义字符：</p>
<pre><code class="language-txt">\n  换行符
\v  垂直制表符
\f  换页符
\r  回车符
</code></pre>
<p>在 ES5 及其以后，字符串可以进行换行书写，每行末尾必须以<code>\</code>结束。</p>
<pre><code class="language-js">let str =
  'aaa\
    aa'
console.log(str) // aaaaa
</code></pre>
<p>当如果在字符串的值内部直接书写<code>\n</code>会表示换行：</p>
<pre><code class="language-js">let str = 'aaa\naa'
console.log(str) // aaa aa
</code></pre>
<p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。</p>
<p><code>toString()</code> 可以将数据转换为字符串，无需参数，比如数值、布尔都可以：</p>
<pre><code class="language-js">let age = 11
let ageAsString = age.toString() // 字符串&quot;11&quot;
let found = true
let foundAsString = found.toString() // 字符串&quot;true&quot;

let num = 10
console.log(num.toString()) // &quot;10&quot;
console.log(num.toString(2)) // &quot;1010&quot;
console.log(num.toString(8)) // &quot;12&quot;
console.log(num.toString(10)) // &quot;10&quot;
console.log(num.toString(16)) // &quot;a&quot;
</code></pre>
<p><code>toString()</code> 针对 undefined、null 之类的数据调用方法会失败，此处可以采用 <code>String()</code>，该函数默认调用<code>toString()</code>，在遇到 undefined、null 后，会将 null 转换为 &quot;null&quot;，undefined 转换为 &quot;undefined&quot;：</p>
<pre><code class="language-js">let value1 = 10
let value2 = true
let value3 = null
let value4
console.log(String(value1)) // &quot;10&quot;
console.log(String(value2)) // &quot;true&quot;
console.log(String(value3)) // &quot;null&quot;
console.log(String(value4)) // &quot;undefined&quot;
</code></pre>
<h3 id="26-symbol-类型"><a class="header" href="#26-symbol-类型">2.6 Symbol 类型</a></h3>
<p>Symbol 类型是 ES6 新增数据类型，在 12 节中专门讲解。</p>
<h2 id="三-引用类型"><a class="header" href="#三-引用类型">三 引用类型</a></h2>
<h3 id="31-引用类型的基本使用"><a class="header" href="#31-引用类型的基本使用">3.1 引用类型的基本使用</a></h3>
<p>引用类型在 JavaScript 中通过 <code>typeof</code> 获得的结果是 <code>object</code>，即引用类型变量存储的值，其实是一个对象，把数据与功能组织到一起的结构，该变量既能存储一定的数据，也保留了一定的行为供用户使用。</p>
<p>示例：</p>
<pre><code class="language-js">// 基本类型
let num1 = 10
let num2 = num1
num1 = 11
console.log(num2) // 10

// 引用类型
let arr = [1, 2, 3]
let arr2 = arr
arr[0] = 9
console.log(arr2) // [ 9, 2, 3 ]
</code></pre>
<p>在上述示例中：</p>
<ul>
<li>数据类型 num1 是基础数据类型，在赋值给 num2 时，是重新申请的内存，并将值拷贝过来进行存储。</li>
<li>数据类型 arr 是引用类型，在复制给 arr2 时，也重新申请内存，但是拷贝过来的是 arr 的内存地址，而不是地址指向的值</li>
</ul>
<p>引用类型存储的数据其实是真实数据在内存中的地址，引用类型的变量复制其实复制的是一个指针，该指针指向存储在堆内存中的真实对象。</p>
<p>在 JS 数据类型中，Object 类型即是引用类型，其实就是一组数据和功能的合集，通过 new 操作符获取该合集具体的一个实例：</p>
<pre><code class="language-js">let obj = new Object() // 没有参数时 () 可以省略，但是不推荐！
</code></pre>
<p>基于 Object 类型还有一些衍生的引用类型，如：Array、Function、Date、Math 等。所以 Object 与 Java 中的 java.lang.Object 类非常相似，也是派生其他对象的<code>基类</code>，即是所有类的祖先！</p>
<p>每个 Object 类的实例都有如下属性和方法：</p>
<ul>
<li><code>constructor</code>：用于创建当前对象实例的函数。在前面的例子中，这个属性的值就是 Object() 函数。</li>
<li><code>hasOwnProperty(propertyName)</code>：用于判断当前对象实例上是否存在给定的属性。</li>
<li><code>isPrototypeOf(object)</code>：用于判断当前对象是否为另一个对象的原型。</li>
<li><code>propertyIsEnumerable(propertyName)</code>：用于判断给定的属性是否可以使用 for-in 语句枚举。</li>
<li><code>toLocaleString()</code>：返回对象的字符串，该字符串反映对象所在的本地化执行环境。</li>
<li><code>toString()</code>：返回对象的字符串。</li>
<li><code>valueOf()</code>：返回对象对应的字符串、数值或布尔值表示。通常与 toString() 的返回值相同。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="032-数据类型-数据类型的转换"><a class="header" href="#032-数据类型-数据类型的转换">03.2-数据类型-数据类型的转换</a></h1>
<h2 id="一-查看数据类型方式"><a class="header" href="#一-查看数据类型方式">一 查看数据类型方式</a></h2>
<h3 id="11-typeof"><a class="header" href="#11-typeof">1.1 typeof</a></h3>
<p>使用 <code>typeof</code>关键字或者<code>typeof()</code>函数可以获得变量的数据类型：</p>
<pre><code class="language-js">let num = 3
let str = 'hello world!'
let fn = function () {}
let arr = [1, 3, 6, 7]
console.log(typeof num) // number
console.log(typeof str) // string
console.log(typeof fn) // function（旧版浏览器会输出 object，新版改为了 function）
console.log(typeof arr) // object
</code></pre>
<p>null 被认为是一个空对象的引用，所以<code>typeof null</code>也返回 object。</p>
<p>Safari 5 及之前版本、Chrome 7 及之前版本在对正则表达式调用 typeof 操作符时会返回&quot;function&quot;，而其他浏览器在这种情况下会返回&quot;object&quot;。函数在 JavaScript 中被认为是一种特殊的对象，拥有自己的特殊属性，但并不是数据类型！</p>
<h3 id="12-instanceof"><a class="header" href="#12-instanceof">1.2 instanceof</a></h3>
<p>如果要知道数据类型的具体类型，如<code>typeof []</code>返回 object，其具体类型是数组，此时可以使用关键字<code>instanceof</code>：</p>
<pre><code class="language-js">let arr = [1, 3, 6, 7]
console.log(arr instanceof Array) // true
</code></pre>
<h2 id="二-数据类型转换"><a class="header" href="#二-数据类型转换">二 数据类型转换</a></h2>
<h3 id="21-转换为字符串"><a class="header" href="#21-转换为字符串">2.1 转换为字符串</a></h3>
<p>toString() 方法示例：</p>
<pre><code class="language-js">// 定义一个数字
let a = 3
console.log(typeof a) // number

// toString() 方法转换为字符串
let b = a.toString() // 数字转换为字符串
console.log(typeof b) // string

// 字符串也可以再转变为数字
let c = parseInt(b) // 字符串转换为数字
console.log(typeof c) // number
</code></pre>
<p>toString() 方法可以传入参数，表示以多少进制格式返回数值的字符串：</p>
<pre><code class="language-js">let num = 10
console.log(num.toString()) // &quot;10&quot;
console.log(num.toString(2)) // &quot;1010&quot;
console.log(num.toString(8)) // &quot;12&quot;
console.log(num.toString(10)) // &quot;10&quot;
console.log(num.toString(16)) // &quot;a&quot;
</code></pre>
<p>注意：null 和 undefined 值分别返回 &quot;null&quot; 、&quot;undefined&quot;，因为 null 和 undefined 是没有 toString() 方法的。</p>
<h3 id="22-转换为-boolean-类型"><a class="header" href="#22-转换为-boolean-类型">2.2 转换为 Boolean 类型</a></h3>
<p>任何数据都可以转换成布尔类型，布尔也可以转换为字符串/数字 (转换为数字时，true 转换为 1，false 转换为 0)：</p>
<pre><code class="language-js">console.log(Boolean(12)) //true
console.log(Boolean(0)) //false

let b = Boolean(12)
console.log(b.toString()) //转换为了字符串 true
</code></pre>
<h3 id="33-转换为数字"><a class="header" href="#33-转换为数字">3.3 转换为数字</a></h3>
<p><strong>Number()、parseInt()、parseFloat() 可以将非数值转换为数值</strong>，后 2 个函数主要用于将字符串转换为数值。</p>
<p>Number() 的转换规则：</p>
<ul>
<li>常见参数：数值直接返回，true/false 分别转换为 1/0，null 转换为 0，undefined 转换为 NaN。</li>
<li>字符串参数：空字符串返回 0，<code>Number('011')</code>为 11，<code>Number('01.1')</code>为 1.1，若字符串包含上述情况外的其他字符，返回 NaN。</li>
<li>对象参数：调用 valueof() 方法，按照上述规则返回，若转换结果是 NaN，则调用 toString() 方法再次转换。</li>
</ul>
<p>Number() 的转换整数规则较为复杂，通常使用 parseInt()：</p>
<ul>
<li>排除空格后，如果第一个字符不是数值字符、+、-，直接返回 NaN，所以空字符串也返回 NaN</li>
<li>接着上述规则依次检测每个字符，如&quot;1234blue&quot;会被转换为 1234</li>
<li>parseInt() 能识别数据的进制，但是也可以在第二个参数中直接传递防止混淆，比如 <code>parseInt(&quot;AF&quot;, 16)</code>，比传入 16 则会直接失败</li>
</ul>
<p>parseInt()：专门用于把字符串转换为整数值。不会像 Number 那样查看规则，有什么数字就会转换为什么数字，如<code>parseInt(&quot;123 你好&quot;)</code>则会转换为 123</p>
<p>parseFloat()：专门用于把字符串转换为小数值，用法同 parseInt()</p>
<p>注意：parseInt() 之类的函数更常用，但是在 ES5 中，<code>070</code>这样的八进制字面量会被直接转换为十进制的 70，而不会是 56，为了解决这个问题，可以传入第二个参数：</p>
<pre><code class="language-js">let num = parseInt('0xAF', 16) //175

// 此时类似十六进制的数据也不需要带 0x 前缀了
let num1 = parseInt('AF', 16) //175
let num2 = parseInt('AF') //NaN
</code></pre>
<p>parseFload() 的示例：</p>
<pre><code class="language-js">let num1 = parseFloat('1234blue') //1234（整数）
let num2 = parseFloat('0xA') //0
let num3 = parseFloat('22.5') //22.5
let num4 = parseFloat('22.34.5') //22.34
let num5 = parseFloat('0908.5') //908.5
let num6 = parseFloat('3.125e7') //31250000
</code></pre>
<h3 id="34-隐式转换"><a class="header" href="#34-隐式转换">3.4 隐式转换</a></h3>
<p>调用方法显式的将数据类型进行改变称为显示转换，JS 中一些操作也会隐式造成数据类型的转换：</p>
<pre><code class="language-js">console.log(233 + '哈哈') // 233 哈哈   这里 233 被隐式转换为了字符串
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-运算符"><a class="header" href="#041-运算符">04.1-运算符</a></h1>
<h2 id="一-js-运算符分类"><a class="header" href="#一-js-运算符分类">一 JS 运算符分类</a></h2>
<p>根据操作的数据数目，可以将操作符划分为一元运算符、二元运算符、三元运算符等：</p>
<ul>
<li>一元运算符：即只能操作一个值的运算符
<ul>
<li>正号、负号、平方、位运算</li>
<li>自增 <code>++</code> ，自减 <code>--</code></li>
<li><code>delete</code>、<code>typeof</code> <code>void</code> 等也被归纳为运算符</li>
</ul>
</li>
<li>二元运算符：即操作两个值的运算符
<ul>
<li>加、减、乘、除、模</li>
</ul>
</li>
<li>三元运算符：<code>表达式？值 1：值 2</code>，（表达式成立取值 1，不成立取值 2）</li>
</ul>
<p>需要注意的是，使用运算符可能出现数据类型的转换，如类似自增自减这样的运算符会遵循下列规范：</p>
<ul>
<li>对于有效数字字符串会先转换为数字，再运算</li>
<li>对于不包含有效数字的字符串，其值会设置为 NaN</li>
<li>对于 Boolean 类型，false 会先转换为 0，true 会转换为 1 再运算</li>
<li>在操作对象时，先调用对象的 valueOf() 方法返回一个可供操作的值，然后依据该值根据上述规律执行操作</li>
</ul>
<h2 id="二-常见运算符的使用"><a class="header" href="#二-常见运算符的使用">二 常见运算符的使用</a></h2>
<h3 id="21-自增自减"><a class="header" href="#21-自增自减">2.1 自增自减</a></h3>
<p>一元运算符中较为特殊的是自增自减运算符：</p>
<ul>
<li>i++：当 i++参与运算，先将 i 原来的值赋值给变量，自己再加 1（先赋值后计算）</li>
<li>++i：当++i 参与运算，先将变量加 1，然后将加 1 后的值赋值给另外一个变量（先计算后赋值）</li>
</ul>
<pre><code class="language-js">let num1 = 2
let num2 = 20
let num3 = num1-- + num2
let num4 = num1 + num2

console.log(num3) // 22
console.log(num4) // 21
</code></pre>
<h3 id="22-位运算"><a class="header" href="#22-位运算">2.2 位运算</a></h3>
<p>在计算机内存中，使用 0 与 1 这样的进制位来表示数据，每一个 0 或者 1 代表一位。JS 的数值以 64 位格式存储，但是位运算会先将 64 位值转换为 32 位整数再进行操作，最后将结果转换回 64 位，所以对于开发者来说，仿佛不存在 64 位整数存储格式，只需要考虑 32 位整数即可。</p>
<p>对于有符号的整数，32 位数据从右至左开始，前 31 位用于表示整数的值，第 32 位是符号位（sign bit）。</p>
<p>以下示例中，数值 18 的二进制表示是：</p>
<pre><code class="language-txt"># 8 的二进制
# 从右至左第32位（左侧第1个）为符号位，0表示正数，1表示负数
# 数值中没有用到的位用 0 来填充

0000 0000 0000 0000 0000 0000 0001 0010
</code></pre>
<p>其实我们可以看到有效位只有 5 位，即：<code>1 0010</code> 这决定实际的值。</p>
<p>$10010 = 2^4 \times 1 + 2^3 \times 0 + 2^2 \times 0 + 2^1 \times 1 + 2^0 \times 0$</p>
<p>由此看到，正数以真正的二进制格式存储，31 位中每一位都是 2 的幂。</p>
<p>负数使用的是二进制补码进行存储的：</p>
<ul>
<li>第一步：先求其绝对值的二进制码，如求 -18 的补码，要先得到其绝对值 18 的二进制码：<code>0000 0000 0000 0000 0000 0000 0001 0010</code></li>
<li>第二步：求绝对值二进制的反码，即 0 和 1 互换，上述二进制位的反码为：<code>1111 1111 1111 1111 1111 1111 1110 1101</code></li>
<li>第三步：反码加 1，得到最终 -18 的二进制位表示结果：<code>1111 1111 1111 1111 1111 1111 1110 1110</code></li>
</ul>
<p>但是 ECMAScript 隐藏了很多细节，在以二进制输出一个负数时，其实是输出这个负数绝对值的二进制码，并添加一个符号，这样处理更符合现实显式逻辑：</p>
<pre><code class="language-js">let num = -18
console.log(num.toString(2)) // &quot;-10010&quot;
</code></pre>
<p>贴士：</p>
<ul>
<li>由于 ECMAScript 做位运算时，会进行 64 与 32 位的转换，这会导致一个后果，NaN 和 Infinity 的值在位操作中，会被视为 0 来处理。</li>
<li>对非数值进行位操作时，会先使用 Number() 方法将其自动转换为一个数值，然后进行位操作</li>
</ul>
<p>常见的位操作：</p>
<ul>
<li><code>~</code> (按位非 NOT）：操作数为 1 则转换为 0，为 0 则转换为 1。其本质其实是操作数的负值减一，如 25 执行按位非，得到 -26，示例：<code>console.log(~25)</code></li>
<li><code>&amp;</code> (按位与 AND）：操作数都为 1 则转换为 1，其余情况都为 0，示例结果为 1：<code>console.log(25 &amp; 3);</code></li>
<li><code>|</code> (按位或 OR）：操作数都为 0 则按位或结果为 0，其余情况都为 1，示例结果为 1：<code>console.log(25 | 3);</code></li>
<li><code>^</code> (按位异或 XOR）：操作数不同为 1，相同为 0，示例结果为 26：<code>console.log(25 ^ 3);</code></li>
<li><code>&lt;&lt;</code> (左移)：位向左移动，右侧空出来的空位使用 0 补充。注意：左移不会影响操作数的符号位</li>
<li><code>&gt;&gt;</code> (右移)：位向右移动，空位使用符号位的值来填充，所以右移动会保留符号位。无符号的右移动使用 <code>&gt;&gt;&gt;</code> 表示，该操作会将操作数的所有 32 位都向右移动：如果是正数，则有无符号的右移动，结果都是相同的；如果是负数，无符号右移以 0 补充空位！</li>
</ul>
<h3 id="23-布尔运算"><a class="header" href="#23-布尔运算">2.3 布尔运算</a></h3>
<p>布尔操作包括：逻辑非、逻辑与。</p>
<p>逻辑非：即使用 ! 取反，要注意的是 NaN、null、undefined、'' 取反得到的都是 true。</p>
<p>逻辑与：使用 &amp;&amp; ，两个操作数中有一个操作数为 false，则结果就位 false，两个操作数都为 true，结果才为 true。注意逻辑与不一定返回布尔值：</p>
<ul>
<li>如果第一个操作数是对象，则返回第二个操作数；</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；</li>
<li>如果两个操作数都是对象，则返回第二个操作数；</li>
<li>如果有一个操作数是 null，则返回 null；</li>
<li>如果有一个操作数是 NaN，则返回 NaN；</li>
<li>如果有一个操作数是 undefined，则返回 undefined。</li>
<li>逻辑或：使用 || ，两个操作数都为 false，结果才为 false，否则都为 true。同样逻辑或也不一定返回布尔值：</li>
<li>如果第一个操作数是对象，则返回第一个操作数；</li>
<li>如果第一个操作数的求值结果为 false，则返回第二个操作数；</li>
<li>如果两个操作数都是对象，则返回第一个操作数；</li>
<li>如果两个操作数都是 null，则返回 null；</li>
<li>如果两个操作数都是 NaN，则返回 NaN；</li>
<li>如果两个操作数都是 undefined，则返回 undefined。</li>
</ul>
<blockquote>
<p>短路操作：第一个操作数能够决定结果，就不会再对第二个操作数求值，逻辑与就是短路操作</p>
</blockquote>
<p>所以下面的代码就不会报错：</p>
<pre><code class="language-js">let found = false
let result = found &amp;&amp; someUndefinedletiable // 不会发生错误，使用逻辑或 || 就会发生错误
console.log(result) // 会执行（ &quot;false&quot;）
</code></pre>
<h3 id="24-加减乘除与取模"><a class="header" href="#24-加减乘除与取模">2.4 加减乘除与取模</a></h3>
<p><code>+</code> 表示加法，遵循以下规则：</p>
<ul>
<li>如果有一个操作数是 NaN，则结果是 NaN；</li>
<li>Infinity 加 Infinity，结果是 Infinity；-Infinity 加 -Infinity，结果是-Infinity；Infinity 加 -Infinity，结果是 NaN；</li>
<li>如果是 +0 加 +0，则结果是 +0；如果是 -0 加 -0，则结果是 -0；如果是 +0 加 -0，则结果是 +0。</li>
<li>如果有一个操作数是字符串，那么就要应用如下规则：</li>
<li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。</li>
<li>如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String() 函数并取得字符串&quot;undefined&quot;和&quot;null&quot;。</li>
</ul>
<p><code>-</code> 表示减法，遵循以下规则：</p>
<ul>
<li>如果有一个操作数是 NaN，则结果是 NaN；</li>
<li>Infinity 减 Infinity 以及 -Infinity 减 -Infinity，结果都是 NaN；Infinity 减 -Infinity，则结果是 Infinity；-Infinity 减 Infinity，则结果是-Infinity；</li>
<li>如果是 +0 减 +0，则结果是 +0；如果是 +0 减 -0，则结果是 -0；如果是 -0 减 -0，则结果是 +0；</li>
<li>如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN；</li>
<li>如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf() 方法，则调用其 toString() 方法并将得到的字符串转换为数值</li>
</ul>
<p><code>*</code> 表示乘法，在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：</p>
<ul>
<li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；</li>
<li>如果有一个操作数是 NaN，则结果是 NaN；</li>
<li>如果是 Infinity 与 0 相乘，则结果是 NaN；</li>
<li>如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；</li>
<li>如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；</li>
<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。</li>
</ul>
<p><code>/</code> 表示除法，也遵循类似规则：</p>
<ul>
<li>如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围，则返回 Infinity 或-Infinity；</li>
<li>如果有一个操作数是 NaN，则结果是 NaN；</li>
<li>如果是 Infinity 被 Infinity 除，则结果是 NaN；</li>
<li>如果是零被零除，则结果是 NaN；</li>
<li>如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；</li>
<li>如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；</li>
<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。</li>
</ul>
<p><code>%</code> 表示取模，特殊值处理规则如下：</p>
<ul>
<li>如果操作数都是数值，执行常规的除法计算，返回除得的余数；</li>
<li>如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；</li>
<li>如果被除数是有限大的数值而除数是零，则结果是 NaN；</li>
<li>如果是 Infinity 被 Infinity 除，则结果是 NaN；</li>
<li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；</li>
<li>如果被除数是零，则结果是零；</li>
<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。</li>
</ul>
<p>贴士：Math.pow() 是指数操作，但是 ES7 推出了指数运算符</p>
<pre><code class="language-js">console.log(Math.pow(3, 2); // 9
console.log(3 ** 2); // 9
</code></pre>
<h3 id="25-关系运算符"><a class="header" href="#25-关系运算符">2.5 关系运算符</a></h3>
<p>进行关系比较时，也会出现数据不是正常数值的比较情况：</p>
<ul>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li>
<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li>
<li>如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf() 方法，则调用 toString() 方法，并用得到的结果根据前面的规则执行比较。</li>
<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较</li>
</ul>
<p>注意：字母比较大小比较的是其字符编码值；<code>&quot;23&quot; &lt; &quot;3&quot;</code>结果是 true，因为同样比较的也是编码值，2 的编码值是 50，3 是 51</p>
<p>在比较相等时，额外要注意：</p>
<ul>
<li>null 和 undefined 是相等的</li>
<li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值</li>
<li>如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。即使两个操作数都是 NaN，相等操作符也返回 false</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true；否则，返回 false。</li>
</ul>
<p><code>===</code>表示全等于，表示只有在两个操作数未经转换就相等的情况下才返回 true。</p>
<h2 id="三-运算符优先级"><a class="header" href="#三-运算符优先级">三 运算符优先级</a></h2>
<pre><code class="language-txt">1   ()
2   !、-（负数）、++、-- （正数省略+）（一元运算）
3   *、/、%
4   +、- （加，减）（二元运算）
5   &lt;、&lt;=、&lt;、&gt;= （一级逻辑运算）
6   ==、!=、===、!==、 （二级逻辑运算）
7   &amp;&amp; （三级级逻辑运算）
8   ||
9   ?: （三元运算）
10  =、+=、-=、*=、/=、%= （赋值运算）
</code></pre>
<h2 id="四-知识补充"><a class="header" href="#四-知识补充">四 知识补充</a></h2>
<h3 id="41-溢出与下溢"><a class="header" href="#41-溢出与下溢">4.1 溢出与下溢</a></h3>
<p>JS 的算术运算在溢出（overflow）或者被零整除时不会报错，而是会返回一个数字上限，表示无穷大，即：<code>+Infinity</code>、<code>-Infinity</code>。</p>
<pre><code class="language-js">console.log(15 / 0) // Infinity
console.log(-15 / 0) // -Infinity
</code></pre>
<p>JS 的算术运算在下溢（underflow）时候也不会报错，而是直接返回 0。下溢即结果值无限趋近于 0：</p>
<pre><code class="language-js">console.log(0.1 / 10e1000) // 0
</code></pre>
<p><code>0/0</code>是没有意义的，会返回一个非数字 NaN。无穷大除以无胸大、负数做开放运算、不是数字的数据进行算术运算，都会返回 NaN：</p>
<pre><code class="language-js">console.log(0 / 0) // NaN
</code></pre>
<h3 id="42-12-0102--03"><a class="header" href="#42-12-0102--03">4.2 1.2 0.1+0.2 == 0.3</a></h3>
<p>先看示例：</p>
<pre><code class="language-js">console.log(0.1 + 0.2 == 0.3) // false
console.log(0.1 + 0.3 == 0.4) // true
</code></pre>
<p>上述并不是 JS 语言的特例，几乎所有现代编程语言都有上述特性，因为他们都使用了 IEEE-754 浮点数表示法。</p>
<h3 id="43-直接量表达式"><a class="header" href="#43-直接量表达式">4.3 直接量表达式</a></h3>
<pre><code class="language-js">// 数组直接量
let arr = [1, 2, 3]

// 对象直接量
let obj = {
  name: 'lisi',
  age: 20,
}

// 函数直接量
let fn = function () {}
</code></pre>
<h3 id="44---运算符的短路"><a class="header" href="#44---运算符的短路">4.4 &amp;&amp; || 运算符的短路</a></h3>
<p>&amp;&amp; || 运算符可以用来填充默认值：</p>
<pre><code class="language-js">// 这样设计变量可以做为默认值处理
let p = 'Angel' || 'Demon'
console.log(p)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-数组-数组的基本使用"><a class="header" href="#061-数组-数组的基本使用">06.1-数组-数组的基本使用</a></h1>
<h2 id="一-流程控制概念"><a class="header" href="#一-流程控制概念">一 流程控制概念</a></h2>
<p>ECMA-262 描述了一些流控制语句，用来完成既定的任务，包含：条件语句、循环语句等</p>
<h2 id="二-条件语句"><a class="header" href="#二-条件语句">二 条件语句</a></h2>
<h3 id="21-if-语句"><a class="header" href="#21-if-语句">2.1 if 语句</a></h3>
<p>if 条件句：</p>
<pre><code class="language-js">if () {

}
</code></pre>
<p>if else 条件句：</p>
<pre><code class="language-js">if () {

} else {

}
</code></pre>
<p>else if 条件句：</p>
<pre><code class="language-js">if () {

} else if () {

} else if () {

} else {

}
</code></pre>
<h3 id="21-switch-语句"><a class="header" href="#21-switch-语句">2.1 switch 语句</a></h3>
<p>switch 条件句：</p>
<pre><code class="language-js">switch (值1) {
    case value1:
        程序1；
        break;
    case value2:
        程序2；
        break;
    default:
        程序3；
}
</code></pre>
<p>注意：
break 可以省略，如果省略，代码会继续执行下一个 case；
switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换
（例如，字符串 &quot;10&quot; 不等于数值 10）；
switch 中的变量数据类型必须和 case 后面值的数据类型一致。</p>
<h2 id="三-循环语句"><a class="header" href="#三-循环语句">三 循环语句</a></h2>
<h3 id="31-for-语句"><a class="header" href="#31-for-语句">3.1 for 语句</a></h3>
<p>for 是一种线测试语句，即先依据初始化条件和后续表达式，检测退出条件，再执行循环体代码：</p>
<pre><code class="language-js">for (let i = 0; i &lt; 10; i++) {}
</code></pre>
<h3 id="32-while-语句"><a class="header" href="#32-while-语句">3.2 while 语句</a></h3>
<p>while 也是一种先测试循环语句，不过不需要增加进入循环前的初始化代码和后续执行表达式：</p>
<pre><code class="language-js">let i = 10
while (i &lt;= 10) {
  console.log(i)
  i++
}
</code></pre>
<h3 id="33-do-while-语句"><a class="header" href="#33-do-while-语句">3.3 do while 语句</a></h3>
<p>do while 是一种后测试循环语句，循环体代码执行后才会对退出条件进行求值：</p>
<pre><code class="language-js">do {
  console.log(1)
} while (i &gt; 10)
{
  console.log(2)
}
</code></pre>
<p>代码首先执行 do 中的代码语句。然后判断条件是否满足。如果条件满足，那么继续执行 do 中的代码语句。否则不再执行。</p>
<h3 id="34-for-in-语句"><a class="header" href="#34-for-in-语句">3.4 for-in 语句</a></h3>
<p>for-in 是严格迭代语句，用于枚举对象中的非符号键。如下示例输出 window 对象的键：</p>
<pre><code class="language-js">for (const key in window) {
  console.log(key)
}
</code></pre>
<p>贴士：由于对象属性无序，所以 for-in 语句也不能保证返回的对象属性的顺序。如果迭代对象是 null/undefined，则不执行循环体。</p>
<h3 id="35-for-of-语句"><a class="header" href="#35-for-of-语句">3.5 for-of 语句</a></h3>
<p>for-of 是严格迭代语句，用于遍历可迭代对象的元素：</p>
<pre><code class="language-js">for (const item of [2, 3, 4, 5]) {
  console.log(item)
}
</code></pre>
<p>for-of 会根据课迭代对象的 next()方法产生的值按顺序迭代元素。如果迭代变量不支持迭代，则抛出错误。</p>
<h3 id="36-break-与-continue-跳出循环"><a class="header" href="#36-break-与-continue-跳出循环">3.6 break 与 continue 跳出循环</a></h3>
<p>break 和 continue 都可用于跳出当前循环，但是二者有不同：</p>
<ul>
<li>break：跳出当前循环，且循环不再执行</li>
<li>continue：跳出当前循环，但是会继续下一次循环（如果仍然可以循环的话）</li>
</ul>
<h2 id="四-其他相关流程控制语句"><a class="header" href="#四-其他相关流程控制语句">四 其他相关流程控制语句</a></h2>
<h3 id="41-标签语句"><a class="header" href="#41-标签语句">4.1 标签语句</a></h3>
<p>使用 label 语句可以在代码中添加标签，以便将来使用。下面的示例中标签语句与 break 一起使用：</p>
<pre><code class="language-js">let num = 100

// 定义一个名为 start 的 label
start: for (let i = 1; i &lt;= 10; i++) {
  if (i == 5) {
    break start
  }
  num++
  console.log(i)
}
console.log(num) // 104
</code></pre>
<h3 id="42-with-语句"><a class="header" href="#42-with-语句">4.2 with 语句</a></h3>
<p>with 是饱受诟病的关键字，不推荐使用。with 的作用是将代码的作用域设置到一个特定对象中：</p>
<pre><code class="language-js">// 普通的定义变量
let qs = location.search.substring(1)
let hostName = location.hostname
let url = location.href

// 使用 with 定义
with (location) {
  let qs = search.substring(1)
  let hostName = hostname
  let url = href
}
</code></pre>
<p>上述示例使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询 location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。</p>
<p>严格模式下不允许使用 with 语句，否则将视为语法错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-数组的基本使用"><a class="header" href="#061-数组的基本使用">06.1-数组的基本使用</a></h1>
<p>本章节主要说明数组的基本使用方式，如：创建、遍历等。在 02-JavaScript 语法进阶的 06.1-容器对象-Array 中更加深入的记录了数组的高阶使用方式。</p>
<h2 id="一-数组的基本使用"><a class="header" href="#一-数组的基本使用">一 数组的基本使用</a></h2>
<h3 id="11-数组的创建"><a class="header" href="#11-数组的创建">1.1 数组的创建</a></h3>
<p>数组的常见创建方式是：字面量方式、构造函数方式，此外 ES6 新增了 2 个静态方法 <code>Array.from()</code>，<code>Array.of()</code> 会在 02-JavaScript 语法进阶的 06.1-容器对象-Array 中介绍：</p>
<pre><code class="language-js">// 直接量方式
let arr0 = [] // 创建一个空数组
let arr1 = [1, 3, 5, 7, 9] // 创建一个包含5个元素的数组
console.log(arr1.length) // 数组长度：5

// 构造函数方式：此时 new 可以省略
let arr2 = new Array()
console.log(arr2.length) // 数组长度：0
console.log(arr2[2]) // undefined

let arr3 = new Array(20) // 初始化一个长度为20的空数组
let arr4 = new Array('zs', 'ls') // 初始化一个拥有2个字符串元素的数组
</code></pre>
<p>注意：在使用构造函数创建数组时，可以传入数字参数，代表创建数组时，会预先申请数值长度的内存。</p>
<h3 id="12-数组的空位"><a class="header" href="#12-数组的空位">1.2 数组的空位</a></h3>
<p>数组字面初始化的时候可以使用一串逗号来创建空位（ hole）。 ES6 之前的方法则会忽略这个空位，ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined：</p>
<pre><code class="language-js">let arr2 = [1, , 3] // 创建了一个元素是空位，值为 undefined
console.log(arr2[2]) // 元素值为：undefined

const options = [, , , , ,] // 创建包含 5 个元素的数组
console.log(options.length) // 5
console.log(options) // [,,,,,]
</code></pre>
<h3 id="13-数组的存取"><a class="header" href="#13-数组的存取">1.3 数组的存取</a></h3>
<p>要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如下所示：</p>
<pre><code class="language-js">let colors = ['red', 'blue', 'green'] // 定义一个字符串数组
console.log(colors[0]) // 显示第一项
colors[2] = 'black' // 修改第三项
colors[3] = 'brown' // 添加第四项
</code></pre>
<p>如果把一个值设置给超过数组最大索引的索引，就像示例中的 <code>colors[3]</code>，则数组长度会自动扩展到该索引值加 1（示例中设置的索引 3，所以数组长度变成了 4）。</p>
<p>数组中元素的数量保存在 length 属性中，这个属性始终返回 0 或大于 0 的值。不过要注意的是 <strong>length 属性不是只读的</strong>，通过修改 length 属性，可以从数组末尾删除或添加元素：</p>
<pre><code class="language-js">let colors = ['red', 'blue', 'green'] // 创建一个包含 3 个字符串的数组
colors.length = 2
console.log(colors[2]) // undefined
</code></pre>
<p>贴士：数组中最后一个元素的索引始终是 length - 1，如果将 length 设置为大于数组元素数的值，则新添加的元素都将以 undefined 填充。</p>
<h3 id="14-数组的检测"><a class="header" href="#14-数组的检测">1.4 数组的检测</a></h3>
<p>在只有一个全局执行上下文的情况下，使用 instanceof 可以检测数组：</p>
<pre><code class="language-js">if (arr instanceof Array) {
  // 操作数组
}
</code></pre>
<p>如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。 ECMAScript 提供了 Array.isArray()方法用来确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的：</p>
<pre><code class="language-js">if (Array.isArray(arr)) {
  // 操作数组
}
</code></pre>
<h2 id="二-数组遍历"><a class="header" href="#二-数组遍历">二 数组遍历</a></h2>
<h3 id="40-数组的遍历方式"><a class="header" href="#40-数组的遍历方式">4.0 数组的遍历方式</a></h3>
<p>通过基本的 for 循环即可遍历数组，也可以通过 for-in，for-of 的迭代来遍历，当然 Array 的实例方法还提供了类似 forEach()，map()这样的迭代方法，本章节简单介绍基础的便利方式</p>
<h3 id="41-for-循环遍历"><a class="header" href="#41-for-循环遍历">4.1 for 循环遍历</a></h3>
<p>一般使用 for 循环直接遍历数组：</p>
<pre><code class="language-js">let arr = [1, 2, 5, 8]

let length = arr.length
for (let i = 0; i &lt; arr.length; i++) {
  console.log(arr[i])
}
</code></pre>
<h3 id="42-for-in-遍历"><a class="header" href="#42-for-in-遍历">4.2 for-in 遍历</a></h3>
<p>如果是稀疏数组，推荐使用 for-in 进行遍历：</p>
<pre><code class="language-js">let arr = new Array(10)

arr[1] = 12
arr[3] = 13

for (let item in arr) {
  console.log(item) // 只会输出 1 3
}
</code></pre>
<h3 id="43-for-of-遍历"><a class="header" href="#43-for-of-遍历">4.3 for-of 遍历：</a></h3>
<pre><code class="language-js">const arr = [1, 2, 3, 4, 5]
for (const iterator of arr) {
  console.log(iterator) // 1 2 3 4 5
}
</code></pre>
<h3 id="44-foreach-方法迭代"><a class="header" href="#44-foreach-方法迭代">4.4 forEach() 方法迭代</a></h3>
<p>forEach()本质上就是普通 for 循环：</p>
<pre><code class="language-js">let arr = [1, 2, 3, 4, 5]
let sum = 0
// 函数参数支持多个
arr.forEach(function (value) {
  // 支持多个参数
  sun += value
})
</code></pre>
<p>注意：forEach 不支持 break 语句，提前终止需要放在 try 中跑出异常处理：</p>
<pre><code class="language-js">function foreach(a, f, t) {
  try {
    a.forEach(f, t)
  } catch (e) {
    if (e === foreach.break) {
      return
    } else {
      throw e
    }
  }
}

foreach.break = new Error('StopIteration')
</code></pre>
<h2 id="二-数组的实例方法"><a class="header" href="#二-数组的实例方法">二 数组的实例方法</a></h2>
<h3 id="20-数组的实例方法汇总"><a class="header" href="#20-数组的实例方法汇总">2.0 数组的实例方法汇总</a></h3>
<p>数组的实例方法有：栈方法（push/pop），队列方法(shift)，排序，操作，搜索，复制，填充，转换，迭代，归并等。本章节主要介绍：栈方法，队列方法，排序方法，操作方法，搜索方法。复制，填充，转换，迭代，归并位于 02-JavaScript 语法进阶的 06.1-容器对象-Array 中。</p>
<h3 id="21-pushpop-栈方法"><a class="header" href="#21-pushpop-栈方法">2.1 push()、pop() 栈方法</a></h3>
<p>数组对象的实例都具备 压栈方法 push() 和 弹栈方法 pop() 用来模仿数据结构栈：</p>
<pre><code class="language-js">let arr = [2, 3, 5]

// push：末尾追加元素
arr.push(7)
console.log(arr) // [ 2, 3, 5, 7 ]

// pop：末尾删除元素
arr.pop()
console.log(arr) // [ 2, 3, 5 ]
</code></pre>
<h3 id="22-shiftunshift队列方法"><a class="header" href="#22-shiftunshift队列方法">2.2 shift()、unshift()队列方法</a></h3>
<p>数组对象的实例都具备 shift 和 unshift 方法，用来模仿数据结构队列：</p>
<pre><code class="language-js">// unshift: 首位添加元素
arr.unshift(1)
console.log(arr) // [ 1, 2, 3, 5 ]

// shift：首位删除元素
arr.shift()
console.log(arr) // [ 2, 3, 5 ]
</code></pre>
<h3 id="23-sortreverse-数组排序"><a class="header" href="#23-sortreverse-数组排序">2.3 sort()、reverse() 数组排序</a></h3>
<pre><code class="language-js">let arr = [3, 7, 2, 5]

// 排序：
arr.sort() // 默认由小到大排序
console.log(arr) // [ 2, 3, 5, 7 ]

// 反转：
arr.reverse()
console.log(arr) // [ 7, 5, 3, 2 ]
</code></pre>
<p>sort 方法默认是由小到大排序，其内部会调用每个元素的 toString() 方法，然后得到可比较字符串，最后确定如何排序。但是会遇到下列问题：</p>
<pre><code class="language-js">let arr = [0, 1, 5, 10, 15]

arr.sort()
console.log(arr) // [ 0, 1, 10, 15, 5 ]
</code></pre>
<p>这里并未得到用户期望的数据。sort 方法可以接收一个比较函数作为参数，以确保哪个值位于哪个值的前面：</p>
<pre><code class="language-js">function compare(v1, v2) {
  if (v1 &lt; v2) {
    return -1
  } else if (v1 &gt; v2) {
    return 1
  } else {
    return 0
  }
}

let arr = [0, 1, 5, 10, 15]

arr.sort(compare)
console.log(arr) // [ 0, 1, 5, 10, 15 ]
</code></pre>
<p>比较函数也可以产生降序效果，只要把返回值交换一下即可。这个比较函数还可简写为一个箭头函数：</p>
<pre><code class="language-js">arr.sort((a, b) =&gt; (a &lt; b ? 1 : a &gt; b ? -1 : 0))
</code></pre>
<p>如果数组的元素是数值，或者是其 valueOf()方法返回数值的对象（如 Date 对象），这个比较函数还可以写得更简单，因为这时可以直接用第二个值减去第一个值：</p>
<pre><code class="language-js">function compare(value1, value2) {
  return value2 - value1
}
</code></pre>
<h3 id="24-indexoflastindexof-获取索引位置"><a class="header" href="#24-indexoflastindexof-获取索引位置">2.4 indexOf()、lastIndexOf() 获取索引位置</a></h3>
<p>ECMAScript 5 为数组实例添加了两个位置方法：indexOf() 和 lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf() 方法从数组的开头（位置 0）开始向后查找，lastIndexOf() 方法则从数组的末尾开始向前查找。</p>
<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回 1。在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等：</p>
<pre><code class="language-js">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
console.log(numbers.indexOf(4)) //3
console.log(numbers.lastIndexOf(4)) //5
console.log(numbers.indexOf(4, 4)) //5
console.log(numbers.lastIndexOf(4, 4)) //3
let person = { name: 'Nicholas' }
let people = [{ name: 'Nicholas' }]
let morePeople = [person]
console.log(people.indexOf(person)) //-1
console.log(morePeople.indexOf(person)) //0
</code></pre>
<h3 id="25-concat-操作方法"><a class="header" href="#25-concat-操作方法">2.5 concat() 操作方法</a></h3>
<p>concat() 方法可以基于当前数组中的所有项创建一个新数组，首先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat() 方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给 concat() 方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾：</p>
<pre><code class="language-js">let colors = ['red', 'green', 'blue']
let colors2 = colors.concat('yellow', ['black', 'brown'])
console.log(colors) // red,green,blue
console.log(colors2) // red,green,blue,yellow,black,brown
</code></pre>
<h3 id="26-slice-操作方法"><a class="header" href="#26-slice-操作方法">2.6 slice() 操作方法</a></h3>
<p>方法 slice()用于创建一个包含原有数组中一个或多个元素的新数组，该方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 slice()会返回该索引到数组末尾的所有元素。如果有两个参数，则 slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，<strong>这个操作不影响原始数组</strong>：</p>
<pre><code class="language-js">let colors = ['red', 'green', 'blue', 'yellow', 'purple']
let colors2 = colors.slice(1)
let colors3 = colors.slice(1, 4)
console.log(colors2) //green,blue,yellow,purple
console.log(colors3) //green,blue,yellow
</code></pre>
<p>注意：如果 slice()的参数有负值，那么就以数值长度加上这个负值的结果确定位置。比如，在包含 5 个元素的数组上调用 slice(-2,-1)，就相当于调用 slice(3,4)。如果结束位置小于开始位置，则返回空数组。</p>
<p>splice() 的主要用途是向数组的中间插入元素，但使用这种方法的方式则有如下 3 种。</p>
<ul>
<li>删除：需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素。</li>
<li>插入：需要给 splice()传 3 个参数：开始位置、 0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如， splice(2, 0, &quot;red&quot;, &quot;green&quot;)会从数组位置 2 开始插入字符串&quot;red&quot;和&quot;green&quot;。</li>
<li>替换：splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如， splice(2, 1, &quot;red&quot;, &quot;green&quot;)会在位置 2 删除一个元素，然后从该位置开始向数组中插入&quot;red&quot;和&quot;green&quot;。</li>
</ul>
<p>splice() 方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）：</p>
<pre><code class="language-js">let colors = ['red', 'green', 'blue']
let removed = colors.splice(0, 1) // 删除第一项
console.log(colors) // green,blue
console.log(removed) // red，返回的数组中只包含一项
removed = colors.splice(1, 0, 'yellow', 'orange') // 从位置 1 开始插入两项
console.log(colors) // green,yellow,orange,blue
console.log(removed) // 返回的是一个空数组
removed = colors.splice(1, 1, 'red', 'purple') // 插入两项，删除一项
console.log(colors) // green,red,purple,orange,blue
console.log(removed) // yellow，返回的数组中只包含一项
</code></pre>
<h3 id="27-indexoflastindexof和-includes-搜索"><a class="header" href="#27-indexoflastindexof和-includes-搜索">2.7 indexOf()、lastIndexOf()和 includes() 搜索</a></h3>
<p>ECMAScript 提供了 3 个严格相等的搜索方法： indexOf()、 lastIndexOf()和 includes()（ES7 新增）。他们都接收两个参数：</p>
<ul>
<li>要查找的元素</li>
<li>起始搜索位置（可选）。</li>
</ul>
<p>indexOf()和 includes()方法从数组前头（第一项）开始向后搜索，而 lastIndexOf()从数组末尾（最后一项）开始向前搜索。</p>
<p>indexOf()和 lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回 -1。includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（ ===）比较，也就是说两项必须严格相等：</p>
<pre><code class="language-js">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]

console.log(numbers.indexOf(4)) // 3
console.log(numbers.lastIndexOf(4)) // 5
console.log(numbers.includes(4)) // true

console.log(numbers.indexOf(4, 4)) // 5
console.log(numbers.lastIndexOf(4, 4)) // 3
console.log(numbers.includes(4, 7)) // false

let person = { name: 'Nicholas' }
let people = [{ name: 'Nicholas' }]
let morePeople = [person]

console.log(people.indexOf(person)) // -1
console.log(morePeople.indexOf(person)) // 0
console.log(people.includes(person)) // false
console.log(morePeople.includes(person)) // true
</code></pre>
<h3 id="28-find和-findindex-断言搜索方法"><a class="header" href="#28-find和-findindex-断言搜索方法">2.8 find()和 findIndex() 断言搜索方法</a></h3>
<p>ECMAScript 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。</p>
<p>find()和 findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。 find()返回第一个匹配的元素， findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值：</p>
<pre><code class="language-js">const people = [
  {
    name: 'Matt',
    age: 27,
  },
  {
    name: 'Nicholas',
    age: 29,
  },
]
console.log(people.find((element, index, array) =&gt; element.age &lt; 28)) // {name: &quot;Matt&quot;, age: 27}

console.log(people.findIndex((element, index, array) =&gt; element.age &lt; 28)) // 0
</code></pre>
<p>找到匹配项后，这两个方法都不再继续搜索：</p>
<pre><code class="language-js">const evens = [2, 4, 6]
// 找到匹配后，永远不会检查数组的最后一个元素
evens.find((element, index, array) =&gt; {
  console.log(element)
  console.log(index)
  console.log(array)
  return element === 4
})
// 2
// 0
// [2, 4, 6]
// 4
// 1
// [2, 4, 6]
</code></pre>
<h2 id="三-稀疏数组"><a class="header" href="#三-稀疏数组">三 稀疏数组</a></h2>
<p>如果数组是稀疏的，则 length 属性值大于元素的个数。</p>
<p>稀疏数组的三种实现方式：</p>
<ul>
<li>利用 Array() 构造函数创建</li>
<li>以大于长度的索引赋值创建</li>
<li>delete 操作符可以生产稀疏数组</li>
</ul>
<p>足够稀疏的数组通常在是线上比稠密的数组更慢，但是内存利用率更高，在查找元素时，其时间复杂度与常规对象属性的查找时间一样长。</p>
<h2 id="四-多维数组"><a class="header" href="#四-多维数组">四 多维数组</a></h2>
<p>JS 不支持真正的多维数组，一般使用数组的数组来近似描述：</p>
<pre><code class="language-js">let arr = new Array(10)
let length = arr.length
for (let i = 0; i &lt; arr.length; i++) {
  arr[i] = new Array(10)
}
</code></pre>
<h2 id="五-类数组"><a class="header" href="#五-类数组">五 类数组</a></h2>
<p>JS 的数组有一些特性，常规对象没有：</p>
<ul>
<li>添加元素时，自动更新 length 属性</li>
<li>length 重设为较小值，会截断数组</li>
<li>从 Array.prototype 中继承了一些有用的方法</li>
<li>类属性为 Array</li>
</ul>
<p>这些特性虽然让数组和对象有了区别，但都不是数组的本质特性。其实可以把一个拥有 length 属性的对象看做类数组，只是类数组的 length 属性不会出现随着元素增删而自动变化：</p>
<pre><code class="language-js">// 制作一个类数组
let a = {}

for (let i = 0; i &lt; 10; i++) {
  a[i] = i * i
}
a.length = 10
</code></pre>
<p>类数组不能直接调用 Array.prototype 上的方法，但是由于二者本质都是对象，可以通过 call() 方式调用：</p>
<pre><code class="language-js">let a = { 0: 'a', 1: 'b', length: 3 }
Array.prototype.join(a, '+') // &quot;a+b+c&quot;
Array.prototype.map.call(a, function (x) {
  // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
  return x.toUpperCase()
})
</code></pre>
<p>注意 Firefox 浏览器将上述方法直接定义到了构造函数上，可以如此使用：</p>
<pre><code class="language-js">let a = { 0: 'a', 1: 'b', length: 3 }
Array.join(a, '+') // &quot;a+b+c&quot;
Array.map.call(a, function (x) {
  // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
  return x.toUpperCase()
})
</code></pre>
<p>那么兼容的代码可以这样写：</p>
<pre><code class="language-js">Array.join =
  Array.join ||
  function (a, sep) {
    return Array.prototype.join.call(a, sep)
  }

Array.map =
  Array.map ||
  function (a, f, thisArg) {
    return Array.prototype.map.call(a, f, thisArg)
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="07-函数的基本使用"><a class="header" href="#07-函数的基本使用">07-函数的基本使用</a></h1>
<h2 id="一-函数的创建"><a class="header" href="#一-函数的创建">一 函数的创建</a></h2>
<p>函数四种创建方式：</p>
<pre><code class="language-js">// 方式一：直接量声明
function fn1() {
  console.log('函数 1')
}

// 方式二：函数表达式
let fn2 = function () {
  console.log('函数 3')
}

// 方式三：箭头函数。这是 ES6 推出的新方式，参数为 1 个时可以省略括号
let fn3 = (num1, num2) =&gt; {
  return num1 + num2
}

// 方式四：创建 Function 对象实例，参数可以有多个，最后一个参数会被看做函数体。
// 不推荐该方式：该语法会导致解析两次代码，第一次解析 JS 代码，第二次解析传入构造函数中的字符串，造成性能降低
let fn4 = new Function(&quot;console.log('函数 2')&quot;)
</code></pre>
<p>贴士：函数体如果只是一个简单的表达式、赋值操作，则可以省略大括号，不过笔者不推荐这样做。</p>
<p>直接量方式声明的函数解析器会先读取函数声明，使其在执行任何代码之前可用（可以访问）。其实函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作函数声明提升（ function declaration hoisting）。在执行代码时， JavaScript 引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部。</p>
<p>而函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解释执行：</p>
<pre><code class="language-js">fn1() // fn1...
fn2() // fn2 is not a function

function fn1() {
  console.log('fn1...')
}
let fn2 = function () {
  console.log('fn2...')
}
</code></pre>
<h2 id="二-函数的一些基本概念"><a class="header" href="#二-函数的一些基本概念">二 函数的一些基本概念</a></h2>
<h3 id="21-函数类型"><a class="header" href="#21-函数类型">2.1 函数类型</a></h3>
<p>函数是 JS 一种特殊的引用类型，在较新的 V8 中，使用 <code>typeof</code> 打印函数的数据类型，会输出 <code>function</code>。</p>
<pre><code class="language-js">function fn() {
  console.log('fn1...')
}

console.log(typeof fn) // function
console.log(fn instanceof Object) // true
</code></pre>
<h3 id="22-函数名"><a class="header" href="#22-函数名">2.2 函数名</a></h3>
<p>函数名其实是指向函数的指针，使用 <code>函数名=null</code> 可以切断名称与函数的联系。</p>
<p>ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用 Function 构造函数创建的，则会标识成&quot;anonymous&quot;：</p>
<pre><code class="language-js">function foo() {}
let bar = function () {}
let baz = () =&gt; {}

console.log(foo.name) // foo
console.log(bar.name) // bar
console.log(baz.name) // baz

console.log((() =&gt; {}).name) //（空字符串）
console.log(new Function().name) // anonymous
</code></pre>
<p>如果函数是一个获取函数、设置函数，或者使用 bind() 实例化，那么标识符前面会加上一个前缀：</p>
<pre><code class="language-js">function foo() {}
console.log(foo.bind(null).name) // bound foo

let dog = {
  years: 1,
  get age() {
    return this.years
  },
  set age(newAge) {
    this.years = newAge
  },
}

let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age')
console.log(propertyDescriptor.get.name) // get age
console.log(propertyDescriptor.set.name) // set age
</code></pre>
<h3 id="23-函数返回值"><a class="header" href="#23-函数返回值">2.3 函数返回值</a></h3>
<p>在函数内部用 return 来返回计算结果，一个函数只能返回一个值，同时会终止代码的执行：</p>
<ul>
<li>如果函数没有显式的使 return 语句，那么函数有默认的返回值：undefined</li>
<li>如果函数使用 return，但 return 后面没有任何值，函数返回值也是：undefined</li>
</ul>
<h2 id="三-函数参数"><a class="header" href="#三-函数参数">三 函数参数</a></h2>
<h3 id="31-理解函数参数"><a class="header" href="#31-理解函数参数">3.1 理解函数参数</a></h3>
<p>与大多数语言不通，ECMAScript 的函数不关心参数个数与数据类型，传入参数个数与函数定义时接收的参数个数不同，解释器不会报错。这是因为参数在 ECMAScript 函数的内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。</p>
<p>对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是 undefined。这就类似于定义了变量而没有初始化。</p>
<p>重载是 Java 等语言中函数的一个特性，如果两到多个函数，其函数的函数名相同，但是参数、返回值不同，则视为 2 个不同的函数！但是<strong>JavaScript 的函数没有重载</strong>，这是因为后面的函数覆盖了前面的函数：</p>
<pre><code class="language-js">function add(num1, num2) {
  return num1 + num2 + num3
}

function add(num1, num2, num3) {
  return num1 * num2 + num3
}

console.log(add(1, 2, 3)) // 5
</code></pre>
<h3 id="32-形参与实参"><a class="header" href="#32-形参与实参">3.2 形参与实参</a></h3>
<p>在函数中，定义时候，指定的变量是形式参数（形参），运行时实际传入的参数叫做实际参数（实参）。</p>
<pre><code class="language-js">// num1 num2 是形式参数
function fn(num1, num2) {
  return num1 + num2
}

fn(1, 3) // 1 和 3 是实参
</code></pre>
<p>一般情况下，形参与实参的数量要一一对应上，但是在 JS 中也允许二者数量不一致，同样也允许形参给予默认值：</p>
<pre><code class="language-js">function fn(num1, num2 = 2) {
  return num1 + num2
}

console.log(fn(1)) // 3 因为第二个参数默认是 2
</code></pre>
<h3 id="33-参数的值传递"><a class="header" href="#33-参数的值传递">3.3 参数的值传递</a></h3>
<p>ECMAScript 的函数参数都是按值传递的！即函数外的值会被复制到函数内部的参数中，如果是引用类型的参数，那么就与引用类型的变量复制一样，即复制的值实际上是一个指针，指向存储在堆内存中的真实对象。</p>
<pre><code class="language-js">let p = {
  name: 'lisi',
}

function setName(obj) {
  obj.name = 'zs'
}

setName(p)
console.log(p.name) // zs

function setNameByNew(obj) {
  obj = new Object()
  obj.name = 'ww'
}
setNameByNew(p)
console.log(p.name) // zs，不会被修改为 ww
</code></pre>
<p>上述示例中，setName() 函数内部复制了一个对象引用 obj，并修改了其引用的数据内容，所以才能修改 p 的属性。而在 setNameByNew() 函数中，由于同样复制了一个 obj，所以修改 obj 的指向也不会影响原来的 p。</p>
<h3 id="33-默认参数"><a class="header" href="#33-默认参数">3.3 默认参数</a></h3>
<p>ES6 之前，如果若要检测参数，常用的方案是：实现默认参数的一种常用方式就是检测某个参数是否等于 undefined，如果是则意味着没有传这个参数，那就给它赋一个值：</p>
<pre><code class="language-js">function makeKing(name) {
  name = typeof name !== 'undefined' ? name : 'Henry'
  return `King ${name} VIII`
}
console.log(makeKing()) // 'King Henry VIII'
console.log(makeKing('Louis')) // 'King Louis VIII
</code></pre>
<p>ES6 支持了显式定义默认参数：</p>
<pre><code class="language-js">function makeKing(name = 'Henry') {
  return `King ${name} VIII`
}

console.log(makeKing('Louis')) // 'King Louis VIII'
console.log(makeKing()) // 'King Henry VIII'
</code></pre>
<p>当参数设置为 undefined 时候，也是相当于没有传值：</p>
<pre><code class="language-js">function makeKing(name = 'Henry', numerals = 'VIII') {
  return `King ${name} ${numerals}`
}
console.log(makeKing()) // 'King Henry VIII'
console.log(makeKing('Louis')) // 'King Louis VIII'
console.log(makeKing(undefined, 'VI')) // 'King Henry VI'
</code></pre>
<p>默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：</p>
<pre><code class="language-js">let romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI']
let ordinality = 0
function getNumerals() {
  // 每次调用后递增
  return romanNumerals[ordinality++]
}
function makeKing(name = 'Henry', numerals = getNumerals()) {
  return `King ${name} ${numerals}`
}
console.log(makeKing()) // 'King Henry I'
console.log(makeKing('Louis', 'XVI')) // 'King Louis XVI'
console.log(makeKing()) // 'King Henry II'
console.log(makeKing()) // 'King Henry III'
</code></pre>
<p>函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。</p>
<p>参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的，像这样就会抛出错误：</p>
<pre><code class="language-js">// 调用时不传第一个参数会报错
function makeKing(name = numerals, numerals = 'VIII') {
  return `King ${name} ${numerals}`
}
</code></pre>
<p>参数也存在于自己的作用域中，它们不能引用函数体的作用域：</p>
<pre><code class="language-js">// 调用时不传第二个参数会报错
function makeKing(name = 'Henry', numerals = defaultNumeral) {
  let defaultNumeral = 'VIII'
  return `King ${name} ${numerals}`
}
</code></pre>
<h3 id="34-参数的扩展操作符"><a class="header" href="#34-参数的扩展操作符">3.4 参数的扩展操作符</a></h3>
<p>在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素，假设有如下函数定义，它会将所有传入的参数累加起来：</p>
<pre><code class="language-js">let values = [1, 2, 3, 4]
function getSum() {
  let sum = 0
  // arguments 对象是收集的函数参数的伪数组
  for (let i = 0; i &lt; arguments.length; ++i) {
    sum += arguments[i]
  }
  return sum
}
</code></pre>
<p>这个函数希望将所有加数逐个传进来，然后通过迭代 arguments 对象来实现累加。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于 apply()方法：</p>
<pre><code class="language-js">console.log(getSum.apply(null, values)) // 10
</code></pre>
<p>ES6 新增的扩展运算符，可以极为简洁地实现这种操作：</p>
<pre><code class="language-js">console.log(getSum(...values)) // 10
</code></pre>
<p>因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数：</p>
<pre><code class="language-js">console.log(getSum(...values)) // 10
console.log(getSum(-1, ...values)) // 9
console.log(getSum(...values, 5)) // 15
console.log(getSum(-1, ...values, 5)) // 14
console.log(getSum(...values, ...[5, 6, 7])) // 28
</code></pre>
<h2 id="四-箭头函数"><a class="header" href="#四-箭头函数">四 箭头函数</a></h2>
<h3 id="41-箭头函数的基础使用"><a class="header" href="#41-箭头函数的基础使用">4.1 箭头函数的基础使用</a></h3>
<p>箭头函数是 ES6 推出的语法。在大多场景中，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的，可以使用函数表达式的地方，都
可以使用箭头函数。</p>
<p>不过箭头函数更加简洁，非常适合嵌入函数的场景：</p>
<pre><code class="language-js">let ints = [1, 2, 3]
console.log(
  ints.map(function (i) {
    return i + 1
  })
) // [2, 3, 4]

console.log(
  ints.map((i) =&gt; {
    return i + 1
  })
) // [2, 3, 4]
</code></pre>
<h3 id="42-箭头函数的简写"><a class="header" href="#42-箭头函数的简写">4.2 箭头函数的简写</a></h3>
<p>箭头函数的参数为只有 1 个时，可以省略小括号。</p>
<p>箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值：</p>
<pre><code class="language-js">// 以下两种写法都有效，而且返回相应的值
let double = (x) =&gt; { return 2 * x; };
let triple = (x) =&gt; 3 * x;

// 可以赋值
let value = {};
let setName = (x) =&gt; x.name = &quot;Matt&quot;;
setName(value);
console.log(value.name); // &quot;Matt&quot;

// 无效的写法：
let multiply = (a, b) =&gt; return a * b;
</code></pre>
<h3 id="43-箭头函数的使用注意事项"><a class="header" href="#43-箭头函数的使用注意事项">4.3 箭头函数的使用注意事项</a></h3>
<p>箭头函数内部不能使用 arguments、super、new.target 等。</p>
<p>箭头函数也不能作为构造函数，更没有 prototype 属性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="095-函数-递归与尾调用"><a class="header" href="#095-函数-递归与尾调用">09.5-函数-递归与尾调用</a></h1>
<h2 id="一-递归函数"><a class="header" href="#一-递归函数">一 递归函数</a></h2>
<h3 id="11-递归函数概念"><a class="header" href="#11-递归函数概念">1.1 递归函数概念</a></h3>
<p>递归函数：该函数在内部调用了自身！</p>
<pre><code class="language-js">function factorial(num) {
  // 结束递归条件
  if (num &lt;= 1) {
    return 1
  }

  return num * factorial(num - 1)
}
</code></pre>
<p>注意：递归函数必须要有递归结束条件，否则很容易造成栈溢出！</p>
<h3 id="12-递归函数的调用问题"><a class="header" href="#12-递归函数的调用问题">1.2 递归函数的调用问题</a></h3>
<p>在上述示例中，如果将递归函数变更为 null，那么就会导致调用错误：</p>
<pre><code class="language-js">let anotherFactorial = factorial
factorial = null
console.log(anotherFactorial(4)) //出错！
</code></pre>
<p>以上代码先把 factorial() 函数保存在变量 anotherFactorial 中，然后将 factorial 变量设置为 null，结果指向原始函数的引用只剩下一个。但在接下来调用 anotherFactorial() 时，由于必须执行 factorial()，而 factorial 已经不再是函数，所以就会导致错误。在这种情况下，使用 arguments.callee 可以解决这个问题。</p>
<p>arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用：</p>
<pre><code class="language-js">function factorial(num) {
  if (num &lt;= 1) {
    return 1
  } else {
    return num * arguments.callee(num - 1)
  }
}
</code></pre>
<p>上述代码使用 arguments.callee 代替函数名，可以确保无论怎样调用函数都不会出问题。因此，在编写递归函数时，使用 arguments.callee 总比使用函数名更保险！</p>
<p>注意：严格模式下不能通过脚本访问 arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果：</p>
<pre><code class="language-js">let factorial = function f(num) {
  if (num &lt;= 1) {
    return 1
  } else {
    return num * f(num - 1)
  }
}
</code></pre>
<h3 id="13-递归函数经典应用"><a class="header" href="#13-递归函数经典应用">1.3 递归函数经典应用</a></h3>
<p>求斐波那契数（n=1 时，结果为 1，n=2 时，结果为 1，后续的数目为前 2 个数目之和）：</p>
<pre><code class="language-js">function fib(n) {
  if (n == 1 || n == 2) {
    return 1
  }
  return fib(n - 1) + fib(n - 2)
}
</code></pre>
<p>递归很容易遇到内存溢出问题，可以利用缓存解决，上述问题的解决方式：</p>
<pre><code class="language-js">let cache = {} // 存储月份 - 数目的 kv 值

function fib(n) {
  if (cache[n]) {
    return cache[n]
  }

  let ret = fib(n - 1) + fib(n - 2)
  cache[n] = ret
  return ret
}
</code></pre>
<h2 id="二-尾调用"><a class="header" href="#二-尾调用">二 尾调用</a></h2>
<h3 id="21-尾调用的概念"><a class="header" href="#21-尾调用的概念">2.1 尾调用的概念</a></h3>
<p>尾调用即：外部函数的返回值是一个内部函数的返回值：</p>
<pre><code class="language-js">function outerFunction() {
  return innerFunction() // 尾调用
}
</code></pre>
<h3 id="22-es6-中尾调用的优化"><a class="header" href="#22-es6-中尾调用的优化">2.2 ES6 中尾调用的优化</a></h3>
<p>在 ES6 优化之前，执行这个例子会在内存中发生如下操作：</p>
<ul>
<li>(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</li>
<li>(2) 执行 outerFunction 函数体，到 return 语句。计算返回值必须先计算 innerFunction。</li>
<li>(3) 执行到 innerFunction 函数体，第二个栈帧被推到栈上。</li>
<li>(4) 执行 innerFunction 函数体，计算其返回值。</li>
<li>(5) 将返回值传回 outerFunction，然后 outerFunction 再返回值。</li>
<li>(6) 将栈帧弹出栈外。</li>
</ul>
<p>在 ES6 优化之后，执行这个例子会在内存中发生如下操作：</p>
<ul>
<li>(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。</li>
<li>(2) 执行 outerFunction 函数体，到达 return 语句。计算返回值必须先计算 innerFunction。</li>
<li>(3) 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction 的返回值。</li>
<li>(4) 弹出 outerFunction 的栈帧。</li>
<li>(5) 执行到 innerFunction 函数体，栈帧被推到栈上。</li>
<li>(6) 执行 innerFunction 函数体，计算其返回值。</li>
<li>(7) 将 innerFunction 的栈帧弹出栈外。</li>
</ul>
<p>很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。这就是 ES6 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。</p>
<h3 id="23-尾调用优化的条件"><a class="header" href="#23-尾调用优化的条件">2.3 尾调用优化的条件</a></h3>
<p>尾调用优化的条件就是确定外部栈帧真的没有必要存在了：</p>
<ul>
<li>代码在严格模式下执行；</li>
<li>外部函数的返回值是对尾调用函数的调用；</li>
<li>尾调用函数返回后不需要执行额外的逻辑；</li>
<li>尾调用函数不是引用外部函数作用域中自由变量的闭包。</li>
</ul>
<p>下面展示了几个违反上述条件的函数，因此都不符号尾调用优化的要求：</p>
<pre><code class="language-js">'use strict'

// 尾调用没有返回
function outerFunction() {
  innerFunction()
}

// 尾调用没有直接返回
function outerFunction() {
  let innerFunctionResult = innerFunction()
  return innerFunctionResult
}

// 尾调用返回后必须转型为字符串
function outerFunction() {
  return innerFunction().toString()
}

// 尾调用是一个闭包
function outerFunction() {
  let foo = 'bar'
  function innerFunction() {
    return foo
  }
  return innerFunction()
}
</code></pre>
<p>下面是几个符合尾调用优化条件的例子：</p>
<pre><code class="language-js">// 栈帧销毁前执行参数计算
function outerFunction(a, b) {
  return innerFunction(a + b)
}

// 初始返回值不涉及栈帧
function outerFunction(a, b) {
  if (a &lt; b) {
    return a
  }
  return innerFunction(a + b)
}

// 两个内部函数都在尾部
function outerFunction(condition) {
  return condition ? innerFunctionA() : innerFunctionB()
}
</code></pre>
<p>无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。</p>
<p>之所以要求严格模式，主要因为在非严格模式下函数调用中允许使用 f.arguments 和 f.caller，而它们都会引用外部函数的栈帧。显然，这意味着不能应用优化了。因此尾调用优化要求必须在严格模式下有效，以防止引用这些属性。</p>
<h3 id="24-尾调用优化的代码"><a class="header" href="#24-尾调用优化的代码">2.4 尾调用优化的代码</a></h3>
<p>原版斐波那契函数：</p>
<pre><code class="language-js">function fib(n) {
  if (n &lt; 2) {
    return n
  }
  return fib(n - 1) + fib(n - 2)
}
</code></pre>
<p>进行尾调用优化：</p>
<pre><code class="language-js">'use strict'
// 基础框架
function fib(n) {
  return fibImpl(0, 1, n)
}
// 执行递归
function fibImpl(a, b, n) {
  if (n === 0) {
    return a
  }
  return fibImpl(b, a + b, n - 1)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="081-作用域-作用域链"><a class="header" href="#081-作用域-作用域链">08.1-作用域-作用域链</a></h1>
<h2 id="一-理解作用域"><a class="header" href="#一-理解作用域">一 理解作用域</a></h2>
<h3 id="11-执行上下文"><a class="header" href="#11-执行上下文">1.1 执行上下文</a></h3>
<p>每个 JS 代码文件在运行时，都有其上下文（Context），并通过一个 <strong>变量对象</strong>（variable object）来表示该上下文。我们常用的变量、函数都位于其上下文中。上下文决定了其内部的变量、函数的生命周期，即上下文会在其所有代码都执行完毕后会被销毁。</p>
<p>上下文有：：</p>
<ul>
<li>全局上下文：浏览器中即 window 对象，Node 中为 Global 对象。通过 var、function 声明后会成为 window 的属性、方法。let/const 的顶级声明并不位于全局上下文中，但是其在作用域链的解析效果上是一样的。</li>
<li>函数上下文：每个函数内部拥有自己独立的上下文。代码运行到函数时，函数的上下文被推到一个上下文执行栈中，函数执行完毕后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。</li>
<li>eval 上下文：暂不讨论。</li>
</ul>
<h3 id="12-作用域"><a class="header" href="#12-作用域">1.2 作用域</a></h3>
<p>变量在上下文内的可活动的边界区域也可以称呼为作用域（Scope）。</p>
<p>根据变量的作用域，可以将变量分类：</p>
<ul>
<li>全局变量：在哪里都可访问到，如进入脚本后立即定义的变量、没有用 let 定义的变量</li>
<li>局部变量：函数内部的变量，只有函数内部可以访问到。</li>
</ul>
<p>以下示例中的局部变量在函数外部被访问时报错：</p>
<pre><code class="language-js">function test() {
  var msg = 'hi' // 局部变量
}
test()
console.log(msg) // 报错
</code></pre>
<h3 id="13-块级作用域与词法作用域"><a class="header" href="#13-块级作用域与词法作用域">1.3 块级作用域与词法作用域</a></h3>
<p>编程语言中，常见作用域有两种：</p>
<ul>
<li>块级作用域：代码块级别的作用域，用大括号包裹的一段代码。简单来说：代码块之外是无法访问到其代码块内部数据的。</li>
<li>词法作用域：在代码写好的那一刻，变量的作用域已经确定。</li>
</ul>
<p>ES6 之前，JavaScript 没有块级作用域，只支持词法作用域，示例：</p>
<pre><code class="language-js">var num = 10
function show() {
  console.log(num)
  if (true) {
    var num = 11
  }
}

show() // undefined
</code></pre>
<p>在词法作用域中，执行函数，直接进入函数内部查找变量，找不到，去全局查找，示例中：<code>show()</code> 内找到了变量 num，提升时值为 undefined。</p>
<h3 id="14-js-的块级作用域支持"><a class="header" href="#14-js-的块级作用域支持">1.4 JS 的块级作用域支持</a></h3>
<p>没有块级作用域，会引发很多问题，如 1.3 中的示例由于代码被提升覆盖打印了 undefined，以及下面的示例：</p>
<pre><code class="language-js">// 本该在 for 结束后销毁的 i 未被销毁
for (var i = 0; i &lt; 7; i++) {}
console.log(i)
</code></pre>
<p>JS 在 ES6 支持了块级作用域（使用 let、const）：</p>
<pre><code class="language-js">let num = 10
function show() {
  console.log(num)
  if (true) {
    let num = 11
  }
}

show() // 打印 10
</code></pre>
<p>for 循环中使用 let：</p>
<pre><code class="language-js">for (let i = 0; i &lt; 7; i++) {}
console.log(i) // 报错
</code></pre>
<h3 id="15-作用域链"><a class="header" href="#15-作用域链">1.5 作用域链</a></h3>
<p>上下文的代码执行时，会创建上下文变量对象的<strong>作用域链</strong>（scope chain）。作用域链决定了各级上下文中的代码在访问变量、函数时的顺序。</p>
<p>当前正在执行的上下文变量对象始终位于作用域链的最前端！代码的执行依赖于标识符的解析，从最前端开始，沿着作用域链开始逐级往后，直到找到标识符，如果未找到标识符，则报错！</p>
<p>上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。</p>
<p>示例：</p>
<pre><code class="language-js">var color = 'blue'

function changeColor() {
  var anotherColor = 'red'

  function swapColors() {
    // 这里可以访问 color、anotherColor、tempColor
    var tempColor = anotherColor
    anotherColor = color
    color = tempColor
  }

  // 这里可以访问 color、anotherColor
  swapColors()
}

// 这里只能访问 color
changeColor()
</code></pre>
<p>如图所示：</p>
<p><img src="01-JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/../images/javascript/scopchain-01.svg" alt="作用域链" /></p>
<p>注意：由于词法作用域的限制，this 在作用域中并不一定是开发者想要的：</p>
<pre><code class="language-js">var obj = {
  name: 'test',
  showThis: function () {
    console.log('this1=', this) // 这里是 obj
    function bar() {
      console.log('this2=', this) // 这里是 window
    }
    bar()
  },
}
obj.showThis()
</code></pre>
<p>使用小技巧解决：</p>
<pre><code class="language-js">var obj = {
  name: 'test',
  showThis: function () {
    console.log('this1=', this) // 这里是 obj
    var that = this
    function bar() {
      console.log('this2=', that) // 这里是 obj
    }
    bar()
  },
}
obj.showThis()
</code></pre>
<p>ES6 可以使用箭头函数来改变这个问题：</p>
<pre><code class="language-js">let obj = {
  name: 'test',
  showThis: function () {
    console.log('this1=', this) // 这里是 obj
    let bar = () =&gt; {
      console.log('this2=', this) // 这里是 obj
    }
    bar()
  },
}
obj.showThis()
</code></pre>
<h3 id="16-作用域链增强"><a class="header" href="#16-作用域链增强">1.6 作用域链增强</a></h3>
<p>除了上述叙述的全局上下文、函数上下文等，作用域链可以通过在其前端临时添加一个上下文来增强作用域链，这个新增的上下文会在代码执行后删除。这种情况位于：catch 语句、with 语句。</p>
<p>这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</p>
<pre><code class="language-js">function buildUrl() {
  let qs = '?debug=true'
  with (location) {
    let url = href + qs
  }
  return url
}
</code></pre>
<p>这里， with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端。buildUrl()函数中定义了一个变量 qs。当 with 语句中的代码引用变量 href 时，实际上引用的是 location.href，也就是自己变量对象的属性。在引用 qs 时，引用的则是定义在 buildUrl()中的那个变量，它定义在函数上下文的变量对象上。而在 with 语句中使用 var 声明的变量 url 会成为函数上下文的一部分，可以作为函数的值被返回；但像这里使用 let 声明的变量 url，因为被限制在块级作用域（稍后介绍），所以在 with 块之外没有定义。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="082-作用域-变量提升"><a class="header" href="#082-作用域-变量提升">08.2-作用域-变量提升</a></h1>
<h2 id="一-变量提升机制"><a class="header" href="#一-变量提升机制">一 变量提升机制</a></h2>
<h3 id="11-变量提升概念"><a class="header" href="#11-变量提升概念">1.1 变量提升概念</a></h3>
<p>var、function 声明的变量会被拿到当前最近作用域的顶部，导致了变量在声明前被使用时不会报错，这个现象叫做<strong>提升</strong>（hoisting）：</p>
<pre><code class="language-js">console.log(name) // 能够输出空字符串，并不会报错，表明其已经声明了
var name = 'Jake'
console.log(name) // 能够输出 Jake
</code></pre>
<p>变量提升的本质是使用 var、function 声明的变量被自动添加到了最接近的上下文中，上述代码其实等价于：</p>
<pre><code class="language-js">var name // 声明
console.log('name=', name)
name = 'Jake' // 赋值
console.log('name=', name)
</code></pre>
<p>同理函数的提升如下所示，函数 sayHi 被提升了，所以即使提前有一个函数 <code>sayHi()</code> 在执行，也不会因为未定义而报错：</p>
<pre><code class="language-js">console.log(sayHi) // 输出该函数：会将声明、定义一起提升
sayHi()
function sayHi() {
  console.log('Hi!')
}
</code></pre>
<h3 id="12-变量提升机制-lhsrhs"><a class="header" href="#12-变量提升机制-lhsrhs">1.2 变量提升机制 LHS、RHS</a></h3>
<p>LHS 查询（赋值操作的左端）：</p>
<pre><code class="language-txt">在编译的过程中，先将标识符和函数声明给提升到其对应的作用域的顶端。
标识符解析的时候，会进行 LHS 查询：
如果标识符一直找不到声明的位置，那么最终就会在全局环境生成一个全局变量。
</code></pre>
<p>示例：</p>
<pre><code class="language-js">console.log(a) // undefined
var a = 3
</code></pre>
<p>RHS 查询（赋值操作的源头）：</p>
<pre><code class="language-txt">RHS 查询的时候，如果找不到对应的标识符，就会抛出一个异常：ReferenceError。
</code></pre>
<p>示例：</p>
<pre><code class="language-js">console.log(fn) // ReferenceError
</code></pre>
<h3 id="13-函数表达式与变量提升"><a class="header" href="#13-函数表达式与变量提升">1.3 函数表达式与变量提升</a></h3>
<p>如果使用函数表达式声明函数，那么就需要与其他表达式一样必须先赋值，以下示例代码就会出现错误：</p>
<pre><code class="language-js">console.log(sayHi) // undefined
sayHi() // 报错，函数不存在
var sayHi = function () {
  console.log('Hi!')
}
</code></pre>
<p>在实际开发中，更推荐使用函数表达式：</p>
<pre><code class="language-js">// 正确代码示例
var sayHi
if (condition) {
  sayHi = function () {
    console.log('Hi')
  }
} else {
  sayHi = function () {
    console.log('Yo')
  }
}

// 错误代码示例：下列代码在 JS 中无效，因为两次声明都被提升，由于重名，第二个函数的函数体代码覆盖了上面的
// 大多浏览器会直接返回第二个函数声明，但是有些浏览器会尝试修复错误，所以仍然推荐使用表达式
if (condition) {
  function sayHi() {
    console.log('Hi')
  }
} else {
  function sayHi() {
    console.log('Yo')
  }
}
</code></pre>
<p>从上面的错误示例也能看出，在预解析时，如果出现同名，会进行替换，如下所示：</p>
<pre><code class="language-js">// 原始代码，期望 func1 在执行 2 次时，分别输出不同的值
func1()
function func1() {
  console.log('第一个 func1 被执行了')
}
func1()
function func1() {
  console.log('第二个 func1 被执行了')
}

// 但是经过预解析后，实际演变为了下列的代码：第一个 func1 被顶替了，输出的结果全部是：第二个 func1 被执行了
function func1() {
  console.log('第一个 func1 被执行了')
}
function func1() {
  console.log('第二个 func1 被执行了')
}
func1()
func1()
</code></pre>
<h3 id="14-同名变量提升"><a class="header" href="#14-同名变量提升">1.4 同名变量提升</a></h3>
<p>如果变量名重复，不会重新声明，但是会按照顺序重新定义：</p>
<pre><code class="language-js">console.log(a) // 输出函数，因为函数被提升了
var a = 3 // 相当于给已经提升的函数 a 重新赋值了 3
console.log(a) // 输出 3
function a() {
  console.log('fn')
}

console.log(a) // 3
</code></pre>
<h3 id="15-类的提升"><a class="header" href="#15-类的提升">1.5 类的提升</a></h3>
<p>类的提升：</p>
<pre><code class="language-js">// 直接定义
console.log(ClassDeclaration) // ReferenceError: ClassDeclaration is not defined
class ClassDeclaration {}
console.log(ClassDeclaration) // class ClassDeclaration {}

// 表达式方式
console.log(ClassExpression) // undefined
var ClassExpression = class {}
console.log(ClassExpression) // class {}
</code></pre>
<h3 id="16-没有-var-的声明"><a class="header" href="#16-没有-var-的声明">1.6 没有 var 的声明</a></h3>
<p>如果变量未经声明就被初始化，则其会被添加到全局上下文，很容易引起一些很难发现的 Bug，在开发中是需要严禁这样做：</p>
<pre><code class="language-js">function(){
  num = 13
}

// 本该存在于函数内部的变量，由于未使用 var 声明，进入了全局上下文
console.log(num)  // 13
</code></pre>
<p>容易产生 BUG 是因为没有被声明标识修饰（function、var、let、class 等）的标识符实质挂载了当前上下文上：</p>
<pre><code class="language-js">a = 10 // 其本质是写了：window.a = 10，是没有变量提升的
</code></pre>
<p>bug 示例：</p>
<pre><code class="language-js">console.log(a, b) // undefined undefined

var a = 12
var b = 12

function fn() {
  // 此时 a b 在内部提升，但是 b 没有 var 提升到上一级作用域
  console.log(a, b) // undefined 12
  var a = (b = 13)
  console.log(a, b) // 13 13
}

fn()
// 外部数据被影响了
console.log(a, b) // 12 13
</code></pre>
<h2 id="二-es6-中的块级作用域"><a class="header" href="#二-es6-中的块级作用域">二 ES6 中的块级作用域</a></h2>
<h3 id="21-块级作用域"><a class="header" href="#21-块级作用域">2.1 块级作用域</a></h3>
<p>var 的声明是函数作用域，而 let、const 最大的作用是带来了<strong>块级作用域</strong>，即 let、const 的作用域仅限于其声明区域。而且 let/const 切断了全局变量与 window 属性的绑定映射机制！！</p>
<p>块级作用域示例：let 声明的变量仅仅限于大括号内，大括号即代码块！</p>
<pre><code class="language-js">for (var i = 0; i &lt; 1; i++) {}
console.log(i) //打印 1

for (let j = 0; j &lt; 1; j++) {}
console.log(j) //报错：j is not defined
</code></pre>
<p>上述示例中 let 声明的 j 的作用域仅仅作用于小括号内。<strong>var 重复声明会被忽略，而 let 则会抛出 SyntaxError</strong>，所以 let 非常适合在循环体中使用。</p>
<h3 id="22-顶级对象绑定"><a class="header" href="#22-顶级对象绑定">2.2 顶级对象绑定</a></h3>
<p>在浏览器环境中。var 声明的变量会被绑定在 window 顶级对象中，如果定义的变量是一些 dom 中的常用名，则会引起错误，而 let/const 则不会出现这样的问题：</p>
<pre><code class="language-js">var screenLeft = 100
console.log(window.screenLeft) // 100

let num = 10
console.log(window.num) // undefined
</code></pre>
<h3 id="23-变量提升与暂时性死区"><a class="header" href="#23-变量提升与暂时性死区">2.3 变量提升与暂时性死区</a></h3>
<p>let、const 没有变量提升现象，如下所示：</p>
<pre><code class="language-js">console.log(age) //报错
let age = 6
</code></pre>
<p>这是因为在解析代码时，let 声明之前的执行区域是<code>暂时性死区 (temporal dead zone)</code>，死区内引用死区后声明的变量都会抛出 ReferenceError。</p>
<p>let 和 const 之所以具备块级作用域，是因为其代码在运行时被重新编译，如下所示原版代码：</p>
<pre><code class="language-js">// 书写的 JS 代码
{
  let a = 20
}
console.log(a) // 由于块级作用域的限制，这里会报错
</code></pre>
<p>编译后的代码：</p>
<pre><code class="language-js">{
  var _a = 20
}
console.log(a) // 没有 a 这个变量，自然就是 未定义
</code></pre>
<h3 id="24-大括号中声明的提升"><a class="header" href="#24-大括号中声明的提升">2.4 大括号中声明的提升</a></h3>
<p>ES6 环境中（高版 Chrome 中），大括号可以被视为块级作用域，那么他内部声明的数据与变量提升类似：</p>
<pre><code class="language-js">console.log(fn1) // 输出函数体
function fn1() {
  console.log('fn1')
}

console.log(fn2) // undefined
if (true) {
  function fn2() {
    console.log('fn2')
  }
}

console.log(fn3) // undefined
for (let i = 0; i &lt; 0; i++) {
  function fn3() {
    console.log('fn3')
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="083-作用域-匿名函数与闭包"><a class="header" href="#083-作用域-匿名函数与闭包">08.3-作用域-匿名函数与闭包</a></h1>
<h2 id="一-匿名函数"><a class="header" href="#一-匿名函数">一 匿名函数</a></h2>
<p>匿名函数就是没有名字的函数：</p>
<pre><code class="language-js">// 使用表达式创建一个函数： = 号右边即是一个匿名函数
let show = function () {
  alert('hello')
}
show()
</code></pre>
<p>匿名函数的调用方式包括立即调用函数表达式等多种：</p>
<pre><code class="language-js">//1.使用！开头，结构清晰，不容易混乱，推荐使用；
!(function () {
  document.write('ni hao')
})(）

//2.无法表明函数与之后的 () 的整体性，不推荐使用。
function () {
    document.write('wo hao')
  }
)()

//3.能够将匿名函数与调用的 () 为一个整体，官方推荐使用；
;(function () {
  document.write('hello')
})()

//4.
;[
  (function () {
    document.write('world')
  })(),
]
</code></pre>
<h2 id="二-立即执行函数模仿块级作用域"><a class="header" href="#二-立即执行函数模仿块级作用域">二 立即执行函数模仿块级作用域</a></h2>
<p>示例：</p>
<pre><code class="language-js">function print(count) {
  for (let i = 0; i &lt; count; i++) {
    // 一些操作
  }
  console.log(i) //计数
}
print()
</code></pre>
<p>在 Java 等语言中，i 的定义范围是 for 内部的代码块，超出 i 的范围，则 i 就会被销毁。但是在 JS 中，变量 i 定义在 print 函数的活动对象中，在函数内部可以随处访问。即使错误的重新声明同一个变量，也不会改变它的值：</p>
<pre><code class="language-js">function print(count) {
  for (let i = 0; i &lt; count; i++) {
    // 一些操作
  }
  let i // 重新声明变量
  console.log(i) //计数
}
print()
</code></pre>
<p>JS 不会告诉用户多次声明了同一个变量，只会对后续的声明视而不见，使用匿名函数能够避免这个问题。</p>
<p>使用匿名函数可以将一些数据进行保护，JS 中的沙箱模式基本模型：</p>
<pre><code class="language-javascript">;(function () {})()
</code></pre>
<p>上述基本模型，也称为立即执行函数 IIFE，该模式不会向外界暴露任何全局变量，形成了一个封闭的空间。</p>
<p>如果直接使用上述沙箱模式，那么类似 jQuery 这样的库就无法向外提供可调用的 API 了，我们可以考虑将想被外界使用的属性和方法加到 window 全局对象上去。</p>
<p>但是 window 全局对象不可以直接引用，这样破坏了沙箱原则，所以 jQuery 中，使用传参形式将 window 对象传入沙箱内，此时就不需要使用全局的 window 对象，而是沙箱内部定义的形参。</p>
<pre><code class="language-javascript">;(function (win) {
  let Obj = {
    getEle: function () {},
  }
  win.Obj = win.$ = Obj
})(window)
</code></pre>
<p>注意：参数如下理解：</p>
<pre><code class="language-js">;(function (形参) {})(实参)
</code></pre>
<p>沙箱模式主要用于书写框架、插件等，主要的原理是：利用函数构建独立作用域。</p>
<h2 id="三-闭包"><a class="header" href="#三-闭包">三 闭包</a></h2>
<h3 id="31-闭包概念"><a class="header" href="#31-闭包概念">3.1 闭包概念</a></h3>
<p>闭包（closure）是引用了另外一个函数作用域中变量的函数，通常是在嵌套函数中实现的，示例：</p>
<pre><code class="language-js">//实现修改数据
function foo() {
  let num = 1
  return function (a) {
    num = num + a
    console.log(num)
  }
}
foo()(456) //这样就修改了函数内部的数据
</code></pre>
<p>示例中 return 的函数引用了外部 foo 函数的 num 变量，return 函数被返回并在其他地方使用后，它仍然引用着变量 num，这是因为 return 的内部函数的作用域链包含 foo()函数作用域。</p>
<p>在 Chrome 中，称呼 foo() 函数即为闭包，而在一部分书籍中，则称呼 return 出去的函数为闭包。</p>
<h3 id="32-闭包应用"><a class="header" href="#32-闭包应用">3.2 闭包应用</a></h3>
<p>闭包可以让函数的书写体验更加优雅：</p>
<pre><code class="language-js">let user = [
  {
    id: 1001,
    age: 21,
    name: 'lisi',
  },
  {
    id: 1003,
    age: 14,
    name: 'ww',
  },
  {
    id: 1002,
    age: 13,
    name: 'zs',
  },
]

// 对上述数据排序，可能会用 age，可能会用 id，可能用 name
function order(field) {
  return function (a, b) {
    return a[field] &gt; b[field] ? 1 : -1
  }
}

console.log(user.sort(order('age')))
</code></pre>
<h3 id="33-闭包与作用域链"><a class="header" href="#33-闭包与作用域链">3.3 闭包与作用域链</a></h3>
<p>作用域链导致闭包只能获取包含函数中所有变量的最后一个值：</p>
<pre><code class="language-js">function createFunctions() {
  let result = new Array()

  for (let i = 0; i &lt; 10; i++) {
    result[i] = function () {
      return i
    }
  }

  return result // 实际返回的 i 都是 10
}
</code></pre>
<p>为了让上述代码符合预期，必须通过另一个匿名函数来实现：</p>
<pre><code class="language-js">function createFunctions() {
  let result = new Array()

  for (let i = 0; i &lt; 10; i++) {
    result[i] = (function (num) {
      return num
    })(i)
  }

  return result // 实际返回的 i 都是 10
}
</code></pre>
<p>注意：闭包并不会导致作用域链（Scop）的变化。因为函数调用栈是在代码执行时确定的，而作用域链是在代码编译阶段就已经确定，虽然作用域链是在代码执行时才会生成，但是其规则并不会在执行时发生变化。</p>
<h3 id="34-闭包中的-this"><a class="header" href="#34-闭包中的-this">3.4 闭包中的 this</a></h3>
<pre><code class="language-js">let name = 'ZS'

let obj = {
  name: 'LS',
  getName: function () {
    return function () {
      return this.name
    }
  },
}

// 非严格模式输出：ZS，严格模式报错：Cannot read property 'name' of undefined
console.log(obj.getName()())
</code></pre>
<p>上述代码，无论在严格模式还是非严格模式，都得不到期望的值：“LiSi”，原因是每个函数被调用都会自动获得两个特殊变量：this、arguments，内部函数在搜索这 2 个变量时，只会搜索到活动对象为止，永远不可能直接访问外部函数中的这 2 个变量。把外部作用域中的 this 对象保存在一个闭包中就可以解决该问题：</p>
<pre><code class="language-js">let name = 'ZS'

let obj = {
  name: 'LS',
  getName: function () {
    let that = this

    return function () {
      return that.name
    }
  },
}

// 输出 LS
console.log(obj.getName()())
</code></pre>
<p>贴士：在 ES6 中提供的箭头函数会将 this 绑定为设定时的对象，而不是当前调用对象。</p>
<h3 id="35-闭包中的内存泄露问题"><a class="header" href="#35-闭包中的内存泄露问题">3.5 闭包中的内存泄露问题</a></h3>
<p>在 **IE 浏览器（IE&lt;=8）**中，有多个垃圾回收机制，闭包很容易导致创建的元素无法被销毁：</p>
<pre><code class="language-js">// 创建 element 元素的事件处理闭包
function assignHandler() {
  let element = document.getElementById('mydiv')
  element.onclick = function () {
    alert(element.id)
  }
}
</code></pre>
<p>以上代码创建了一个作为 element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对 assignHandler() 的活动对象的引用，因此就会导致无法减少 element 的引用数。只要匿名函数存在，element 的引用数至少也是 1，因此它所占用的内存就永远不会被回收。这里必须为 element 创造掷空条件：</p>
<pre><code class="language-js">function assignHandler() {
  let element = document.getElementById('mydiv')
  let elementId = element.id

  element.onclick = function () {
    alert(elementId)
  }

  element = null
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="091-面向对象-思想概念"><a class="header" href="#091-面向对象-思想概念">09.1-面向对象-思想概念</a></h1>
<h2 id="一-面向对象初识"><a class="header" href="#一-面向对象初识">一 面向对象初识</a></h2>
<h3 id="11-面向对象概念"><a class="header" href="#11-面向对象概念">1.1 面向对象概念</a></h3>
<p>软件开发领域具有两种开发思想：</p>
<ul>
<li>面向过程：比如经典的 C 语言即是面向过程语言。如果需要写一个功能，直接按照操作过程一步一步实现即可。</li>
<li>面向对象：比如经典的 Java 语言即是面向对象语言。任何功能都是由一个已经存在的工具来提供，由不同工具的组合实现一个完整系统</li>
</ul>
<p>面向对象有优点也有缺点，使用对象必须存在实例化的过程，造成了一定的性能损失，但是其优点也很明显，让大型工程更加易于维护和管理。</p>
<blockquote>
<p>OO：面向对象，即 Object Oriented
OOP：面向对象编程，即 Object Oriented Programming
OOA：面向对象分析，即 Object Oriented Analysis
OOD：面向对象设计，即 Object Oriented Design</p>
</blockquote>
<h3 id="12-面向对象的三大特性"><a class="header" href="#12-面向对象的三大特性">1.2 面向对象的三大特性</a></h3>
<p>面向对象三大特性：</p>
<ul>
<li><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式。封装可以将变化隔离，便于使用，提高复用性和安全性。</li>
<li><strong>继承</strong>：通过父子关系引用，子类无需书写父类成员，也能使用父类的成员。继承主要提高代码复用性。</li>
<li><strong>多态</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。多态用来提升程序的拓展性。</li>
</ul>
<h3 id="13-面向对象的五个基本原则"><a class="header" href="#13-面向对象的五个基本原则">1.3 面向对象的五个基本原则</a></h3>
<ul>
<li>单一职责原则 SRP（Single Responsibility Principle）：类的功能要单一</li>
<li>开放封闭原则 OCP(Open－Close Principle)：一个模块对于拓展是开放的，对于修改是封闭的</li>
<li>里式替换原则 LSP(the Liskov Substitution Principle LSP)：子类可以替换父类出现在父类能够出现的任何地方</li>
<li>依赖倒置原则 DIP(the Dependency Inversion Principle DIP)：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</li>
<li>接口分离原则 ISP(the Interface Segregation Principle ISP)：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。</li>
</ul>
<h2 id="二-javascript-面向对象"><a class="header" href="#二-javascript-面向对象">二 JavaScript 面向对象</a></h2>
<h3 id="20-javascript-中的对象"><a class="header" href="#20-javascript-中的对象">2.0 JavaScript 中的对象</a></h3>
<p>在 JavaScript 中，对象是无序属性的集合，其属性可以包含基本值、对象、函数等，即：对象是由一系列无序的 key-value 对组成，value 可以是多种数据类型。如下所示：</p>
<pre><code class="language-js">let person = {
  name: 'Tom',
  age: 18,
  getName: function () {
    return this.name
  },
}
</code></pre>
<h3 id="21-javascript-的类与实例"><a class="header" href="#21-javascript-的类与实例">2.1 JavaScript 的类与实例</a></h3>
<blockquote>
<p><strong>类</strong>：类是用于创建对象的模板。他们用代码封装数据以处理该数据。JS 中的类建立在原型上，但也具有某些语法和语义未与 ES5 类相似语义共享。类与引用类型相似，但不是一个概念，其意义在于约束一个事物的模板，引用类型则是一种数据类型！
<strong>实例</strong>：通过 new 操作符创建，其实就是一个引用的值，经常称某个引用类型的<strong>实例</strong>为对象。</p>
</blockquote>
<p>JavaScript 是一门面向对象的编程语言，但是其缺少传统面向对象语言的基本特征，如：类、接口。所以我们不能简单的将类、引用类型等混为一谈。</p>
<p>JavaScript 创建对象示例：</p>
<pre><code class="language-js">// now：实例；Date()：构造函数，在 Java 中我们也可以称 Date 为类
let now = new Date()
</code></pre>
<h3 id="22-构造函数"><a class="header" href="#22-构造函数">2.2 构造函数</a></h3>
<blockquote>
<p>构造函数：用来描述对象内部数据结构</p>
</blockquote>
<p>注意：构造函数只是对对象内部数据的描述，并没有达到创建对象的作用，<code>new</code>操作才是创建了对象。</p>
<p>示例：</p>
<pre><code class="language-js">// Person 构造函数：名称与类名一致，且大写
function Person(name, age) {
  this.name = name // 不添加 this 限定就会让 name 造成污染：创建的多个不同实例，其 name 都一样
  this.age = age
}

let p = new Person('lisi', age)
console.log(p.name)
</code></pre>
<h3 id="23-原型"><a class="header" href="#23-原型">2.3 原型</a></h3>
<p>在 JS 中，创建一个类依赖于构造函数、原型两个条件。（至于原型出现的原因将会在下一节创建 JS 对象中详细说明）。</p>
<p>示例：</p>
<pre><code class="language-js">// Person 构造函数：名称与类名一致，且大写
function Person(name, age) {
  this.name = name // 不添加 this 限定就会让 name 造成污染：创建的多个不同实例，其 name 都一样
  this.age = age
}

// 构造函数的原型：用于挂载类的实例方法
Person.prototype.sing = function () {
  console.log(this.name + '在唱歌...')
}
</code></pre>
<p>上述代码完整、标准展现了 JS 中的一个类 Person，一个标准的类包括两部分：</p>
<ul>
<li>构造函数：首字母大写，与类名相同，内部包含该类的通用属性</li>
<li>构造函数的原型：每个构造函数都具备的属性 prototype，内部包含该类的通用方法</li>
</ul>
<p>有了类，现在就可以通过类创建对象了：</p>
<pre><code class="language-js">let p1 = new Person('张三', 30)
console.log(p.age) // 30
p1.sing() // 张三在唱歌...

let p2 = new Person('张三', 30)
console.log(p.age) // 30
p2.sing() // 张三在唱歌...
</code></pre>
<p>构造函数中的 this，其实就代表了对象的实例！</p>
<h3 id="24-成员"><a class="header" href="#24-成员">2.4 成员</a></h3>
<p>我们通常称呼一个类的字段、函数为成员，类的成员通常有两部分：</p>
<ul>
<li>属性：即类包含的一些键值</li>
<li>方法：即类包含的一些函数。用类或对象来调用的函数，我们一般称之为方法</li>
</ul>
<p>方法可以挂载在构造函数的原型上，也可以直接挂载在构造函数上，那么此时就可以分为：</p>
<ul>
<li>实例方法：由类创建的实例对象调用，如示例中的 sing 方法</li>
<li>静态方法：也称为类方法，由类本身调用，挂载在构造函数上</li>
</ul>
<p>静态方法示例：</p>
<pre><code class="language-js">Person.eat = function () {
  console.log('eat....')
}

Person.eat()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="092-面向对象-对象的创建方式"><a class="header" href="#092-面向对象-对象的创建方式">09.2-面向对象-对象的创建方式</a></h1>
<h2 id="一-直接量创建对象"><a class="header" href="#一-直接量创建对象">一 直接量创建对象</a></h2>
<p>直接量是最简单的实例创建方式：</p>
<pre><code class="language-js">// 创建实例：
let obj = {
  name: '张学友',
  age: 13,
  run: function () {
    console.log(this.name + '唱歌...')
  },
}

// 操作实例：
p.run()
</code></pre>
<p>方法也可以简写为：</p>
<pre><code class="language-js">// 创建实例：
let obj = {
  name: '张学友',
  age: 13,
  run() {
    console.log(this.name + '唱歌...')
  },
}
</code></pre>
<h2 id="二-使用-object-基类创建对象"><a class="header" href="#二-使用-object-基类创建对象">二 使用 Object 基类创建对象</a></h2>
<pre><code class="language-js">let person = new Object()

person.name = 'Nicholas'
person.age = 29
person.job = 'Software Engineer'
person.sayName = function () {
  console.log(this.name)
}

person.sayName()
</code></pre>
<p>贴士：这种方式写法较为繁琐，往往直接使用字面量方式即可。</p>
<p>ES5 的 Object 对象还提供了 create() 方法用来创建对象，这种创建方式主要用来指定原型的：</p>
<pre><code class="language-js">let other = {
  age: 30,
}

let obj = Object.create(other)
obj.name = 'Lisi'

console.log(obj.age) // 30
console.log(obj.__proto__) // { age: 30 }
console.log(Object.getPrototypeOf(person) === other) // true
</code></pre>
<p>注意：该方法传入参数为 null 时，会创建一个没有原型的新对象，不会继承任何东西，甚至不能使用<code>toString()</code>这样的基础方法，所以创建空对象的方式是：</p>
<pre><code class="language-js">let obj = Object.create(Object.prototype)
</code></pre>
<p>create() 方法还有第二个参数可以用来自定义子类对象的属性：</p>
<pre><code class="language-js">let p1 = Object.create(p, {
  name: {
    value: 'lisi',
  },
})
console.log(p1.name) //  lisi
</code></pre>
<h2 id="三-基于构造函数和原型创建对象"><a class="header" href="#三-基于构造函数和原型创建对象">三 基于构造函数和原型创建对象</a></h2>
<h3 id="31-使用构造函数"><a class="header" href="#31-使用构造函数">3.1 使用构造函数</a></h3>
<p>传统的面向对象语言，如 Java，对象都是通过构造函数进行构造，其作用很类似工厂函数：</p>
<pre><code class="language-js">// 构造函数首字母要大写
function Man(name, age) {
  this.name = name
  this.age = age
  this.sex = '男' // 无需使用参数的成员
  this.sayName = function () {
    console.log(this.name)
  }
}

let person1 = new Person('Nicholas', 29)
let person2 = new Person('Greg', 27)
person1.sayName() // Nicholas
person2.sayName() // Greg
</code></pre>
<p>贴士：构造函数不一定要写成函数声明的形式，赋值的函数表达式也可以 <code>const Man = ()=&gt;{}</code>。在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。</p>
<p>构造函数与普通函数没有本质上的区别，其调用方式采用 new。其实只要是使用 new 方式调用的函数即构造函数！</p>
<h3 id="32-使用原型配合构造函数创建对象"><a class="header" href="#32-使用原型配合构造函数创建对象">3.2 使用原型配合构造函数创建对象</a></h3>
<p>构造函数创建对象有个<strong>弊端</strong>：当我们无限制的 new 对象时，对象引用的函数对象就会越来越多！逻辑上这些函数都应该是同一个函数（做同一个事情！），反复创建浪费了空间：</p>
<pre><code class="language-js">function Person(name, age) {
  this.name = name
  this.age = age
  this.say = function () {
    console.log(`My name is ${this.name}`)
  }
}

let p1 = new Person('lisi', 18)
let p2 = new Person('zs', 22)

console.log(p1.say == p2.say) // false
</code></pre>
<p>我们发现实例方法如果直接写在构造函数后，不同的实例方法在判断相等时候，结果是 false。这是因为每次通过 new 创建一个全新的实例时，都等于重新申请了新的内存，并将构造函数的数据拷贝进该内存，这也造成了 p1 和 p2 的 say 方法不相等，也导致了无故多创建了一个函数内存！</p>
<p>为了解决构造函数问题，我们可以成员方法转义到构造函数外部，每个函数都有一个 prototype 属性，用来包含所有实例<strong>共享</strong>的属性、方法！原型不会被拷贝，因为他是构造函数自身的属性，不是实例上的属性，为了统一处理这些不会被拷贝的数据，JS 规定将这些数据都存放在构造函数的 prototype 属性上。</p>
<pre><code class="language-js">function Man(name, age) {
  this.name = name
  this.age = age
}

Man.prototype.say = function () {
  console.log(`My name is ${this.name}`)
}

let m1 = new Man('lisi', 18)
let m2 = new Man('zs', 22)
m1.say() // My name is lisi
m2.say() // My name is zs

console.log(m1.say == m2.say) // true
</code></pre>
<p>贴士：原型内部适合存储实例方法、共享数据，存储非共享数据会产生致命影响，比如： <code>Man.prototype.sex = 1</code>，这会导致所有的对象实例的 sex 都一样。</p>
<p>总结： <strong>一般将属性放在构造函数中，方法放在原型中！</strong>：</p>
<ul>
<li>构造函数内部的函数，在每次创建实例的时候都会在内存中新建一次该函数，比如一个 Person() 类 new10 次就会产生 10 个 run 方法，会严重造成资源浪费。但是在 protoype 属性上挂载的方法则不会，因为原型本身其实也是一个对象，所有的实例都会引用这一个对象上的方法。</li>
<li>原型上书写属性字段，会造成 new 出的实例的该字段值都是一样的，无法定制化，比如上述实例 new 出的对象其 sex 属性都为”男“。原型上若存储非函数的普通变量数据的，但是这种数据无法被实例改变，只能像静态方法那样，通过类名修改。</li>
</ul>
<h2 id="四-es6-的-class-类方式创建对象"><a class="header" href="#四-es6-的-class-类方式创建对象">四 ES6 的 class 类方式创建对象</a></h2>
<pre><code class="language-js">class Person {
  constructor() {}
}

const p = new Person()
</code></pre>
<p>class 创建对象方式详见下一章。</p>
<h2 id="五-总结与理解"><a class="header" href="#五-总结与理解">五 总结与理解</a></h2>
<h3 id="51-创建对象方式总结"><a class="header" href="#51-创建对象方式总结">5.1 创建对象方式总结</a></h3>
<p>上述介绍了四种创建对象的方式：</p>
<p>常见的对象创建方式：</p>
<ul>
<li>直接量方式（也即字面量）</li>
<li>使用基类 Object 创建</li>
<li>构造函数与原型方式</li>
<li>ES6 类方式</li>
</ul>
<p>除了常见的四种创建对象方式，我们可以在上述基础上利用工厂模式创建对象：</p>
<pre><code class="language-js">function createPerson(name, age, job) {
  let o = new Object()
  o.name = name
  o.age = age
  o.job = job
  o.sayName = function () {
    console.log(this.name)
  }
  return o
}

let person1 = createPerson('Nicholas', 29, 'Software Engineer')
let person2 = createPerson('Greg', 27, 'Doctor')
</code></pre>
<p>工厂模式可以对要创建的对象实现更多的可定制，但并不是真正创建对象的方式，内部仍然是使用 new 或者直接量等。只是利用设计模式思想，让开发更方便（世界更美好）。</p>
<h3 id="52-new-的过程"><a class="header" href="#52-new-的过程">5.2 new 的过程</a></h3>
<p>new 创建对象的过程：</p>
<ul>
<li>1、在内存中开辟空间，创建一个新的空对象</li>
<li>2、新对象的 <code>[[Prototype]]</code> 特性被赋值为构造函数的 prototype 属性</li>
<li>3、将构造函数内部的 this 指向新对象</li>
<li>4、执行构造函数内部的代码，即给新对象添加属性！</li>
<li>5、正常情况下，对象创建完毕，并将该对象交给了开发者使用。如果构造函数有返回值，且返回值是引用类型，则生成的实例是该返回值。</li>
</ul>
<p>伪代码演示 new 过程：</p>
<pre><code class="language-js">this = {} // 1
this.__proto__ = 构造函数.prototype // 3
this.age = 18 // 4
return this // 5
</code></pre>
<h2 id="附-构造函数与原型写法优化"><a class="header" href="#附-构造函数与原型写法优化">附 构造函数与原型写法优化</a></h2>
<blockquote>
<p>前情提醒：笔者本人不推荐该写法，因为现在普遍使用 class 方式创建，下列优化比较鸡肋！添加本小节只是对一些知识点的科普</p>
</blockquote>
<p>采用构造函数与原型创建对象的方式中，prototype 上的每个方法都要写一次<code>构造函数.prototype.方法名 = </code>，既然 prototype 是个对象，其实可以使用字面量形式直接书写。</p>
<pre><code class="language-js">function Person() {}

Person.prototype = {
  name: 'Nicholas',
  age: 29,
  job: 'Software Engineer',
  sayName() {
    console.log(this.name)
  },
}
</code></pre>
<p>这里会出现一个问题：</p>
<pre><code class="language-js">let friend = new Person()
console.log(friend.constructor == Person) // false
</code></pre>
<p>解决方案：</p>
<pre><code class="language-js">function Person() {}

Person.prototype = {
  constructor: Person,
  name: 'Nicholas',
  age: 29,
  job: 'Software Engineer',
  sayName() {
    console.log(this.name)
  },
}
</code></pre>
<p>这里仍然有个问题：上述的 constructor 属性会创建一个 <code>[[Enumerable]]</code> 为 true 的属性，而原生的 constructor 属性默认是不可枚举的，如果要照顾兼容性，则可以使用下面的方式：</p>
<pre><code class="language-js">function Person() {}
Person.prototype = {
  name: 'Nicholas',
  age: 29,
  job: 'Software Engineer',
  sayName() {
    console.log(this.name)
  },
}

// 恢复 constructor 属性
Object.defineProperty(Person.prototype, 'constructor', {
  enumerable: false,
  value: Person,
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="093-面向对象-es6-新增-class-关键字"><a class="header" href="#093-面向对象-es6-新增-class-关键字">09.3-面向对象-ES6 新增 class 关键字</a></h1>
<h2 id="一-使用-class-类创建对象"><a class="header" href="#一-使用-class-类创建对象">一 使用 class 类创建对象</a></h2>
<h3 id="11-class-类概念"><a class="header" href="#11-class-类概念">1.1 class 类概念</a></h3>
<p>类是 Java 这种面向对象语言的核心概念，ES6 也提出了类，并使用关键字 <code>class</code> 来描述。</p>
<p>我们可以简单的认为类就是创建对象的模板，默认情况下，类定义中的代码都在严格模式下执行，与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例：</p>
<pre><code class="language-js">class Person {
  // 构造方法：包含类的属性
  constructor(name) {
    this.name = name
    this.age = 0
  }
  run() {
    console.log(this.name + ' is running...')
  }
}

let p = new Person('zs')
p.run()
</code></pre>
<p>ECMAScript 中没有类这个类型，从各方面来看， class 类就是一种特殊函数：</p>
<pre><code class="language-js">class Person {}
console.log(typeof Person) // function
</code></pre>
<h3 id="12-类与构造函数区别"><a class="header" href="#12-类与构造函数区别">1.2 类与构造函数区别</a></h3>
<p>在 JavaScript 中，用 class 实现的类其实是语法糖，其本质仍然是构造函数与原型：</p>
<pre><code class="language-js">class Person {}
console.log(Person) // class Person {}
console.log(typeof Person) // function
</code></pre>
<p>他们的主要区别是：</p>
<ul>
<li>class 声明不会像构造函数声明那样出现变量提升，类声明收到了块级作用域限制</li>
<li>构造函数原型上的方法是可以用 <code>for in</code> 遍历到的，使用 class 创建的方法无法被遍历(不可枚举)</li>
<li>调用类必须使用 new 操作符，不使用 new 会报错，而普通构造函数如果不使用 new 调用，那么就会以全局的 this（通常是 window）作为内部对象。</li>
</ul>
<pre><code class="language-js">// 区别一：console.log(Person)  // 报错

class Person {
  constructor(name) {
    this.name = name
  }
  say() {
    console.log('say...')
  }
}

function Human(name) {
  this.name = name
}
Human.prototype.say = function () {
  console.log('say...')
}

let p = new Person('lisi')
let h = new Human('zs')

// 区别二：遍历出来的结果不同
for (const item in p) {
  console.log('p item: ', item) // name，没有 say
}
for (const item in h) {
  console.log('h item: ', item) // name，有 say
}
console.log(Object.getOwnPropertyDescriptor(Person.prototype, 'say')) // enumerable 为 false
console.log(Object.getOwnPropertyDescriptor(Human.prototype, 'say')) // enumerable 为 true

// 区别三：不使用new操作符时
// let p2 = Person('h2')    // 报错
let h2 = Human('h2') // 绑定在全局作用域window上
</code></pre>
<h2 id="二-类的构造方法"><a class="header" href="#二-类的构造方法">二 类的构造方法</a></h2>
<p>constructor 关键字是类定义块内部的构造方法。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。</p>
<p>构造方法的定义不是必需的，不定义构造方法相当于将构造方法定义为空函数。</p>
<p>默认情况下，类构造方法在执行之后会返回 this 对象，该对象会被用作实例化的对象。如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 instanceof 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改：</p>
<pre><code class="language-js">class Person {
  constructor(override) {
    this.foo = 'foo'
    if (override) {
      return {
        bar: 'bar',
      }
    }
  }
}

let p1 = new Person(),
  p2 = new Person(true)
console.log(p1) // Person{ foo: 'foo' }
console.log(p1 instanceof Person) // true
console.log(p2) // { bar: 'bar' }
console.log(p2 instanceof Person) // false
</code></pre>
<p>类构造方法没有什么特殊之处，实例化之后可以在实例上引用它：</p>
<pre><code class="language-js">class Person {}
// 使用类创建一个新实例
let p1 = new Person()
let p2 = new p1.constructor()

// 作为构造方法必须使用new调用！！
// p1.constructor() //  TypeError: Class constructor Person cannot be invoked without 'new'
</code></pre>
<p>类标识符有 prototype 属性，而这个原型也有一个 constructor 属性指向类自身：</p>
<pre><code class="language-js">class Person {}
console.log(Person.prototype) // { constructor: f() }
console.log(Person === Person.prototype.constructor) // true
</code></pre>
<p><strong>重点：类中定义的 constructor 方法不会被当成构造函数，在对它使用 instanceof 操作符时会返回 false，但是，如果在 new 实例时直接将类构造函数当成普通构造函数来使用，那么 instanceof 操作符的返回值会反转</strong>：</p>
<pre><code class="language-js">class Person {}
let p1 = new Person()
console.log(p1.constructor === Person) // true
console.log(p1 instanceof Person) // true
console.log(p1 instanceof Person.constructor) // false

let p2 = new Person.constructor()
console.log(p2.constructor === Person) // false
console.log(p2 instanceof Person) // false
console.log(p2 instanceof Person.constructor) // true
</code></pre>
<h2 id="三-类的成员"><a class="header" href="#三-类的成员">三 类的成员</a></h2>
<h3 id="31-类的成员汇总"><a class="header" href="#31-类的成员汇总">3.1 类的成员汇总</a></h3>
<p>成员即对象的属性、方法等，包括构造方法、实例方法、获取函数、设置函数和静态类方法等，这些成员都是可选的可以通过 点语法 或者 [] 获取或者添加成员：</p>
<pre><code class="language-js">let obj = {
  name: 'lisi',
  age: 30,
}

obj[0] = function () {
  console.log('添加成功')
}

// 在以前，如果要让变量的值作为属性，必须：先声明对象，再使用中括号语法添加属性：
const key1 = 'name'
obj[key1] = 'Matt'

// 现在，通过可计算属性，可以直接在字面量内完成赋值：
const key2 = 'age'
let person = {
  [key2]: 30,
}

// 删除成员
delete obj.age // delete 不能删除原型上的属性，所以也不能删除继承属性！
</code></pre>
<p>贴士：从通过 [] 可以访问成员可以看出，JS 的对象其实就是一个字典（或者说哈希表、散列表），其构造类似于 ES6 中的 Map。可以通过 for in 来遍历对象中的元素。</p>
<h3 id="32-实例成员"><a class="header" href="#32-实例成员">3.2 实例成员</a></h3>
<p>每次通过 new 调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（ this）添加“自有”属性。至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员：</p>
<pre><code class="language-js">class Person {
  constructor(name) {
    this.name = name
  }

  // 实例方法
  run() {
    console.log(this.name + ' is running...')
  }
}

let p = new Person('lisi')

// 默认设置属性
console.log('设置前姓名:', p.name) // lisi
p.name = 'zhangsan'
console.log('设置后姓名:', p.name) // zhangsan
p.age = 30
console.log('年龄:', p.age) // 30
</code></pre>
<p>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法：</p>
<pre><code class="language-js">class Person {
  constructor() {
    // 添加到 this 的所有内容都会存在于不同的实例上
    this.locate = () =&gt; console.log('instance')
  }
  // 在类块中定义的所有内容都会定义在类的原型上
  locate() {
    console.log('prototype')
  }
}
let p = new Person()
p.locate() // instance
Person.prototype.locate() // prototype
</code></pre>
<p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：</p>
<pre><code class="language-js">const symbolKey = Symbol('symbolKey')
class Person {
  stringKey() {
    console.log('invoked stringKey')
  }
  [symbolKey]() {
    console.log('invoked symbolKey')
  }
  ['computed' + 'Key']() {
    console.log('invoked computedKey')
  }
}
let p = new Person()
p.stringKey() // invoked stringKey
p[symbolKey]() // invoked symbolKey
p.computedKey() // invoked computedKey
</code></pre>
<p>类定义也支持获取和设置访问器。语法与行为跟普通对象一样。</p>
<h3 id="33-静态类方法"><a class="header" href="#33-静态类方法">3.3 静态类方法</a></h3>
<p>静态成员其实是通过构造函数、类能够直接使用的成员，无需使用实例调用：</p>
<pre><code class="language-js">function Person() {}

// 静态属性
Person.sex = '男'

// 静态方法
Person.run = function () {
  console.log('running...')
}

console.log(Person.sex)
Person.run()
</code></pre>
<p>在 ES6 中，提供了关键字 static 用来描述静态成员：</p>
<pre><code class="language-js">class Person {
  static sex = '男'
  static run() {
    console.log('running...')
  }
}

console.log(Person.sex)
Person.run()
</code></pre>
<p>静态成员一般是一些无需实例使用的属性，比如在 run() 中无需使用 this，为了节省空间，可以将 run() 方法定义为静态方法。</p>
<p>静态类方法非常适合作为实例工厂：</p>
<pre><code class="language-js">class Person {
  constructor(age) {
    this.age_ = age
  }
  sayAge() {
    console.log(this.age_)
  }
  static create() {
    // 使用随机年龄创建并返回一个 Person 实例
    return new Person(Math.floor(Math.random() * 100))
  }
}
console.log(Person.create()) // Person { age_: ... }
</code></pre>
<h3 id="34-非函数原型和类成员"><a class="header" href="#34-非函数原型和类成员">3.4 非函数原型和类成员</a></h3>
<p>虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加：</p>
<pre><code class="language-js">class Person {
  sayName() {
    console.log(`${Person.greeting} ${this.name}`)
  }
}
// 在类上定义数据成员
Person.greeting = 'My name is'
// 在原型上定义数据成员
Person.prototype.name = 'Jake'
let p = new Person()
p.sayName() // My name is Jake
</code></pre>
<h3 id="35-迭代器与生成器方法"><a class="header" href="#35-迭代器与生成器方法">3.5 迭代器与生成器方法</a></h3>
<p>类定义语法支持在原型和类本身上定义生成器方法：</p>
<pre><code class="language-js">class Person {
  // 在原型上定义生成器方法
  *createNicknameIterator() {
    yield 'Jack'
    yield 'Jake'
    yield 'J-Dog'
  }
  // 在类上定义生成器方法
  static *createJobIterator() {
    yield 'Butcher'
    yield 'Baker'
    yield 'Candlestick maker'
  }
}

let jobIter = Person.createJobIterator()
console.log(jobIter.next().value) // Butcher
console.log(jobIter.next().value) // Baker
console.log(jobIter.next().value) // Candlestick maker

let p = new Person()
let nicknameIter = p.createNicknameIterator()
console.log(nicknameIter.next().value) // Jack
console.log(nicknameIter.next().value) // Jake
console.log(nicknameIter.next().value) // J-Dog
</code></pre>
<p>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象：</p>
<pre><code class="language-js">class Person {
  constructor() {
    this.nicknames = ['Jack', 'Jake', 'J-Dog']
  }
  *[Symbol.iterator]() {
    yield* this.nicknames.entries()
  }
}
let p = new Person()
for (let [idx, nickname] of p) {
  console.log(nickname) // Jack Jake J-Dog
}
</code></pre>
<p>也可以只返回迭代器实例：</p>
<pre><code class="language-js">class Person {
  constructor() {
    this.nicknames = ['Jack', 'Jake', 'J-Dog']
  }
  [Symbol.iterator]() {
    return this.nicknames.entries()
  }
}
let p = new Person()
for (let [idx, nickname] of p) {
  console.log(nickname) // Jack Jake J-Dog
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="094-面向对象-原型与原型链"><a class="header" href="#094-面向对象-原型与原型链">09.4-面向对象-原型与原型链</a></h1>
<h2 id="一-理解原型"><a class="header" href="#一-理解原型">一 理解原型</a></h2>
<h3 id="11-原型对象"><a class="header" href="#11-原型对象">1.1 原型对象</a></h3>
<p>创建的函数都会拥有一个 prototype 属性，该属性即是原型对象的引用，这样做可以让多个实例间通用方法使用同一个引用，减少空间占用！</p>
<p>而原型对象默认会获得两个属性：</p>
<ul>
<li><code>constructor</code>：指向与原型对象关联的构造函数</li>
<li><code>__proto__</code>：指向其构造函数的原型，默认是 Object。该属性不是标准属性，但是已经被各大浏览器接受并实现。</li>
</ul>
<p>其对应关系如图：</p>
<p><img src="01-JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/../images/javascript/prototype-01.svg" alt="原型关系" /></p>
<pre><code class="language-js">class Person {}
console.log(Person.prototype) // { constructor: f Person(), __proto__: Object}
console.log(Person.prototype.constructor === Person) // true

console.log(Person.prototype.__proto__.constructor === Object) // true

// 正常的原型链都会终止于 Object 的原型对象
console.log(Person.prototype.__proto__ === Object.prototype) // true
console.log(Person.prototype.__proto__.__proto__ === null) // true

// 实例与构造函数没有直接联系，与原型对象有直接联系
let p = new Person()
console.log(p.prototype) // undefined，因为是手动 new 出来的实例，我们没有添加该属性
console.log(p.__proto__ == Person.prototype) // true
conosle.log(p.__proto__.constructor === Person) // true
</code></pre>
<p>如果我们将 Object 对象加入：</p>
<p><img src="01-JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/../images/javascript/prototype-01-o.svg" alt="原型关系" /></p>
<h3 id="12-原型的动态性"><a class="header" href="#12-原型的动态性">1.2 原型的动态性</a></h3>
<p>由于从原型上搜索值的过程是动态的，即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。</p>
<pre><code class="language-js">class Person {}

// 先创建实例
let friend = new Person()

// 后修改原型
Person.prototype.sayHi = function () {
  console.log('hi')
}

// 后添加的方法能够被调用
friend.sayHi() // &quot;hi&quot;，没问题！
</code></pre>
<p>注意：如果是对原型的重写，则不会出现上述现象，如下所示：</p>
<pre><code class="language-js">class Person {}

// 先创建对象
let friend = new Person()

// 后重写原型
Person.prototype = {
  constructor: Person,
  name: 'Nicholas',
  age: 29,
  job: 'Software Engineer',
  sayName() {
    console.log(this.name)
  },
}

// 调用错误：friend.sayName is not a function
friend.sayName()
</code></pre>
<p>这是因为实例的 <code>[[Prototype]]</code> 指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。</p>
<h2 id="二-原型链"><a class="header" href="#二-原型链">二 原型链</a></h2>
<h3 id="21-原型链介绍"><a class="header" href="#21-原型链介绍">2.1 原型链介绍</a></h3>
<p>在 JS 中，几乎所有对象都可以是原型对象，也可以是实例对象，还可以是构造函数。当一个对象身兼多职时，就可以看做一个节点。每个节点都可以通过一些属性来访问到另外一个节点，多个节点会形成一个链式结构，在这个链式结构上，原型对象是每个节点之间进行关联的核心，这个链式结构可以看做原型链。</p>
<p>如图所示：</p>
<p><img src="01-JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/../images/javascript/prototype-chain.svg" alt="原型链" /></p>
<p>原型链的本质：<strong>原型链的实现依赖于实例指向原型的指针 <code>[[Prototype]]</code></strong>，图中紫色部分都可以通过 <code>__proto__</code> 属性进行链接，加粗部分原型链即为实例指向原型的指针！<strong>正是因为该指针的存在，才能进行成员的向上搜索！</strong>。</p>
<p>比如一个 Person 构造函数，一个实例对象 p：</p>
<pre><code class="language-js">Person.prototype.constructor = Person
p.constructor = Person
p._proto_ = Person.prototype
p._proto_.constructor = Person
p._proto_.constructor = Person.prototype.constructor
</code></pre>
<p>当然构造函数本身其实也是一个对象的实例，即 Function 对象，那么他们的关系如下所示：
<img src="01-JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/../images/javascript/prototype-chain-f.svg" alt="原型链" /></p>
<h3 id="22-属性搜索原则"><a class="header" href="#22-属性搜索原则">2.2 属性搜索原则</a></h3>
<p>与普通构造函数一样， 类可以使用 instanceof 操作符检查构造函数原型是否存在于实例的原型链中：</p>
<pre><code class="language-js">class Person {}
let p = new Person()
console.log(p instanceof Person) // true
</code></pre>
<p>在通过对象访问属性时，会按照这个属性的名称开始搜索，属性的搜索过程：</p>
<pre><code class="language-txt">1、先在自身实例查找
2、再去当前对象的原型中查找
3、再找原型的原型对象...依次向上查找
4、最后查找 Objct.prototype
5、找不到报错
</code></pre>
<p>使用 delete 操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象：</p>
<pre><code class="language-js">class Person {}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
  console.log(this.name)
}

let person1 = new Person()
let person2 = new Person()
person1.name = 'Greg'
console.log(person1.name) // &quot;Greg&quot;，来自实例
console.log(person2.name) // &quot;Nicholas&quot;，来自原型
delete person1.name
console.log(person1.name) // &quot;Nicholas&quot;，来自原型
</code></pre>
<h3 id="23-object-的原型"><a class="header" href="#23-object-的原型">2.3 Object 的原型</a></h3>
<p>首先看构造函数：</p>
<pre><code class="language-js">let obj = new Object()
let obj1 = {}

console.log(obj.constructor === obj1.constructor) // true
console.log(obj.constructor === Object) // true
</code></pre>
<p>现在看 Object 的原型：</p>
<pre><code class="language-js">console.log(Object.prototype) // 一系列 Object 上的函数
console.log(Object.prototype.prototype) // undefined
</code></pre>
<h3 id="24-没有原型的对象"><a class="header" href="#24-没有原型的对象">2.4 没有原型的对象</a></h3>
<p>没有原型的对象是存在的：</p>
<pre><code class="language-js">// 此时 obj 没有父亲！
let obj = Object.create(null, {})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="095-面向对象-三大特性之封装"><a class="header" href="#095-面向对象-三大特性之封装">09.5-面向对象-三大特性之封装</a></h1>
<h2 id="一-封装概念"><a class="header" href="#一-封装概念">一 封装概念</a></h2>
<blockquote>
<p>封装：将对象的某些成员隐藏，不允许外部程序直接访问。</p>
</blockquote>
<p>经过封装的成员只能通过规定好的方式访问，可以隐藏一些细节，方便修改、实现。</p>
<p>在 JavaScript 中，通过设置器、访问器可以对成员进行初步封装，也可以通过 <code>Object.defineProperty()</code> 方法对成员的特征进行限制。</p>
<h2 id="二-封装的实现"><a class="header" href="#二-封装的实现">二 封装的实现</a></h2>
<h3 id="21-封装方式一设置器访问器"><a class="header" href="#21-封装方式一设置器访问器">2.1 封装方式一：设置器、访问器</a></h3>
<p>JS 的关键字 get、set 是对象总的访问器、设置器。我们通过点语法对对象进行属性的访问、设置，其内部其实是利用了访问器与设置器：</p>
<pre><code class="language-js">const obj = {
  age: 10,
  get age() {
    console.log('访问器被调用')
    // 这里不能使用 this.age，this.age 同样也是调用了 get，会引起循环调用
    return 1 // 注意
  },
  set age(v) {
    console.log('设置器被调用')
  },
}

obj.age = 100 // 设置器被调用
console.log(obj.age) // 访问器被调用  输出 1 而不是 10
</code></pre>
<p>由上看出，自定义的设置器、访问器，其优先级要比直接 <code>obj.age</code> 高，即如果访问器、设置的名称与对象中原有的属性名称一致，则以访问器、设置器为准，即他们的优先级更高。而且不能直接使用 <code>return age</code>，会引起循环引用。为了避免这些现象，一般推荐使用 下划线开头重新命名元素：</p>
<pre><code class="language-js">const obj = {
  _age: 10,
  get age() {
    console.log('访问器被调用')
    return this._age
  },
  set age(v) {
    console.log('设置器被调用')
    this._age = v
  },
}

obj.age = 100 // 设置器被调用
console.log(obj.age) // 访问器被调用 100
</code></pre>
<p>通过上述方式，可以对原本的成员 age 进行简单保护！当然也可以如下方式书写：</p>
<pre><code class="language-js">const obj = {
  data: {age :10}
  set age(v){
    age  = v;
  }
}
</code></pre>
<p>在 ES5 以前，开发者会使用两个非标准的访问创建访问器属性： <code>__defineGetter__()</code>和<code>__defineSetter__()</code>。</p>
<h3 id="22-封装方式二-objectdefineproperty-设置成员特征"><a class="header" href="#22-封装方式二-objectdefineproperty-设置成员特征">2.2 封装方式二： Object.defineProperty() 设置成员特征</a></h3>
<p>ECMA-262 使用了一些内部特性来描述对象的成员特征，比如：可枚举型、是否可修改等，这些特性是由 JavaScript 引擎所规范定义的，开发者不能直接在 JavaScript 中访问。使用 <code>Object.defineProperty()，getOwnPropertyDescriptor</code> 分别可以设置、获取这些特性。</p>
<p>具体细节参见 02-JavaScript 语法进阶中的 02.2-基类 Object-限制对象成员章节。</p>
<h2 id="三-私有变量"><a class="header" href="#三-私有变量">三 私有变量</a></h2>
<h3 id="31-私有变量概念"><a class="header" href="#31-私有变量概念">3.1 私有变量概念</a></h3>
<p>严格来讲， JavaScript 没有私有成员的概念，所有对象属性都公有的。不过，倒是有私有变量的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。来看下面的例子：</p>
<pre><code class="language-js">function add(num1, num2) {
  let sum = num1 + num2
  return sum
}
</code></pre>
<p>在这个函数中，函数 add()有 3 个私有变量： num1、 num2 和 sum。这几个变量只能在函数内部使用，不能在函数外部访问。如果这个函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部的这 3 个变量。基于这一点，就可以创建出能够访问私有变量的公有方法。</p>
<p>其实函数内的成员都可以认为是私有的，因为在函数外部都无法访问，只有通过特权方法（ privileged method）才能访问。在对象上有两种创建特权方法：</p>
<ul>
<li>在构造函数中实现</li>
<li>静态私有变量实现特权方法</li>
</ul>
<h3 id="32-构造函数方式实现特权方法"><a class="header" href="#32-构造函数方式实现特权方法">3.2 构造函数方式实现特权方法</a></h3>
<p>在构造函数中实现的示例：</p>
<pre><code class="language-js">function MyObject() {
  // 把私有变量和私有函数都定义在构造函数中
  let privateVariable = 10
  function privateFunction() {
    return false
  }

  // 创建一个能够访问这些私有成员的特权方法
  this.publicMethod = function () {
    privateVariable++
    return privateFunction()
  }
}
</code></pre>
<p>定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。在这个例子中，变量 privateVariable 和函数 privateFunction()只能通过 publicMethod()方法来访问。在创建 MyObject 的实例后，没有办法直接访问 privateVariable 和 privateFunction()，唯一的办法是使用 publicMethod()。</p>
<p>可以定义私有变量和特权方法，以隐藏不能被直接修改的数据：</p>
<pre><code class="language-js">function Person(name) {
  this.getName = function () {
    return name
  }
  this.setName = function (value) {
    name = value
  }
}
let person = new Person('Nicholas')
console.log(person.getName()) // 'Nicholas'
person.setName('Greg')
console.log(person.getName()) // 'Greg'
</code></pre>
<p>构造函数模式的缺点是每个实例都会重新创建一遍新方法。使用静态私有变量实现特权方法可以避免这个问题。</p>
<h3 id="33-静态私有变量方式实现特权方法"><a class="header" href="#33-静态私有变量方式实现特权方法">3.3 静态私有变量方式实现特权方法</a></h3>
<p>特权方法也可以通过使用私有作用域定义私有变量和函数来实现：</p>
<pre><code class="language-js">;(function () {
  // 私有变量和私有函数
  let privateVariable = 10
  function privateFunction() {
    return false
  }
  // 构造函数：注意在严格模式下给未声明的变量赋值会导致错误
  MyObject = function () {}
  // 公有和特权方法
  MyObject.prototype.publicMethod = function () {
    privateVariable++
    return privateFunction()
  }
})()
</code></pre>
<p>这个模式与前一个模式的主要区别就是，私有变量和私有函数是由实例共享的。因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域。</p>
<p>新的示例：</p>
<pre><code class="language-js">;(function () {
  let name = ''
  Person = function (value) {
    name = value
  }
  Person.prototype.getName = function () {
    return name
  }
  Person.prototype.setName = function (value) {
    name = value
  }
})()
let person1 = new Person('Nicholas')
console.log(person1.getName()) // 'Nicholas'
person1.setName('Matt')
console.log(person1.getName()) // 'Matt'
let person2 = new Person('Michael')
console.log(person1.getName()) // 'Michael'
console.log(person2.getName()) // 'Michael'
</code></pre>
<p>这里的 Person 构造函数可以访问私有变量 name，跟 getName()和 setName()方法一样。使用这种模式， name 变成了静态变量，可供所有实例使用。这意味着在任何实例上调用 setName()修改这个变量都会影响其他实例。调用 setName()或创建新的 Person 实例都要把 name 变量设置为一个新值。而所有实例都会返回相同的值。</p>
<p>像这样创建静态私有变量可以利用原型更好地重用代码，只是每个实例没有了自己的私有变量。最终，到底是把私有变量放在实例中，还是作为静态私有变量，都需要根据自己的需求来确定。不过使用闭包和私有变量会导致作用域链变长，作用域链越长，则查找变量所需的时间也越多。</p>
<h3 id="33-模块模式"><a class="header" href="#33-模块模式">3.3 模块模式</a></h3>
<p>模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法：</p>
<pre><code class="language-js">let singleton = (function () {
  // 私有变量和私有函数
  let privateVariable = 10
  function privateFunction() {
    return false
  }
  // 特权/公有方法和属性
  return {
    publicProperty: true,
    publicMethod() {
      privateVariable++
      return privateFunction()
    },
  }
})()
</code></pre>
<p>模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函数。本质上，对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式：</p>
<pre><code class="language-js">let application = (function () {
  // 私有变量和私有函数
  let components = new Array()
  // 初始化
  components.push(new BaseComponent())
  // 公共接口
  return {
    getComponentCount() {
      return components.length
    },
    registerComponent(component) {
      if (typeof component == 'object') {
        components.push(component)
      }
    },
  }
})()
</code></pre>
<p>在 Web 开发中，经常需要使用单例对象管理应用程序级的信息。上面这个简单的例子创建了一个 application 对象用于管理组件。在创建这个对象之后，内部就会创建一个私有的数组 components，然后将一个 BaseComponent 组件的新实例添加到数组中。（BaseComponent 组件的代码并不重要，在这里用它只是为了说明模块模式的用法。）对象字面量中定义的 getComponentCount() 和 registerComponent() 方法都是可以访问 components 私有数组的特权方法。前一个方法返回注册组件的数量，后一个方法负责注册新组件。</p>
<p>在模块模式中，单例对象作为一个模块，经过初始化可以包含某些私有的数据，而这些数据又可以通过其暴露的公共方法来访问。以这种方式创建的每个单例对象都是 Object 的实例，因为最终单例都由一个对象字面量来表示。不过这无关紧要，因为单例对象通常是可以全局访问的，而不是作为参数传给函数的，所以可以避免使用 instanceof 操作符确定参数是不是对象类型的需求。</p>
<h3 id="34-模块增强模式"><a class="header" href="#34-模块增强模式">3.4 模块增强模式</a></h3>
<p>另一个利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景：</p>
<pre><code class="language-js">let singleton = (function () {
  // 私有变量和私有函数
  let privateVariable = 10
  function privateFunction() {
    return false
  }
  // 创建对象
  let object = new CustomType()
  // 添加特权/公有属性和方法
  object.publicProperty = true
  object.publicMethod = function () {
    privateVariable++
    return privateFunction()
  }
  // 返回对象
  return object
})()
</code></pre>
<p>如果前一节的 application 对象必须是 BaseComponent 的实例，那么就可以使用下面的代码来创建它：</p>
<pre><code class="language-js">let application = (function () {
  // 私有变量和私有函数
  let components = new Array()
  // 初始化
  components.push(new BaseComponent())
  // 创建局部变量保存实例
  let app = new BaseComponent()
  // 公共接口
  app.getComponentCount = function () {
    return components.length
  }
  app.registerComponent = function (component) {
    if (typeof component == 'object') {
      components.push(component)
    }
  }
  // 返回实例
  return app
})()
</code></pre>
<p>在这个重写的 application 单例对象的例子中，首先定义了私有变量和私有函数，跟之前例子中一样。主要区别在于这里创建了一个名为 app 的变量，其中保存了 BaseComponent 组件的实例。这是最终要变成 application 的那个对象的局部版本。在给这个局部变量 app 添加了能够访问私有变量的公共方法之后，匿名函数返回了这个对象。然后，这个对象被赋值给 application。</p>
<h3 id="35-私有语法的官方支持"><a class="header" href="#35-私有语法的官方支持">3.5 私有语法的官方支持</a></h3>
<p>在最新的 JS 提案中，可以使用 <code>#</code> 标识变量为私有。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="096-面向对象-三大特性之继承"><a class="header" href="#096-面向对象-三大特性之继承">09.6-面向对象-三大特性之继承</a></h1>
<h2 id="一-继承概念"><a class="header" href="#一-继承概念">一 继承概念</a></h2>
<p>继承是 OO 语言的核心概念，描述了对象与对象之间父子关系，主要作用是提升代码复用性，让代码更为简洁。</p>
<p>继承分为两种继承方式：</p>
<ul>
<li>接口继承：只继承方法签名，继承者自己来实现具体的方法。</li>
<li>实现继承：直接继承父类的方法</li>
</ul>
<p>JS 的函数没有签名，无法实现面向接口编程，JS 的继承主要依赖于原型链实现。</p>
<h2 id="二-基于原型链的继承"><a class="header" href="#二-基于原型链的继承">二 基于原型链的继承</a></h2>
<h3 id="21-基于原型链实现继承"><a class="header" href="#21-基于原型链实现继承">2.1 基于原型链实现继承</a></h3>
<p>继承最常见的实现思路是依赖原型链实现。每个对象的实例都会作为原型链中的一个节点，那么子类对父类的继承其实是依赖于父类的实例：</p>
<pre><code class="language-js">// 父类
function Father(name) {
  this.surname = 'li' // 姓氏
  this.friends = ['a', 'b', 'c']
  this.name = name // 名字
}
Father.prototype.run = function () {
  console.log(`Father: ${this.name} is running...`) // 跑步，可以继承
}

// 子类
function Son(name, age) {
  this.name = name
  this.age = age // 子类自己的成员
}
// 子类继承父类：构建一个父类的实例赋值给子类原型，则子类原型就拥有了所有父类成员
Son.prototype = new Father()
Son.prototype.constructor = Son // 要修改一下原型构造器

Son.prototype.study = function () {
  console.log(`Son: ${this.name} is studying...`) // 子类自己的成员
}

// 测试
let s = new Son('Sum', 30)
console.log(s instanceof Father) // true
console.log(s instanceof Son) // true
console.log(s.surname) // &quot;li&quot;
console.log(s.name) // &quot;Sum&quot;
console.log(s.age) // 30 是自己的属性
s.run() // 直接调用父类方法：Father...
s.study() // 调用自己的方法：Son...
</code></pre>
<p>为什么要使用父类的实例作为子类的原型对象？我们可以考虑下，本质上子类的实例在通过点语法获取成员的时候，类似把原型看做了一个普通对象：</p>
<pre><code class="language-js">let s = new Son('Lisi', 18)
console.log(s.surname) // &quot;li&quot;
// 类似于Son的原型是这样的：
Son.proptotype = {
  surname: 'li',
}

// 我们要实现将Father的所有成员都拷贝到这个原型对象里，又不能对Father构造函数本身造成影响，那么实例是最好的选择
</code></pre>
<p>在上述案例中，虽然完整的实现了继承的各个要素：继承属性、继承方法，但是这里有一个极大的隐患：</p>
<pre><code class="language-js">let s1 = new Son('Sum', 30)
s1.friends.push('d')
console.log(s1.friends) // [ 'a', 'b', 'c', 'd' ]

let s2 = new Son('Kai', 21)
console.log(s2.friends) // [ 'a', 'b', 'c', 'd' ]
</code></pre>
<p>在上述示例中，子类的原型是父类的具体的一个实例，我们发现子类 s1 修改 <strong>引用类属性</strong> 时，另外一个子类 s2 也受到了影响！！！！Son 类的 2 个实例 s1，s2 在调用继承过来的属性时，使用的都是其原型，而其原型恰好是父类的实例。这很显然是致命的错误，这种继承的实现包含 bug 当然是不能正式使用的。</p>
<h3 id="22-最终方案组合继承"><a class="header" href="#22-最终方案组合继承">2.2 最终方案：组合继承</a></h3>
<p><strong>组合继承</strong>即通过对象伪装方式，配合原型链方式形成继承，继而解决基于原型的继承中父类引用类型成员共享的问题。组合继承也称为伪经典继承。</p>
<p>对象伪装（constructor stealing）即在子类构造函数中调用父类构造函数，使用 apply() 或者 call() 方法新建的对象为上下文执行构造函数：</p>
<pre><code class="language-js">// 父类
function Father(name) {
  this.surname = 'li'
  this.friends = ['a', 'b', 'c']
  this.name = name
}
Father.prototype.run = function () {
  console.log(`Father: ${this.name} is running...`)
}

// 子类
function Son(name, age) {
  // 属性继承
  Father.call(this, name)
  // 子类自己的成员
  this.age = age
}
// 子类继承父类
Son.prototype = new Father()
Son.prototype.constructor = Son

Son.prototype.study = function () {
  console.log(`Son: ${this.name} is studying...`)
}

// 测试
let s1 = new Son('Sum', 30)
s1.friends.push('d')
console.log(s1.friends) // [ 'a', 'b', 'c', 'd' ]

let s2 = new Son('Kai', 21)
console.log(s2.friends) // [ 'a', 'b', 'c' ]
</code></pre>
<p>组合继承是 JavaScript 中使用最多的继承模式，也保留了 instanceof 操作符和 isPrototypeOf() 方法识别合成对象的能力。</p>
<p>但是组合继承也有其缺陷：父类构造函数被二次调用了！其优化方式位于后文。</p>
<h2 id="三-基于寄生思想的继承"><a class="header" href="#三-基于寄生思想的继承">三 基于寄生思想的继承</a></h2>
<h3 id="31-原型式继承与-objectcreate"><a class="header" href="#31-原型式继承与-objectcreate">3.1 原型式继承与 Object.create()</a></h3>
<p>2006 年，道格拉斯· 克罗克福德在他的文章中红描述了一种继承方法：原型式继承：</p>
<pre><code class="language-js">// 参数必须是实例
function inherit(obj) {
  function F() {} // 首先创建一个临时构造函数
  F.prototype = obj
  return new F() // 返回该临时构造函数的实例
}

// 只能以如下方式继承一个对象
let father = {
  name: 'father',
  age: 50,
  friends: ['a', 'b', 'c'],
  sayName: function () {
    console.log(this.name)
  },
}
// 所有成员都被继承到了
let son = inherit(father)
console.log(son.name) // father
console.log(son.age) // 50
son.sayName() // father

// 构造器来自于Object
console.log(son.constructor) // Object() { [native code] }

// 如果修改继承自父类的引用类型属性，会影响到父类
son.friends.push('d')
console.log(father.friends) // [ 'a', 'b', 'c', 'd' ]
</code></pre>
<p>其实这是对 2.1 中原型链继承写法的变种，只是在继承函数 inherit() 内部没有类似这样一句话： <code>F.prototype.constructor = F</code>。这种实现方式与 2.1 的对比，思路完全不一样，它基于已有的对象创建新对象，同时还不必因此创建自定义类型，简单优雅。</p>
<p>ES5 基于上述思想提供了<code>Object.create()</code>函数规范了原型式继承方式：</p>
<pre><code class="language-js">// 父类
let father = {
  surename: 'li',
  friends: ['a', 'b', 'c'],
  run: function () {
    console.log('Father run...')
  },
}

// 子对象
let son = Object.create(father)
console.log(son.friends) //  [ 'a', 'b', 'c' ]
son.run() //  Father run...

// 再建一个子对象
let other = Object.create(father)
other.friends.push('d')

// 查看原有子对象、父级对象的friends
console.log(son.friends) // 已被修改：[ 'a', 'b', 'c', 'd' ]
console.log(father.friends) // 已被修改：[ 'a', 'b', 'c', 'd' ]
</code></pre>
<p>这种基于 Object.create 的方式，适合不使用麻烦的构造函数场景，但是要注意的是：原型式继承、寄生式继承，其父类的引用类型是会被共享的，笔者认为这在正常的项目中完全不可行！</p>
<p>同样，该方案由于和原型链继承中核心代码一致，也导致了这个问题：修改继承自父类的引用类型属性，会影响到父类。</p>
<h3 id="32-寄生式继承"><a class="header" href="#32-寄生式继承">3.2 寄生式继承</a></h3>
<p>与原型式继承比较接近的一种继承方式是寄生式继承（ parasitic inheritance），也是 Crockford 首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象：</p>
<pre><code class="language-js">function inherit(obj) {
  let clone = Object.create(obj)
  obj.sayHi = function () {
    console.log('hi...')
  }
  return clone
}
</code></pre>
<p>该工厂函数虽然解决了子级对象自定义属性的问题，但是创建多了多少个对象，则方法也被维护了多少份，所以存在两个致命缺陷：</p>
<ul>
<li>被继承对象的成员如果是引用类型，则互相修改会影响对方，子级对象修改自身引用类型也会影响其他子类</li>
<li>创建了多少个对象，方法也被维护了多少份，方法并未被重用</li>
</ul>
<h2 id="四-继承最终方案寄生组合式继承"><a class="header" href="#四-继承最终方案寄生组合式继承">四 继承最终方案：寄生组合式继承</a></h2>
<p>在 02.2 继承章节中，继承的最终版是组合式继承，但是该继承其实也有一个缺陷：父类构造函数的二次调用</p>
<pre><code class="language-js">// 父类
function Father() {
  this.surname = 'li'
  this.age = 30
  this.friends = ['a', 'b', 'c']
}

Father.prototype.run = function () {
  console.log('Father run...')
}

// 子类
function Son() {
  Father.call(this) // 第二次调用 Father
  this.age = 5
}

// 第一次调用：Father()
Son.prototype = new Father()
</code></pre>
<p>所谓寄生组合式继承，即不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。实现思路：</p>
<ul>
<li>通过构造函数来继承属性，解决引用类型属性修改后父类、子类互相影响的问题</li>
<li>通过原型链的混成形式来继承方法，解决构造函数被二次调用问题</li>
</ul>
<pre><code class="language-js">// 父类
function Father(name) {
  this.surname = 'li' // 姓氏
  this.friends = ['a', 'b', 'c']
  this.name = name // 名字
}
Father.prototype.run = function () {
  console.log(`Father: ${this.name} is running...`) // 跑步，可以继承
}

// 子类构造函数：用来继承属性
function Son(name, age) {
  // 属性继承
  Father.call(this, name)
  // 子类自己的成员
  this.age = age
}

// 子类原型：用来继承公用成员，如方法
// 这里不能直接写为：Son.prototype=Father.prototype，因为修改子类 prototype 会影响父类
Son.prototype = Object.create(Father.prototype) // create()内部临时创建了一个F()，避免了父类构造函数被调用2次
Son.prototype.constructor = Son
// 子类自定义
Son.prototype.study = function () {
  console.log(`Son: ${this.name} is studying...`) // 子类自己的成员
}

// 测试
let s = new Son('Sum', 30)
console.log(s instanceof Father) // true
console.log(s instanceof Son) // true
console.log(s.surname) // &quot;li&quot;
console.log(s.name) // &quot;Sum&quot;
console.log(s.age) // 30 是自己的属性
s.run() // 直接调用父类方法：Father...
s.study() // 调用自己的方法：Son...
</code></pre>
<p>这里只调用了一次父类构造函数，而且原型链仍然保持不变，因此 instanceof 操作符和 isPrototypeOf() 方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。</p>
<h2 id="五-es6-中的继承"><a class="header" href="#五-es6-中的继承">五 ES6 中的继承</a></h2>
<h3 id="51-继承关键字-extends"><a class="header" href="#51-继承关键字-extends">5.1 继承关键字 extends</a></h3>
<p>ECMAScript 6 新增特性中最出色的一个就是原生支持了类继承机制，其原理依旧使用的是原型链。</p>
<p>ES6 的继承通过 extends 关键字实现，可以继承任何拥有 <code>[[Construct]]</code> 和原型的对象</p>
<pre><code class="language-js">class Father {
  constructor(name) {
    this.name = name
  }
  surname = 'li'
  friends = ['a', 'b', 'c']
  run() {
    console.log(`Father: ${this.name} is running...`)
  }
}

class Son extends Father {
  constructor(name, age) {
    super(name)
    this.age = age
  }
  study() {
    console.log(`Son: ${this.name} is studying...`)
  }
}

// 测试
let s = new Son('Sum', 30)
console.log(s instanceof Father) // true
console.log(s instanceof Son) // true
console.log(s.surname) // &quot;li&quot;
console.log(s.name) // &quot;Sum&quot;
console.log(s.age) // 30 是自己的属性
s.run() // 直接调用父类方法：Father...
s.study() // 调用自己的方法：Son...
</code></pre>
<p>贴士：为了向后兼容，extends 也是可以直接继承普通构造函数的：</p>
<pre><code class="language-js">class Vehicle {}

// 继承类
class Bus extends Vehicle {}
let b = new Bus()
console.log(b instanceof Bus) // true
console.log(b instanceof Vehicle) // true

function Person() {}
// 继承普通构造函数
class Engineer extends Person {}
let e = new Engineer()
console.log(e instanceof Engineer) // true
console.log(e instanceof Person) // true
</code></pre>
<h3 id="52-super"><a class="header" href="#52-super">5.2 super()</a></h3>
<p>在类构造函数中使用 super 可以调用父类构造函数。派生类的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。</p>
<p>注意：ES6 给类构造函数和静态方法添加了内部特性<code>[[HomeObject]]</code>，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在 JavaScript 引擎内部访问。super 始终会定义为<code>[[HomeObject]]</code>的原型。</p>
<p>在 constructor() 内调用 super() 会调用父类构造函数，并将返回的实例赋值给 this：</p>
<pre><code class="language-js">class Vehicle {}

class Bus extends Vehicle {
  constructor() {
    // 不能在调用 super() 之前引用 this
    super() // 相当于 super.constructor()
    console.log(this instanceof Vehicle)
  }
}
</code></pre>
<p>如果父类构造方法可以传参，则子类调用 super 可以手动传入：</p>
<pre><code class="language-js">class Vehicle {
  constructor(licensePlate) {
    this.licensePlate = licensePlate
  }
}
class Bus extends Vehicle {
  constructor(licensePlate) {
    super(licensePlate)
  }
}
console.log(new Bus('1337H4X')) // Bus { licensePlate: '1337H4X' }
</code></pre>
<p>即使没有定义类构造函数，在实例化派生类时也会调用 super()，而且会传入所有传给派生类的参数：</p>
<pre><code class="language-js">class Vehicle {
  constructor(licensePlate) {
    this.licensePlate = licensePlate
  }
}

class Bus extends Vehicle {}

console.log(new Bus('1337H4X')) // Bus { licensePlate: '1337H4X' }
</code></pre>
<p>如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象：</p>
<pre><code class="language-js">class Vehicle {}
class Car extends Vehicle {}
class Bus extends Vehicle {
  constructor() {
    super()
  }
}
class Van extends Vehicle {
  constructor() {
    return {}
  }
}
console.log(new Car()) // Car {}
console.log(new Bus()) // Bus {}
console.log(new Van()) // {}
</code></pre>
<p>在静态方法中可以通过 super 调用继承的类上定义的静态方法：</p>
<pre><code class="language-js">class Vehicle {
  static identify() {
    console.log('vehicle')
  }
}
class Bus extends Vehicle {
  static identify() {
    super.identify()
  }
}
Bus.identify() // vehicle
</code></pre>
<h3 id="53-抽象类"><a class="header" href="#53-抽象类">5.3 抽象类</a></h3>
<p>抽象类即：本身不会被实例化的类，专门用于提供给其他类来继承，ECMAScript 目前不支持抽象类，但通过 new.target 也很容易实现：</p>
<pre><code class="language-js">//  抽象类
class Vehicle {
  constructor() {
    // 在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化
    if (new.target === Vehicle) {
      throw new Error('Vehicle cannot be directly instantiated')
    }
  }
}

// 派生类
class Bus extends Vehicle {}
new Bus() // class Bus {}
new Vehicle() // Error: Vehicle cannot be directly instantiated
</code></pre>
<p>抽象类的主要作用是限制派生类必须定义某个方法，在抽象类的构造函数中可以进行检查：</p>
<pre><code class="language-js">// 抽象基类
class Vehicle {
  constructor() {
    if (new.target === Vehicle) {
      throw new Error('Vehicle cannot be directly instantiated')
    }
    if (!this.foo) {
      throw new Error('Inheriting class must define foo()')
    }
    console.log('success!')
  }
}

// 派生类
class Bus extends Vehicle {
  foo() {}
}

// 派生类
class Van extends Vehicle {}
new Bus() // success!
new Van() // Error: Inheriting class must define foo()
</code></pre>
<h3 id="54-继承内置类型"><a class="header" href="#54-继承内置类型">5.4 继承内置类型</a></h3>
<p>ES6 继承内置类型很方便：</p>
<pre><code class="language-js">class SuperArray extends Array {
  shuffle() {
    // 洗牌算法
    for (let i = this.length - 1; i &gt; 0; i--) {
      const j = Math.floor(Math.random() * (i + 1))
      ;[this[i], this[j]] = [this[j], this[i]]
    }
  }
}
let a = new SuperArray(1, 2, 3, 4, 5)
console.log(a instanceof Array) // true
console.log(a instanceof SuperArray) // true
console.log(a) // [1, 2, 3, 4, 5]
a.shuffle()
console.log(a) // [3, 1, 4, 5, 2]
</code></pre>
<p>有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原始实例的类型是一致的：</p>
<pre><code class="language-js">class SuperArray extends Array {}
let a1 = new SuperArray(1, 2, 3, 4, 5)
let a2 = a1.filter((x) =&gt; !!(x % 2))
console.log(a1) // [1, 2, 3, 4, 5]
console.log(a2) // [1, 3, 5]
console.log(a1 instanceof SuperArray) // true
console.log(a2 instanceof SuperArray) // true
</code></pre>
<p>如果想覆盖这个默认行为，则可以覆盖 Symbol.species 访问器，这个访问器决定在创建返回的实例时使用的类：</p>
<pre><code class="language-js">class SuperArray extends Array {
  static get [Symbol.species]() {
    return Array
  }
}
let a1 = new SuperArray(1, 2, 3, 4, 5)
let a2 = a1.filter((x) =&gt; !!(x % 2))
console.log(a1) // [1, 2, 3, 4, 5]
console.log(a2) // [1, 3, 5]
console.log(a1 instanceof SuperArray) // true
console.log(a2 instanceof SuperArray) // false
</code></pre>
<h3 id="55-类混入"><a class="header" href="#55-类混入">5.5 类混入</a></h3>
<p>类混入，即：把不同类的行为集中到一个类的 JavaScript 模式，类似多继承机制。ES6 支持度有限，Object.assign()方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用 Object.assign()就可以了。</p>
<p>很多 JavaScript 框架（特别是 React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（ composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="097-面向对象-三大特性之-多态"><a class="header" href="#097-面向对象-三大特性之-多态">09.7-面向对象-三大特性之-多态</a></h1>
<h2 id="一-多态概念"><a class="header" href="#一-多态概念">一 多态概念</a></h2>
<p>在现实生活中，鸟类都会鸣叫，但是不同的鸟类叫声不同，现在我们获取到了一个鸟类，要听其声音，运用到编程中应该是：</p>
<pre><code class="language-js">鸟.叫()
</code></pre>
<p>现在的问题是：鸟到底要以哪种具体的实际形态来发出声音呢？当然是鸟的真实类型，比如鸡发出 咯咯咯、鸭发出嘎嘎嘎。</p>
<p>在面向对象中，对象往往有多种不同的具体表现形式，这种<strong>父类引用指向子类对象</strong>的概念叫做多态。</p>
<h2 id="二-多态的实现"><a class="header" href="#二-多态的实现">二 多态的实现</a></h2>
<h3 id="21-java-中的多态"><a class="header" href="#21-java-中的多态">2.1 Java 中的多态</a></h3>
<p>首先看 Java 中的多态：</p>
<pre><code class="language-java">// 抽象公共类
abstract class Animal {
    abstract void makeSound();          // 抽象方法
}

// 鸡类：继承自动物类
class Chicken extends Animal {
    public void makeSound(){
        System.out.println(&quot;咯咯咯&quot;);
    }
}

// 鸭子类：继承自动物类
class Duck extends Animal {
    public void makeSound(){
        System.out.println(&quot;嘎嘎嘎&quot;);
    }
}

class Test {
    public static void main(String[]args){

        Animal duck = new Duck();       // 创建动物类型 duck，但是实现方式是 Duck()
        Animal chick = new Chicken();  // 创建动物类型 chick，但是实现方式是 Chicken()

        duck.makeSound();               // 嘎嘎嘎
        chick.makeSound();              // 咯咯咯

    }
}
</code></pre>
<h3 id="22-js-模拟多态"><a class="header" href="#22-js-模拟多态">2.2 js 模拟多态</a></h3>
<p>Java 中通过向上转型，天生就可以实现多态，而 js 的变量是运行期可变的，一个 js 对象既可以表示 Duck 类型，也可以表示 Chicken 类型，所以 JS 的只能模拟多态：</p>
<pre><code class="language-js">function MakeSound(animal) {
  animal.sound()
}

let Duck = function () {}
Duck.prototype.sound = function () {
  console.log('嘎嘎嘎')
}

let Chiken = function () {}
Chiken.prototype.sound = function () {
  console.log('咯咯咯')
}

MakeSound(new Chicken())
MakeSound(new Duck())
</code></pre>
<h3 id="23-多态的作用"><a class="header" href="#23-多态的作用">2.3 多态的作用</a></h3>
<blockquote>
<p>《重构》：多态的最根本好处在于，你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。</p>
</blockquote>
<p>从上 2.2 示例看出，多态的思想实际上是把 “做什么” 和 “谁去做” 分离了开来，消除了类型之间的耦合关系。所以本质上多态也是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。</p>
<p>假设我们要编写一个地图应用，现在有两家可选的地图 API 提供商供我们接入自己的应用。目前我们选择的是谷歌地图，谷歌地图的 API 中提供了 show 方法，负责在页面上展示整个地图。示例代码如下：</p>
<pre><code class="language-js">const googleMap = {
  show: function () {
    console.log('开始渲染谷歌地图')
  },
}
const renderMap = function () {
  googleMap.show()
}
renderMap() // 输出：开始渲染谷歌地图
</code></pre>
<p>后来因为某些原因，要把谷歌地图换成百度地图，为了让 renderMap 函数保持一定的弹性，我们用一些条件分支来让 renderMap 函数同时支持谷歌地图和百度地图：</p>
<pre><code class="language-js">const googleMap = {
  show: function () {
    console.log('开始渲染谷歌地图')
  },
}

const baiduMap = {
  show: function () {
    console.log('开始渲染百度地图')
  },
}

const renderMap = function (type) {
  if (type === 'google') {
    googleMap.show()
  } else if (type === 'baidu') {
    baiduMap.show()
  }
}
renderMap('google') // 输出：开始渲染谷歌地图
renderMap('baidu') // 输出：开始渲染百度地图
</code></pre>
<p>可以看到，虽然 renderMap 函数目前保持了一定的弹性，但这种弹性是很脆弱的，一旦需要替换成搜搜地图，那无疑必须得改动 renderMap 函数，继续往里面堆砌条件分支语句。我们还是先把程序中相同的部分抽象出来，那就是显示某个地图：</p>
<pre><code class="language-js">const renderMap = function (map) {
  if (map.show instanceof Function) {
    map.show()
  }
}

renderMap(googleMap) // 输出：开始渲染谷歌地图
renderMap(baiduMap) // 输出：开始渲染百度地图
</code></pre>
<p>现在来找找这段代码中的多态性。当我们向谷歌地图对象和百度地图对象分别发出“展示地图”的消息时，会分别调用它们的 show 方法，就会产生各自不同的执行结果。对象的多态性提示我们，“做什么”和“怎么去做”是可以分开的，即使以后增加了搜搜地图， renderMap 函数仍然不需要做任何改变，如下所示：</p>
<pre><code class="language-js">const sosoMap = {
  show: function () {
    console.log('开始渲染搜搜地图')
  },
}
renderMap(sosoMap) // 输出：开始渲染搜搜地图
</code></pre>
<p>在这个例子中，我们假设每个地图 API 提供展示地图的方法名都是 show，在实际开发中也许不会如此顺利，这时候可以借助适配器模式来解决问题。</p>
<h2 id="三-抽象基类"><a class="header" href="#三-抽象基类">三 抽象基类</a></h2>
<p>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 ECMAScript 没有专门支持这种类的语法，但通过 new.target 也很容易实现。new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化：</p>
<pre><code class="language-js">// 抽象基类
class Vehicle {
  constructor() {
    console.log(new.target)
    if (new.target === Vehicle) {
      throw new Error('Vehicle cannot be directly instantiated')
    }
  }
}

// 派生类
class Bus extends Vehicle {}

new Bus() // class Bus {}
// new Vehicle() // Error: Vehicle cannot be directly instantiated
</code></pre>
<p>通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法：</p>
<pre><code class="language-js">// 抽象基类
class Vehicle {
  constructor() {
    if (new.target === Vehicle) {
      throw new Error('Vehicle cannot be directly instantiated')
    }
    if (!this.foo) {
      throw new Error('Inheriting class must define foo()')
    }
    console.log('success!')
  }
}

// 派生类
class Bus extends Vehicle {
  foo() {}
}

// 派生类
class Van extends Vehicle {}

new Bus() // success!
new Van() // Error: Inheriting class must define foo()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="101-常用内置对象-基本包装类"><a class="header" href="#101-常用内置对象-基本包装类">10.1-常用内置对象-基本包装类</a></h1>
<h2 id="一-基本包装类型概念"><a class="header" href="#一-基本包装类型概念">一 基本包装类型概念</a></h2>
<p>字符串不是对象，但是字符串仍然能像对象那样利用点语法来调用方法。这是因为 JS 会通过 <code>new String(str)</code>来将字符串包装为对象，这个新的对象继承了字符串的方法。</p>
<pre><code class="language-js">let str = 'hello' // 内部进行了包装：str = new String(&quot;hello&quot;);
console.log(s.substring(2))
</code></pre>
<p>为了方便操作基本数据类型，ECMAScript 共提供了 3 个特殊的类，用来包装基本类型：Boolean、Number、String。</p>
<p>在包装对象后，一旦属性引用结束，那么包装的对象就会被销毁：</p>
<pre><code class="language-js">let str = 'test'
str.len = 4 // 给其设置一个属性
console.log(str.len) // undefined 此时对象已经被销毁了
</code></pre>
<p>Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例：</p>
<pre><code class="language-js">let obj = new Object('some text')
console.log(obj instanceof String) // true
</code></pre>
<p>注意：使用 new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样：</p>
<pre><code class="language-js">let value = '25'
let number = Number(value) // 转型函数
console.log(typeof number) // &quot;number&quot;
let obj = new Number(value) // 构造函数
console.log(typeof obj) // &quot;object&quot;
</code></pre>
<h2 id="二-基本包装类boolean"><a class="header" href="#二-基本包装类boolean">二 基本包装类：Boolean</a></h2>
<p>Boolean 对象示例：</p>
<pre><code class="language-js">let trueObj = new Boolean(true)
console.log(typeof trueObj) // object，因为现在这个变量被包装为了引用类型

let flag = trueObj &amp;&amp; true
console.log(flag) // true
</code></pre>
<p>Boolean 类型的实例重写了 valueOf() 方法，返回基本类型值 true 或 false，同样重写了 toString() 方法，返回字符串&quot;true&quot;和&quot;false&quot;，它经常会造成人们的误解，<strong>推荐绝不使用该对象</strong>！</p>
<pre><code class="language-js">let falseObject = new Boolean(false)
let result = falseObject &amp;&amp; true
console.log(result) // true

let falseValue = false
result = falseValue &amp;&amp; true
console.log(result) // false
</code></pre>
<p>除此之外，原始值和引用值（ Boolean 对象）还有几个区别。首先， typeof 操作符对原始值返回&quot;boolean&quot;，但对引用值返回&quot;object&quot;。同样， Boolean 对象是 Boolean 类型的实例，在使用 instaceof 操作符时返回 true，但对原始值则返回 false，如下所示：</p>
<pre><code class="language-js">console.log(typeof falseObject) // object
console.log(typeof falseValue) // boolean
console.log(falseObject instanceof Boolean) // true
console.log(falseValue instanceof Boolean) // false
</code></pre>
<p>再次强调：<strong>推荐绝不使用该对象</strong>！</p>
<h2 id="三-基本包装类number"><a class="header" href="#三-基本包装类number">三 基本包装类：Number</a></h2>
<h3 id="31-number-类的基本使用"><a class="header" href="#31-number-类的基本使用">3.1 Number 类的基本使用</a></h3>
<p>由于数字支持基本包装类 Number，所以声明的数字也可以直接调用一些方法：</p>
<pre><code class="language-js">let num = 10
console.log(num.toString()) //&quot;10&quot;
console.log(num.toString(2)) //&quot;1010&quot;
console.log(num.toString(8)) //&quot;12&quot;
console.log(num.toString(10)) //&quot;10&quot;
console.log(num.toString(16)) //&quot;a&quot;
</code></pre>
<p>Number 类型也重写了 valueOf()、toLocaleString() 和 toString() 方法。重写后的 valueOf() 方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。</p>
<p>直接声明一个 Number 类型对象：</p>
<pre><code class="language-js">let numObj = new Number(10)
console.log(typeof numObj) // object
console.log(numObj.toString()) // &quot;10&quot;
</code></pre>
<h3 id="32-fixed-自动摄入"><a class="header" href="#32-fixed-自动摄入">3.2 fixed() 自动摄入</a></h3>
<p>除了继承的方法之外，Number 类型还提供了一些用于将数值格式化为字符串的方法。其中，toFixed() 方法会按照指定的小数位返回数值的字符串表示：</p>
<pre><code class="language-js">let num = 10
console.log(num.toFixed(2)) //&quot;10.00&quot;

let num2 = 10.005
console.log(num2.toFixed(2)) //&quot;10.01&quot;
</code></pre>
<p>不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，</p>
<pre><code class="language-txt">0.1 + 0.2 = 0.30000000000000004
</code></pre>
<p>另一个用于格式化数值的方法是 toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串。与 toFixed()一样， toExponential()也接收一个参数，表示结果中小数的位数：</p>
<pre><code class="language-js">let num = 10
console.log(num.toExponential(1)) // &quot;1.0e+1&quot;
</code></pre>
<p>一般来说，这么小的数不用表示为科学记数法形式。如果想得到数值最适当的形式，那么可以使用 toPrecision()，该方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）：</p>
<pre><code class="language-js">let num = 99
console.log(num.toPrecision(1)) // &quot;1e+2&quot;
console.log(num.toPrecision(2)) // &quot;99&quot;
console.log(num.toPrecision(3)) // &quot;99.0&quot;
</code></pre>
<p>在这个例子中，首先要用 1 位数字表示数值 99，得到&quot;1e+2&quot;，也就是 100。因为 99 不能只用 1 位数字来精确表示，所以这个方法就将它舍入为 100，这样就可以只用 1 位数字（及其科学记数法形式）来表示了。用 2 位数字表示 99 得到&quot;99&quot;，用 3 位数字则是&quot;99.0&quot;。本质上， toPrecision()方法会</p>
<p>根据数值和精度来决定调用 toFixed()还是 toExponential()。为了以正确的小数位精确表示数值，这 3 个方法都会向上或向下舍入。</p>
<h3 id="33-isinteger-类型推断"><a class="header" href="#33-isinteger-类型推断">3.3 isInteger() 类型推断</a></h3>
<p>Number 与 Boolean 对象存在同样的问题，因此并不建议直接实例化 Number 对象。在处理原始数值和引用数值时， typeof 和 instacnceof 操作符会返回不同的结果，如下所示：</p>
<pre><code class="language-js">let numberObject = new Number(10)
let numberValue = 10

// 原始数值在调用 typeof 时始终返回&quot;number&quot;，而 Number 对象则返回&quot;object&quot;。
console.log(typeof numberObject) // &quot;object&quot;
console.log(typeof numberValue) // &quot;number&quot;

// 类似地， Number对象是 Number 类型的实例，而原始数值不是
console.log(numberObject instanceof Number) // true
console.log(numberValue instanceof Number) // false
</code></pre>
<p>ES6 额外提供了 isInteger() 方法用来辨别一个数值是否被保存为了整数：</p>
<pre><code class="language-js">console.log(Number.isInteger(1)) // true
console.log(Number.isInteger(1.0)) // true
console.log(Number.isInteger(1.01)) // false
</code></pre>
<p>IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。对超出这个范围的数值，即使尝试保存为整数， IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用 Number.isSafeInteger()方法：</p>
<pre><code class="language-js">console.log(Number.isSafeInteger(-1 * 2 ** 53)) // false
console.log(Number.isSafeInteger(-1 * 2 ** 53 + 1)) // true
console.log(Number.isSafeInteger(2 ** 53)) // false
console.log(Number.isSafeInteger(2 ** 53 - 1)) // true
</code></pre>
<h2 id="四-对象序列化"><a class="header" href="#四-对象序列化">四 对象序列化</a></h2>
<p>对象序列化（serialization）即将对象的状态转换为字符串。ES5 提供了<code>JSON.stringify()</code>和<code>JSON.parse()</code>分别序列化、反序列化 js 对象。
均使用 JSON 作为数据交换格式（JavaScript Object Notation），JSON 是 js 对象表示法，语法与 js 相近。</p>
<p>注意：</p>
<ul>
<li>NaN、Infinity、-Infinity 序列化的结构都是 null</li>
<li>日期对象序列化结果是 ISO 格式的日期字符串，且 JSON.parse() 也仍然会保留字符串形态，不会还原为日期对象</li>
<li>函数、RegExp、Error、undefined 都不能序列化和还原</li>
<li>JSON.stringif() 只能序列化对象的可枚举自有属性</li>
<li>这 2 个函数都可以接收第二个可选参数，传入需要序列化、还原的属性列表自定义操作</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="102-常用内置对象-基本包装类-string"><a class="header" href="#102-常用内置对象-基本包装类-string">10.2-常用内置对象-基本包装类 String</a></h1>
<h2 id="一-string-类的基本使用"><a class="header" href="#一-string-类的基本使用">一 String 类的基本使用</a></h2>
<p>每个 String 对象都在其原始值上拥有 length 属性，同样也有继承过来的<code>valueOf()</code>、<code>toString()</code>、<code>toLocalString()</code>：</p>
<pre><code class="language-js">// 字面量方式
let str = 'hello world'
console.log(str.length) // 11

// 也可以使用构造函数直接创建一个 String 对象：
let str2 = new String('hello world')
</code></pre>
<h3 id="二-string-字符串存储"><a class="header" href="#二-string-字符串存储">二 String 字符串存储</a></h3>
<h3 id="21-查看指定码元的字符编码"><a class="header" href="#21-查看指定码元的字符编码">2.1 查看指定码元的字符编码</a></h3>
<p>JavaScript 字符串由 16 位码元（ code unit）组成。对多数字符来说，每 16 位码元对应一个字符，即字符串的 length 属性表示字符串包含多少 16 位码元。charAt()方法可以查找指定索引位置的 16 位码元，并返回该码元对应的字符：</p>
<pre><code class="language-js">let str = 'hello world!'

// 通过索引获取对应字符
console.log(str.charAt(2)) // l
console.log(str[2]) // l

// 通过索引获取对应字符的 ASCII 码
console.log(str.charCodeAt(2)) // 108,ASCII 码中对应 l

// 通过 ASCII 码创建字符串
console.log(String.fromCharCode(108)) // l
</code></pre>
<p>使用 charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。比如：</p>
<pre><code class="language-js">let message = 'abcde'
// Unicode &quot;Latin small letter C&quot;的编码是 U+0063
console.log(message.charCodeAt(2)) // 99
// 十进制 99 等于十六进制 63
console.log(99 === 0x63) // true
</code></pre>
<p>fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串：</p>
<pre><code class="language-js">// Unicode &quot;Latin small letter A&quot;的编码是 U+0061
// Unicode &quot;Latin small letter B&quot;的编码是 U+0062
// Unicode &quot;Latin small letter C&quot;的编码是 U+0063
// Unicode &quot;Latin small letter D&quot;的编码是 U+0064
// Unicode &quot;Latin small letter E&quot;的编码是 U+0065
console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)) // &quot;abcde&quot;
// 0x0061 === 97
// 0x0062 === 98
// 0x0063 === 99
// 0x0064 === 100
// 0x0065 === 101
console.log(String.fromCharCode(97, 98, 99, 100, 101)) // &quot;abcde&quot;
</code></pre>
<h3 id="22-代理对"><a class="header" href="#22-代理对">2.2 代理对</a></h3>
<p>对于 U+0000~U+FFFF 范围内的字符， length、 charAt()、 charCodeAt()和 fromCharCode()返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用 16 位表示的，而这几个方法也都基于 16 位码元完成操作。这个对应关系在扩展到 Unicode 增补字符平面时就不成立了。问题很简单，即 16 位只能唯一表示 65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面（ BMP）。为了表示更多的字符， Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为代理对：</p>
<pre><code class="language-js">// &quot;smiling face with smiling eyes&quot; 表情符号的编码是 U+1F60A
// 0x1F60A === 128522
let message = 'ab☺de'
console.log(message.length) // 6
console.log(message.charAt(1)) // b
console.log(message.charAt(2)) // &lt;?&gt;
console.log(message.charAt(3)) // &lt;?&gt;
console.log(message.charAt(4)) // d
console.log(message.charCodeAt(1)) // 98
console.log(message.charCodeAt(2)) // 55357
console.log(message.charCodeAt(3)) // 56842
console.log(message.charCodeAt(4)) // 100
console.log(String.fromCodePoint(0x1f60a)) // ☺
console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab☺de
</code></pre>
<p>这些方法仍然将 16 位码元当作一个字符，事实上索引 2 和索引 3 对应的码元应该被看成一个代理对，只对应一个字符。 fromCharCode()方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对（由两个码元构成），并正确地将其识别为一个 Unicode 笑脸字符。</p>
<p>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 codePointAt()来代替 charCodeAt()。跟使用 charCodeAt()时类似， codePointAt()接收 16 位码元的索引并返回该索引位置上的码点（ code point）。 码点是 Unicode 中一个字符的完整标识。比如， &quot;c&quot;的码点是 0x0063，而&quot;☺&quot;的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位，而 codePointAt()方法可以从指定码元位置识别完整的码点。</p>
<pre><code class="language-js">let message = 'ab☺de'
console.log(message.codePointAt(1)) // 98
console.log(message.codePointAt(2)) // 128522
console.log(message.codePointAt(3)) // 56842
console.log(message.codePointAt(4)) // 100
</code></pre>
<p>注意，如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字符的时候才会出现，可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别代理对的码点：</p>
<pre><code class="language-js">console.log([...'ab☺de']) // [&quot;a&quot;, &quot;b&quot;, &quot;☺&quot;, &quot;d&quot;, &quot;e&quot;]
</code></pre>
<p>与 charCodeAt()有对应的 codePointAt()一样， fromCharCode()也有一个对应的 fromCodePoint()。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串：</p>
<pre><code class="language-js">console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)) // ab☺de
console.log(String.fromCodePoint(97, 98, 128522, 100, 101)) // ab☺de
</code></pre>
<h3 id="23-normalize方法"><a class="header" href="#23-normalize方法">2.3 normalize()方法</a></h3>
<p>某些 Unicode 字符可以有多种编码方式。有的字符既可以通过一个 BMP 字符表示，也可以通过一个代理对表示。比如：</p>
<pre><code class="language-js">// U+00C5：上面带圆圈的大写拉丁字母 A
console.log(String.fromCharCode(0x00c5)) // Å
// U+212B：长度单位“埃”
console.log(String.fromCharCode(0x212b)) // Å
// U+004：大写拉丁字母 A
// U+030A：上面加个圆圈
console.log(String.fromCharCode(0x0041, 0x030a)) // Å
</code></pre>
<p>比较操作符不在乎字符看起来是什么样的，因此这 3 个字符互不相等。</p>
<pre><code class="language-js">let a1 = String.fromCharCode(0x00c5),
  a2 = String.fromCharCode(0x212b),
  a3 = String.fromCharCode(0x0041, 0x030a)
console.log(a1, a2, a3) // Å, Å, Å
console.log(a1 === a2) // false
console.log(a1 === a3) // false
console.log(a2 === a3) // false
</code></pre>
<p>为解决这个问题， Unicode 提供了 4 种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这 4 种规范化形式是： NFD（ Normalization Form D）、 NFC（ Normalization Form C）、NFKD（ Normalization Form KD）和 NFKC（ Normalization Form KC）。可以使用 normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串： &quot;NFD&quot;、 &quot;NFC&quot;、 &quot;NFKD&quot;或&quot;NFKC&quot;。</p>
<p>通过比较字符串与其调用 normalize()的返回值，就可以知道该字符串是否已经规范化了：</p>
<pre><code class="language-js">let a1 = String.fromCharCode(0x00c5),
  a2 = String.fromCharCode(0x212b),
  a3 = String.fromCharCode(0x0041, 0x030a)
// U+00C5 是对 0+212B 进行 NFC/NFKC 规范化之后的结果
console.log(a1 === a1.normalize('NFD')) // false
console.log(a1 === a1.normalize('NFC')) // true
console.log(a1 === a1.normalize('NFKD')) // false
console.log(a1 === a1.normalize('NFKC')) // true
// U+212B 是未规范化的
console.log(a2 === a2.normalize('NFD')) // false
console.log(a2 === a2.normalize('NFC')) // false
console.log(a2 === a2.normalize('NFKD')) // false
console.log(a2 === a2.normalize('NFKC')) // false
// U+0041/U+030A 是对 0+212B 进行 NFD/NFKD 规范化之后的结果
console.log(a3 === a3.normalize('NFD')) // true
console.log(a3 === a3.normalize('NFC')) // false
console.log(a3 === a3.normalize('NFKD')) // true
console.log(a3 === a3.normalize('NFKC')) // false
</code></pre>
<p>选择同一种规范化形式可以让比较操作符返回正确的结果：</p>
<pre><code class="language-js">let a1 = String.fromCharCode(0x00c5),
  a2 = String.fromCharCode(0x212b),
  a3 = String.fromCharCode(0x0041, 0x030a)
console.log(a1.normalize('NFD') === a2.normalize('NFD')) // true
console.log(a2.normalize('NFKC') === a3.normalize('NFKC')) // true
console.log(a1.normalize('NFC') === a3.normalize('NFC')) // true
</code></pre>
<h2 id="三-字符串操作方法"><a class="header" href="#三-字符串操作方法">三 字符串操作方法</a></h2>
<h3 id="31-字符串拼接-concat"><a class="header" href="#31-字符串拼接-concat">3.1 字符串拼接 concat()</a></h3>
<pre><code class="language-js">let str1 = 'hello'
let str2 = 'world!'

// 拼接方式一
let str = str1 + ' ' + str2
console.log(str) // hello world!

// 拼接方式二
str = str1.concat(' ').concat(str2)
console.log(str) // hello world!
</code></pre>
<p>concat()方法可以接收任意多个参数，因此可以一次性拼接多个字符串：</p>
<pre><code class="language-js">let stringValue = 'hello '
let result = stringValue.concat('world', '!')
console.log(result) // &quot;hello world!&quot;
console.log(stringValue) // &quot;hello&quot;
</code></pre>
<h3 id="32-字符串提取-slice-substr和-substring"><a class="header" href="#32-字符串提取-slice-substr和-substring">3.2 字符串提取 slice()、 substr()和 substring()</a></h3>
<p>ECMAScript 提供了 3 个从字符串中提取子字符串的方法： slice()、 substr()和 substring()。这 3 个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数：</p>
<ul>
<li>第一个参数表示子字符串开始的位置</li>
<li>第二个参数表示子字符串结束的位置。</li>
<li>对 slice()和 substring()而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。</li>
<li>对 substr()而言，第二个参数表示返回的子字符串数量。</li>
</ul>
<p>任何情况下，省略第二个参数都意味着提取到字符串末尾。与 concat()方法一样， slice()、 substr()和 substring()也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。</p>
<pre><code class="language-js">let data = 'hello world!'

console.log(data.slice(1, 3)) // el
console.log(data.substring(1, 3)) // el
console.log(data.substr(1, 3)) // ell
</code></pre>
<p>当某个参数是负值时，这 3 个方法的行为又有不同：</p>
<ul>
<li>slice()方法将所有负值参数都当成字符串长度加上负参数值</li>
<li>substr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0</li>
<li>substring()方法会将所有负参数值都转换为 0</li>
</ul>
<pre><code class="language-js">let stringValue = 'hello world'
console.log(stringValue.slice(-3)) // &quot;rld&quot;
console.log(stringValue.substring(-3)) // &quot;hello world&quot;
console.log(stringValue.substr(-3)) // &quot;rld&quot;

// 第二个参数是负值时：
console.log(stringValue.slice(3, -4)) // &quot;lo w&quot;
console.log(stringValue.substring(3, -4)) // &quot;hel&quot;
console.log(stringValue.substr(3, -4)) // &quot;&quot; (empty string)
</code></pre>
<h3 id="33-字符串定位-indexof和-lastindexof"><a class="header" href="#33-字符串定位-indexof和-lastindexof">3.3 字符串定位 indexOf()和 lastIndexOf()</a></h3>
<p>indexOf()和 lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1），第二个参数表示开始搜索的位置：</p>
<pre><code class="language-js">let data = 'hello world!'

console.log(data.indexOf('o')) // 4    返回找到数据的位置
console.log(data.indexOf('o', 6)) // 7
console.log(data.indexOf('o', 7)) // -1 返回 -1 表示未找到

console.log(data.lastIndexOf('o')) // 7
</code></pre>
<p>ES6 新增的查询：</p>
<pre><code class="language-js">let str = 'hello world!'
console.log(str.startsWith('h'))
console.log(str.endsWith('!'))
console.log(str.includes('h'))
</code></pre>
<p>startsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符：</p>
<pre><code class="language-js">let message = 'foobarbaz'
console.log(message.startsWith('foo')) // true
console.log(message.startsWith('foo', 1)) // false
console.log(message.includes('bar')) // true
console.log(message.includes('bar', 4)) // false
</code></pre>
<p>endsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样：</p>
<pre><code class="language-js">let message = 'foobarbaz'
console.log(message.endsWith('bar')) // false
console.log(message.endsWith('bar', 6)) // true
</code></pre>
<h3 id="34-清除字符串空格-trim"><a class="header" href="#34-清除字符串空格-trim">3.4 清除字符串空格 trim()</a></h3>
<pre><code class="language-js">let str = ' hello world '
console.log(str.trim()) //&quot;hello world&quot;
</code></pre>
<p>trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符。</p>
<h3 id="35-字符串转换大小写"><a class="header" href="#35-字符串转换大小写">3.5 字符串转换大小写</a></h3>
<p>在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），Unicode 大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。</p>
<pre><code class="language-js">let str = 'hello world'
console.log(str.toLocaleUpperCase()) //&quot;HELLO WORLD&quot;
console.log(str.toUpperCase()) //&quot;HELLO WORLD&quot;
console.log(str.toLocaleLowerCase()) //&quot;hello world&quot;
console.log(str.toLowerCase()) //&quot;hello world&quot;
</code></pre>
<h3 id="36-字符串比较-localecompare"><a class="header" href="#36-字符串比较-localecompare">3.6 字符串比较 localeCompare()</a></h3>
<pre><code class="language-js">let str = 'yellow'
// 按照字母表顺序比较，排在前返回 1，排在后返回 -1
console.log(str.localeCompare('brick')) //1
console.log(str.localeCompare('yellow')) //0
console.log(str.localeCompare('zoo')) // -1
</code></pre>
<h3 id="37-字符串模式匹配"><a class="header" href="#37-字符串模式匹配">3.7 字符串模式匹配</a></h3>
<pre><code class="language-js">let str = 'cat,bat,sat,fat'

// match() 方法与 RegExp 的 exec() 方法本质一样
let matches = str.match(/.at/)
console.log(matches.index) // 0
console.log(matches[0]) // cat

// search() 方法返回第一个匹配的位置索引，没有找到返回 -1
let pos = str.search(/at/)
console.log(pos) // 1

// 字符串替换
let res = str.replace('at', 'ond')
console.log(res) //cond,bat,sat,fat

res = str.replace(/at/g, 'ond')
console.log(res) //cond,bond,sond,fond
</code></pre>
<h3 id="38-字符串复制-padstart和-padend"><a class="header" href="#38-字符串复制-padstart和-padend">3.8 字符串复制 padStart()和 padEnd()</a></h3>
<p>padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（ U+0020）。</p>
<pre><code class="language-js">let stringValue = 'foo'
console.log(stringValue.padStart(6)) // &quot; foo&quot;
console.log(stringValue.padStart(9, '.')) // &quot;......foo&quot;
console.log(stringValue.padEnd(6)) // &quot;foo &quot;
console.log(stringValue.padEnd(9, '.')) // &quot;foo......&quot;
</code></pre>
<p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串：</p>
<pre><code class="language-js">let stringValue = 'foo'
console.log(stringValue.padStart(8, 'bar')) // &quot;barbafoo&quot;
console.log(stringValue.padStart(2)) // &quot;foo&quot;
console.log(stringValue.padEnd(8, 'bar')) // &quot;foobarba&quot;
console.log(stringValue.padEnd(2)) // &quot;foo&quot;
</code></pre>
<h3 id="39-字符串迭代与解构"><a class="header" href="#39-字符串迭代与解构">3.9 字符串迭代与解构</a></h3>
<p>字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器：</p>
<pre><code class="language-js">let message = 'abc'
let stringIterator = message[Symbol.iterator]()
console.log(stringIterator.next()) // {value: &quot;a&quot;, done: false}
console.log(stringIterator.next()) // {value: &quot;b&quot;, done: false}
console.log(stringIterator.next()) // {value: &quot;c&quot;, done: false}
console.log(stringIterator.next()) // {value: undefined, done: true}
</code></pre>
<p>在 for-of 循环中可以通过这个迭代器按序访问每个字符：</p>
<pre><code class="language-js">// 迭代
for (const c of 'abcde') {
  console.log(c) // a b c d e
}

// 解构
console.log([...message]) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="103-常用内置对象-datemathglobal"><a class="header" href="#103-常用内置对象-datemathglobal">10.3-常用内置对象-Date、Math、Global</a></h1>
<h2 id="一-时间对象-date"><a class="header" href="#一-时间对象-date">一 时间对象 Date</a></h2>
<h3 id="11-date-基本使用"><a class="header" href="#11-date-基本使用">1.1 Date 基本使用</a></h3>
<p>ECMAScript 的 Date 类型使用 UTC 世界标准时间，即 1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期。</p>
<p>Date 的使用示例：</p>
<pre><code class="language-js">// 创建当前时间对象
new Date() // Tue Jan 24 2023 14:07:34 GMT+0800 (中国标准时间)

// 传入 1970 年 1 月 1 日午夜之后的毫秒数
new Date(600000000) // Thu Jan 08 1970 06:40:00 GMT+0800 (中国标准时间)

// 传入格式化日期数据：'2021-12-12' 或者 '2019-05-23T00:00:00' 或者'May 25, 2004'
new Date('May 25, 2004') // Tue May 25 2004 00:00:00 GMT+0800 (中国标准时间)
</code></pre>
<p>当构造函数有参数时，Date 内部有两种调用方式：</p>
<ul>
<li><code>Date.parse()</code>：接收可表示为日期的参数，并尝试将其转化为毫秒数，返回 GMT 时间，若转化失败，则返回 NaN。常见接收格式有：
<ul>
<li>”月/日/年”，如&quot;5/23/2019&quot;；</li>
<li>“月名 日, 年”，如&quot;May 23, 2019&quot;；</li>
<li>“周几 月名 日 年 时:分:秒 时区”，如&quot;Tue May 23 2019 00:00:00 GMT-0700&quot;；</li>
<li>ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于兼容 ES5 的实现）</li>
</ul>
</li>
<li><code>Date.UTC()</code>：参数是年、零起点月数（ 1 月是 0， 2 月是 1，以此类推）、日（ 1~31）、时（ 0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。返回值为本地日期。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">// 创建表示 2019年5月23日 的日期对象，以下2种方式一样
new Date('May 23, 2019') // Thu May 23 2019 00:00:00 GMT+0800 (中国标准时间)
new Date(Date.parse('May 23, 2019')) // Thu May 23 2019 00:00:00 GMT+0800 (中国标准时间)

// 第一个日期是 2000 年 1 月 1 日零点（ GMT）， 2000 代表年， 0 代表月（ 1 月）。
// 因为没有其他参数（日取 1，其他取 0），所以结果就是该月第 1 天零点
new Date(2000, 0) // Sat Jan 01 2000 00:00:00 GMT+0800 (中国标准时间)
new Date(new Date(Date.UTC(2000, 0))) // Sat Jan 01 2000 08:00:00 GMT+0800 (中国标准时间)

// 2005年 5 月 5 日下午 5 点 55 分 55 秒（ GMT）。
// 虽然日期里面涉及的都是 5，但月数必须用 4，因为月数是零起点的。小时也必须是 17，因为这里采用的是 24 小时制，即取值范围是 0~23。
new Date(2005, 4, 5, 17, 55, 55) // Thu May 05 2005 17:55:55 GMT+0800 (中国标准时间)
new Date(Date.UTC(2005, 4, 5, 17, 55, 55)) // Fri May 06 2005 01:55:55 GMT+0800 (中国标准时间)
</code></pre>
<h3 id="12-datenow"><a class="header" href="#12-datenow">1.2 Date.now()</a></h3>
<p>ES5 添加了 <code>Date.now()</code> 方法，返回表示调用这个方法时的日期和时间的毫秒数：</p>
<pre><code class="language-js">// 起始时间
let start = Date.now();

//调用函数
doSomething();

//取得停止时间
let stop = Date.now()
let result = stop – start;
</code></pre>
<h3 id="13-实例方法获取当前时间"><a class="header" href="#13-实例方法获取当前时间">1.3 实例方法获取当前时间</a></h3>
<p>Date 对象还有一些时间设置与获取方法：</p>
<pre><code class="language-js">// 获取当前时间
let now = new Date()

console.log(now.getFullYear()) // 2020
console.log(now.getMonth()) // 2    其中 0 表示一月，11 表示十二月，类推
console.log(now.getDate()) // 27
console.log(now.getHours()) // 13

console.log(now.getTime()) // 时间戳
console.log(now.valueof()) // 时间戳

// 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
now.setDate(33)
console.log(now.getMonth()) // 3
</code></pre>
<h3 id="14-继承的-api"><a class="header" href="#14-继承的-api">1.4 继承的 API</a></h3>
<p>Date 类型重写了继承的 toLocaleString()、 toString()和 valueOf()方法：</p>
<pre><code class="language-js">// 创建当前时间对象
let nowDate = new Date()

console.log(nowDate) // Tue Jan 24 2023 14:27:21 GMT+0800 (中国标准时间)
console.log(nowDate.toLocaleString()) // 2023/1/24 14:27:21
console.log(nowDate.toLocaleDateString()) // 2023/1/24
console.log(nowDate.toLocaleTimeString()) // 14:27:21

// valueOf() 返回的是日期的毫秒表示
let date1 = new Date(2019, 0, 1) // 2019 年 1 月 1 日
let date2 = new Date(2019, 1, 1) // 2019 年 2 月 1 日
console.log(date1 &lt; date2) // true
console.log(date1 &gt; date2) // false
</code></pre>
<h3 id="15-日期格式化方法"><a class="header" href="#15-日期格式化方法">1.5 日期格式化方法</a></h3>
<p>Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p>
<ul>
<li>toDateString()显示日期中的周几、月、日、年（格式特定于实现）；</li>
<li>toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；</li>
<li>toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；</li>
<li>toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；</li>
<li>toUTCString()显示完整的 UTC 日期（格式特定于实现）。</li>
</ul>
<h2 id="二-数学对象-math"><a class="header" href="#二-数学对象-math">二 数学对象 Math</a></h2>
<h3 id="21-math-的基本使用"><a class="header" href="#21-math-的基本使用">2.1 Math 的基本使用</a></h3>
<p>Math 对象包含了很多运算相关的方法。</p>
<p>min()/max()：用于比较参数大小，可以接收多个参数，返回一个最终值。不过在数组中要查找最大最小值，还要依靠 apply：</p>
<pre><code class="language-js">let values = [1, 2, 3, 4, 5, 6, 7, 8]
let max = Math.max.apply(Math, values)
</code></pre>
<p>常用的舍入方法：</p>
<ul>
<li>Math.ceil() 执行向上舍入，即它总是将数值向上舍入为最接近的整数；</li>
<li>Math.floor() 执行向下舍入，即它总是将数值向下舍入为最接近的整数；</li>
<li>Math.round() 执行标准舍入，即它总是将数值四舍五入为最接近的整数，也即常见的四舍五入</li>
<li>Math.fround() 方法返回数值最接近的单精度（ 32 位）浮点值表示</li>
</ul>
<pre><code class="language-js">console.log(Math.ceil(25.9)) // 26
console.log(Math.ceil(25.5)) // 26
console.log(Math.ceil(25.1)) // 26
console.log(Math.round(25.9)) // 26
console.log(Math.round(25.5)) // 26
console.log(Math.round(25.1)) // 25
console.log(Math.fround(0.4)) // 0.4000000059604645
console.log(Math.fround(0.5)) // 0.5
console.log(Math.fround(25.9)) // 25.899999618530273
console.log(Math.floor(25.9)) // 25
console.log(Math.floor(25.5)) // 25
console.log(Math.floor(25.1)) // 25
</code></pre>
<p>Math.random() 方法返回大于等于 0 小于 1 的一个随机数，如选择一个 1-10 的数：</p>
<pre><code class="language-js">Math.floor(Math.random() * 10 + 1) // 因为 rundom() 返回的是一个小数
</code></pre>
<h2 id="三-global"><a class="header" href="#三-global">三 Global</a></h2>
<h3 id="31-global-对象概念"><a class="header" href="#31-global-对象概念">3.1 Global 对象概念</a></h3>
<p>Global 对象无法通过代码显式访问，它所针对的是不属于任何对象的属性和方法。<strong>所谓的全局变量、全局函数其实都是 Global 对象的成员！！！</strong>。包括 isNaN()、 isFinite()、 parseInt()和 parseFloat()等实际上都是 Global 对象的方法。</p>
<h3 id="32-global-对象方法"><a class="header" href="#32-global-对象方法">3.2 Global 对象方法</a></h3>
<p>Global 对象的 URL 编码、解码方法：</p>
<pre><code class="language-js">// url 编码方法
let uri = 'http://www.wrox.com/illegal value.js#start'
// &quot;http://www.wrox.com/illegal%20value.js#start&quot;
console.log(encodeURI(uri))
// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;
console.log(encodeURIComponent(uri)) // 不会编码非法字符

// url 解码方法
let uri = 'http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start'
// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start
console.log(decodeURI(uri))
// http:// www.wrox.com/illegal value.js#start
console.log(decodeURIComponent(uri))
</code></pre>
<p>eval 方法：</p>
<pre><code class="language-js">eval(&quot;console.log('hi')&quot;)
</code></pre>
<h3 id="33-global-对象属性"><a class="header" href="#33-global-对象属性">3.3 Global 对象属性</a></h3>
<p>Global 对象的属性包括：</p>
<ul>
<li>一些特殊值：undefined、NaN、Infinity</li>
<li>所有原生引用类型构造函数：Object、Function、Array、String、Blloean、Number、Date、Error、Symbol、TypeError 等。</li>
</ul>
<h3 id="34-window-对象"><a class="header" href="#34-window-对象">3.4 window 对象</a></h3>
<p>在浏览器环境中，window 对象被实现为了 Global。因此，所有全局作用域中声明的变量和函数都变成了 window 的属性。</p>
<p>在 Node 环境中，拥有 Global 对象。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="104-常用内置对象-function"><a class="header" href="#104-常用内置对象-function">10.4-常用内置对象-Function</a></h1>
<h2 id="一-function-对象简介"><a class="header" href="#一-function-对象简介">一 Function 对象简介</a></h2>
<h3 id="11-函数的本质"><a class="header" href="#11-函数的本质">1.1 函数的本质</a></h3>
<p>函数是 JS 一种特殊的引用类型，其本质是对象，每个函数都是 Function 类型的实例，所以函数名就是指向函数对象的指针。</p>
<p>函数内部有三个特殊对象：arguments、this、caller。</p>
<h3 id="12-内部对象arguments"><a class="header" href="#12-内部对象arguments">1.2 内部对象：arguments</a></h3>
<p>在使用 function 关键字定义函数时，会在函数内部创建一个 arguments 对象实例，用来存储传递过来的实参。</p>
<p>arguments 对象是个伪数组（不是 Array 的实例，但是使用方式类似数组），其长度由实参个数决定。</p>
<pre><code class="language-js">function fn(a, b) {
  console.log(fn.length) //输出形参个数 2
  console.log(arguments) //输出：Arguments(1) 即：{ '0': 1 }
  console.log(arguments.length) // 输出实参个数 1
}
fn(1)
</code></pre>
<p>其实也可以由此看到，其他语言不同，在 ECMAScript 中的命名参数不会创建让之后的调用必须匹配的函数签名，因为根本不存在验证命名参数的机制。所以即使函数的声明没有参数，我们仍然可以这样获取：</p>
<pre><code class="language-js">function fn() {
  console.log(arguments[0]) // 1
}
fn(1)
</code></pre>
<p>arguments 对象可以跟命名参数一起使用：</p>
<pre><code class="language-js">// 命名参数 num1 保存着与arugments[0]一样的值， num2 也保存着跟 arguments[1]一样的值,因此使用谁都无所谓
function doAdd(num1, num2) {
  if (arguments.length === 1) {
    console.log(num1 + 10)
  } else if (arguments.length === 2) {
    console.log(arguments[0] + num2)
  }
}
</code></pre>
<p>同理，在上述示例中，修改 arguments 内的元素的值，也会同步到函数参数中。但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。</p>
<p>严格模式下， arguments 会有一些变化：</p>
<ul>
<li>给 arguments 内的元素赋值不会再影响函数参数的值。</li>
<li>在函数中尝试重写 arguments 对象会导致语法错误，代码也不会执行。</li>
</ul>
<p>虽然箭头函数不支持 arguments 对象，但是可以通过参数收集方式获取到参数列表：</p>
<pre><code class="language-js">// 注意只支持多余参数在前，即： (param1,param2, ...values)，多余参数在后面报错
let getSum = (...values) =&gt; {
  return values.reduce((x, y) =&gt; x + y, 0)
}
console.log(getSum(1, 2, 3)) // 6
</code></pre>
<p>使用 arguments.callee 就可以让函数逻辑与函数名解耦：</p>
<pre><code class="language-js">// 阶乘函数
function factorial(num) {
  if (num &lt;= 1) {
    return 1
  } else {
    // return num * factorial(num - 1)
    return num * arguments.callee(num - 1)
  }
}
</code></pre>
<p>这个重写之后的 factorial()函数已经用 arguments.callee 代替了之前硬编码的 factorial。这意味着无论函数叫什么名称，都可以引用正确的函数。</p>
<h3 id="13-内部对象this"><a class="header" href="#13-内部对象this">1.3 内部对象：this</a></h3>
<p>this 标准函数和箭头函数中有不同的行为：</p>
<ul>
<li>在标准函数中， this 引用的是把函数当成方法调用的上下文对象</li>
<li>在箭头函数中， this 引用的是定义箭头函数的上下文</li>
</ul>
<p>this 在标准函数中的示例：</p>
<pre><code class="language-js">window.color = 'red'
let o = {
  color: 'blue',
}

function sayColor() {
  console.log(this.color)
}

sayColor() // 'red'
o.sayColor = sayColor
o.sayColor() // 'blue'
</code></pre>
<p>this 在箭头函数中的示例：</p>
<pre><code class="language-js">window.color = 'red'
let o = {
  color: 'blue',
}
let sayColor = () =&gt; console.log(this.color)
sayColor() // 'red'
o.sayColor = sayColor
o.sayColor() // 'red'
</code></pre>
<p>在事件回调或定时回调中调用某个函数时， this 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的 this 会保留定义该函数时的上下文：</p>
<pre><code class="language-js">function King() {
  this.royaltyName = 'Henry'
  // this 引用 King 的实例
  setTimeout(() =&gt; console.log(this.royaltyName), 1000)
}

function Queen() {
  this.royaltyName = 'Elizabeth'
  // this 引用 window 对象
  setTimeout(function () {
    console.log(this.royaltyName)
  }, 1000)
}
new King() // Henry
new Queen() // undefined
</code></pre>
<h3 id="14-内部对象caller"><a class="header" href="#14-内部对象caller">1.4 内部对象：caller</a></h3>
<p>caller 对象中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，其值为 null：</p>
<pre><code class="language-js">// 下列代码会导致警告框中显示 outer() 函数的源代码，因为 outer() 调用了 inter()，所以 inner.caller 就指向 outer()。
function outer() {
  inner()
}

function inner() {
  alert(inner.caller)
}

outer()

// 使用 caller 实现松耦合
function outer() {
  inner()
}

function inner() {
  alert(arguments.callee.caller)
}

outer()
</code></pre>
<p>ECMAScript 5 也定义了 arguments.caller，但在严格模式下访问它会报错，在非严格模式下则始终是 undefined。这是为了分清 arguments.caller
和函数的 caller 而故意为之的。</p>
<p>此外，严格模式下还有一个限制，就是不能给函数的 caller 属性赋值，否则会导致错误。</p>
<h3 id="15-newtarget"><a class="header" href="#15-newtarget">1.5 new.target</a></h3>
<p>ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。</p>
<pre><code class="language-js">function King() {
  if (!new.target) {
    throw 'King must be instantiated using &quot;new&quot;'
  }
  console.log('King instantiated using &quot;new&quot;')
}

new King() // King instantiated using &quot;new&quot;
King() // Error: King must be instantiated using &quot;new&quot;
</code></pre>
<h2 id="二-函数属性和方法"><a class="header" href="#二-函数属性和方法">二 函数属性和方法</a></h2>
<h3 id="21-函数属性"><a class="header" href="#21-函数属性">2.1 函数属性</a></h3>
<p>函数也是对象，因此也有属性与方法。</p>
<p>每个函数都包含两个属性：</p>
<ul>
<li>length：表示函数命名参数的个数</li>
<li>prototype：原型属性，和对象的原型一样保存了实例方法用于实现继承，如 toString()、 valueOf()。要注意的是 prototype 属性不可枚举（即不能通过 for in 发现）</li>
</ul>
<h3 id="22-函数方法-apply-call"><a class="header" href="#22-函数方法-apply-call">2.2 函数方法 apply() call()</a></h3>
<p>每个函数也都包含两个非继承而获得的方法：apply()、call()，都可以通过指定 this 后调用当前函数：</p>
<pre><code class="language-js">let a = 20
let obj = {
  a: 40,
}

function fn() {
  console.log(this.a)
}

fn() // 输出 20，因为这里的 this 是全局的 window

// 修改 this 指向
fn.call(obj) // 40
fn.apply(obj) // 40
</code></pre>
<p>apply 与 call 都修改了函数内部 this 的指向，this 指向第一个参数，如果这个参数为 null，则 this 指向 window。</p>
<p>apply 与 call 的区别是第二个参数及其后续参数传递形式不同：</p>
<ul>
<li>apply：第二个参数为数组，将函数执行需要的参数组装为数组再传入，用于函数的形参个数不确定的情况：函数名.apply(绑定对象，函数参数列表数组);</li>
<li>call：第二个及其之后的参数是函数执行需要的参数用于确定了函数的形参有多少个的时候使用：函数名.call(绑定对象，函数参数 1，参数 2，参数 3....);</li>
</ul>
<p>apply 和 call 的第一个参数都为 null 时，表示为函数调用模式，即 this 指向 window。</p>
<p>使用案例一：求数组最大值</p>
<pre><code class="language-javascript">let arr = [9, 1, 4, 10, 7]
let max1 = Math.max(9, 1, 4, 10, 7)
let max2 = Math.max.apply(null, arr)
console.log(max1) //输出 10
console.log(max2) //输出 10
</code></pre>
<p>使用案例二：伪数组</p>
<pre><code class="language-javascript">//obj 是个伪数组，无法使用 obj.0 获取属性，也无法像数组那样用 obj[0] 获取
let obj = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3,
}
// [].concat(1,2,3) 会产生数组 [1,2,3]
let arr = [].concat.apply([], obj)
console.log(arr) //输出 ['a','b','c']
</code></pre>
<h3 id="23-bind"><a class="header" href="#23-bind">2.3 bind()</a></h3>
<p>ES5 增加了 bind 函数，也用来改变函数内部的 this 指向。但是 bind 函数与 call/apply 不同的是，返回的是一个新的函数，这个新函数与原函数有共同的函数体，但是并非原函数，所以不会像 call/apply 那样立即执行！！！！</p>
<pre><code class="language-js">function fn(num1, num2) {
  return this.a + num1 + num1
}

let a = 20
let obj = {
  a: 40,
}

let _fn = fn.bind(obj, 1, 2)

console.log(_fn === fn) // false
_fn() // 43
_fn(1, 4) // 43，因为参数绑定，重新传入的参数是无效的
</code></pre>
<p>手动实现 bind：</p>
<pre><code class="language-js">function myBind(context) {
  const that = this
  const args = Array.prototype.slice.call(arguments, 1)
  return function () {
    const innerArgs = Array.prototype.slice.call(arguments)
    return that.apply(context, args.concat(innerArgs))
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="105-常用内置对象-错误对象"><a class="header" href="#105-常用内置对象-错误对象">10.5-常用内置对象-错误对象</a></h1>
<h2 id="一-traycatch-语句"><a class="header" href="#一-traycatch-语句">一 tray/catch 语句</a></h2>
<p>任何可能出错的代码都应该放到 try 块中，而处理错误的代码则放在 catch 块中，如下所示：</p>
<pre><code class="language-js">try {
  throw 'foo'
} catch (e) {
  // ES2019 之后此处函数括号和参数可以省略
  console.log('An error happened!')
  console.log(e.message) // 可以向用户显示错误消息
}
</code></pre>
<p>如果 try 中的代码发生错误，则代码会立即退出执行，跳入 catch 中，并传入包含错误信息的对象，该对象的 message 属性在浏览器中的支持度最高。</p>
<p>try/catch 语句中有一个可选的 finally 子句，该子句无论是否发生错误都会最终运行。try 或 catch 块无法阻止 finally 块执行，包括 return 语句。</p>
<pre><code class="language-js">function testFinally() {
  try {
    return 2
  } catch (error) {
    return 1
  } finally {
    return 0
  }
}
</code></pre>
<p>贴士：如果写出 finally 子句， catch 块就成了可选的（它们两者中只有一个是必需的）。只要代码中包含了 finally 子句， try 块或 catch 块中的 return 语句就会被忽略，上述示例中的 try 和 catch 的 return 数值并未获取到。</p>
<p>try/catch 语句最好用在自己无法控制的错误上。例如，假设你的代码中使用了一个大型 JavaScript 库的某个函数，而该函数可能会有意或由于出错而抛出错误。因为不能修改这个库的代码，所以为防止这个函数报告错误，就有必要通过 try/catch 语句把该函数调用包装起来，对可能的错误进行处理。</p>
<p>如果你明确知道自己的代码会发生某种错误，那么就不适合使用 try/catch 语句。例如，如果给函数传入字符串而不是数值时就会失败，就应该检查该函数的参数类型并采取相应的操作。这种情况下，没有必要使用 try/catch 语句。</p>
<h2 id="二-错误类型"><a class="header" href="#二-错误类型">二 错误类型</a></h2>
<p>代码执行过程中会发生各种类型的错误，每种类型都会对应一个错误发生时抛出的错误对象。常见的错误对象有 8 种：</p>
<pre><code class="language-txt"># 基本错误类型，其他错误类型继承该类型。
Error

# 继承自Error的具体错误类型
InternalError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
</code></pre>
<p>InternalError 类型的错误会在底层 JavaScript 引擎抛出异常时由浏览器抛出。例如，递归过多导致了栈溢出。这个类型并不是代码中通常要处理的错误，如果真发生了这种错误，很可能代码哪里弄错了或者有危险了。</p>
<p>RangeError 错误会在数值越界时抛出。例如，定义数组时如果设置了并不支持的长度，如-20 或 Number.MAX_VALUE，就会报告该错误：</p>
<pre><code class="language-js">let items1 = new Array(-20) // 抛出 RangeError
let items2 = new Array(Number.MAX_VALUE) // 抛出 RangeError
</code></pre>
<p>ReferenceError 会在找不到对象时发生。（这就是著名的&quot;object expected&quot;浏览器错误的原因。）这种错误经常是由访问不存在的变量而导致的：</p>
<pre><code class="language-js">let obj = x // 在 x 没有声明时会抛出 ReferenceError
</code></pre>
<p>TypeError 在 JavaScript 中很常见，主要发生在变量不是预期类型，或者访问不存在的方法时。很多原因可能导致这种错误，尤其是在使用类型特定的操作而变量类型不对时。</p>
<pre><code class="language-js">let o = new 10() // 抛出 TypeError
console.log('name' in true) // 抛出 TypeError
Function.prototype.toString.call('name') // 抛出 TypeError
</code></pre>
<h2 id="三-错误抛出"><a class="header" href="#三-错误抛出">三 错误抛出</a></h2>
<p>throw 用于抛出错误，该操作符必须有一个值：</p>
<pre><code class="language-js">throw 12345
throw 'Hello world!'
throw true
throw { name: 'JavaScript' }
</code></pre>
<p>使用 throw 操作符时，代码立即停止执行，除非 try/catch 语句捕获了抛出的值。</p>
<p>可以通过内置的错误类型来模拟浏览器错误：</p>
<pre><code class="language-js">throw new Error('Something bad happened.') // 可以是具体的错误类型
</code></pre>
<p>过继承 Error（第 6 章介绍过继承）也可以创建自定义的错误类型。创建自定义错误类型时，需要提供 name 属性和 message 属性，比如：</p>
<pre><code class="language-js">class CustomError extends Error {
  constructor(message) {
    super(message)
    this.name = 'CustomError'
    this.message = message
  }
}
throw new CustomError('My message')
</code></pre>
<h2 id="四-error-事件"><a class="header" href="#四-error-事件">四 error 事件</a></h2>
<p>任何没有被 try/catch 语句处理的错误都会在 window 对象上触发 error 事件。该事件是浏览器早期支持的事件，为保持向后兼容，很多浏览器保持了其格式不变。</p>
<pre><code class="language-js">window.onerror = (message, url, line) =&gt; {
  console.log(message)
}
</code></pre>
<p>在任何错误发生时，无论是否是浏览器生成的，都会触发 error 事件并执行这个事件处理程序。然后，浏览器的默认行为就会生效，像往常一样显示这条错误消息。可以返回 false 来阻止浏览器默认报告错误的行为，如下所示：</p>
<pre><code class="language-js">window.onerror = (message, url, line) =&gt; {
  console.log(message)
  return false
}
</code></pre>
<h2 id="五-调试"><a class="header" href="#五-调试">五 调试</a></h2>
<h3 id="51-控制台打印"><a class="header" href="#51-控制台打印">5.1 控制台打印</a></h3>
<p>常见的 consle 方法：</p>
<pre><code class="language-txt">error(message)：在控制台中记录错误消息。
info(message)：在控制台中记录信息性内容。
log(message)：在控制台记录常规消息。
warn(message)：在控制台中记录警告消息
</code></pre>
<h3 id="52-debugger-关键字"><a class="header" href="#52-debugger-关键字">5.2 debugger 关键字</a></h3>
<pre><code class="language-js">function pauseExecution() {
  console.log('Will print before breakpoint')
  debugger
  console.log('Will not print until breakpoint continues')
}
</code></pre>
<p>在运行时碰到这个关键字时，所有主流浏览器都会打开开发者工具面板，并在指定位置显示断点。然后，可以通过单独的浏览器控制台在断点所在的特定词法作用域中执行代码。此外，还可以执行标准的代码调试器操作（单步进入、单步跳过、继续，等等）。</p>
<p>浏览器也支持在开发者工具的源代码标签页中选择希望设置断点的代码行来手动设置断点（不使用 debugger 关键字）。这样设置的断点与使用 debugger 关键字设置的一样，只是不会在不同浏览器会话之间保持。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="106-常用内置对象-正则表达式"><a class="header" href="#106-常用内置对象-正则表达式">10.6-常用内置对象-正则表达式</a></h1>
<h2 id="一-正则表达式的基本使用"><a class="header" href="#一-正则表达式的基本使用">一 正则表达式的基本使用</a></h2>
<h3 id="11-创建正则表达式"><a class="header" href="#11-创建正则表达式">1.1 创建正则表达式</a></h3>
<p>正则表达式用于数据的匹配，创建方式有两种：</p>
<pre><code class="language-js">// 判断时报包含 ruyue
let str = 'iruyuejun'

// 方式一：字面量
let flag = /ruyue/g.test(str) // 正则使用 // 包裹
console.log(flag) // true

// 方式二：构造函数方式
let reg = new RegExp('ruyue', 'g') // 或者 new RegExp(/ruyue/g)
console.log(reg.test(str)) // true
</code></pre>
<p>在 JavaScript 中，推荐使用字面量形式定义对象！字面量的缺陷是正则内部放置变量时候处理较为困难，如下所示：</p>
<pre><code class="language-js">let str = 'iruyuejun'
let c = 'ruyue'
console.log(eval('/' + c + '/').test(str))
</code></pre>
<h3 id="12-匹配模式标记"><a class="header" href="#12-匹配模式标记">1.2 匹配模式标记</a></h3>
<p>表示匹配模式的标记有：</p>
<ul>
<li>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</li>
<li>i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。</li>
<li>m：多行模式，表示查找到一行文本末尾时会继续查找。</li>
<li>y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。</li>
<li>u： Unicode 模式，启用 Unicode 匹配。</li>
<li>s： dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">// 匹配字符串中的所有&quot;at&quot;
let pattern1 = /at/g
// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写
let pattern2 = /[bc]at/i
// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi

// 所有元字符在模式中也必须转义，如：( [ { \ ^ $ | ) ] } ? * + .
// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写
let pattern1 = /[bc]at/i
// 匹配第一个&quot;[bc]at&quot;，忽略大小写
let pattern2 = /\[bc\]at/i
// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi
// 匹配所有&quot;.at&quot;，忽略大小写
let pattern4 = /\.at/gi
</code></pre>
<p>贴士：因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如 <code>\n</code>（ <code>\</code> 转义后的字符串是 <code>\\</code> ，在正则表达式字符串中则要写成 <code>\\\\</code> ）。
ll 模式，表示元字符。匹配任何字符（包括\n 或\r）。</p>
<h2 id="二-regexp-的成员"><a class="header" href="#二-regexp-的成员">二 RegExp 的成员</a></h2>
<h3 id="21-regexp-实例属性"><a class="header" href="#21-regexp-实例属性">2.1 RegExp 实例属性</a></h3>
<p>RegExp 实例都有下列属性：</p>
<ul>
<li>global：布尔值，表示是否设置了 g 标记。</li>
<li>ignoreCase：布尔值，表示是否设置了 i 标记。</li>
<li>unicode：布尔值，表示是否设置了 u 标记。</li>
<li>sticky：布尔值，表示是否设置了 y 标记。</li>
<li>lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。</li>
<li>multiline：布尔值，表示是否设置了 m 标记。</li>
<li>dotAll：布尔值，表示是否设置了 s 标记。</li>
<li>source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</li>
<li>flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）</li>
</ul>
<pre><code class="language-js">let pattern1 = /\[bc\]at/i
console.log(pattern1.global) // false
console.log(pattern1.ignoreCase) // true
console.log(pattern1.multiline) // false
console.log(pattern1.lastIndex) // 0
console.log(pattern1.source) // &quot;\[bc\]at&quot;
console.log(pattern1.flags) // &quot;i&quot;

let pattern2 = new RegExp('\\[bc\\]at', 'i')
console.log(pattern2.global) // false
console.log(pattern2.ignoreCase) // true
console.log(pattern2.multiline) // false
console.log(pattern2.lastIndex) // 0
console.log(pattern2.source) // &quot;\[bc\]at&quot;
console.log(pattern2.flags) // &quot;i
</code></pre>
<h3 id="22-regexp-实例方法-exec"><a class="header" href="#22-regexp-实例方法-exec">2.2 RegExp 实例方法 exec()</a></h3>
<p>RegExp 实例的主要方法是：exec()、test()。</p>
<p>exec() 的参数为应用模式的字符串，返回值为第一个匹配信息的数组，若没找到匹配项，则返回 null。返回的数组额外包含 2 个属性：</p>
<ul>
<li>index：字符串中匹配模式的起始位置</li>
<li>input：要查找的字符串</li>
</ul>
<pre><code class="language-js">let text = 'mom and dad and baby'
let pattern = /mom( and dad( and baby)?)?/gi
let matches = pattern.exec(text)

console.log(matches.index) // 0
console.log(matches.input) // &quot;mom and dad and baby&quot;
console.log(matches[0]) // &quot;mom and dad and baby&quot;
console.log(matches[1]) // &quot; and dad and baby&quot;
console.log(matches[2]) // &quot; and baby&quot;
</code></pre>
<p>如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息：</p>
<pre><code class="language-js">let text = 'cat, bat, sat, fat'

// 没有设置全局标记，因此调用 exec()只返回第一个匹配项（ &quot;cat&quot;）。 lastIndex在非全局模式下始终不变。
let pattern = /.at/
let matches = pattern.exec(text)
console.log(matches.index) // 0
console.log(matches[0]) // cat
console.log(pattern.lastIndex) // 0

matches = pattern.exec(text)
console.log(matches.index) // 0
console.log(matches[0]) // cat
console.log(pattern.lastIndex) // 0

// 如果在这个模式上设置了 g 标记，则每次调用 exec()都会在字符串中向前搜索下一个匹配项
let patternGlobal = /.at/g
let matchesGlobal = patternGlobal.exec(text)
console.log(matchesGlobal.index) // 0
console.log(matchesGlobal[0]) // cat
console.log(patternGlobal.lastIndex) // 3

matchesGlobal = patternGlobal.exec(text)
console.log(matchesGlobal.index) // 5
console.log(matchesGlobal[0]) // bat
console.log(patternGlobal.lastIndex) // 8

matches = patternGlobal.exec(text)
console.log(matchesGlobal.index) // 10
console.log(matchesGlobal[0]) // sat
console.log(patternGlobal.lastIndex) // 13
</code></pre>
<p>如果模式设置了粘附标记 y，则每次调用 exec()就只会在 lastIndex 的位置上寻找匹配项。粘附标记覆盖全局标记：</p>
<pre><code class="language-js">let text = 'cat, bat, sat, fat'
let pattern = /.at/y

let matches = pattern.exec(text)
console.log(matches.index) // 0
console.log(matches[0]) // cat
console.log(pattern.lastIndex) // 3

// 以索引 3 对应的字符开头找不到匹配项，因此 exec()返回 null
// exec()没找到匹配项，于是将 lastIndex 设置为 0
matches = pattern.exec(text)
console.log(matches) // null
console.log(pattern.lastIndex) // 0

// 向前设置 lastIndex 可以让粘附的模式通过 exec()找到下一个匹配项：
pattern.lastIndex = 5
matches = pattern.exec(text)
console.log(matches.index) // 5
console.log(matches[0]) // bat
console.log(pattern.lastIndex) // 8
</code></pre>
<h3 id="23-regexp-实例方法-test"><a class="header" href="#23-regexp-实例方法-test">2.3 RegExp 实例方法 test()</a></h3>
<p>test()方法接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，否则返回 false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。test()经常用在 if 语句中：</p>
<pre><code class="language-js">let text = '000-00-0000'
let pattern = /\d{3}-\d{2}-\d{4}/

// 如果输入的文本与模式匹配，则显示匹配成功的消息
if (pattern.test(text)) {
  console.log('The pattern was matched.')
}
</code></pre>
<h3 id="24-regexp-静态成员"><a class="header" href="#24-regexp-静态成员">2.4 RegExp 静态成员</a></h3>
<p>包括：</p>
<pre><code class="language-txt">全名            简写     说明
input           $_      最后搜索的字符串（非标准特性）
lastMatch       $&amp;      最后匹配的文本
lastParen       $+      最后匹配的捕获组（非标准特性）
leftContext     $`      input 字符串中出现在 lastMatch 前面的文本
rightContext    $'      input 字符串中出现在 lastMatch 后面的文本
</code></pre>
<p>通过这些属性可以提取出与 exec()和 test()执行的操作相关的信息：</p>
<pre><code class="language-js">let text = 'this has been a short summer'
let pattern = /(.)hort/g
if (pattern.test(text)) {
  // input 属性中包含原始的字符串，简写方式为：RegExp.$_
  console.log(RegExp.input) // this has been a short summer
  // leftConext 属性包含原始字符串中&quot;short&quot;之前的内容， rightContext 属性包含&quot;short&quot;之后的内容
  console.log(RegExp.leftContext) // this has been a
  console.log(RegExp.rightContext) // summer
  // lastMatch 属性包含匹配整个正则表达式的上一个字符串，即&quot;short&quot;
  console.log(RegExp.lastMatch) // short
  //   lastParen 属性包含捕获组的上一次匹配，即&quot;s&quot;
  console.log(RegExp.lastParen) // s
}
</code></pre>
<h2 id="三-常用正则"><a class="header" href="#三-常用正则">三 常用正则</a></h2>
<h3 id="31-字符区间集合"><a class="header" href="#31-字符区间集合">3.1 字符区间集合</a></h3>
<p>字符区间集合：</p>
<pre><code class="language-js">// 匹配所有小写字母
/[a-z]/g

// 匹配所有字母、数字
/[a-zA-Z0-9]/g

// 中文区间匹配
/[\u4e00-\u9fa5]/g // 匹配 我 你之间

// 匹配区间之外
/[^a-z]/g // 匹配 a 到 z 之外的所有字符
</code></pre>
<h3 id="32-重复匹配"><a class="header" href="#32-重复匹配">3.2 重复匹配</a></h3>
<pre><code class="language-js">// +匹配多次
;/ry+/g // 匹配一个 r，再可以匹配多次 y，如 ry 可以被匹配到，ryy 也可以被匹配到

// 匹配 r R，重复的 y Y
/[rR][yY]+/ // 可以匹配到 RYY  Ry 等

// 匹配可有可无的
/[rR][yY]+[!*\.~%]*/ // 可以匹配到 ry ry! ry*  等

// 匹配
/[rR][yY]+j?[!*\.~%]*/ // 可以匹配到 ry ry! ryj!
</code></pre>
<h3 id="33-分组匹配"><a class="header" href="#33-分组匹配">3.3 分组匹配</a></h3>
<pre><code class="language-js">// () 为分组，$可以获取到分组匹配到的实际内容 $1 可以获取下面第一个分组，$2获取第二个分组，$3无法获取第三个分组，因为 ?: 标记了不捕获
;/(http|https):\/{2}w{3}\.(baidu|google|sogou)\.(?:com|cn|net)/g // {2} 表示重复2个
</code></pre>
<h3 id="34-正向预查与反向预查"><a class="header" href="#34-正向预查与反向预查">3.4 正向预查与反向预查</a></h3>
<pre><code class="language-js">// 如果有数据为：200 元，300 元，400 磅，500 刀
;/\d+(?=元)/g // 正向肯定预查询：可以匹配到 200，300
;/\d+(?!元)/g // 正向否定预查询：可以匹配到 400, 500

// 如果有数据为：￥200，￥300，$400，$500
;/\d+(?&lt;=￥)/g // 反向肯定预查询：可以匹配到 200，300
;/\d+(?&lt;!￥)/g // 反向否定预查询：可以匹配到 400, 500
</code></pre>
<h3 id="35-常用格式校验"><a class="header" href="#35-常用格式校验">3.5 常用格式校验</a></h3>
<pre><code class="language-js">// 账号校验：必须由字母、数组、下划线构成，并且以字母开头，4-16 位
;/^[a-zA-Z]\w{3, 15}$/g

// 手机号校验：11 位，1 开头，3578 为第 2 位
/^1[3|5|7|*|9]\d{9}/g

// 身份证号校验:18 位前 17 是数字，最后一位可以是数字或者 x/X,15 位全是数字
/^(\d{15}$)|(^\d{18}$)\(^\d{17}(\d|X|x))/g

// 邮箱校验：第一部分 @第二部分.com|cn|net
/^[a-zA-Z0-9-._]+[@][a-zA-Z0-9-._]+\.(com|cn|net)/g
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-基本类型-symbol"><a class="header" href="#111-基本类型-symbol">11.1-基本类型-Symbol</a></h1>
<h2 id="一-symbol-类型基本使用"><a class="header" href="#一-symbol-类型基本使用">一 Symbol 类型基本使用</a></h2>
<p>Symbol(符号) 是 ES6 新增的基本数据类型，其实例是<strong>唯一、不可变的</strong>，其用途是确保对象属性使用唯一标识符，不发生属性冲突！</p>
<p>贴士：Symbol 并不能用来作为创建对象的私有属性，因为 Object API 提供了获取 Symbol 属性的方法，且 ES 未来方案已经规定 <code>#</code> 符号表示私有属性。</p>
<p>创建 Symbol 类型：</p>
<pre><code class="language-js">// 直接创建
let s1 = Symbol()
console.log(typeof s1) // symbol
let s2 = Symbol()
console.log(typeof s2) // symbol

// 传入一个字符串参数描述，这个字符串只是一个描述，用来提供调试帮助，没有其他意义
let s3 = Symbol('demo3')
console.log(typeof s3) // symbol
let s4 = Symbol('demo4')
console.log(typeof s4) // symbol

// 甚至可以传入对象
let s5 = Symbol({ name: 'lisi' })

// 任意两个 Symbol 都不相等
console.log(s1 == s2) // false
console.log(s3 == s4) // false
</code></pre>
<p>注意：Symbol 类型是值类型，其没有对应包装对象！而数值、布尔等都有包装类型，如：Number()、Boolean()，这种包装类型与 Symbol 并不是一回事。所以 Symbol 不能使用 <code>new</code>进行构造，会报错：<code>Symbol is not a constructor</code>。如果要强行使用符号包装对象，可以使用 Object 函数：</p>
<pre><code class="language-js">let s = Symbol()
let sObj = Object(s)
</code></pre>
<h2 id="二-symbol-作用示例"><a class="header" href="#二-symbol-作用示例">二 Symbol 作用示例</a></h2>
<h3 id="21-symbol-控制对象属性唯一"><a class="header" href="#21-symbol-控制对象属性唯一">2.1 Symbol 控制对象属性唯一</a></h3>
<p>任意两个 Symbol 都不相等，利用该特性可以解决一些实际问题。比如两个对象都要对一个对象进行属性插入，插入的属性的 key 名称相同，那么就会引发问题，有了 Symbol 就可以解决：</p>
<pre><code class="language-js">let obj = {
  name: 'zs',
  [Symbol('category')]: '食品',
}

// 再添加一个 category 分类
obj[Symbol('category')] = '西餐'
console.log(obj) // {name: &quot;zs&quot;, Symbol(category): &quot;食品&quot;, Symbol(category): &quot;西餐&quot;}

// Symbol 属性需要使用特殊的获取方式
console.log(Object.getOwnPropertySymbols(obj)) // [Symbol(category), Symbol(category)]
console.log(Reflect.ownKeys(obj)) //[&quot;name&quot;, Symbol(category), Symbol(category)]
</code></pre>
<h3 id="22-symbol-控制对象属性无法访问"><a class="header" href="#22-symbol-控制对象属性无法访问">2.2 Symbol 控制对象属性无法访问</a></h3>
<pre><code class="language-js">let users = {
  lisi: '30 岁，前端工程师',
  lisi: '24 岁，设计师',
}

// 这 2 个人的名字一样
console.log(users.lisi) // 24 岁，设计师
</code></pre>
<p>如果要继续采用上述的书写格式：</p>
<pre><code class="language-js">let user1 = {
  name: 'lisi',
  key: Symbol(),
}

let user2 = {
  name: 'lisi',
  key: Symbol(),
}

let userInfo = {
  [user1.key]: '30 岁，前端工程师',
  [user2.key]: '24 岁，设计师',
}
</code></pre>
<p>使用 Symbol 来控制对象中的成员无法被访问：</p>
<pre><code class="language-js">const DATA = Symol();
const user = {
  [DATA]: {name},
  set name(v) {
    this[DATA].name = v;
  }
  get name(){
    return this[DATA].name;
  }
}
</code></pre>
<h2 id="三-symbol-作为对象属性"><a class="header" href="#三-symbol-作为对象属性">三 Symbol 作为对象属性</a></h2>
<p>如果对象的属性是 symbol 类型，那么推荐使用反射方式获取：</p>
<pre><code class="language-js">let s = Symbol()

let p = {
  name: 'lisi',
  [s]: '隐藏属性',
}

// 使用 for in 或者 for of遍历：无法遍历到 [s] 成员
// for (const key in p){}
// for (const key of Object.keys(p)){}

// 使用 Object.getOwnPropertySymbols(p) ：只能遍历到 Symbol 类型属性
// for(const key of Object.getOwnPropertySymbols(p)){}

// 使用Reflect.ownKeys(p)： 遍历所有属性
for (const key of Reflect.ownKeys(p)) {
  console.log(key) // name  Symbol()
}
</code></pre>
<h3 id="四-symbol-常用属性"><a class="header" href="#四-symbol-常用属性">四 Symbol 常用属性</a></h3>
<h3 id="41-symbolfor-全局符号注册表"><a class="header" href="#41-symbolfor-全局符号注册表">4.1 Symbol.for() 全局符号注册表</a></h3>
<p>先看示例：</p>
<pre><code class="language-js">let s1 = Symbol.for('foo')
let s2 = Symbol.for('foo')
console.log(s1 === s2) // true

let s3 = Symbol('foo')
console.log(s1 === s3) // false
</code></pre>
<p>通过 Symbol.for() 创建的 Symbol 会注册到一个全局表中，这个全局表内的数据可以通过 Symbol.keyFor() 查询到：</p>
<pre><code class="language-js">let s1 = Symbol.for('foo')
console.log(Symbol.keyFor(s1)) // foo

let s2 = Symbol('bar')
console.log(Symbol.keyFor(s2)) // undefined，如果传递的参数不是符号，则报错
</code></pre>
<p>全局注册表使用场景：运行时候的不同部分需要共享和重用符号，则可以使用一个相同的字符串作为键，在全局符号注册表中创建该符号。</p>
<h3 id="42-symbolhasinstance"><a class="header" href="#42-symbolhasinstance">4.2 Symbol.hasInstance</a></h3>
<p>类似关键字 instanceof，Symbol.hasInstance 用来检查对象在其原型链上是否存在原型：</p>
<pre><code class="language-js">class Foo {}

let f = new Foo()

// 检查 f 实例的原型链上是否有 Foo
console.log(Foo[Symbol.hasInstance](f)) // true
</code></pre>
<p>不过要注意静态修饰符：</p>
<pre><code class="language-js">class Foo {}

class Fov extends Foo {
  static [Symbol.hasInstance]() {
    return false
  }
}

let f = new Fov()

console.log(Foo[Symbol.hasInstance](f)) // true
console.log(f instanceof Foo) // true
console.log(Fov[Symbol.hasInstance](f)) // false
console.log(f instanceof Fov) // false
</code></pre>
<h3 id="43-symbolasynciterator"><a class="header" href="#43-symbolasynciterator">4.3 Symbol.asyncIterator</a></h3>
<p>Symbol.asyncIterator 是 ES2018 中实现异步迭代器 API 的函数，返回对象默认的 AsyncIterator，由 for-await-of 语句使用：</p>
<pre><code class="language-js">class Foo {
  async *[Symbol.asyncIterator]() {}
}

let f = new Foo()
console.log(f[Symbol.asyncIterator]()) //AsyncGenerator {&lt;suspended&gt;}
</code></pre>
<p>由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回 Promise 实例。可以通过显式地调用 next()方法返回，也可以隐式地通过异步生成器函数返回：</p>
<pre><code class="language-js">class Emitter {
  constructor(max) {
    this.max = max
    this.asyncIdx = 0
  }
  async *[Symbol.asyncIterator]() {
    while (this.asyncIdx &lt; this.max) {
      yield new Promise((resolve) =&gt; resolve(this.asyncIdx++))
    }
  }
}
async function asyncCount() {
  let emitter = new Emitter(5)
  for await (const x of emitter) {
    console.log(x)
  }
}
asyncCount() // 0 1 2 3 4
</code></pre>
<h3 id="44-symboliterator"><a class="header" href="#44-symboliterator">4.4 Symbol.iterator</a></h3>
<p>Symbol.iterator 用于返回对象默认的 Iterator，由 for-of 使用：</p>
<pre><code class="language-js">class Foo {
  *[Symbol.iterator]() {}
}
let f = new Foo()
console.log(f[Symbol.iterator]()) // Generator {&lt;suspended&gt;}
</code></pre>
<p>由 Symbol.iterator 函数生成的对象应该通过其 next()方法陆续返回值，可以通过显式调用 next()方法返回，也可以隐式地通过生成器函数返回：</p>
<pre><code class="language-js">class Emitter {
  constructor(max) {
    this.max = max
    this.idx = 0
  }
  *[Symbol.iterator]() {
    while (this.idx &lt; this.max) {
      yield this.idx++
    }
  }
}
function count() {
  let emitter = new Emitter(5)
  for (const x of emitter) {
    console.log(x)
  }
}
count() // 0 1 2 3 4
</code></pre>
<h3 id="45-symbolspecies"><a class="header" href="#45-symbolspecies">4.5 Symbol.species</a></h3>
<p>Symbol.species 是创建派生对象的构造函数，这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用 Symbol.species 定义静态的获取器（ getter）方法，可以覆盖新创建实例的原型定义：</p>
<pre><code class="language-js">class Bar extends Array {}

class Baz extends Array {
  static get [Symbol.species]() {
    return Array
  }
}

let bar = new Bar()
console.log(bar instanceof Array) // true
console.log(bar instanceof Bar) // true
bar = bar.concat('bar')
console.log(bar instanceof Array) // true
console.log(bar instanceof Bar) // true

let baz = new Baz()
console.log(baz instanceof Array) // true
console.log(baz instanceof Baz) // true
baz = baz.concat('baz')
console.log(baz instanceof Array) // true
console.log(baz instanceof Baz) // false
</code></pre>
<h3 id="46-symboltoprimitive"><a class="header" href="#46-symboltoprimitive">4.6 Symbol.toPrimitive</a></h3>
<p>Symbol.toPrimitive 可以将对象转换为相应的原始值。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的 Symbol.toPrimitive 属性上定义一个函数可以改变默认行为。</p>
<pre><code class="language-js">class Foo {}
let foo = new Foo()
console.log(3 + foo) // &quot;3[object Object]&quot;
console.log(3 - foo) // NaN
console.log(String(foo)) // &quot;[object Object]&quot;
class Bar {
  constructor() {
    this[Symbol.toPrimitive] = function (hint) {
      switch (hint) {
        case 'number':
          return 3
        case 'string':
          return 'string bar'
        case 'default':
        default:
          return 'default bar'
      }
    }
  }
}

let bar = new Bar()
console.log(3 + bar) // &quot;3default bar&quot;
console.log(3 - bar) // 0
console.log(String(bar)) // &quot;string bar&quot;
</code></pre>
<h3 id="47-symboltostringtag"><a class="header" href="#47-symboltostringtag">4,7 Symbol.toStringTag</a></h3>
<p>Symbol.toStringTag 用于创建对象的默认字符串描述。通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为&quot;Object&quot;。内置类型已经指定了这个值，但自定义类实例还需要明确定义：</p>
<pre><code class="language-js">let s = new Set()
console.log(s) // Set(0) {}
console.log(s.toString()) // [object Set]
console.log(s[Symbol.toStringTag]) // Set

class Foo {}
let foo = new Foo()
console.log(foo) // Foo {}
console.log(foo.toString()) // [object Object]
console.log(foo[Symbol.toStringTag]) // undefined

class Bar {
  constructor() {
    this[Symbol.toStringTag] = 'Bar'
  }
}
let bar = new Bar()
console.log(bar) // Bar {}
console.log(bar.toString()) // [object Bar]
console.log(bar[Symbol.toStringTag]) // Bar
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="01-语法更迭--1-js-设计缺陷"><a class="header" href="#01-语法更迭--1-js-设计缺陷">01-语法更迭 -1-JS 设计缺陷</a></h1>
<h2 id="一-javascript-语言精粹"><a class="header" href="#一-javascript-语言精粹">一 JavaScript 语言精粹</a></h2>
<p>JavaScript 是一门诞生仓促的语言，他的诞生源自于网景公司要创造一门类似 Java 但是又足够简单的页面脚本语言，这个决策实际上将当时的 Perl、Python、Tcl、Scheme 等语言都排除在外了，而当时正在大肆推广的 Java 公司也与网警公司搭线在了一起，但是 Java 过于庞大，偏偏作者 Brendan Eich 本人对 Java 毫无兴趣，所以诞生了现在的 JS。</p>
<p>他的设计思路是这样的：</p>
<ul>
<li>借鉴 C 语言的基本语法;</li>
<li>借鉴 Java 语言的数据类型和内存管理;</li>
<li>借鉴 Scheme 语言，将函数提升到&quot;第一等公民&quot;(first class) 的地位;</li>
<li>借鉴 Self 语言，使用基于原型 (prototype) 的继承机制。</li>
</ul>
<p>Brendan Eich 一点也不喜欢自己的这个作品：&quot;与其说我爱 Javascript，不如说我恨它。它是 C 语言和 Self 语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：'它的优秀之 处并非原创，它的原创之处并不优秀。</p>
<p>JavaScript 也有其优雅的地方：</p>
<ul>
<li>函数是顶级对象，是拥有词法作用域的闭包；</li>
<li>基于原型的继承系统，让对象可以通过普通赋值，添加任意一个新成员，或者从另外一个对象继承其成员属性；</li>
<li>对象字面量、数组字面量使用起来非常方便。</li>
</ul>
<h2 id="二-javascript-的毒瘤"><a class="header" href="#二-javascript-的毒瘤">二 JavaScript 的毒瘤</a></h2>
<p>针对一些毒瘤设计，需要准备对应的应对措施。</p>
<h3 id="21-依赖全局变量"><a class="header" href="#21-依赖全局变量">2.1 依赖全局变量</a></h3>
<p>大多语言都有全局变量的设定，比如 Java 中的 <code>public static</code> 属性前缀修饰的变量，编程中允许使用全局变量没有问题。但是 JavaScript 还会依赖全局变量，由于没有链接器（linker），所有的编译单元都会载入一个公共全局对象中。</p>
<p>在微小的程序中，这没有问题，但是在大型程序中，全局变量使得在同一个程序中运行的子程序可靠性降低，如：全局变量名碰巧与子程序的变量名相同。</p>
<p>三种定义全局变量的方式：</p>
<pre><code class="language-js">var foo = 'bar1'
window.foo = 'bar2'
foo = 'bar3'

console.log(foo) //bar3
</code></pre>
<p>第三种方式的本意是让定义变量更加方便，但是忘记预先声明，成为了全局变量，会让 bug 追踪变得非常困难。</p>
<h3 id="22-作用域"><a class="header" href="#22-作用域">2.2 作用域</a></h3>
<p>JavaScript 语法来自于 C，所以一个代码块会创造一个作用域，代码块内的变量在包含此代码块的函数的任何位置都是可见的。所以 JavaScript 没有块级作用域！这会导致大量的 Bug：</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  setTimeout(function () {
    console.log(i) // 每次都输出 10，而不是输出在当时循环时的 i 的真实大小
  }, 0)
}
</code></pre>
<p>为了避免上述错误，必须引入自执行函数，以实现作用域的限定：</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  ;(function (i) {
    setTimeout(function () {
      console.log(i)
    }, 0)
  })(i)
}
</code></pre>
<p><strong>这在 ES6 中通过箭头函数方式得到了解决！</strong></p>
<h3 id="23-自动插入分号"><a class="header" href="#23-自动插入分号">2.3 自动插入分号</a></h3>
<p>JavaScript 会自动插入未补足的分号，来修复源码，但是这样很容易造成错误：</p>
<pre><code class="language-js">return // 此处分号不写，自动插入后就会让后续代码无效
{
  status: true
}
</code></pre>
<p>我们应该避免这种写法，规范的写法是：</p>
<pre><code class="language-js">return {
  status: true;
}
</code></pre>
<h3 id="24-unicode-支持"><a class="header" href="#24-unicode-支持">2.4 Unicode 支持</a></h3>
<p>JavaScript 诞生时，Unicode 预期只有 65536 个字符，但是现在却有了百万个，JavaScript 的字符是 16 位的，在满足最初的 65536 个字符后，还需要用一对字符的形式来表示剩余的 Unicode 字符。但是：Unicode 把一对字符视为一个单一字符，而 JavaScript 认为一对字符是两个不同的字符。</p>
<h3 id="25-typeof-检查"><a class="header" href="#25-typeof-检查">2.5 typeof 检查</a></h3>
<p><code>typeof</code> 检测能力极度糟糕：</p>
<pre><code class="language-js">type of null;           // 返回的是 object 而不是 null
type of [1,2,3];        // 返回的是 object，无法识别到是数组
</code></pre>
<p>判断数组的正确方式是利用其构造函数：</p>
<pre><code class="language-js">function isArray(arr) {
  if (arr &amp;&amp; typeof arr === 'object' &amp;&amp; arr.constructor === Array) {
    return true
  } else {
    return false
  }
}
</code></pre>
<p>对于在不同窗口创建的数组，上述函数会返回 false，下面的检测更可靠：</p>
<pre><code class="language-js">function isArray(arr) {
  if (Object.prototyoe.toString.apply(arr) === '[object Array]') {
    return true
  } else {
    return false
  }
}
</code></pre>
<h3 id="26--运算符"><a class="header" href="#26--运算符">2.6 + 运算符</a></h3>
<p><code>+</code> 运算符同时也可以用来作为字符串连接使用，这里很容易在做运算时候出现 Bug，应该确保两个运算数都是整数。</p>
<h3 id="27-01--02--03"><a class="header" href="#27-01--02--03">2.7 0.1 + 0.2 != 0.3</a></h3>
<p>这并不是 JavaScript 的错误，而是遵循了二进制浮点算术标准（IEEE 754）的编程语言都会存在 <code>0.1 + 0.2 != 0.3</code> 的现象。这个错误可以通过指定精度来避免。</p>
<h3 id="28-nanundefined"><a class="header" href="#28-nanundefined">2.8 NaN、undefined</a></h3>
<p>Nan 也是 IEEE 754 中定义的一个特殊的数值，表示其不是一个数字，但是：</p>
<pre><code class="language-js">typeof NaN === 'number' // true
</code></pre>
<p>而且 NaN 还有以下崩溃的现象：</p>
<pre><code class="language-js">console.log(NaN === NaN) // false
console.log(NaN !== NaN) // true
</code></pre>
<p>JavaScript 提供了很多函数来判断是否是数字，如 <code>isNaN()</code>， <code>isFinite()</code> 还会筛除 NaN 和 Infinity，但是该函数在遇到非数字时，会将其转换为数字。。。</p>
<p>最佳判断是否是数字的函数：</p>
<pre><code class="language-js">function isNumber(num) {
  return typeof num === 'number' &amp;&amp; isFinite(num)
}
</code></pre>
<p>在 IE8 及之前的浏览器中，NaN 和 undefined 都可以被重新赋值，这很容易引起错误，比如使用 <code>item == null</code> 来判断成员是否不在对象中，但是 ES5 中，规定 NaN 和 undefined 都为常量不能更改，这个问题得到了解决。</p>
<h3 id="29-hasownproperty-方法可以被替换"><a class="header" href="#29-hasownproperty-方法可以被替换">2.9 hasOwnProperty() 方法可以被替换</a></h3>
<p>如果一个对象的 <code>hasOwnProperty()</code> 被替换，甚至设置为 null，则会在对象使用中引发很多问题。</p>
<h3 id="210-没有空对象"><a class="header" href="#210-没有空对象">2.10 没有空对象</a></h3>
<p>JavaScript 的对象永远不会是真正的空对象，因为其可以从原型链中获得成员。在一定场景，这会带来麻烦，比如计算文本中每个单词出现的次数：</p>
<pre><code class="language-js">function count(text) {
  var word = ''
  var wordArr = text.toLowerCase().split(/[\s,.]+/)
  var count = {}
  for (var i = 0; i &lt; wordArr.length; i++) {
    word = wordArr[i]
    if (count[word]) {
      count[word] += 1
    } else {
      count[word] = 1
    }
  }
  return count
}

var text = 'Constructor is'

console.log(count(text)) // { constructor: 'function Object() { [native code] }1', is: 1 }
</code></pre>
<p>上述现象的原因是：count 对象继承自 Object.prototype，这个对象内部包含着一个名为 constructor 的成员对象，值为 Object。
<code>+=</code> 运算符执行的结果不是做假发，而是转换为了字符串。</p>
<p>应该额外这样处理：</p>
<pre><code class="language-js">if (typeof count[word] === 'number') {
}
</code></pre>
<h2 id="三-javascript-的毒瘤补充"><a class="header" href="#三-javascript-的毒瘤补充">三 JavaScript 的毒瘤补充</a></h2>
<h3 id="31-尽量使用全等于"><a class="header" href="#31-尽量使用全等于">3.1 尽量使用全等于</a></h3>
<p><code>==</code> 和 <code>!=</code> 在比较数据时，如果二者数据类型不一致，则会强制进行数据类型转换，往往会造成意想不到的结果。<code>===</code> 和 <code>!==</code> 则不会存在该情况。</p>
<h3 id="32-with-语句问题"><a class="header" href="#32-with-语句问题">3.2 with 语句问题</a></h3>
<p>with 语句用来边界访问对象成员：</p>
<pre><code class="language-js">with (obj) {
  a = b
}
</code></pre>
<p>其本质是：</p>
<pre><code class="language-js">if (obj.a === undefined) {
  a = obj.b === undefiend ? b : obj.b
} else {
  obj.a = obj.b === undefined ? b : obj.b
}
</code></pre>
<p>等于下列语句中的一条：</p>
<pre><code class="language-js">a = b
a = obj.b
obj.a = b
obj.a = obj.b
</code></pre>
<p>with 语句往返准确的判断出程序要做的结果，影响了 JS 的运算速度。应该去除！</p>
<h3 id="33-eval-问题"><a class="header" href="#33-eval-问题">3.3 eval() 问题</a></h3>
<p>eval() 函数会显著降低性能，也会让代码检查软件 ESLint 等失效。此外，该函数还会降低安全性，文本会被赋予很多权力。</p>
<p>同理，setTimeout 和 setInterval 函数的参数如果是字符串，也会按照 eval 的形式进行处理，应该避免使用字符串作为参数。</p>
<h3 id="34-switch-穿越"><a class="header" href="#34-switch-穿越">3.4 switch 穿越</a></h3>
<p>除非能够明确的中断流程，每次都应该在条件判断后穿越到下一个 case 条件，以降低出错的概率。</p>
<h3 id="35-块语法简写造成的问题"><a class="header" href="#35-块语法简写造成的问题">3.5 块语法简写造成的问题</a></h3>
<p>简写的代码：</p>
<pre><code class="language-js">if (ok) flag = true
fn()
</code></pre>
<p>上述代码可能有多种表达意思：</p>
<pre><code class="language-js">// 可能的意思
if (ok) {
  flag = true
  fn()
}

// 可能的意思
if (ok) {
  flag = true
}
fn()
</code></pre>
<p>类似的简写还有 <code>++</code> <code>--</code> 等多次执行写在一行，这种行为，恕我直言，不可饶恕。</p>
<p><strong>笔者与《JavaScript 语言精粹》作者看法一致，对这种简写行为深恶痛绝，语言就应该见名知意，统一标准，严格遵循</strong>！以至于在 Golang 出现时，发现 Golang 有强制换行、干掉三元运算符等做法，甚为宽慰。</p>
<h3 id="36-函数定义的建议"><a class="header" href="#36-函数定义的建议">3.6 函数定义的建议</a></h3>
<p>函数推荐使用表达式形式：</p>
<pre><code class="language-js">var fn = function () {}
</code></pre>
<p>function 语句在解析时会被提升，放宽了函数必须先声明后使用的要求，这会导致一定的混乱，而且不同浏览器之间处理可能也有不同。</p>
<h3 id="37-void-在-js-中是运算符"><a class="header" href="#37-void-在-js-中是运算符">3.7 void 在 JS 中是运算符</a></h3>
<p>void 在大多语言中，代表没有值，或者代表函数没有返回值，而在 JS 中，void 是一个运算符，它接受一个运算数并返回 undefined。应该避免使用该标识符。</p>
<h3 id="38-new"><a class="header" href="#38-new">3.8 new</a></h3>
<p>JavaScript 中可以对类型进行包装：</p>
<pre><code class="language-js">new Boolean(false)
</code></pre>
<p>这在 JS 中完全没有必要，同时也要避免 <code>new Object()</code>、<code>new Array()</code> 的使用，直接用 <code>{}</code>、<code>[]</code> 不香吗。</p>
<p>new 关键字在创建对象上时，其实是创建了一个继承了原对象原型的新对象，并为新建的对象绑定 this，如果忘记使用 new 运算符，得到的会是一个普通的函数调用，并且 this 被绑定到了全局对象上，而不是新建对象上。这就意味着你的函数尝试去初始化新成员时，会污染全局变量！！！！为了尽量减少 没有写 new 的误操作，一般约定 构造函数用大写字母开头方式命名，以更显眼，但是这仍然无法真正避免。。。最好的办法是：尽量不使用 new。</p>
<h2 id="四-人生很美好"><a class="header" href="#四-人生很美好">四 人生很美好</a></h2>
<p>美好人生的示例：</p>
<pre><code class="language-js">var arr1 = []
var arr2 = []

console.log(arr1 &gt;= arr2) // true
console.log(arr1 &lt;= arr2) // true
console.log(arr1 == arr2) // false

console.log(null &gt;= false) // true
console.log(null &lt;= false) // true
console.log(null == false) // false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-语法更迭--2-严格模式"><a class="header" href="#01-语法更迭--2-严格模式">01-语法更迭 -2-严格模式</a></h1>
<h2 id="一-严格模式概念"><a class="header" href="#一-严格模式概念">一 严格模式概念</a></h2>
<p>严格模式（strict mode）是 ES5 引入的概念，使用方式是在 JS 代码顶部添加如下代码：</p>
<pre><code class="language-js">'use strict'
</code></pre>
<p>也可以单独指定函数在严格模式下执行：</p>
<pre><code class="language-js">function fn() {
  'use strict'
}
</code></pre>
<p>在严格模式下，ES3 中的一些不确定行为会得到处理，一些不安全的操作也会被抛出。</p>
<p>支持严格模式的浏览器有：IE10+、Firefox4+、Chrome、Safari5.1+等。</p>
<h2 id="二-严格模式下的变化"><a class="header" href="#二-严格模式下的变化">二 严格模式下的变化</a></h2>
<h3 id="21-变量"><a class="header" href="#21-变量">2.1 变量</a></h3>
<p>严格模式不再允许没有 var 创建全局变量，会产生 ReferenceError：</p>
<pre><code class="language-js">'use strict'

msg = 'helloworld'
</code></pre>
<p>严格模式不能对变量使用 delete 操作符，使用后会导致错误（非严格模式下会返回 false）。</p>
<p>严格模式下的变量名，不能使用这些关键字、保留字：<code>implements</code>、 <code>interface</code>、 <code>let</code>、 <code>package</code>、<code>private</code>、 <code>protected</code>、 <code>public</code>、 <code>static</code>、<code>yield</code>。</p>
<p>严格模式也不能使用 <code>eval</code>、<code>arguments</code>作为标识符，但是在非严格模式下可以重写 eval，也可以给 arguments 赋值。</p>
<h3 id="22-对象"><a class="header" href="#22-对象">2.2 对象</a></h3>
<p>严格模式下的下列对象操作会导致错误：</p>
<ul>
<li>为只读属性赋值会抛出 TypeError；</li>
<li>对不可配置的（nonconfigurable）的属性使用 delete 操作符会抛出 TypeError；</li>
<li>为不可扩展的（nonextensible）的对象添加属性会抛出 TypeError</li>
</ul>
<p>严格模式下使用字面量创建对象，其属性名必须唯一！</p>
<h3 id="23-函数"><a class="header" href="#23-函数">2.3 函数</a></h3>
<p>严格模式下，参数必须唯一，以下函数会抛出语法错误：</p>
<pre><code class="language-js">function sum(num, num) {}
</code></pre>
<p>上述函数在非严格模式下，num 参数名只能访问到第二个参数，第一个参数必须通过 arguments 对象访问。</p>
<p>严格模式下淘汰了：<code>arguments.callee</code>，<code>arguments.caller</code>。</p>
<p>严格模式中，if 语句内部声明函数会导致语法错误！</p>
<h3 id="24-eval"><a class="header" href="#24-eval">2.4 eval()</a></h3>
<p>eval() 函数在严格模式下不会在上下文中创建变量、函数：</p>
<pre><code class="language-js">function show() {
  'use strict'

  eval('var x = 10')
  console.log(x) // ReferenceError，因为 x 未定义，但是非严格模式下则会获取到变量 x
}
</code></pre>
<p>不过要注意的是 eval 中的数据仍然可以被返回：</p>
<pre><code class="language-js">'use strict'
var result = eval('var x=10, y=11; x+y')
console.log(result) // 12
</code></pre>
<h3 id="25-限制-this"><a class="header" href="#25-限制-this">2.5 限制 this</a></h3>
<p>在严格模式下，this 的值始终是指定的值：</p>
<pre><code class="language-js">'use strict'

var color = 'red'

function showColor() {
  console.log(this.color)
}

// 非严格模式下：this 访问全局属性
// 严格模式下：this 被指定为了 null，报错
showColor.call(null)
</code></pre>
<p>贴士：ES6 的新语法中，class 默认就会限制 this，即使没有严格模式：</p>
<pre><code class="language-js">class Person {
  show() {
    function test() {
      console.log(this) // undefined
    }
    test()
  }
}
</code></pre>
<h3 id="26-放弃-with-语句"><a class="header" href="#26-放弃-with-语句">2.6 放弃 with 语句</a></h3>
<p>严格模式下 with 语句不再被支持！</p>
<h3 id="27-八进制字面量无效"><a class="header" href="#27-八进制字面量无效">2.7 八进制字面量无效</a></h3>
<p>严格模式下，八进制字面量是无效的：</p>
<pre><code class="language-js">var num = 010 // 被当做了十进制
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-语法更迭--3-es6-的改进"><a class="header" href="#01-语法更迭--3-es6-的改进">01-语法更迭 -3-ES6 的改进</a></h1>
<h2 id="一-letconst-声明与块级作用域"><a class="header" href="#一-letconst-声明与块级作用域">一 let/const 声明与块级作用域</a></h2>
<p>这是 ES6 核心变化之一，在 01 章，09 节中已经介绍。</p>
<h2 id="二-箭头函数的使用"><a class="header" href="#二-箭头函数的使用">二 箭头函数的使用</a></h2>
<h3 id="21-箭头函数声明"><a class="header" href="#21-箭头函数声明">2.1 箭头函数声明</a></h3>
<p>为了解决 ES5 的调用者对象变更问题，ES6 推出了箭头函数：</p>
<pre><code class="language-js">let add = (a) =&gt; {
  return a + 3
}
console.log(add(5)) //函数体只有一句 return，大括号可省略
</code></pre>
<p>参数只有一个时，可以省略参数括号 (不推荐，笔者认为失去了可读性！)，函数体只有一行时可以省略大括号，默认将数据 return 出来：</p>
<pre><code class="language-js">let fn = (a) =&gt; a++
</code></pre>
<p>贴士：箭头函数只能替换函数表达式，即 var/let/const 声明的函数，而不能用来定义函数。</p>
<h3 id="21-this-绑定"><a class="header" href="#21-this-绑定">2.1 this 绑定</a></h3>
<p>在 function 中，this 取决于谁调用，this 是可以变化的，在箭头函数中 this 取决于所处环境，比如 window/在某个对象内等，this 是恒定的。</p>
<p>function 示例：</p>
<pre><code class="language-js">var name = 'Tom'

var getName = function () {
  console.log(this.name)
}

var p = {
  name: 'Alex',
  getName: getName,
}

var other = {
  name: 'Jerry',
}

// function 声明的函数，this 为调用者
p.getName() // Alex  this 就是 p
getName.call(other) // Jerry call 修改了 this 为 other
</code></pre>
<p>但是在箭头函数中：</p>
<pre><code class="language-js">var name = 'Tom'

var getName = () =&gt; {
  console.log(111111)
  console.log(this.name)
}

var p = {
  name: 'Alex',
  getName: getName,
}

var other = {
  name: 'Jerry',
}

// 箭头函数的 this 是其当初定义时候的实例：window
p.getName() // Jerry
getName.call(other) // Jerry
</code></pre>
<p>也就是说箭头函数中的 this，就是声明函数时所处上下文中的 this，不会被其他方式改变。</p>
<p>贴士：上述示例不要使用 let 声明变量，因为 let 声明的变量不会绑定到 window 中，造成演示失败！</p>
<h3 id="23-箭头函数没有-arguments"><a class="header" href="#23-箭头函数没有-arguments">2.3 箭头函数没有 arguments</a></h3>
<p>注意：箭头函数中没有 arguments 对象。
ES6 提供了许多写法上的改进，开发体验获得了极大提升！</p>
<h3 id="三-字符串模板"><a class="header" href="#三-字符串模板">三 字符串模板</a></h3>
<pre><code class="language-js">let json = { name: 'lisi', age: '18' }
console.log(`我是：${json.name}`)
</code></pre>
<h3 id="四-解构赋值"><a class="header" href="#四-解构赋值">四 解构赋值</a></h3>
<pre><code class="language-js">const tom = {
  name: 'zs',
  age: 13,
}

let { name, age } = tom

//相当于下面的简写
// let {name: name, age: age} = tom;
</code></pre>
<p>若存在变量找不到的情况，可以指定默认值：</p>
<pre><code class="language-js">let { name = 'Jack', age } = tom
</code></pre>
<p>变量也可以重新命名：</p>
<pre><code class="language-js">let { name: n, age } = tom
</code></pre>
<p>嵌套的数据也可以解构：</p>
<pre><code class="language-js">const p = {
    info: {
        age: 10,
        name: 'zs;
    }
}

let {detail: {info} } = p;
</code></pre>
<p>数组也可以进行解构，不过值和序号要一一对应：</p>
<pre><code class="language-js">const arr = [1, 2, 3]
const [a, b, c] = arr
</code></pre>
<h2 id="五--展开运算符"><a class="header" href="#五--展开运算符">五 <code>...</code> 展开运算符</a></h2>
<p>展开运算符（剩余操作符）在数组中使用：</p>
<pre><code class="language-js">const arr1 = [1, 2, 3]
console.log(...ar1) //  1 2 3
const arr2 = [...arr1, 4, 5, 6] // [1,2,3,4,5,6]
</code></pre>
<p>展开运算符在解构赋值中使用：</p>
<pre><code class="language-js">const tom = {
  name: 'TOM',
  age: 20,
  job: 'teacher',
}

const { name, ...others } = tom // others = {age: 20, job:'teacher'}
</code></pre>
<p>展开运算符代替 arguments 参数将伪数组转换为真数组：</p>
<pre><code class="language-js">let divs = document.querySelectorAll('div')
let realArr = [...divs]
</code></pre>
<p>ES 新标准中，剩余操作符可以在解构对象时将所有剩下未指定的可枚举属性收集到一个对象中：</p>
<pre><code class="language-js">const person = { name: 'Matt', age: 27, job: 'Engineer' }
const { name, ...remainingData } = person
console.log(name) // Matt
console.log(remainingData) // { age: 27, job: 'Engineer' }
</code></pre>
<h2 id="六-获取实参-reset-参数"><a class="header" href="#六-获取实参-reset-参数">六 获取实参 reset 参数</a></h2>
<p>reset 参数用来获取获取函数的实参，可以代替 arguments，不过要注意的是，如果参数是多个，展开符必须在最后：</p>
<pre><code class="language-js">function fn(num, ...args) {
  console.log(args)
}

fn(1, 'a', { id: 23 }) // [ 'a', { id: 23 } ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-基类-object-基本使用"><a class="header" href="#021-基类-object-基本使用">02.1-基类 Object-基本使用</a></h1>
<h2 id="一-object-类型"><a class="header" href="#一-object-类型">一 Object 类型</a></h2>
<h3 id="11-object-类实例的创建"><a class="header" href="#11-object-类实例的创建">1.1 Object 类实例的创建</a></h3>
<p>Object 是 ECMAScript 所有引用类型的祖先，即基类（基本类）。</p>
<p>创建方式：</p>
<pre><code class="language-js">// 构造函数方式：有效不推荐该方式
let obj1 = new Object()
console.log(typeof obj1) // object

let obj2 = new Object()
console.log(obj1 == obj2) // false

// 字面量方式
let obj = {}
console.log(obj1 == obj) // false
</code></pre>
<p>基于 Object 类型还有一些衍生的引用类型，如：Array、Function、Date、Math 等。所以 Object 与 Java 中的 java.lang.Object 类非常相似，也是派生其他对象的<code>基类</code>，即是所有类的祖先！</p>
<h3 id="12-object-对象的成员"><a class="header" href="#12-object-对象的成员">1.2 Object 对象的成员</a></h3>
<p>由于 Object 对象是所有对象的祖先对象（基类），所以其属性和方法，其他对象都会拥有：</p>
<ul>
<li><code>constructor</code>属性：保存当前对象的构造函数</li>
<li><code>hasOwnProperty(propStr) 方法</code>：检测实例对象是否包含该属性用于检查给定的属性（不会检测原型中的属性）</li>
<li><code>isPrototypeOf(protoObj) 方法</code>：检测当前对象是否是传入的原型对象</li>
<li><code>propertyIsEnumerable(propStr)</code>：检测传入的参数属性是否能够被 for-in 枚举到。</li>
<li><code>toString()</code>：返回对象的字符串表示。</li>
<li><code>valueOf()</code>：返回对象的字符串、数值或布尔值表示</li>
<li><code>getPrototypeOf(obj)</code>：返回 obj 实例对应构造函数的原型</li>
</ul>
<p>从上看出，<strong>Object 主要用来处理对象相关的操作</strong>。一般通过<strong>点语法</strong>来使用成员，但也可以使用中括号：</p>
<pre><code class="language-js">let obj = { name: 'zs' }
console.log(obj['name']) // &quot;zs&quot;
console.log(obj.name) // &quot;zs&quot;

// 中括号的优势是可以使用变量访问属性，也可以在属性名存在保留字关键字、存在语法错误时使用：
let propertyName = 'name'
console.log(obj[propertyName]) // &quot;zs&quot;
</code></pre>
<h2 id="二-object-类常见使用场景"><a class="header" href="#二-object-类常见使用场景">二 Object 类常见使用场景</a></h2>
<h3 id="21-objectkeys-获取对象成员"><a class="header" href="#21-objectkeys-获取对象成员">2.1 Object.keys() 获取对象成员</a></h3>
<p>Object.keys() 用来获取对象成员数组：</p>
<pre><code class="language-js">let obj = {
  name: 'lisi',
  age: 30,
  run: function () {
    console.log(this.name + ' is running')
  },
}

let keys = Object.keys(obj)
console.log(keys) //[ 'name', 'age', 'run' ]

for (let item in obj) {
  console.log(item) // name  age  run
}
</code></pre>
<blockquote>
<p>可枚举性：JS 代码创建的属性都是可枚举的，包括自有属性、继承属性都是可枚举的，但是可以使用特殊手段改变属性为不可枚举</p>
</blockquote>
<p>注意：**<code>Object.keys()</code> 只能获取对象中可被枚举的属性！**属性是否可枚举在下一节中有介绍。<strong>只有可被枚举的属性，才能使用 <code>for in</code> 方式进行遍历</strong>。</p>
<p>与<code>Object.keys()</code> 类似的是：<code>Object.getOwnPropertyNames()</code>，该方法用于返回对象所有自有属性名称的数组。</p>
<p>技巧延伸：在遍历对象属性时，往往需要一些过滤操作，如去除继承属性，去除函数属性，示例如下：</p>
<pre><code class="language-js">for (let item in obj) {
  if (!item.hasOwnProperty(item)) {
    continue // 跳过继承的属性
  }

  if (typeof son[item] === 'function') {
    continue // 跳过方法
  }
}
</code></pre>
<h3 id="22-对象的成员检测"><a class="header" href="#22-对象的成员检测">2.2 对象的成员检测</a></h3>
<p>使用属性直接查询、in、hasOwnProperty()、propertyIsEnumerable() 等方式可以检测对象中是否存在该成员。但是如果对象的属性是通过继承得到的，那么上述操作就会出现一些特殊情况：</p>
<pre><code class="language-js">class Father {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  run() {
    console.log('running...')
  }
}

class Son extends Father {
  constructor(name, age) {
    super()
  }
}

let s = new Son('四', 30)
s.age = 40

// in 方式 检测成员：继承方法也可以检测到
console.log('age' in s) // true
console.log('name' in s) // true
console.log('toString' in s) // true

// Object.hasOwnProperty() 方式：不会检查原型链
console.log(s.hasOwnProperty('age')) // true
console.log(s.hasOwnProperty('name')) // true
console.log(s.hasOwnProperty('toString')) // false 继承方法无法识别

// Object.propertyIsEnumerable()() 方式：是 hasOwnProperty() 的增强版
// 只有检测到是自有属性，且可枚举型为 true 时，返回值才为 true
console.log(s.hasOwnProperty('age')) // true
console.log(s.hasOwnProperty('name')) // true
console.log(s.hasOwnProperty('toString')) // false 继承方法无法识别
</code></pre>
<p>延伸：使用 <code>s.age !== undefined</code> 的方式也可以用来判断对象是否存在属性，作用与 in 类似，但是在一些场合，这种做法欠妥周全：</p>
<pre><code class="language-js">let obj = { x: undefined } // 对象属性被显式赋值了 undefined
console.log(obj.x !== undefined) // false
console.log('x' in obj) // true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="022-基类-object-限制对象成员"><a class="header" href="#022-基类-object-限制对象成员">02.2-基类 Object-限制对象成员</a></h1>
<h2 id="一-对象成员的特征"><a class="header" href="#一-对象成员的特征">一 对象成员的特征</a></h2>
<h3 id="11-成员特征概念"><a class="header" href="#11-成员特征概念">1.1 成员特征概念</a></h3>
<p>对象的成员的特征可以用一些内特性来描述，比如特征属性有两种：数据属性、访问器属性，特性名会被两个中括号包裹。</p>
<h3 id="11-特征属性一数据属性"><a class="header" href="#11-特征属性一数据属性">1.1 特征属性一：数据属性</a></h3>
<p>对象的成员的特征可以用一些内特性来描述，比如特征属性有两种：数据属性、访问器属性，特性名会被两个中括号包裹。</p>
<p>数据属性有 4 个特性描述其行为：</p>
<ul>
<li><code>[[Configurable]]</code>：默认值为 true，表示特性是否可以修改，包括属性是否可以 delete 删除并重新定义，是否可以修改为访问器属性</li>
<li><code>[[Enumerable]]</code>：默认值为 true，表示是否可以枚举（即是否支持 for in 循环）</li>
<li><code>[[Writable]]</code>：默认值为 true，表示属性的值是否可以被修改</li>
<li><code>[[Value]]</code>：默认值为 undefined，表示属性实际的值，即读取和写入属性值的位置</li>
</ul>
<pre><code class="language-js">const p = {
  name: 'zs',
}

const descriptor = Object.getOwnPropertyDescriptor(p, 'name')
console.log(descriptor.configurable) // true
console.log(descriptor.enumerable) // true
console.log(descriptor.writable) // true
console.log(descriptor.value) // zs
</code></pre>
<h3 id="12-获取特征属性方法"><a class="header" href="#12-获取特征属性方法">1.2 获取特征属性方法</a></h3>
<p>Object.getOwnPropertyDescriptor() 可以获取属性的描述符。ECMAScript 2017 新增了 Object.getOwnPropertyDescriptors()静态方法，这个方法实际上会在每个自有属性上调用 Object.getOwnPropertyDescriptor()并在一个新对象中返回它们：</p>
<pre><code class="language-js">console.log(Object.getOwnPropertyDescriptors(book))
/*
  {
    edition: {
    configurable: false,
    enumerable: false,
    value: 1,
    writable: false
  },
  year: {
    configurable: false,
    enumerable: false,
    get: f(),
    set: f(newValue),
  },
  year_: {
    configurable: false,
    enumerable: false,
    value: 2017,
    writable: false
  }
}
*/
</code></pre>
<h3 id="13-设置特征属性方法"><a class="header" href="#13-设置特征属性方法">1.3 设置特征属性方法</a></h3>
<p>使用 <code>Object.defineProperty()</code> 可以设置属性的特性，不过这种方式下 configurable、enumerable 和 writable 的值如果不指定，则都默认为 false，示例：</p>
<pre><code class="language-js">const p = {}

Object.defineProperty(p, 'name', {
  writable: false,
  value: 'zs',
})

const descriptor = Object.getOwnPropertyDescriptor(p, 'name')
console.log(descriptor.configurable) // false
console.log(descriptor.enumerable) // false
console.log(descriptor.writable) // false
console.log(descriptor.value) // zs

// 重新设置值，不会发生改变
console.log(p.name) // zs
p.name = 'lisi'
console.log(p.name) // zs
</code></pre>
<p>注意：一个属性如果被设置为不可配置后，就不能再变回可配置的了，而且这个属性不能从对象上删除，非严格模式下对这个属性调用 delete 没有效果，严格模式下会抛出错误。</p>
<h3 id="14-特征属性二访问器属性"><a class="header" href="#14-特征属性二访问器属性">1.4 特征属性二：访问器属性</a></h3>
<p>访问器属性不包含数据值，包含两个非必须的函数：访问器 getter、设置器 setter。访问器属性特征有四个 key：</p>
<ul>
<li><code>[[Configurable]]</code>：默认值为 true，表示特性是否可以修改，包括是否可以 delete 删除，是否可以修改为数据属性</li>
<li><code>[[Enumerable]]</code>：默认值为 true，表示是否可以枚举（即是否支持 for in 循环）</li>
<li><code>[[Get]]</code>：默认值为 undefined，属性获取函数，在读取属性时调用</li>
<li><code>[[Set]]</code>：默认值为 undefined，属性设置函数，在写入属性时调用</li>
</ul>
<pre><code class="language-js">let book = {
  _year: 2017,
  edition: 1,
}

Object.defineProperty(book, 'year', {
  get() {
    return this._year
  },
  set(newValue) {
    if (newValue &gt; 2017) {
      this._year = newValue
      this.edition += newValue - 2017
    }
  },
})

book.year = 2018
console.log(book.edition) // 2
</code></pre>
<p>贴士：Object.defineProperty() 只能设置某一个属性的特征，Object.defineProperties() 可以对多个属性进行设置。</p>
<h2 id="二-objectfreeze"><a class="header" href="#二-objectfreeze">二 Object.freeze()</a></h2>
<p><strong>如果要让 const 声明的引用类型变量的内容也无法改变，可以使用 Object.freeze()</strong>:</p>
<pre><code class="language-js">const HOST = {
  url: '/api/users',
  port: 80,
}
Object.freeze(HOST)

HOST.port = 443
console.log(HOST.port) // 仍然为 80
</code></pre>
<p>注意：<strong>var 重复声明不会报错，而 let、const 会报错！</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-对象操作-对象的检测"><a class="header" href="#031-对象操作-对象的检测">03.1-对象操作-对象的检测</a></h1>
<h2 id="一--符号与-objectis"><a class="header" href="#一--符号与-objectis">一 === 符号与 Object.is()</a></h2>
<p>在 ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力：</p>
<pre><code class="language-js">// 这些是===符合预期的情况
console.log(true === 1) // false
console.log({} === {}) // false
console.log('2' === 2) // false

// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等
console.log(+0 === -0) // true
console.log(+0 === 0) // true
console.log(-0 === 0) // true

// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN()
console.log(NaN === NaN) // false
console.log(isNaN(NaN)) // true
</code></pre>
<p>为改善这类情况，ECMAScript 6 规范新增了 Object.is()，这个方法与===很像，但同时也考虑到了上述边界情形：</p>
<pre><code class="language-js">// 符合预期
console.log(Object.is(true, 1)) // false
console.log(Object.is({}, {})) // false
console.log(Object.is('2', 2)) // false

// 正确的 0、 -0、 +0 相等/不等判定
console.log(Object.is(+0, -0)) // false
console.log(Object.is(+0, 0)) // true
console.log(Object.is(-0, 0)) // false

// 正确的 NaN 相等判定
console.log(Object.is(NaN, NaN)) // true
</code></pre>
<p>要检查超过两个值，递归地利用相等性传递即可：</p>
<pre><code class="language-js">function recursivelyCheckEqual(x, ...rest) {
  return (
    Object.is(x, rest[0]) &amp;&amp; (rest.length &lt; 2 || recursivelyCheckEqual(...rest))
  )
}
</code></pre>
<h2 id="二-类型检测"><a class="header" href="#二-类型检测">二 类型检测</a></h2>
<h3 id="20-类型检测机制"><a class="header" href="#20-类型检测机制">2.0 类型检测机制</a></h3>
<p>在使用构造函数创建对象时，构造函数的 prototype 属性被用作新对象的原型，这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，他们都是同一个类型！<strong>原型对象是类型的唯一标识，对象的原型对象如果一样，那么这 2 个构造函数创建出来的实例其实是一个类型</strong>。</p>
<p>typeof 只能检测出对象最基本的数据类型 <code>object</code>，无法检测其真实的原型，这就需要其他方式。</p>
<h3 id="21-instanceof-检测方式"><a class="header" href="#21-instanceof-检测方式">2.1 instanceof 检测方式</a></h3>
<p>instanceof 会顺着原型链一直查找：</p>
<pre><code class="language-js">function A() {}

let a = new A()

console.log(a instanceof A) // true
console.log(a instanceof Object) // true
</code></pre>
<h3 id="22-isprototypeof-检测类型"><a class="header" href="#22-isprototypeof-检测类型">2.2 isPrototypeOf() 检测类型</a></h3>
<p>isPrototypeOf() 可以确定两个对象之间原型的关系：</p>
<pre><code class="language-js">function Person() {}

let p = new Person()

console.log(Person.prototype.isPrototypeOf(p)) // true
</code></pre>
<h3 id="23-setprototypeof"><a class="header" href="#23-setprototypeof">2.3 setPrototypeOf()</a></h3>
<p><code>Object.setPrototypeOf()</code>方法，可以向实例的私有特性<code>[[Prototype]]</code>写入一个新值，用来重写一个对象的原型继承关系：</p>
<pre><code class="language-js">let obj = {
  name: 'Lisi',
}

let other = {
  age: 30,
}

// 向 objec 写入 other 的值
Object.setPrototypeOf(obj, other)
console.log(obj.age) // 30：obj 具备了 other 的值

console.log(Object.getPrototypeOf(obj) === other) // true
</code></pre>
<p><code>Object.setPrototypeOf()</code> 性能极其严重，可以通过 <code>Object.create()</code>创建一个新对象并指定原型：</p>
<pre><code class="language-js">let other = {
  age: 30,
}

let obj = Object.create(other)
obj.name = 'Lisi'

console.log(obj.age) // 30
console.log(obj.__proto__) // { age: 30 }
console.log(Object.getPrototypeOf(person) === other) // true
</code></pre>
<p>注意：该方法传入参数为 null 时，会创建一个没有原型的新对象，不会继承任何东西，甚至不能使用<code>toString()</code>这样的基础方法，所以创建空对象的方式是：</p>
<pre><code class="language-js">let obj = Object.create(Object.prototype)
</code></pre>
<h2 id="三-对象成员枚举"><a class="header" href="#三-对象成员枚举">三 对象成员枚举</a></h2>
<h3 id="31-hasownproperty方法"><a class="header" href="#31-hasownproperty方法">3.1 hasOwnProperty()方法</a></h3>
<p>hasOwnProperty()方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自 Object 的，会在属性存在于调用它的对象实例上时返回 true，如下面的例子所示：</p>
<pre><code class="language-js">function Person() {}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
  console.log(this.name)
}

let person = new Person()
console.log(person.hasOwnProperty('name')) // false
person1.name = 'Greg'
console.log(person.hasOwnProperty('name')) // true
delete person1.name
console.log(person.name) // &quot;Nicholas&quot;，来自原型
console.log(person.hasOwnProperty('name')) // false
</code></pre>
<h3 id="32-in-操作符"><a class="header" href="#32-in-操作符">3.2 in 操作符</a></h3>
<p>有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时， in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。来看下面的例子：</p>
<pre><code class="language-js">function Person() {}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
  console.log(this.name)
}

let person1 = new Person()
let person2 = new Person()
console.log(person1.hasOwnProperty('name')) // false
console.log('name' in person1) // true
person1.name = 'Greg'
console.log(person1.name) // &quot;Greg&quot;，来自实例
console.log(person1.hasOwnProperty('name')) // true
console.log('name' in person1) // true
console.log(person2.name) // &quot;Nicholas&quot;，来自原型
console.log(person2.hasOwnProperty('name')) // false
console.log('name' in person2) // true
delete person1.name
console.log(person1.name) // &quot;Nicholas&quot;，来自原型
console.log(person1.hasOwnProperty('name')) // false
console.log('name' in person1) // true
</code></pre>
<p>如果要确定某个属性是否存在于原型上，则可以像下面这样同时使用 hasOwnProperty()和 in 操作符：</p>
<pre><code class="language-js">function hasPrototypeProperty(object, name) {
  return !object.hasOwnProperty(name) &amp;&amp; name in object
}
</code></pre>
<p>只要通过对象可以访问， in 操作符就返回 true，而 hasOwnProperty()只有属性存在于实例上时才返回 true。因此，只要 in 操作符返回 true 且 hasOwnProperty()返回 false，就说明该属性是一个原型属性：</p>
<pre><code class="language-js">function Person() {}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
  console.log(this.name)
}
let person = new Person()
console.log(hasPrototypeProperty(person, 'name')) // true
person.name = 'Greg'
console.log(hasPrototypeProperty(person, 'name')) // false
</code></pre>
<h3 id="33-for-in"><a class="header" href="#33-for-in">3.3 for-in</a></h3>
<p>在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（ [[Enumerable]]特性被设置为 false）属性的实例属性也会在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。要获得对象上所有可枚举的实例属性，可以使用 Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。</p>
<pre><code class="language-js">function Person() {}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'Software Engineer'
Person.prototype.sayName = function () {
  console.log(this.name)
}
let keys = Object.keys(Person.prototype)
console.log(keys) // &quot;name,age,job,sayName&quot;
let p1 = new Person()
p1.name = 'Rob'
p1.age = 31
let p1keys = Object.keys(p1)
console.log(p1keys) // &quot;[name,age]&quot;
</code></pre>
<p>这里， keys 变量保存的数组中包含&quot;name&quot;、 &quot;age&quot;、 &quot;job&quot;和&quot;sayName&quot;。这是正常情况下通过 for-in 返回的顺序。而在 Person 的实例上调用时， Object.keys()返回的数组中只包含&quot;name&quot;和&quot;age&quot;两个属性。</p>
<h3 id="34-objectgetownpropertynames-列出所有实例属性"><a class="header" href="#34-objectgetownpropertynames-列出所有实例属性">3.4 Object.getOwnPropertyNames() 列出所有实例属性</a></h3>
<p>如果想列出所有实例属性，无论是否可以枚举，都可以使用 Object.getOwnPropertyNames()：</p>
<pre><code class="language-js">let keys = Object.getOwnPropertyNames(Person.prototype)
console.log(keys) // &quot;[constructor,name,age,job,sayName]&quot;
</code></pre>
<p>返回的结果中包含了一个不可枚举的属性 constructor。 Object.keys()和 Object.getOwnPropertyNames()在适当的时候都可用来代替 for-in 循环。</p>
<p>在 ECMAScript 6 新增符号类型之后，相应地出现了增加一个 Object.getOwnPropertyNames()的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此， Object.getOwnPropertySymbols()方法就出现了，这个方法与 Object.getOwnPropertyNames()类似，只是针对符号而已：</p>
<pre><code class="language-js">let k1 = Symbol('k1'),
  k2 = Symbol('k2')
let o = {
  [k1]: 'k1',
  [k2]: 'k2',
}
console.log(Object.getOwnPropertySymbols(o)) // [Symbol(k1), Symbol(k2)]
</code></pre>
<h3 id="35-属性枚举顺序"><a class="header" href="#35-属性枚举顺序">3.5 属性枚举顺序</a></h3>
<p>for-in 循环、 Object.keys()、 Object.getOwnPropertyNames()、 Object.getOwnPropertySymbols()以及 Object.assign()在属性枚举顺序方面有很大区别。 for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。</p>
<p>Object.getOwnPropertyNames()、 Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</p>
<pre><code class="language-js">let k1 = Symbol('k1'),
  k2 = Symbol('k2')
let o = {
  1: 1,
  first: 'first',
  [k1]: 'sym2',
  second: 'second',
  0: 0,
}

o[k2] = 'sym2'
o[3] = 3
o.third = 'third'
o[2] = 2
console.log(Object.getOwnPropertyNames(o)) // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;third&quot;]

console.log(Object.getOwnPropertySymbols(o)) // [Symbol(k1), Symbol(k2)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="032-对象操作-对象的迭代合并与扩展"><a class="header" href="#032-对象操作-对象的迭代合并与扩展">03.2-对象操作-对象的迭代合并与扩展</a></h1>
<h2 id="一-对象的迭代"><a class="header" href="#一-对象的迭代">一 对象的迭代</a></h2>
<h3 id="11-es2017-的-objectvalues-和-objectentries"><a class="header" href="#11-es2017-的-objectvalues-和-objectentries">1.1 ES2017 的 Object.values() 和 Object.entries()</a></h3>
<p>在 JavaScript 有史以来的大部分时间内，迭代对象属性都是一个难题。ECMAScript 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法 Object.values() 和 Object.entries() 接收一个对象，返回它们内容的数组。Object.values() 返回对象值的数组，Object.entries() 返回键/值对的数组。</p>
<pre><code class="language-js">const o = {
  foo: 'bar',
  baz: 1,
  qux: {},
}
console.log(Object.values(o)) // [&quot;bar&quot;, 1, {}]
console.log(Object.entries(o)) // [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, {}]]
</code></pre>
<p>非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p>
<pre><code class="language-js">const o = {
  qux: {},
}
console.log(Object.values(o)[0] === o.qux) // true

console.log(Object.entries(o)[0][1] === o.qux) // true
</code></pre>
<p>符号属性会被忽略：</p>
<pre><code class="language-js">const sym = Symbol()
const o = {
  [sym]: 'foo',
}
console.log(Object.values(o)) // []

console.log(Object.entries(o)) // []
</code></pre>
<h2 id="二-对象的合并"><a class="header" href="#二-对象的合并">二 对象的合并</a></h2>
<h3 id="21-合并的概念"><a class="header" href="#21-合并的概念">2.1 合并的概念</a></h3>
<p>把源对象的所有本地属性复制到目标对象上，称为合并（merge），也称为混入（mixin），通过合并可以增强对象的功能。</p>
<h3 id="22-合并方法-objectassign"><a class="header" href="#22-合并方法-objectassign">2.2 合并方法 Object.assign()</a></h3>
<p>ES6 提供了对象合并方法：<code>Object.assign()</code>，该方法可以接收多个源对象，将源对象的可枚举属性（ Object.propertyIsEnumerable()返回 true）、自有属性（ Object.hasOwnProperty()返回 true）复制到目标对象：</p>
<pre><code class="language-js">const dest = {}
Object.assign(dest, { a: 'foo' }, { b: 'bar' }) // 也会返回一个全新的复制后的对象
console.log(dest) // { a: foo, b: bar }
</code></pre>
<p>贴士：</p>
<ul>
<li>以字符串和符号为键的属性才会被复制。</li>
<li>这个方法会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标对象上的<code>[[Set]]</code>设置属性的值。</li>
<li>如果多个源对象都有相同的属性，则使用最后一个复制的值。</li>
</ul>
<pre><code class="language-js">let dest = {
  _num: 10,
  set num(v) {
    this._num = v
  },
  get num() {
    return this._num
  },
}

let src = {
  get num() {
    return 'foo'
  },
}
Object.assign(dest, src)
console.log(dest.num)
</code></pre>
<p>Object.assign() 实际上对每个源对象执行的是浅复制，浅复制也意味着只会复制对象的引用：</p>
<pre><code class="language-js">let dest = {}

let src = { a: {} }
Object.assign(dest, src)
console.log(dest.a === src.a) // true
</code></pre>
<p>贴士：如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign() 没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。</p>
<h2 id="三-如何安全扩展内置对象"><a class="header" href="#三-如何安全扩展内置对象">三 如何安全扩展内置对象</a></h2>
<h3 id="31-es5-扩展内置对象"><a class="header" href="#31-es5-扩展内置对象">3.1 ES5 扩展内置对象</a></h3>
<p>我们不推荐扩展内置对象，但是可以使用下列方法更安全的扩展。</p>
<pre><code class="language-javascript">function MyArray() {}
MyArray.prototype = new Array() //MyArray 即成为了具备和 Array 一样的功能
</code></pre>
<h3 id="32-es6-扩展内置对象"><a class="header" href="#32-es6-扩展内置对象">3.2 ES6 扩展内置对象</a></h3>
<p>ES6 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型：</p>
<pre><code class="language-js">class SuperArray extends Array {
  shuffle() {
    // 洗牌算法
    for (let i = this.length - 1; i &gt; 0; i--) {
      const j = Math.floor(Math.random() * (i + 1))
      ;[this[i], this[j]] = [this[j], this[i]]
    }
  }
}

let a = new SuperArray(1, 2, 3, 4, 5)
console.log(a instanceof Array) // true
console.log(a instanceof SuperArray) // true
console.log(a) // [1, 2, 3, 4, 5]
a.shuffle()
console.log(a) // [3, 1, 4, 5, 2]
</code></pre>
<p>有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原始实例的类型是一致的：</p>
<pre><code class="language-js">class SuperArray extends Array {}
let a1 = new SuperArray(1, 2, 3, 4, 5)
let a2 = a1.filter((x) =&gt; !!(x % 2))
console.log(a1) // [1, 2, 3, 4, 5]
console.log(a2) // [1, 3, 5]
console.log(a1 instanceof SuperArray) // true
console.log(a2 instanceof SuperArray) // true
</code></pre>
<p>如果想覆盖这个默认行为，则可以覆盖 Symbol.species 访问器，这个访问器决定在创建返回的实例时使用的类：</p>
<pre><code class="language-js">class SuperArray extends Array {
  static get [Symbol.species]() {
    return Array
  }
}

let a1 = new SuperArray(1, 2, 3, 4, 5)
let a2 = a1.filter((x) =&gt; !!(x % 2))
console.log(a1) // [1, 2, 3, 4, 5]
console.log(a2) // [1, 3, 5]
console.log(a1 instanceof SuperArray) // true
console.log(a2 instanceof SuperArray) // false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="033-对象操作-对象的拷贝"><a class="header" href="#033-对象操作-对象的拷贝">03.3-对象操作-对象的拷贝</a></h1>
<h2 id="一-浅拷贝"><a class="header" href="#一-浅拷贝">一 浅拷贝</a></h2>
<h3 id="10-浅拷贝概念"><a class="header" href="#10-浅拷贝概念">1.0 浅拷贝概念</a></h3>
<p>浅拷贝：直接拷贝引用。浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>
<h3 id="11-简单实现"><a class="header" href="#11-简单实现">1.1 简单实现</a></h3>
<pre><code class="language-js">function copy(obj) {
  let res = {}
  for (let i in obj) {
    res[i] = obj[i]
  }
  return res
}

// 示例
let obj = {
  name: 'lisi',
  age: 30,
  arr: [1, 2, 3],
}

let newObj = copy(obj)
newObj.arr.push(5)
console.log(obj.arr) // [ 1, 2, 3, 5 ]，拷贝出来的对象属性修改影响了原对象
</code></pre>
<h3 id="12-es6-的-objectassign-与-create"><a class="header" href="#12-es6-的-objectassign-与-create">1.2 ES6 的 Object.assign() 与 create()</a></h3>
<p>ES6 提供了 Object.assign() 方法可以把任意多个源对象自身 可枚举 的属性拷贝给目标对象，也同样属于浅拷贝：</p>
<pre><code class="language-js">// 示例
let obj = {
  name: 'lisi',
  age: 30,
  arr: [1, 2, 3],
}

let newObj = Object.assign({}, obj)
newObj.arr.push(5)
console.log(obj.arr) // [ 1, 2, 3, 5 ]

let newObj2 = Object.create(obj)
newObj2.arr.push(6)
console.log(obj.arr) // [ 1, 2, 3, 5 ]
</code></pre>
<h2 id="二-深拷贝"><a class="header" href="#二-深拷贝">二 深拷贝</a></h2>
<h3 id="20-深拷贝概念"><a class="header" href="#20-深拷贝概念">2.0 深拷贝概念</a></h3>
<p>对象属于引用类型，在传值时使用的是引用传递：</p>
<pre><code class="language-js">let obj = {
  name: 'lisi',
  age: 30,
}

let other = obj // 重新赋值
other.age = 40
console.log(obj.age) // 40
</code></pre>
<p>要做到重新赋值后的对象修改不会影响到以前的变量，必须进行深拷贝。</p>
<h3 id="41-json-的方法转换"><a class="header" href="#41-json-的方法转换">4.1 JSON 的方法转换</a></h3>
<p>将对象转换为 JSON 字符串，然后再将字符串转换回一个新的对象。该方式简单实用，但是只能处理能够被 JSON 直接表示的数据结构，如：Number、String、Array 等（函数就不可以转换），进行深拷贝后会变成 Object。</p>
<pre><code class="language-js">function copy(obj) {
  return JSON.parse(JSON.stringify(obj))
}

// 示例
let obj = {
  name: 'lisi',
  age: 30,
  arr: [1, 2, 3],
}

let newObj = copy(obj)
newObj.arr.push(5)
console.log(obj.arr) // [ 1, 2, 3 ]
</code></pre>
<h3 id="22-递归拷贝"><a class="header" href="#22-递归拷贝">2.2 递归拷贝</a></h3>
<pre><code class="language-js">// 实现一个深拷贝函数
function extend(Father, Son) {
  for (let key in Father) {
    let item = Father[key]
    if (item instanceof Array) {
      Son[key] = []
      extend(item, Son[key])
    } else if (item instanceof Object) {
      Son[key] = {}
      extend(item, Son[key])
    } else {
      Son[key] = item
    }
  }
}
</code></pre>
<h3 id="23-第三方库提供的拷贝"><a class="header" href="#23-第三方库提供的拷贝">2.3 第三方库提供的拷贝</a></h3>
<ul>
<li>jQuery：提供了$.extend</li>
<li>lodash：提供了.cloneDeep</li>
</ul>
<h2 id="三-拷贝特性"><a class="header" href="#三-拷贝特性">三 拷贝特性</a></h2>
<p>如果要完成属性特性的拷贝，可以封装如下：</p>
<pre><code class="language-js">Object.defineProperty(
  // 创建 extend 为 Object 的方法
  Object.prototype,
  'extend',
  {
    writable: true,
    enumerable: false, // 定义为不可枚举
    configurable: true,
    value: function (obj) {
      let names = Object.getOwnPropertyNames(obj)
      for (let i = 0; i &lt; names.length; i++) {
        let describe = Object.getOwnPropertyDescriptor(obj, names[i])
        Object.defineProperty(this, names[i], describe)
      }
    },
  }
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="034-对象操作-对象的使用细节优化"><a class="header" href="#034-对象操作-对象的使用细节优化">03.4-对象操作-对象的使用细节优化</a></h1>
<h2 id="一-对象成员的简写"><a class="header" href="#一-对象成员的简写">一 对象成员的简写</a></h2>
<p>对象的变量和变量名一致时简写：</p>
<pre><code class="language-js">// 属性值简写
let name = 'Matt'
let person = {
  name,
}
console.log(person) // { name: 'Matt' }

// 返回属性值简写
function makePerson(name) {
  return {
    name,
  }
}

// 简写方法名对获取函数和设置函数也是适用的：
let person = {
  name_: '',
  get name() {
    return this.name_
  },
  set name(name) {
    this.name_ = name
  },
  sayName() {
    console.log(`My name is ${this.name_}`)
  },
}
person.name = 'Matt'
person.sayName() // My name is Matt
</code></pre>
<h2 id="二-可计算属性"><a class="header" href="#二-可计算属性">二 可计算属性</a></h2>
<p>如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性：</p>
<pre><code class="language-js">const nameKey = 'name'
const ageKey = 'age'
const jobKey = 'job'
let person = {}
person[nameKey] = 'Matt'
person[ageKey] = 27
person[jobKey] = 'Software engineer'
console.log(person) // { name: 'Matt', age: 27, job: 'Software engineer' }
</code></pre>
<p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值：</p>
<pre><code class="language-js">const nameKey = 'name'
const ageKey = 'age'
const jobKey = 'job'
let person = {
  [nameKey]: 'Matt',
  [ageKey]: 27,
  [jobKey]: 'Software engineer',
}
</code></pre>
<p>因为被当作 JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值：</p>
<pre><code class="language-js">const nameKey = 'name'
const ageKey = 'age'
const jobKey = 'job'
let uniqueToken = 0
function getUniqueKey(key) {
  return `${key}_${uniqueToken++}`
}
let person = {
  [getUniqueKey(nameKey)]: 'Matt',
  [getUniqueKey(ageKey)]: 27,
  [getUniqueKey(jobKey)]: 'Software engineer',
}
console.log(person) // { name_0: 'Matt', age_1: 27, job_2: 'Software engineer' }
</code></pre>
<p>简写方法名与可计算属性键相互兼容：</p>
<pre><code class="language-js">const methodKey = 'sayName'
let person = {
  [methodKey](name) {
    console.log(`My name is ${name}`)
  },
}
person.sayName('Matt') // My name is Matt
</code></pre>
<h2 id="三-对象解构"><a class="header" href="#三-对象解构">三 对象解构</a></h2>
<h3 id="31-解构赋值的基本使用"><a class="header" href="#31-解构赋值的基本使用">3.1 解构赋值的基本使用</a></h3>
<p>ECMAScript 6 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作，即：使用与对象匹配的结构来实现对象属性赋值。如下所示：</p>
<pre><code class="language-js">let person = {
  name: 'Matt',
  age: 27,
}

// 不使用对象解构
let personName1 = person1.name
let personAge1 = person1.age
console.log(personName1) // Matt
console.log(personAge1) // 27

// 使用对象结构
let { name: personName2, age: personAge2 } = person
console.log(personName2) // Matt
console.log(personAge2) // 27

// 简写
let { name, age } = person
console.log(name) // Matt
console.log(age) // 27
</code></pre>
<p>解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined</p>
<p>也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况：</p>
<pre><code class="language-js">let person = {
  name: 'Matt',
  age: 27,
}
let { name, job = 'Software engineer' } = person
console.log(name) // Matt
console.log(job) // Software engineer
</code></pre>
<p>解构在内部使用函数 ToObject()（不能在运行时环境中直接访问）把源数据结构转换为对象，所以 null 和 undefined 不能被解构，否则会抛出错误。</p>
<p>如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：</p>
<pre><code class="language-js">let personName, personAge
let person = {
  name: 'Matt',
  age: 27,
}
;({ name: personName, age: personAge } = person)
console.log(personName, personAge) // Matt, 27
</code></pre>
<h3 id="32-嵌套解构"><a class="header" href="#32-嵌套解构">3.2 嵌套解构</a></h3>
<p>解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性：</p>
<pre><code class="language-js">let person = {
  name: 'Matt',
  age: 27,
  job: {
    title: 'Software engineer',
  },
}
let personCopy = {}

;({ name: personCopy.name, age: personCopy.age, job: personCopy.job } = person)

// 因为一个对象的引用被赋值给 personCopy，所以修改
// person.job 对象的属性也会影响 personCopy
person.job.title = 'Hacker'
console.log(person) // { name: 'Matt', age: 27, job: { title: 'Hacker' } }
console.log(personCopy) // { name: 'Matt', age: 27, job: { title: 'Hacker' } }
</code></pre>
<p>解构赋值可以使用嵌套结构，以匹配嵌套的属性：</p>
<pre><code class="language-js">let person = {
  name: 'Matt',
  age: 27,
  job: {
    title: 'Software engineer',
  },
}
// 声明 title 变量并将 person.job.title 的值赋给它
let {
  job: { title },
} = person
console.log(title) // Software engineer
</code></pre>
<p>在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样：</p>
<pre><code class="language-js">let person = {
  job: {
    title: 'Software engineer',
  },
}
let personCopy = {}

// foo 在源对象上是 undefined
;({
  foo: { bar: personCopy.bar },
} = person)
// TypeError: Cannot destructure property 'bar' of 'undefined' or 'null'.

// job 在目标对象上是 undefined
;({
  job: { title: personCopy.job.title },
} = person)
// TypeError: Cannot set property 'title' of undefined
</code></pre>
<h3 id="33-不分解构"><a class="header" href="#33-不分解构">3.3 不分解构</a></h3>
<p>涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分：</p>
<pre><code class="language-js">let person = {
  name: 'Matt',
  age: 27,
}
let personName, personBar, personAge

try {
  // person.foo 是 undefined，因此会抛出错误
  ;({
    name: personName,
    foo: { bar: personBar },
    age: personAge,
  } = person)
} catch (e) {}
console.log(personName, personBar, personAge) // Matt, undefined, undefined
</code></pre>
<h3 id="34-参数上下文匹配"><a class="header" href="#34-参数上下文匹配">3.4 参数上下文匹配</a></h3>
<p>在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响 arguments 对象，但可以在函数签名中声明在函数体内使用局部变量：</p>
<pre><code class="language-js">let person = {
  name: 'Matt',
  age: 27,
}

function printPerson(foo, { name, age }, bar) {
  console.log(arguments)
  console.log(name, age)
}

function printPerson2(foo, { name: personName, age: personAge }, bar) {
  console.log(arguments)
  console.log(personName, personAge)
}
printPerson('1st', person, '2nd') // ['1st', { name: 'Matt', age: 27 }, '2nd']  'Matt', 27
printPerson2('1st', person, '2nd') // ['1st', { name: 'Matt', age: 27 }, '2nd'] 'Matt', 27
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-容器对象-array"><a class="header" href="#041-容器对象-array">04.1-容器对象-Array</a></h1>
<h2 id="一-数组的创建"><a class="header" href="#一-数组的创建">一 数组的创建</a></h2>
<h3 id="11-arrayfrom-和-arrayof-创建数组"><a class="header" href="#11-arrayfrom-和-arrayof-创建数组">1.1 Array.from() 和 Array.of() 创建数组</a></h3>
<p>Object 对象是 JavaScript 所有对象的祖先对象，通过该对象也派生了一部分子数据类型，如 Array、Function、Date 等。Array 即 JavaScript 的数组，和其他静态编程语言不同的是，JavaScript 的 Array 对象可以保存任意类型数据，且长度不固定（内部自动扩容缩容）。</p>
<p>创建 Array 有多种方式，如：字面量、构造函数等，ES6 给出了 2 个静态方法：from()、of() 也可以创建数组。</p>
<p>Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构：</p>
<pre><code class="language-js">// 字符串会被拆分为单字符数组
console.log(Array.from('Matt')) // [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;]

// 可以使用 from()将集合和映射转换为一个新数组
const m = new Map().set(1, 2).set(3, 4)
const s = new Set().add(1).add(2).add(3).add(4)
console.log(Array.from(m)) // [[1, 2], [3, 4]]
console.log(Array.from(s)) // [1, 2, 3, 4]

// Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1)
console.log(a1) // [1, 2, 3, 4]
console.log(a1 === a2) // false

// 可以使用任何可迭代对象
const iter = {
  *[Symbol.iterator]() {
    yield 1
    yield 2
    yield 3
    yield 4
  },
}
console.log(Array.from(iter)) // [1, 2, 3, 4]

// arguments 对象可以被轻松地转换为数组
function getArgsArray() {
  return Array.from(arguments)
}
console.log(getArgsArray(1, 2, 3, 4)) // [1, 2, 3, 4]

// from()也能转换带有必要属性的自定义对象
const arrayLikeObject = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  length: 4,
}
console.log(Array.from(arrayLikeObject)) // [1, 2, 3, 4]
</code></pre>
<p>Array.from() 还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用 Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中 this 的值，但这个重写的 this 值在箭头函数中不适用：</p>
<pre><code class="language-js">const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1, (x) =&gt; x ** 2)
const a3 = Array.from(
  a1,
  function (x) {
    return x ** this.exponent
  },
  { exponent: 2 }
)
console.log(a2) // [1, 4, 9, 16]
console.log(a3) // [1, 4, 9, 16]
</code></pre>
<p>Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6 之前使用的拙劣的对象转数组方法 Array.prototype.slice.call(arguments)：</p>
<pre><code class="language-js">console.log(Array.of(1, 2, 3, 4)) // [1, 2, 3, 4]
console.log(Array.of(undefined)) // [undefined]
</code></pre>
<h2 id="二-数组的实例方法-1"><a class="header" href="#二-数组的实例方法-1">二 数组的实例方法</a></h2>
<h3 id="20-数组的实例方法汇总-1"><a class="header" href="#20-数组的实例方法汇总-1">2.0 数组的实例方法汇总</a></h3>
<p>数组的实例方法有：栈方法（push/pop），队列方法(shift)，排序，操作，搜索，检索迭代器，复制，填充，转换，迭代，归并等。本章节主要介绍：复制，填充，转换，迭代，归并，基础用法位于 01-JavaScript 基础语法的 06-数组的基本使用中。</p>
<h3 id="21-迭代器方法检索数组内容"><a class="header" href="#21-迭代器方法检索数组内容">2.1 迭代器方法：检索数组内容</a></h3>
<p>在 ES6 中， Array 的原型上暴露了 3 个用于检索数组内容的方法：</p>
<ul>
<li>keys()：返回数组索引的迭代器</li>
<li>values()：返回数组元素的迭代器</li>
<li>entries()：返回索引/值对的迭代器</li>
</ul>
<pre><code class="language-js">const arr = ['foo', 'bar', 'baz', 'qux']

// 使用 ES6 的解构可以非常容易地在循环中拆分键/值对：
for (const [index, item] of arr.entries()) {
  console.log(index)
  console.log(item)
}
// 0 foo
// 1 bar
// 2 baz
// 3 qux

// 因为这些方法都返回迭代器，所以可以将它们的内容通过 Array.from()直接转换为数组实例
const keyArr = Array.from(arr.keys())
const valueArr = Array.from(arr.values())
const entryArr = Array.from(arr.entries())
console.log(keyArr) // [0, 1, 2, 3]
console.log(valueArr) // [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]
console.log(entryArr) // [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]
</code></pre>
<h3 id="22-fill-填充方法"><a class="header" href="#22-fill-填充方法">2.2 fill() 填充方法</a></h3>
<p>fill() 方法可以向数组中插入全部或部分相同的值，使用这个方法不会改变数组的大小：</p>
<pre><code class="language-js">const zeroes = [0, 0, 0, 0, 0]

// 不提供开始索引，结束索引，则填充整个数组
zeroes.fill(5) // 用 5 填充整个数组
console.log(zeroes) // [5, 5, 5, 5, 5]
zeroes.fill(0) // 重置为0

// 使用索引位置
zeroes.fill(7, 1, 3) // 用 7 填充索引大于等于 1 且小于 3 的元素
console.log(zeroes) // [0, 7, 7, 0, 0];
zeroes.fill(0) // 重置

// 开始索引用于指定开始填充的位置，它是可选的。结束索引若不提供，则一直填充到数组末尾
zeroes.fill(6, 3) // 用 6 填充索引大于等于 3 的元素
console.log(zeroes) // [0, 0, 0, 6, 6]
zeroes.fill(0) // 重置

// 负值索引从数组末尾开始计算，也可以将负索引想象成数组长度加上它得到的一个正索引：
zeroes.fill(8, -4, -1)
console.log(zeroes) // [0, 8, 8, 8, 0];
</code></pre>
<p>fill()静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
<pre><code class="language-js">const zeroes = [0, 0, 0, 0, 0]

// 索引过低，忽略
zeroes.fill(1, -10, -6)
console.log(zeroes) // [0, 0, 0, 0, 0]

// 索引过高，忽略
zeroes.fill(1, 10, 15)
console.log(zeroes) // [0, 0, 0, 0, 0]

// 索引反向，忽略
zeroes.fill(2, 4, 2)
console.log(zeroes) // [0, 0, 0, 0, 0]

// 索引部分可用，填充可用部分
zeroes.fill(4, 3, 10)
console.log(zeroes) // [0, 0, 0, 4, 4]
</code></pre>
<h3 id="23-copywithin-复制方法"><a class="header" href="#23-copywithin-复制方法">2.3 copyWithin() 复制方法</a></h3>
<p>copyWithin()可以在数组指定范围中浅复制数组中的部分内容，然后将他们插入到指定索引开始的位置，与 fill() 方法使用方式类似，可以指定开始索引、结束索引：</p>
<pre><code class="language-js">let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
const reset = () =&gt; {
  ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
}

// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置
// 在源索引或目标索引到达数组边界时停止
ints.copyWithin(5)
console.log(ints) // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
reset() // 重置

// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置
ints.copyWithin(0, 5)
console.log(ints) // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]
reset() // 重置

// 从 ints 中复制索引 0 开始到索引 3 结束的内容
ints.copyWithin(4, 0, 3) // 插入到索引 4 开始的位置
console.log(ints) // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]
reset() // 重置

// JavaScript 引擎在插值前会完整复制范围内的值，因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6)
console.log(ints) // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]
reset() // 重置

// 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的
ints.copyWithin(-4, -7, -3)
console.log(ints) // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]
</code></pre>
<p>copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
<pre><code class="language-js">let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
const reset = () =&gt; {
  ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
}

// 索引过低，忽略
ints.copyWithin(1, -15, -12)
console.log(ints) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()

// 索引过高，忽略
ints.copyWithin(1, 12, 15)
console.log(ints) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()

// 索引反向，忽略
ints.copyWithin(2, 4, 2)
console.log(ints) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()

// 索引部分可用，复制、填充可用部分
ints.copyWithin(4, 7, 10)
console.log(ints) // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];
</code></pre>
<h3 id="24-tostring和-valueof-转换方法"><a class="header" href="#24-tostring和-valueof-转换方法">2.4 toString()和 valueOf() 转换方法</a></h3>
<p>toString() 返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串，即对数组的每个值都会调用其 toString()方法，以得到最终的字符串。
valueOf()返回的还是数组本身：</p>
<pre><code class="language-js">let colors = ['red', 'blue', 'green'] // 创建一个包含 3 个字符串的数组
console.log(colors.toString()) // red,blue,green
console.log(colors.valueOf()) // red,blue,green
console.log(colors) // red,blue,green
</code></pre>
<p>贴士：数组实例的 toLocaleString()方法则是在内部调用数组每个值的 toLocaleString()方法。</p>
<p>join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串：</p>
<pre><code class="language-js">let colors = ['red', 'green', 'blue']
console.log(colors.join(',')) // red,green,blue
console.log(colors.join('||')) // red||green||blue
</code></pre>
<h3 id="25-迭代方法"><a class="header" href="#25-迭代方法">2.5 迭代方法</a></h3>
<p>ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影响方法的返回值。</p>
<ul>
<li>every()： 对数组每一项都运行传入的函数，如果对每一项函数都返回 true， 则这个方法返回 true。</li>
<li>filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。</li>
<li>forEach()：对数组每一项都运行传入的函数，没有返回值。</li>
<li>map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</li>
<li>some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。</li>
</ul>
<p>注意：<strong>这些方法都不改变调用它们的数组</strong>。</p>
<p>every()和 some()用法相同，其内部原理都是循环数组元素，从数组中搜索符合某个条件的元素。但是 every 强调所有元素都必须满足条件，some 只会循环到第一个符合的元素。对 every()来说，传入的函数必须对每一项都返回 true，它才会返回 true；否则，它就返回 false。而对 some()来说，只要有一项让传入的函数返回 true，它就会返回 true：</p>
<pre><code class="language-js">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]

// 传入的函数都是在给定项大于 2 时返回 true
// every()返回 false 是因为并不是每一项都能达到要求。
let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2)
console.log(everyResult) // false
// some()返回 true 是因为至少有一项满足条件
let someResult = numbers.some((item, index, array) =&gt; item &gt; 2)
console.log(someResult) // true
</code></pre>
<p>filter()方法基于给定的函数来决定某一项是否应该包含在它返回的数组中。比如，要返回一个所有数值都大于 2 的数组，可以使用如下代码：</p>
<pre><code class="language-js">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2)
console.log(filterResult) // 3,4,5,4,3
</code></pre>
<p>map()方法也会返回一个数组。这个数组的每一项都是对原始数组中同样位置的元素运行传入函数而返回的结果。例如，可以将一个数组中的每一项都乘以 2，并返回包含所有结果的数组，如下所示：</p>
<pre><code class="language-js">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
let mapResult = numbers.map((item, index, array) =&gt; item * 2)
console.log(mapResult) // 2,4,6,8,10,8,6,4,2
</code></pre>
<p>forEach()方法只会对每一项运行传入的函数，没有返回值。本质上， forEach()方法相当于使用 for 循环遍历数组。比如：</p>
<pre><code class="language-js">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
numbers.forEach((item, index, array) =&gt; {
  // 执行某些操作
})
</code></pre>
<h3 id="26-归并方法"><a class="header" href="#26-归并方法">2.6 归并方法</a></h3>
<p>ECMAScript 为数组提供了两个归并方法： reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。</p>
<p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。</p>
<p>传给 reduce()和 reduceRight()的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p>
<p>可以使用 reduce()函数执行累加数组中所有数值的操作，比如：</p>
<pre><code class="language-js">let values = [1, 2, 3, 4, 5]
let sum = values.reduce((prev, cur, index, array) =&gt; prev + cur)
console.log(sum) // 15
</code></pre>
<p>第一次执行归并函数时， prev 是 1， cur 是 2。第二次执行时， prev 是 3（ 1 + 2）， cur 是 3（数组第三项）。如此递进，直到把所有项都遍历一次，最后返回归并结果。</p>
<p>reduceRight()和 reduce() 没有区别，他们的使用只取决于遍历数组元素的方向：</p>
<pre><code class="language-js">let values = [1, 2, 3, 4, 5]
let sum = values.reduceRight(function (prev, cur, index, array) {
  return prev + cur
})
console.log(sum) // 15
</code></pre>
<h2 id="三-数组打平"><a class="header" href="#三-数组打平">三 数组打平</a></h2>
<h3 id="31-阻止-concat-数组打平行为"><a class="header" href="#31-阻止-concat-数组打平行为">3.1 阻止 concat 数组打平行为</a></h3>
<p>打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号： Symbol.isConcatSpreadable。这个符号能够阻止 concat()打平参数数组。相反，把这个值设置为 true 可以强制打平类数组对象：</p>
<pre><code class="language-js">let colors = ['red', 'green', 'blue']
let newColors = ['black', 'brown']

let moreNewColors = {
  [Symbol.isConcatSpreadable]: true,
  length: 2,
  0: 'pink',
  1: 'cyan',
}
newColors[Symbol.isConcatSpreadable] = false

// 强制不打平数组
let colors2 = colors.concat('yellow', newColors)

// 强制打平类数组对象
let colors3 = colors.concat(moreNewColors)
console.log(colors) // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]
console.log(colors2) // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]]
console.log(colors3) // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;]
</code></pre>
<h3 id="32-flat-和-flatmap-数组打平"><a class="header" href="#32-flat-和-flatmap-数组打平">3.2 flat() 和 flatMap() 数组打平</a></h3>
<p>ECMAScript 2019 在 Array.prototype 上增加了两个方法：flat() 和 flatMap()。这两个方法为打平数组提供了便利。如果没有这两个方法，则打平数组就要使用迭代或递归。</p>
<p>下面是如果没有这两个新方法要打平数组的一个示例实现：</p>
<pre><code class="language-js">function flatten(sourceArray, flattenedArray = []) {
  for (const element of sourceArray) {
    if (Array.isArray(element)) {
      flatten(element, flattenedArray)
    } else {
      flattenedArray.push(element)
    }
  }
  return flattenedArray
}
const arr = [[0], 1, 2, [3, [4, 5]], 6]
console.log(flatten(arr))
// [0, 1, 2, 3, 4, 5, 6]
</code></pre>
<p>这个例子在很多方面像一个树形数据结构：数组中每个元素都像一个子节点，非数组元素是叶节点。因此，这个例子中的输入数组是一个高度为 2 有 7 个叶节点的树。打平这个数组本质上是对叶节点的按序遍历。</p>
<p>有时候如果能指定打平到第几级嵌套是很有用的。比如下面这个例子，它重写了上面的版本，允许指定要打平几级：</p>
<pre><code class="language-js">function flatten(sourceArray, depth, flattenedArray = []) {
  for (const element of sourceArray) {
    if (Array.isArray(element) &amp;&amp; depth &gt; 0) {
      flatten(element, depth - 1, flattenedArray)
    } else {
      flattenedArray.push(element)
    }
  }
  return flattenedArray
}
const arr = [[0], 1, 2, [3, [4, 5]], 6]
console.log(flatten(arr, 1))
// [0, 1, 2, 3, [4, 5], 6]
</code></pre>
<p>为了解决上述问题，规范增加了 Array.prototype.flat() 方法。该方法接收 depth 参数（默认值为 1），返回一个对要打平 Array 实例的浅复制副本。下面看几个例子：</p>
<pre><code class="language-js">const arr = [[0], 1, 2, [3, [4, 5]], 6]
console.log(arr.flat(2))
// [0, 1, 2, 3, 4, 5, 6]
console.log(arr.flat())
// [0, 1, 2, 3, [4, 5], 6]
</code></pre>
<p>因为是执行浅复制，所以包含循环引用的数组在被打平时会从源数组复制值：</p>
<pre><code class="language-js">const arr = [[0], 1, 2, [3, [4, 5]], 6]
arr.push(arr)
console.log(arr.flat())
// [0, 1, 2, 3, 4, 5, 6, [0], 1, 2, [3, [4, 5]], 6]
</code></pre>
<p>Array.prototype.flatMap() 方法会在打平数组之前执行一次映射操作。在功能上，arr.flatMap(f) 与 arr.map(f).flat() 等价；但 arr.flatMap() 更高效，因为浏览器只需要执行一次遍历：</p>
<pre><code class="language-js">const arr = [[1], [3], [5]]
console.log(arr.map(([x]) =&gt; [x, x + 1]))
// [[1, 2], [3, 4], [5, 6]]
console.log(arr.flatMap(([x]) =&gt; [x, x + 1]))
// [1, 2, 3, 4, 5, 6]
</code></pre>
<p>flatMap() 在非数组对象的方法返回数组时特别有用，例如字符串的 split() 方法。来看下面的例子，该例子把一组输入字符串分割为单词，然后把这些单词拼接为一个单词数组：</p>
<pre><code class="language-js">const arr = ['Lorem ipsum dolor sit amet,', 'consectetur adipiscing elit.']
console.log(arr.flatMap((x) =&gt; x.split(/[\W+]/)))
// [&quot;Lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;, &quot;&quot;, &quot;consectetur&quot;, &quot;adipiscing&quot;,&quot;elit&quot;, &quot;&quot;]
</code></pre>
<p>对于上面的例子，可以利用空数组进一步过滤上一次映射后的结果，这也是一个数据处理技巧（虽然可能会有些性能损失）。下面的例子扩展了上面的例子，去掉了空字符串：</p>
<pre><code class="language-js">const arr = ['Lorem ipsum dolor sit amet,', 'consectetur adipiscing elit.']
console.log(arr.flatMap((x) =&gt; x.split(/[\W+]/)).flatMap((x) =&gt; x || []))
// [&quot;Lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;, consectetur&quot;, &quot;adipiscing&quot;, &quot;elit&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="042-容器对象-map-与-weakmap"><a class="header" href="#042-容器对象-map-与-weakmap">04.2-容器对象-Map 与 WeakMap</a></h1>
<h2 id="一-map-类型的基本使用"><a class="header" href="#一-map-类型的基本使用">一 Map 类型的基本使用</a></h2>
<h3 id="10-map-简介"><a class="header" href="#10-map-简介">1.0 Map 简介</a></h3>
<p>Map 是 ES6 提供的用来 <strong>专门存储 K/V 键值对</strong> 的集合类型，其作用于 Object 类似，但是二者有一定的差别。</p>
<h3 id="11-map-的创建"><a class="header" href="#11-map-的创建">1.1 Map 的创建</a></h3>
<p>Map 直接使用构造函数创建：</p>
<pre><code class="language-js">// 构建一个空Map映射
const m = new Map()

// 获取空映射的内容
console.log(m.has('firstName')) // false
console.log(m.get('firstName')) // undefined
console.log(m.size) // 0

// 设置普通的kv
m.set(1, 'WW')
m.set('name', 'Lisi')
console.log(m.get(1))
console.log(m.get('name'))

// 使用对象作为key
const obj = function () {}
m.set(obj, 'ZS') // 对象为 key
console.log(m.get(obj))
</code></pre>
<p>Map 构造函数也可以直接传值，且实例会维护插入键值对的插入顺序！</p>
<pre><code class="language-js">const m = new Map([
  ['key1', 'value1'],
  ['key2', 'value2'],
  ['key3', 'value3'],
])
console.log(m.size) // 3
console.log(m.get('key1')) // value1;

// 使用自定义迭代器初始化映射
const m2 = new Map({
  [Symbol.iterator]: function* () {
    yield ['key1', 'val1']
    yield ['key2', 'val2']
    yield ['key3', 'val3']
  },
})
console.log(m2.size) // 3

// 映射期待的键/值对，无论是否提供
const m3 = new Map([[]])
console.log(m3.has(undefined)) // true
console.log(m3.get(undefined)) // undefined
</code></pre>
<h3 id="12-map-的增删改查"><a class="header" href="#12-map-的增删改查">1.2 Map 的增删改查</a></h3>
<pre><code class="language-js">const m = new Map()

// set 方法用来添加键/值对
m.set('firstName', 'Matt')
// set() 方法返回映射实例，因此可以把多个操作连缀起来
m.set('lastName', 'Frisbie').set('realName', 'zs')

// size 属性用来获取键值对数量
console.log(m.size) // 3

// get() 方法获取key对应的值
console.log(m.get('firstName')) // Matt

// has() 方法判断是否存在对应key
console.log(m.has('firstName')) // true

// delete() 方法删除键值对
m.delete('firstName') // 只删除这一个键/值对
console.log(m.has('firstName')) // false
console.log(m.has('lastName')) // true
console.log(m.size) // 1

// clear() 方法清空map，即清除所有键值对
m.clear()
console.log(m.has('firstName')) // false
console.log(m.has('lastName')) // false
console.log(m.size) // 0
</code></pre>
<h3 id="13-任意数据类型作为-map-的-key"><a class="header" href="#13-任意数据类型作为-map-的-key">1.3 任意数据类型作为 Map 的 Key</a></h3>
<p>Map 与 Object 最大的不同是可以使用任意 JavaScript 数据类型作为 key：</p>
<pre><code class="language-js">const m = new Map()

const functionKey = function () {}
const symbolKey = Symbol()
const objectKey = new Object()
m.set(functionKey, 'functionValue')
m.set(symbolKey, 'symbolValue')
m.set(objectKey, 'objectValue')

console.log(m.get(functionKey)) // functionValue
console.log(m.get(symbolKey)) // symbolValue
console.log(m.get(objectKey)) // objectValue
</code></pre>
<p>Map 内部使用 SameValueZero 比较操作（ ECMAScript 规范内部定义的比较算法，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。</p>
<p>与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：</p>
<pre><code class="language-js">const m = new Map()

const objKey = {}
const objVal = { name: 'zs' }
const arrKey = []
const arrVal = [1, 2, 3]
m.set(objKey, objVal)
m.set(arrKey, arrVal)

objKey.foo = 'foo'
objVal.bar = 'bar'
arrKey.push('foo')
arrVal.push('bar')
console.log(m.get(objKey)) // {bar: &quot;bar&quot;}
console.log(m.get(arrKey)) // [&quot;bar&quot;]
</code></pre>
<p>SameValueZero 比较也可能导致意想不到的冲突：</p>
<pre><code class="language-js">const m = new Map()
const a = 0 / '', // NaN
  b = 0 / '', // NaN
  pz = +0,
  nz = -0
console.log(a === b) // false
console.log(pz === nz) // true
m.set(a, 'foo')
m.set(pz, 'bar')
console.log(m.get(b)) // foo
console.log(m.get(nz)) // bar
</code></pre>
<h3 id="14-顺序与迭代"><a class="header" href="#14-顺序与迭代">1.4 顺序与迭代</a></h3>
<p>Map 与 Object 主要差异是 Map 实例会维护键值对的插入顺序。通过 entries()、Symbol.iterator 属性（引用了 entries）迭代：</p>
<pre><code class="language-js">const m = new Map([
  ['key1', 'val1'],
  ['key2', 'val2'],
  ['key3', 'val3'],
])

console.log(m.entries === m[Symbol.iterator]) // true

for (let pair of m.entries()) {
  console.log(pair) // [key1,val1]  [key2,val2]  [key3,val3]
}

// 因为 entries() 是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：
console.log([...m]) // [[key1,val1],[key2,val2],[key3,val3]]
</code></pre>
<p>如果不使用迭代器，而是使用回调方式，则可以调用映射的 forEach(callback, opt_thisArg)方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：</p>
<pre><code class="language-js">const m = new Map([
  ['key1', 'val1'],
  ['key2', 'val2'],
  ['key3', 'val3'],
])

m.forEach((val, key) =&gt; {
  console.log(`${key} -&gt; ${val}`) //  key1 -&gt; val1  key2 -&gt; val2  key3 -&gt; val3
})

// keys()和 values()分别返回以插入顺序生成键和值的迭代器：
for (let key of m.keys()) {
  console.log(key) // key1 key2 key3
}

for (let key of m.values()) {
  console.log(key) // value1 value2 value3
}
</code></pre>
<p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。不过这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份：</p>
<pre><code class="language-js">const m1 = new Map([['key1', 'val1']])

// 作为键的字符串原始值是不能修改的
for (let key of m1.keys()) {
  key = 'newKey'
  console.log(key) // newKey
  console.log(m1.get('key1')) // val1
}

const keyObj = { id: 1 }
const m = new Map([[keyObj, 'val1']])

// 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值
for (let key of m.keys()) {
  key.id = 'newKey'
  console.log(key) // {id: &quot;newKey&quot;}
  console.log(m.get(keyObj)) // val1
}
console.log(keyObj) // {id: &quot;newKey&quot;}
</code></pre>
<h2 id="二-object-与-map-的取舍"><a class="header" href="#二-object-与-map-的取舍">二 Object 与 Map 的取舍</a></h2>
<p>对于大多数前端开发来说，Object 和 Map 的区别影响并不大，其主要影响体现在内存占用、性能等方面：</p>
<p>第一、内存占用：内存的占用与不同浏览器的内存分配实现有关，但是给定固定大小的内存，Map 大约可以比 Object 多存储 50% 的键/值对。</p>
<p>第二、插入性能：向 Object 和 Map 中插入新键/值对的消耗大致相当，不过插入 Map 在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然 Map 的性能更佳。</p>
<p>第三、查找速度：与插入不同，从大型 Object 和 Map 中查找键/值对的性能差异极小，但如果只包含少量键/值对，则 Object 有时候速度更快。在把 Object 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对 Map 来说是不可能的。对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加。</p>
<p>第四、删除性能：对大多数浏览器引擎来说，Map 的 delete() 操作都比插入和查找更快。</p>
<h2 id="三-weakmap"><a class="header" href="#三-weakmap">三 WeakMap</a></h2>
<h3 id="30-weakmap-概念"><a class="header" href="#30-weakmap-概念">3.0 WeakMap 概念</a></h3>
<p>WeakMap 是 Map 的操作类似，其 API 也是 Map 的子集，weak 是描述 JS 垃圾回收时对待弱映射中键的方式。由于是弱引用，WeakMap 也只能支持很少的属性与方法，如 set/get/delete/has。</p>
<h3 id="31-weakmap-的基础使用"><a class="header" href="#31-weakmap-的基础使用">3.1 WeakMap 的基础使用</a></h3>
<p>WeakMap 的使用与 Map 类似：</p>
<pre><code class="language-js">const wm = new WeakMap()
const key1 = { id: 1 }
const key2 = { id: 2 }
const key3 = { id: 3 }

wm.set(key1, 'val1')
wm.set(key2, 'val2')
console.log(wm.has(key1)) // true
console.log(wm.get(key1)) // val1
wm.delete(key1)

// 声明时初始化：若有任意一个键无效，则初始化失败，比如key1重置值为基本类型 “name”
const wm2 = new WeakMap([
  [key1, 'val1'],
  [key2, 'val3'],
  [key3, 'val3'],
])
</code></pre>
<p>注意：WeakMap 的 key 必须是 Object 类型或者继承自 Object 类型，否则会抛出 TypeError，不过原始值可以包装为对象后再作为键使用。</p>
<h3 id="32-weakmap-的弱引用"><a class="header" href="#32-weakmap-的弱引用">3.2 WeakMap 的弱引用</a></h3>
<p>弱引用意味着 <strong>key 不属于正式引用</strong>，不会阻止垃圾回收，如下所示：</p>
<pre><code class="language-js">const wm = new WeakMap()
wm.set({}, 'val')
</code></pre>
<p>set() 方法初始化了一个新对象并将它用作一个字符串的键，因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身也会成为垃圾回收的目标。</p>
<p>以下代码中， container 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标。不过，如果调用了 removeReference()，就会摧毁键对象的最后一个引用，垃圾回收程序就可以把这个键/值对清理掉：</p>
<pre><code class="language-js">const wm = new WeakMap()
const container = {
  key: {},
}

wm.set(container.key, 'val')
function removeReference() {
  container.key = null
}

removeReference()
</code></pre>
<h3 id="33-不可迭代键"><a class="header" href="#33-不可迭代键">3.3 不可迭代键</a></h3>
<p>因为 WeakMap 中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。当然，也用不着像 clear() 这样一次性销毁所有键/值的方法。WeakMap 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱映射中取得值。即便代码可以访问 WeakMap 实例，也没办法看到其中的内容。</p>
<p>WeakMap 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了</p>
<h2 id="四-weakmap-的应用"><a class="header" href="#四-weakmap-的应用">四 WeakMap 的应用</a></h2>
<h3 id="41-私有变量"><a class="header" href="#41-私有变量">4.1 私有变量</a></h3>
<p>私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。如下所示：</p>
<pre><code class="language-js">const wm = new WeakMap()

class User {
  constructor(id) {
    this.idPrpperty = Symbol('id')
    this.setId(id)
  }

  setPrivate(property, value) {
    const privateMembers = wm.get(this) || {}
    privateMembers[property] = value
    wm.set(this, privateMembers)
  }

  getPrivate(property) {
    return wm.get(this)[property]
  }

  setId(id) {
    this.setPrivate(this.idPrpperty, id)
  }

  getId() {
    return this.getPrivate(this.idPrpperty)
  }
}

const user = new User(123)
console.log(user.getId())
user.setId(456)
console.log(user.getId())

// 没有实现私有：只要拿到 wm 和 user 的引用即可获取私有变量
console.log(wm.get(user)[user.idPrpperty])
</code></pre>
<p>可以使用闭包的形式实现彻底的私有：</p>
<pre><code class="language-js">const User = (() =&gt; {
  const wm = new WeakMap()

  class User {
    constructor(id) {
      this.idPrpperty = Symbol('id')
      this.setId(id)
    }

    setPrivate(property, value) {
      const privateMembers = wm.get(this) || {}
      privateMembers[property] = value
      wm.set(this, privateMembers)
    }

    getPrivate(property) {
      return wm.get(this)[property]
    }

    setId(id) {
      this.setPrivate(this.idPrpperty, id)
    }

    getId() {
      return this.getPrivate(this.idPrpperty)
    }
  }

  return User
})()
</code></pre>
<h3 id="42-dom-节点作为键名"><a class="header" href="#42-dom-节点作为键名">4.2 DOM 节点作为键名</a></h3>
<p>WeakMap 的典型应用是：以 DOM 节点作为键名的场景。如果 Map 和 Set 中引用了不再需要的大型对象，如已经从 DOM 树中删除的 DOM 元素，那么其回收代价是昂贵的。为了解决这个问题，ES6 还引入了另外两种新的数据结构，即称为 WeakMap 和 WeakSet 的弱集合。这些集合之所以是“弱的”，是因为它们允许从内存中继续使用不再需要的被这些集合所引用的对象。</p>
<pre><code class="language-js">const m = new Map()
const loginButton = document.querySelector('#login')
// 给这个节点关联一些元数据
m.set(loginButton, { disabled: true })
</code></pre>
<p>假设在上面的代码执行后，页面被 JavaScript 改变了，原来的登录按钮从 DOM 树中被删掉了。但由于映射中还保存着按钮的引用，所以对应的 DOM 节点仍然会逗留在内存中，除非明确将其从映射中删除或者等到映射本身被销毁。如果这里使用的是弱映射，如以下代码所示，那么当节点从 DOM 树中被删除后，垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）：</p>
<pre><code class="language-js">const wm = new WeakMap()
const loginButton = document.querySelector('#login')
// 给这个节点关联一些元数据
wm.set(loginButton, { disabled: true })
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="043-容器对象-set-与-weakset"><a class="header" href="#043-容器对象-set-与-weakset">04.3-容器对象-Set 与 WeakSet</a></h1>
<h2 id="一-set-类型的基本使用"><a class="header" href="#一-set-类型的基本使用">一 Set 类型的基本使用</a></h2>
<h3 id="11-set-的创建"><a class="header" href="#11-set-的创建">1.1 Set 的创建</a></h3>
<p>Set 是 ES6 引入的新的数据容器之一，用于存储不重复的数据：</p>
<pre><code class="language-js">// 创建空Set
let s1 = new Set()
s1.add(1)
s1.add(2)
s1.add(2)
console.log(s1) // Set { 1, 2 }

// 传入可迭代对象创建Set
let s2 = new Set([1, 2, 2])
console.log(s2) // Set { 1, 2 }

// 字符串在构造 Set 的时候，会将字符串进行展开
let s3 = new Set('hello')
console.log(s3) // Set { 'h', 'e', 'l', 'o' }

// 传入自定义迭代器初始化集合
const s4 = new Set({
  [Symbol.iterator]: function* () {
    yield 'val1'
    yield 'val2'
    yield 'val3'
  },
})
</code></pre>
<h3 id="12-set-的增删改查"><a class="header" href="#12-set-的增删改查">1.2 Set 的增删改查</a></h3>
<pre><code class="language-js">let s = new Set([1, 3, 5])
s.add(6)
console.log(s.size) // 4 获取元素个数
console.log(s.has(1)) // true 判断元素是否存在
console.log(s.delete(5)) // true 删除元素
console.log(s.values()) // SetIterator { 1, 3, 6 }
s.clear() // 清空
</code></pre>
<p>与 Map 类似，Set 可以包含任何 JavaScript 数据类型作为值。集合也使用 SameValueZero 操作，基本上相当于使用严格对象相等的标准来检查值的匹配性：</p>
<pre><code class="language-js">const s = new Set()

const functionVal = function () {}
const symbolVal = Symbol()
const objectVal = new Object()

s.add(functionVal)
s.add(symbolVal)
s.add(objectVal)

console.log(s.has(functionVal)) // true
console.log(s.has(symbolVal)) // true
console.log(s.has(objectVal)) // true
// SameValueZero 检查意味着独立的实例不会冲突
console.log(s.has(function () {})) // false
</code></pre>
<p>与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变：</p>
<pre><code class="language-js">const s = new Set()
const objVal = {},
  arrVal = []
s.add(objVal)
s.add(arrVal)

objVal.bar = 'bar'
arrVal.push('bar')
console.log(s.has(objVal)) // true
console.log(s.has(arrVal)) // true
</code></pre>
<p>add()和 delete()操作是幂等的。 delete()返回一个布尔值，表示集合中是否存在要删除的值：</p>
<pre><code class="language-js">const s = new Set()
s.add('foo')
console.log(s.size) // 1
s.add('foo')
console.log(s.size) // 1
// 集合里有这个值
console.log(s.delete('foo')) // true
// 集合里没有这个值
console.log(s.delete('foo')) // false
</code></pre>
<h3 id="13-顺序与迭代"><a class="header" href="#13-顺序与迭代">1.3 顺序与迭代</a></h3>
<p>Set 迭代方式有：</p>
<pre><code class="language-js">let s = new Set([1, 3, 5])

// forEach 方式
s.forEach((v, k, data) =&gt; {
  console.log(v) // 1，由于 set 不是 kv 形式，这里为了统一，让其 v 和 k 一致
  console.log(k) // 1
  console.log(data) // Set { 1, 3, 5 }
})

// for of 方式
for (v of s) {
  console.log(v) // 1 3 5
}
</code></pre>
<p>Set 会维护值插入时的顺序，因此支持按顺序迭代，集合实例可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 values() 方法及其别名方法 keys()（或者 Symbol.iterator 属性，它引用 values()）取得这个迭代器：</p>
<pre><code class="language-js">const s = new Set(['val1', 'val2', 'val3'])
console.log(s.values === s[Symbol.iterator]) // true
console.log(s.keys === s[Symbol.iterator]) // true

for (let value of s.values()) {
  console.log(value) // val1 val2 val3
}

for (let value of s[Symbol.iterator]()) {
  console.log(value) // val1 val2 val3
}
</code></pre>
<p>因为 values() 是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：</p>
<pre><code class="language-js">const s = new Set(['val1', 'val2', 'val3'])
console.log([...s]) // [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]
</code></pre>
<p>集合的 entries() 方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现：</p>
<pre><code class="language-js">const s = new Set(['val1', 'val2', 'val3'])
for (let pair of s.entries()) {
  console.log(pair) // [&quot;val1&quot;, &quot;val1&quot;] [&quot;val2&quot;, &quot;val2&quot;] [&quot;val3&quot;, &quot;val3&quot;]
}
</code></pre>
<p>如果不使用迭代器，而是使用回调方式，则可以调用集合的 forEach() 方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：</p>
<pre><code class="language-js">const s = new Set(['val1', 'val2', 'val3'])
s.forEach((val, dupVal) =&gt; {
  console.log(`${val} -&gt; ${dupVal}`) //  val1 -&gt; val1 val2 -&gt; val2 val3 -&gt; val3
})
</code></pre>
<p>修改集合中值的属性不会影响其作为集合值的身份：</p>
<pre><code class="language-js">const s1 = new Set(['val1'])

// 字符串原始值作为值不会被修改
for (let value of s1.values()) {
  value = 'newVal'
  console.log(value) // newVal
  console.log(s1.has('val1')) // true
}

const valObj = { id: 1 }
const s2 = new Set([valObj])

// 修改值对象的属性，但对象仍然存在于集合中
for (let value of s2.values()) {
  value.id = 'newVal'
  console.log(value) // {id: &quot;newVal&quot;}
  console.log(s2.has(valObj)) // true
}
console.log(valObj) // {id: &quot;newVal&quot;}
</code></pre>
<h2 id="二-set-的常用操作"><a class="header" href="#二-set-的常用操作">二 Set 的常用操作</a></h2>
<h3 id="21-set-与数组的转换"><a class="header" href="#21-set-与数组的转换">2.1 Set 与数组的转换</a></h3>
<pre><code class="language-js">// 在 1.1 数组可以直接构造为 Set
let s2 = new Set([1, 2, 2])

// Set 也可以重新转换为数组，有两种方式
let arr2 = Array.from(s1)
let arr3 = [...s2]
</code></pre>
<h3 id="22-求交集并集差集"><a class="header" href="#22-求交集并集差集">2.2 求交集、并集、差集</a></h3>
<pre><code class="language-js">let s1 = new Set([1, 2, 3, 4])
let s2 = new Set([2, 3, 5, 7])

// 求并集
console.log(new Set([...s1, ...s2]))

// 差集
console.log(
  new Set(
    [...s1].filter((item) =&gt; {
      return !s1.has(item)
    })
  )
)

// 交集
console.log(
  new Set(
    [...s1].filter((item) =&gt; {
      return s1.has(item)
    })
  )
)
</code></pre>
<h3 id="23-定义正式集合操作"><a class="header" href="#23-定义正式集合操作">2.3 定义正式集合操作</a></h3>
<p>从各方面来看， Set 跟 Map 都很相似，只是 API 稍有调整。唯一需要强调的就是集合的 API 对自身的简单操作。很多开发者都喜欢使用 Set 操作，但需要手动实现：或者是子类化 Set，或者是定义一个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。在实现这些操作时，需要考虑几个地方：</p>
<ul>
<li>某些 Set 操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。</li>
<li>Set 保留插入顺序，所有方法返回的集合必须保证顺序。</li>
<li>尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能够节省对象初始化成本。</li>
<li>不要修改已有的集合实例。 union(a, b)或 a.union(b)应该返回包含结果的新集合实例</li>
</ul>
<pre><code class="language-js">class XSet extends Set {
  union(...sets) {
    return XSet.union(this, ...sets)
  }
  intersection(...sets) {
    return XSet.intersection(this, ...sets)
  }
  difference(set) {
    return XSet.difference(this, set)
  }
  symmetricDifference(set) {
    return XSet.symmetricDifference(this, set)
  }
  cartesianProduct(set) {
    return XSet.cartesianProduct(this, set)
  }
  powerSet() {
    return XSet.powerSet(this)
  }
  // 返回两个或更多集合的并集
  static union(a, ...bSets) {
    const unionSet = new XSet(a)
    for (const b of bSets) {
      for (const bValue of b) {
        unionSet.add(bValue)
      }
    }
    return unionSet
  }
  // 返回两个或更多集合的交集
  static intersection(a, ...bSets) {
    const intersectionSet = new XSet(a)
    for (const aValue of intersectionSet) {
      for (const b of bSets) {
        if (!b.has(aValue)) {
          intersectionSet.delete(aValue)
        }
      }
    }
    return intersectionSet
  }
  // 返回两个集合的差集
  static difference(a, b) {
    const differenceSet = new XSet(a)
    for (const bValue of b) {
      if (a.has(bValue)) {
        differenceSet.delete(bValue)
      }
    }
    return differenceSet
  }
  // 返回两个集合的对称差集
  static symmetricDifference(a, b) {
    // 按照定义，对称差集可以表达为
    return a.union(b).difference(a.intersection(b))
  }
  // 返回两个集合（数组对形式）的笛卡儿积:必须返回数组集合，因为笛卡儿积可能包含相同值的对
  static cartesianProduct(a, b) {
    const cartesianProductSet = new XSet()
    for (const aValue of a) {
      for (const bValue of b) {
        cartesianProductSet.add([aValue, bValue])
      }
    }
    return cartesianProductSet
  }
  // 返回一个集合的幂集
  static powerSet(a) {
    const powerSet = new XSet().add(new XSet())
    for (const aValue of a) {
      for (const set of new XSet(powerSet)) {
        powerSet.add(new XSet(set).add(aValue))
      }
    }
    return powerSet
  }
}
</code></pre>
<h2 id="三-weakset"><a class="header" href="#三-weakset">三 WeakSet</a></h2>
<h3 id="41-weakset-的基本使用"><a class="header" href="#41-weakset-的基本使用">4.1 WeakSet 的基本使用</a></h3>
<p>WeakSet 与 Set 集合一样，用来存储不重复的数据，但是 WeakSet 只能存储引用类型，尝试使用非对象设置值会抛出 TypeError，不过原始值可以先包装成对象再用作值：</p>
<pre><code class="language-js">// const ws = new WeakSet();
const val1 = { id: 1 },
  val2 = { id: 2 },
  val3 = { id: 3 }
// 使用数组初始化弱集合
const ws1 = new WeakSet([val1, val2, val3])
console.log(ws1.has(val1)) // true
console.log(ws1.has(val2)) // true
console.log(ws1.has(val3)) // true

// 初始化之后可以使用 add() 再添加新值，可以使用 has() 查询，还可以使用 delete() 删除：
const val4 = { id: 4 }
ws1.add(val4, 'val4')

// 初始化是全有或全无的操作:只要有一个值无效就会抛出错误，导致整个初始化失败
const ws2 = new WeakSet([val1, 'BADVAL', val3]) // TypeError: Invalid value used in WeakSet
typeof ws2 // ReferenceError: ws2 is not defined

// 原始值可以先包装成对象再用作值
const stringVal = new String('val1')
const ws3 = new WeakSet([stringVal])
console.log(ws3.has(stringVal)) // true
</code></pre>
<h3 id="42-弱值"><a class="header" href="#42-弱值">4.2 弱值</a></h3>
<p>WeakSet 中 weak 表示弱集合的值是不属于正式的引用，不会阻止垃圾回收。</p>
<pre><code class="language-js">// 因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象值就会被当作垃圾回收。然后，这个值就从弱集合中消失了，使其成为一个空集合。
const ws = new WeakSet()
console.log(ws) //WeakSet { &lt;items unknown&gt; }
ws.add({}, '11')
console.log(ws) //WeakSet { &lt;items unknown&gt; }
</code></pre>
<p>不会被垃圾回收的示例：</p>
<pre><code class="language-js">const ws = new WeakSet()
const container = {
  val: {},
}
// container 对象维护着一个对弱集合值的引用，不会被垃圾回收
ws.add(container.val)

// 当地调用该函数后，weakset 的键会被回收
function removeReference() {
  container.val = null
}
</code></pre>
<h3 id="43-不可迭代值"><a class="header" href="#43-不可迭代值">4.3 不可迭代值</a></h3>
<p>因为 WeakSet 中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。当然，也用不着像 clear() 这样一次性销毁所有值的方法。WeakSet 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱集合中取得值。即便代码可以访问 WeakSet 实例，也没办法看到其中的内容。</p>
<p>WeakSet 之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。</p>
<h3 id="44-弱集合应用"><a class="header" href="#44-弱集合应用">4.4 弱集合应用</a></h3>
<p>WeakSet 实际用处较少，适合少量场景，如给对象打标签：</p>
<pre><code class="language-js">// 通过查询元素在不在 disabledElements 中，就可以知道它是不是被禁用了
// 使用 WeakSet 才能被回收：只要 WeakSet 中任何元素从 DOM 树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。
const disabledElements = new WeakSet()
const loginButton = document.querySelector('#login')
// 通过加入对应集合，给这个节点打上“禁用”标签
disabledElements.add(loginButton)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="044-容器对象-定型数组"><a class="header" href="#044-容器对象-定型数组">04.4-容器对象-定型数组</a></h1>
<h2 id="一-定型数组概念"><a class="header" href="#一-定型数组概念">一 定型数组概念</a></h2>
<p>定型数组（TypedArray）是新增的数据结构，目的是提升向原生库传输数据的效率，如 WebGL。</p>
<p>WebGL 是一套浏览器能够原生执行的计算机图形 API，在 WebGL 的早期版本中，因为 JavaScript 数组与原生数组之间不匹配，所以出现了性能问题。吐信驱动的 API 不需要 JavaScript 默认的双精度浮点格式，因此，每次 WebGL 与 JavaScript 运行时之间传递数组时， WebGL 绑定都需要在目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式，而这些要花费很多时间。</p>
<p>为了解决这个问题，Mozilla 实现了 CanvasFloatArray 数据结构，这是一个 C 语言风格的浮点值数组，JavaScript 运行时使用该结构可以直接进行分配、读写，底层图形驱动程序拿到该数组也无需转换。CanvasFloatArray 最终演化成了 Float32Array。</p>
<h2 id="二-基本单位-arraybuffer"><a class="header" href="#二-基本单位-arraybuffer">二 基本单位 ArrayBuffer</a></h2>
<p>ArrayBuffer 是一块预分配的内存，是所有定型数组、视图引用的基本单位，其本质仍然是一个普通的 JS 构造函数，用于在内存中分配特定数量的字节空间：</p>
<pre><code class="language-js">const buf = new ArrayBuffer(16) // 在内存中分配 16 字节
console.log(buf.byteLength) // 16
</code></pre>
<p>与普通数组不同的是，ArrayBuffer 一旦创建就不能调整大小，只能使用 slice() 复制其全部、部分到一个全新的实例中：</p>
<pre><code class="language-js">const buf1 = new ArrayBuffer(16)
const buf2 = buf1.slice(4, 12)
console.log(buf2.byteLength) // 8
</code></pre>
<p>ArrayBuffer 与 C++ 中的 malloc 很相似，区别如下：</p>
<ul>
<li>ArrayBuffer 在分配失败时抛出错误，而 malloc() 则返回 null 指针</li>
<li>ArrayBuffer 可分配内存不能超过 Number.MAX_SAFE_INTEGER 字节，malloc() 则可以使用虚拟内存</li>
<li>ArrayBuffer 声明后，所有二进制位都被初始化为 0，malloc() 则不会初始化实际地址</li>
<li>ArrayBuffer 申请的内存支持垃圾回收，malloc() 则需要使用 free() 手动释放</li>
</ul>
<p><strong>ArrayBuffer 内存储的二进制数据不能直接读写，必须通过一些专门设计好的类来实现读写</strong>，如：</p>
<ul>
<li>视图类 DataView</li>
<li>ElementType</li>
<li>定型数组</li>
</ul>
<h2 id="三-操作基本单位"><a class="header" href="#三-操作基本单位">三 操作基本单位</a></h2>
<h3 id="31-dataview-类"><a class="header" href="#31-dataview-类">3.1 DataView 类</a></h3>
<p>视图 DataView 是专门为 I/O 设计的读写 ArrayBuffer 的类：</p>
<pre><code class="language-js">const buf = new ArrayBuffer(16)

// 视图默认使用整个 ArrayBuffer：
const dv = new DataView(buf)
console.log(dv.byteLength) // 16
console.log(dv.byteOffset) // 0
console.log(dv.buffer === buf) // true

// 构造函数通过参数字节偏移量和字节长度，使用部分 ArrayBuffer：
const dv1 = new DataView(buf, 0, 8) // 参数二 byteOffset 表示缓冲起点；参数三 byteLength 限制视图为前 8 个字节
console.log(dv1.buffer === buf) // true
console.log(dv1.byteLength) // 8
console.log(dv1.byteOffset) // 0

// 若 byteLength 未指定，视图默认使用剩余缓冲，则视图使用剩余缓冲
const dv2 = new DataView(buf, 8) // byteOffset=8 表示视图从缓冲的第 9 个字节开始
console.log(dv2.byteLength) // 8
console.log(dv2.byteOffset) // 8
console.log(dv2.buffer === buf) // true
</code></pre>
<p>视图没有预设数据类型，也不能迭代！</p>
<h3 id="32-elementtype"><a class="header" href="#32-elementtype">3.2 ElementType</a></h3>
<p>由于 DataView 没有预设数据类型，不能直接实现对 ArrayBuffer 数据的读写，要通过 DataView 读取缓冲，还需要几个组件：</p>
<ul>
<li>首先是要读或写的字节偏移量。可以看成 DataView 中的某种“地址”。</li>
<li>DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换。</li>
<li>最后是内存中值的字节序。默认为大端字节序。</li>
</ul>
<p>ES6 支持 8 中 ElementType：</p>
<p><img src="02-JavaScript%E8%AF%AD%E6%B3%95%E8%BF%9B%E9%98%B6/../images/javascript/array-buffer.png" alt="ElementType" /></p>
<p>DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移量）定位要读取或写入值的位置，类型也是可以互换使用的：</p>
<pre><code class="language-js">// 在内存中分配两个字节并声明一个 DataView
const buf = new ArrayBuffer(2)
const view = new DataView(buf)

// 查询缓冲中所有二进制位的值，默认都是0
console.log(view.getInt8(0)) // 检查第一个字符：0
console.log(view.getInt8(1)) // 检查第二个字符：0
console.log(view.getInt16(0)) // 检查整个缓冲：0

// 将整个缓冲都设置为 1
view.setUint8(0, 255) // 255 的二进制表示是 11111111（2^8 - 1）

// DataView 会自动将数据转换为特定的 ElementType
view.setUint8(1, 0xff) // 255 的十六进制表示是 0xFF

// 缓冲现在都是 1，如果当成二补数的有符号整数，则应该是 -1
console.log(view.getInt16(0)) // -1
</code></pre>
<h2 id="四-字节序与边界"><a class="header" href="#四-字节序与边界">四 字节序与边界</a></h2>
<h3 id="41-字节序"><a class="header" href="#41-字节序">4.1 字节序</a></h3>
<p>“字节序”指的是计算系统维护的一种字节顺序的约定。字节序”指的是计算系统维护的一种字节顺序的约定，一般有两种：</p>
<ul>
<li>大端字节序：最高有效位保存在第一个字节，最低有效位保存在最后一个字节，也称为网络字节序</li>
<li>小端字节序：最低有效位保存在第一个字节，最高有效位保存在最后一个字节</li>
</ul>
<p>JavaScript 的运行时所在的操作系统会决定如何读取、写入字节，但是 DataView 会遵循开发者指定的字节序，默认是大端字节序，但接收一个可选的布尔值参数，设置为 true 即可启用小端字节序：</p>
<pre><code class="language-js">// 在内存中分配两个字节并声明一个 DataView
const buf = new ArrayBuffer(2)
const view = new DataView(buf)

// 填充缓冲，让第一位和最后一位都是 1
view.setUint8(0, 0x80) // 设置最左边的位等于 1
view.setUint8(1, 0x01) // 设置最右边的位等于 1

// 缓冲内容（为方便阅读，人为加了空格）
// 0x8 0x0 0x0 0x1
// 1000 0000 0000 0001

// 按大端字节序读取 Uint16
// 0x80 是高字节，0x01 是低字节
// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769
console.log(view.getUint16(0)) // 32769

// 按小端字节序读取 Uint16
// 0x01 是高字节，0x80 是低字节
// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384
console.log(view.getUint16(0, true)) // 384

// 按大端字节序写入 Uint16
view.setUint16(0, 0x0004)

// 缓冲内容（为方便阅读，人为加了空格）
// 0x0 0x0 0x0 0x4
// 0000 0000 0000 0100
console.log(view.getUint8(0)) // 0
console.log(view.getUint8(1)) // 4

// 按小端字节序写入 Uint16
view.setUint16(0, 0x0002, true)

// 缓冲内容（为方便阅读，人为加了空格）
// 0x0 0x2 0x0 0x0
// 0000 0010 0000 0000
console.log(view.getUint8(0)) // 2
console.log(view.getUint8(1)) // 0
</code></pre>
<h3 id="42-边界"><a class="header" href="#42-边界">4.2 边界</a></h3>
<p>DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError：</p>
<pre><code class="language-js">const buf = new ArrayBuffer(6)
const view = new DataView(buf)

// 尝试读取部分超出缓冲范围的值
view.getInt32(4)

// 尝试读取超出缓冲范围的值
view.getInt32(8) // RangeError

// 尝试读取超出缓冲范围的值
view.getInt32(-1) // RangeError

// 尝试写入超出缓冲范围的值
view.setInt32(4, 123) // RangeError
</code></pre>
<p>DataView 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如果无法转换，则抛出错误：</p>
<pre><code class="language-js">const buf = new ArrayBuffer(1)
const view = new DataView(buf)

view.setInt8(0, 1.5)
console.log(view.getInt8(0)) // 1

view.setInt8(0, [4])
console.log(view.getInt8(0)) // 4

view.setInt8(0, 'f')
console.log(view.getInt8(0)) // 0

view.setInt8(0, Symbol()) // TypeError
// TypeError
</code></pre>
<h2 id="五-定型数组"><a class="header" href="#五-定型数组">五 定型数组</a></h2>
<h3 id="51-定型数组概念"><a class="header" href="#51-定型数组概念">5.1 定型数组概念</a></h3>
<p>定型数组是另一种 ArrayBuffer 的视图，特定于一种 ElementType，遵循系统原生字节序！</p>
<p>设计定型数组的目的就是提高与 WebGL 等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript 引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快。</p>
<p>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过<code>&lt;ElementType&gt;.from()</code>和<code>&lt;ElementType&gt;.of()</code>也可以创建定型数组：</p>
<pre><code class="language-js">// 创建一个 12 字节的缓冲
const buf = new ArrayBuffer(12)
// 创建一个引用该缓冲的定型数组
const ints = new Int32Array(buf)
console.log(ints.length) // 每个元素需要 4 字节，因此长度为 3

// 创建一个长度为 6 的 Int32Array
const ints2 = new Int32Array(6)
// 每个数值使用 4 字节，因此 ArrayBuffer 是 24 字节
console.log(ints2.length) // 6
// 类似 DataView，定型数组也有一个指向关联缓冲的引用
console.log(ints2.buffer.byteLength) // 24

// 创建一个包含 [2, 4, 6, 8] 的 Int32Array
const ints3 = new Int32Array([2, 4, 6, 8])
console.log(ints3.length) // 4
console.log(ints3.buffer.byteLength) // 16
console.log(ints3[2]) // 6

// 通过复制 ints3 的值创建一个 Int16Array
const ints4 = new Int16Array(ints3)
// 这个新类型数组会分配自己的缓冲
// 对应索引的每个值会相应地转换为新格式
console.log(ints4.length) // 4
console.log(ints4.buffer.byteLength) // 8
console.log(ints4[2]) // 6

// 基于普通数组来创建一个 Int16Array
const ints5 = Int16Array.from([3, 5, 7, 9])
console.log(ints5.length) // 4
console.log(ints5.buffer.byteLength) // 8
console.log(ints5[2]) // 7

// 基于传入的参数创建一个 Float32Array
const floats = Float32Array.of(3.14, 2.718, 1.618)
console.log(floats.length) // 3
console.log(floats.buffer.byteLength) // 12
console.log(floats[2]) // 1.6180000305175781
</code></pre>
<p>定型数组的构造函数和实例都有一个 BYTES_PER_ELEMENT 属性，返回该类型数组中每个元素的大小：</p>
<pre><code class="language-js">console.log(Int16Array.BYTES_PER_ELEMENT) // 2
console.log(Int32Array.BYTES_PER_ELEMENT) // 4

const ints = new Int32Array(1)
const floats = new Float64Array(1)
console.log(ints.BYTES_PER_ELEMENT) // 4
console.log(floats.BYTES_PER_ELEMENT) // 8
</code></pre>
<p>如果定型数组没有用任何值初始化，则其关联的缓冲会以 0 填充：</p>
<pre><code class="language-js">const ints = new Int32Array(4)
console.log(ints[0]) // 0
console.log(ints[1]) // 0
console.log(ints[2]) // 0
console.log(ints[3]) // 0
</code></pre>
<h3 id="52-定型数组行为"><a class="header" href="#52-定型数组行为">5.2 定型数组行为</a></h3>
<p>定型数组与普通数组都很相似，支持绝大多数普通数组的方法。</p>
<p>定型数组有一个 Symbol.iterator 符号属性，因此可以通过 for..of 循环和扩展操作符来操作：</p>
<pre><code class="language-js">const ints = new Int16Array([1, 2, 3])
for (const int of ints) {
  console.log(int) // 1 2 3
}
console.log(Math.max(...ints)) // 3
</code></pre>
<p>定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组：</p>
<pre><code class="language-js">concat()
pop()
push()
shift()
splice()
unshift()
</code></pre>
<p>不过定型数组也提供了两个新方法，可以快速向外或向内复制数据：set() 和 subarray()。示例：</p>
<pre><code class="language-js">// 创建长度为 8 的 int16 数组
const container = new Int16Array(8)

// 把定型数组复制为前 4 个值
// 偏移量默认为索引 0
container.set(Int8Array.of(1, 2, 3, 4))
console.log(container) // [1,2,3,4,0,0,0,0]

// 把普通数组复制为后 4 个值
// 偏移量 4 表示从索引 4 开始插入
container.set([5, 6, 7, 8], 4)
console.log(container) // [1,2,3,4,5,6,7,8]

// 溢出会抛出错误
container.set([5, 6, 7, 8], 7)
// RangeError
</code></pre>
<p>subarray() 执行与 set() 相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的：</p>
<pre><code class="language-js">const source = Int16Array.of(2, 4, 6, 8)

// 把整个数组复制为一个同类型的新数组
const fullCopy = source.subarray()
console.log(fullCopy) // [2, 4, 6, 8]

// 从索引 2 开始复制数组
const halfCopy = source.subarray(2)
console.log(halfCopy) // [6, 8]

// 从索引 1 开始复制到索引 3
const partialCopy = source.subarray(1, 3)
console.log(partialCopy) // [4, 6]
</code></pre>
<p>定型数组没有原生的拼接能力，但使用定型数组 API 提供的很多工具可以手动构建：</p>
<pre><code class="language-js">// 第一个参数是应该返回的数组类型
// 其余参数是应该拼接在一起的定型数组
function typedArrayConcat(typedArrayConstructor, ...typedArrays) {
  // 计算所有数组中包含的元素总数
  const numElements = typedArrays.reduce((x, y) =&gt; (x.length || x) + y.length)
  // 按照提供的类型创建一个数组，为所有元素留出空间
  const resultArray = new typedArrayConstructor(numElements)
  // 依次转移数组
  let currentOffset = 0
  typedArrays.map((x) =&gt; {
    resultArray.set(x, currentOffset)
    currentOffset += x.length
  })
  return resultArray
}
const concatArray = typedArrayConcat(
  Int32Array,
  Int8Array.of(1, 2, 3),
  Int16Array.of(4, 5, 6),
  Float32Array.of(7, 8, 9)
)
console.log(concatArray) // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(concatArray instanceof Int32Array) // true
</code></pre>
<h3 id="53-下溢上溢"><a class="header" href="#53-下溢上溢">5.3 下溢、上溢</a></h3>
<p>定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。以下代码演示了如何处理下溢和上溢：</p>
<pre><code class="language-js">// 长度为 2 的有符号整数数组
// 每个索引保存一个二补数形式的有符号整数
// 范围是 -128（ -1 * 2^7） ~127（2^7 - 1）
const ints = new Int8Array(2)

// 长度为 2 的无符号整数数组
// 每个索引保存一个无符号整数
// 范围是 0~255（2^7 - 1）
const unsignedInts = new Uint8Array(2)

// 上溢的位不会影响相邻索引
// 索引只取最低有效位上的 8 位
unsignedInts[1] = 256 // 0x100
console.log(unsignedInts) // [0, 0]
unsignedInts[1] = 511 // 0x1FF
console.log(unsignedInts) // [0, 255]

// 下溢的位会被转换为其无符号的等价值
// 0xFF 是以二补数形式表示的 -1（截取到 8 位） ,
// 但 255 是一个无符号整数
unsignedInts[1] = -1 // 0xFF (truncated to 8 bits)
console.log(unsignedInts) // [0, 255]

// 上溢自动变成二补数形式
// 0x80 是无符号整数的 128，是二补数形式的 -128
ints[1] = 128 // 0x80
console.log(ints) // [0, -128]

// 下溢自动变成二补数形式
// 0xFF 是无符号整数的 255，是二补数形式的 -1
ints[1] = 255 // 0xFF
console.log(ints) // [0, -1]
</code></pre>
<p>除了 8 种元素类型，还有一种“夹板”数组类型： Uint8ClampedArray，不允许任何方向溢出。超出最大值 255 的值会被向下舍入为 255，而小于最小值 0 的值会被向上舍入为 0。</p>
<pre><code class="language-js">const clampedInts = new Uint8ClampedArray([-1, 0, 255, 256])
console.log(clampedInts) // [0, 0, 255, 255]
</code></pre>
<p>按照 JavaScript 之父 Brendan Eich 的说法：“Uint8ClampedArray 完全是 HTML5canvas 元素的历史留存。除非真的做跟 canvas 相关的开发，否则不要使用它。”</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-迭代器与生成器-iterator"><a class="header" href="#051-迭代器与生成器-iterator">05.1-迭代器与生成器-Iterator</a></h1>
<h2 id="一-迭代的概念"><a class="header" href="#一-迭代的概念">一 迭代的概念</a></h2>
<p>迭代的意思其实就是按照顺序反复多次执行一段程序，通常拥有明确的终止条件。在 JS 中，计数 for 循环是最简单的迭代。循环是迭代机制的基础，主要包含三个要素：</p>
<ul>
<li>迭代的次数</li>
<li>迭代的操作。每次下一次迭代之前，本轮迭代操作必须完成。</li>
<li>迭代的顺序。</li>
</ul>
<p>由于数组有长度、索引，直接就能满足上述要求，是可以执行迭代的最基础的数据结构，仅仅通过 for 循环就能实现很优秀的遍历。然而普通的 for 循环迭代，会让复杂的代码发生混乱，尤其是在一些高级数据结构的遍历表现，因为：</p>
<ul>
<li>迭代之前需要事先知道如何使用数据结构。数组中的每一项都只能先通过引用取得数组对象，然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。</li>
<li>遍历顺序并不是数据结构固有的。通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。</li>
</ul>
<p>如果执行得带使用循环或者其他辅助结构，随着代码量增加，代码就会变得越发混乱。针对上述问题，ES5 为数组对象提供了 <code>Array.prototype.forEach()</code> 迭代方法，解决了单独记录索引、通用数组对象取值等问题，但是没办法标识迭代何时终止，所以该方法只适用于数组！</p>
<p>编程语言应该为数据结构提供更加通用的迭代方法，Java、Python 在语言层面已经实现，这就是迭代器模式：开发者无须事先知道如何迭代就能实现迭代操作。</p>
<h2 id="二-迭代器模式"><a class="header" href="#二-迭代器模式">二 迭代器模式</a></h2>
<h3 id="20-迭代器模式概念"><a class="header" href="#20-迭代器模式概念">2.0 迭代器模式概念</a></h3>
<p>迭代器模式其实是一个迭代方案：定义了一个迭代器接口（Iterator），实现该接口的结构可以通过迭代器 Iterator 进行消费！这种结构也称呼为可迭代对象，比如我们常见的数组、集合都是。</p>
<p>任何实现 Iterable 接口的数据结构都可以被实现 Iterator 接口的结构“消费”（ consume）。 迭代器（ iterator）是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的 API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的
值。这种概念上的分离正是 Iterable 和 Iterator 的强大之处。</p>
<h3 id="21-可迭代协议"><a class="header" href="#21-可迭代协议">2.1 可迭代协议</a></h3>
<p>实现 Iterable 接口（可迭代协议）要求同时具备两种能力：</p>
<ul>
<li>支持迭代的自我识别能力</li>
<li>创建实现 Iterator 接口的对象的能力</li>
</ul>
<p>从上可以理解到可迭代协议的概念：数据结构必须暴露一个默认迭代属性，由于其特殊性，该属性必须采用 Symbol.iterator 作为 key，值必须是一个返回新迭代器的工厂函数。</p>
<p>以下示例是没有实现迭代器工厂函数的数据：</p>
<pre><code class="language-js">let num = 1
let obj = {}
console.log(num[Symbol.iterator]) // undefined
console.log(obj[Symbol.iterator]) // undefined
</code></pre>
<p>实现了 Iterator 接口的原生 JavaScript 结构有：tring、Array、Set、Map、Arguments 对象、TypedArray、NodeList 等 DOM 集合。如下所示：</p>
<pre><code class="language-js">let str = 'abc'
let arr = ['a', 'b', 'c']
let map = new Map().set('a', 1).set('b', 2).set('c', 3)
let set = new Set().add('a').add('b').add('c')

console.log(str[Symbol.iterator]) // f values() { [native code] }
console.log(arr[Symbol.iterator]) // f values() { [native code] }
console.log(map[Symbol.iterator]) // f values() { [native code] }
console.log(set[Symbol.iterator]) // f values() { [native code] }

// 调用这个工厂函数会生成一个迭代器
console.log(str[Symbol.iterator]()) // StringIterator {}
console.log(arr[Symbol.iterator]()) // ArrayIterator {}
console.log(map[Symbol.iterator]()) // MapIterator {}
console.log(set[Symbol.iterator]()) // SetIterator {}
</code></pre>
<p>实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。下面这些语言结构都会在语言层面直接调用其提供的可迭代对象工厂函数，从而创建一个迭代器：</p>
<ul>
<li>支持 for-of 循环</li>
<li>支持数组结构</li>
<li>支持扩展操作符</li>
<li>支持 Array.from() 创建数组，也支持创建集合</li>
<li>支持 <code>yield*</code> 操作符</li>
<li>支持 Promise.all()、Promise.race() 接收的可迭代对象</li>
</ul>
<pre><code class="language-js">let arr = ['foo', 'bar', 'baz']

// for-of 循环
for (let el of arr) {
  console.log(el) // foo, bar, baz
}

// 数组解构
let [a, b, c] = arr
console.log(a, b, c) // foo, bar, baz

// 扩展操作符
let arr2 = [...arr]
console.log(arr2) // ['foo', 'bar', 'baz']

// Array.from()
let arr3 = Array.from(arr)
console.log(arr3) // ['foo', 'bar', 'baz']

// Set 构造函数
let set = new Set(arr)
console.log(set) // Set(3) {'foo', 'bar', 'baz'}

// Map 构造函数
let pairs = arr.map((x, i) =&gt; [x, i])
console.log(pairs) // [['foo', 0], ['bar', 1], ['baz', 2]]
let map = new Map(pairs)
console.log(map) // Map(3) { 'foo'=&gt;0, 'bar'=&gt;1, 'baz'=&gt;2 }
</code></pre>
<p>如果对象原型链上的父类实现了 Iterable 接口，那这个对象也就实现了这个接口：</p>
<pre><code class="language-js">class FooArray extends Array {}

let fooArr = new FooArray('foo', 'bar', 'baz')
for (let el of fooArr) {
  console.log(el)
}
</code></pre>
<h3 id="22-迭代器协议"><a class="header" href="#22-迭代器协议">2.2 迭代器协议</a></h3>
<p>通过迭代器工厂获得的迭代器是只能一次性使用的对象，使用 next() 方法遍历可迭代对象中的数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next()，则无法知道迭代器的当前位置。</p>
<p>next() 方法返回的迭代器对象 IteratorResult 包含两个属性：</p>
<ul>
<li>done：是一个布尔值，表示是否还可以再次调用 next() 取得下一个值</li>
<li>value：包含可迭代对象的下一个值（done 为 false），或者 undefined（done 为 true）。<code>done: true</code> 状态则称为“耗尽”</li>
</ul>
<p>如下所示：</p>
<pre><code class="language-js">// 可迭代对象
let arr = ['a', 'b', 'c']

// 执行工厂函数，获取迭代器
let iter = arr[Symbol.iterator]()

// 手动执行迭代
console.log(iter.next()) // { value: 'a', done: false }
console.log(iter.next()) // { value: 'b', done: false }
console.log(iter.next()) // { value: 'c', done: false }
console.log(iter.next()) // { value: undefined, done: true }

// 反复执行迭代：
console.log(iter.next()) // { value: undefined, done: true }
console.log(iter.next()) // { value: undefined, done: true }
</code></pre>
<p>贴士：迭代器并不知道如何从可迭代对象中取得下一个值，也不知道可迭代对象的容量，只是迭代到 <code>done: true</code>状态之后，会一直返回同样的值而已。</p>
<p>注意 1：同一个迭代工厂创建的不同迭代器之间没有关联，都可以独立迭代对象：</p>
<pre><code class="language-js">let arr = ['foo', 'bar']
let iter1 = arr[Symbol.iterator]()
let iter2 = arr[Symbol.iterator]()
console.log(iter1.next()) // { done: false, value: 'foo' }
console.log(iter2.next()) // { done: false, value: 'foo' }
console.log(iter2.next()) // { done: false, value: 'bar' }
console.log(iter1.next()) // { done: false, value: 'bar' }
</code></pre>
<p>注意 2：迭代器并不与可迭代对象的快照绑定，游标是遍历的唯一准则。即迭代时，可迭代对象修改了，迭代器也会发生变化：</p>
<pre><code class="language-js">let arr = ['foo', 'baz']
let iter = arr[Symbol.iterator]()
console.log(iter.next()) // { done: false, value: 'foo' }
// 在数组中间插入值
arr.splice(1, 0, 'bar')
console.log(iter.next()) // { done: false, value: 'bar' }
console.log(iter.next()) // { done: false, value: 'baz' }
console.log(iter.next()) // { done: true, value: undefined }
</code></pre>
<h2 id="三-自定义迭代器"><a class="header" href="#三-自定义迭代器">三 自定义迭代器</a></h2>
<h3 id="31-自定义迭代器"><a class="header" href="#31-自定义迭代器">3.1 自定义迭代器</a></h3>
<p>任何实现 Iterator 接口的对象都可以作为迭代器使用：</p>
<pre><code class="language-js">class Counter {
  // Counter 的实例应该迭代 limit 次
  constructor(limit) {
    this.count = 1
    this.limit = limit
  }

  next() {
    // 必须进行次数如下限制，否则for-of会无限循环
    if (this.count &lt;= this.limit) {
      return { done: false, value: this.count++ }
    } else {
      return { done: true, value: undefined }
    }
  }

  [Symbol.iterator]() {
    return this
  }
}

let counter = new Counter(3)
for (let i of counter) {
  console.log(i) // 1 2 3
}

// 再次迭代无输出
for (let i of counter) {
  console.log(i)
}
</code></pre>
<p>上述迭代器有个 BUG：只能 for of 迭代一次，下次再迭代就会失败，因为 count 已经变化了，必须对 count 进行闭包保护：</p>
<pre><code class="language-js">class Counter {
  constructor(limit) {
    this.limit = limit
  }

  [Symbol.iterator]() {
    let count = 1,
      limit = this.limit
    return {
      next() {
        if (count &lt;= limit) {
          return { done: false, value: count++ }
        } else {
          return { done: true, value: undefined }
        }
      },
    }
  }
}

let counter = new Counter(3)
for (let i of counter) {
  console.log(i) // 1 2 3
}
for (let i of counter) {
  console.log(i) // 1 2 3
}
</code></pre>
<h3 id="32-提前终止迭代器"><a class="header" href="#32-提前终止迭代器">3.2 提前终止迭代器</a></h3>
<p>return() 方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回{ done: true }，这个返回值只会用在生成器的上下文中。</p>
<p>可选的 return() 方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。</p>
<p>可能的情况包括：</p>
<ul>
<li>for-of 循环通过 break、continue、return 或 throw 提前退出；</li>
<li>解构操作并未消费所有值。</li>
</ul>
<p>如下所示，内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用 return() 方法：</p>
<pre><code class="language-js">class Counter {
  constructor(limit) {
    this.limit = limit
  }

  [Symbol.iterator]() {
    let count = 1,
      limit = this.limit
    return {
      next() {
        if (count &lt;= limit) {
          return { done: false, value: count++ }
        } else {
          return { done: true }
        }
      },
      return() {
        console.log('Exiting early')
        return { done: true }
      },
    }
  }
}

let counter1 = new Counter(5)

// 1 2 Exiting early
for (let i of counter1) {
  if (i &gt; 2) {
    break
  }
  console.log(i)
}

// 1 2 Exiting early
let counter2 = new Counter(5)
try {
  for (let i of counter2) {
    if (i &gt; 2) {
      throw 'err'
    }
    console.log(i)
  }
} catch (e) {}

// Exiting early
let counter3 = new Counter(5)
let [a, b] = counter3
</code></pre>
<p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的：</p>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5]
let iter = a[Symbol.iterator]()

// 1 2 3
for (let i of iter) {
  console.log(i)
  if (i &gt; 2) {
    break
  }
}

// 4 5
for (let i of iter) {
  console.log(i)
}
</code></pre>
<p>因为 return() 方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用 return() 不会强制迭代器进入关闭状态。即便如此，return() 方法还是会被调用：</p>
<pre><code class="language-js">let a = [1, 2, 3, 4, 5]
let iter = a[Symbol.iterator]()
iter.return = function () {
  console.log('Exiting early')
  return { done: true }
}

// 1 2 3 提前退出
for (let i of iter) {
  console.log(i)
  if (i &gt; 2) {
    break
  }
}

// 4 5
for (let i of iter) {
  console.log(i)
}
</code></pre>
<h2 id="四-实际开发中的应用"><a class="header" href="#四-实际开发中的应用">四 实际开发中的应用</a></h2>
<p>迭代器最重要的应用场景就是开发者自定义数据的遍历方式：</p>
<pre><code class="language-js">const students = {
  room: '0001',
  list: ['小明', '小陈', '小张', '小李'],
}

// 现在要求：遍历 students 对象，能够获得学生列表
// 直接使用 for of 显然是不正确的，只能 for(let item of students.list)
// 上述的做法不符合面向对象的规范，我们要遍历的是原本的对象，而不是让使用者去手动遍历其内部数据
</code></pre>
<p>解决方案：手动添加迭代器实现！</p>
<pre><code class="language-js">const students = {
  room: '0001',
  list: ['小明', '小陈', '小张', '小李'],
  [Symbol.iterator]() {
    let index = 0
    return {
      next: () =&gt; {
        let result = { value: this.list[index], done: false }
        if (index &lt; this.list.length) {
          index++
        } else {
          result.done = true
        }
        return result
      },
    }
  },
}

for (let item of students) {
  console.log(item)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="052-迭代器与生成器-generator"><a class="header" href="#052-迭代器与生成器-generator">05.2-迭代器与生成器-Generator</a></h1>
<h2 id="一-理解生成器"><a class="header" href="#一-理解生成器">一 理解生成器</a></h2>
<h3 id="11-创建生成器"><a class="header" href="#11-创建生成器">1.1 创建生成器</a></h3>
<p>生成器是 ES6 新增的结构，拥有能力：<strong>在一个函数块内暂停、恢复代码的执行</strong>。</p>
<p>生成器的形式是一个函数，函数名称前面加一个星号表示它是一个生成器，只要是可以定义函数的地方，就可以定义生成器：</p>
<pre><code class="language-js">// 生成器函数声明
function* generatorFn() {}
// 生成器函数表达式
let generatorFn = function* () {}
// 作为对象字面量方法的生成器函数
let foo = {
  *generatorFn() {},
}
// 作为类实例方法的生成器函数
class Foo {
  *generatorFn() {}
}
// 作为类静态方法的生成器函数
class Bar {
  static *generatorFn() {}
}
</code></pre>
<p>贴士：箭头函数不能用来定义生成器函数，标识生成器的星号不受空格位置的影响。</p>
<h3 id="12-生成器执行原理"><a class="header" href="#12-生成器执行原理">1.2 生成器执行原理</a></h3>
<p>生成器的原理是其内部被包装成了迭代器（实现了 Iterator 接口），利用 next() 的方式调用：</p>
<pre><code class="language-js">function* gen() {
  console.log('hello world!')
}

// 调用生成器函数会产生一个生成器对象,生成器对象一开始处于暂停执行（ suspended）的状态
let iter = gen()
console.log(iter) // Object [Generator] {}

iter.next() // hello world!
iter.next() // 空
</code></pre>
<p>next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。函数体为空的生成器函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态。</p>
<pre><code class="language-js">function* generatorFn() {}
let generatorObject = generatorFn()
console.log(generatorObject) // generatorFn {&lt;suspended&gt;}
console.log(generatorObject.next()) // { done: true, value: undefined }
</code></pre>
<p>value 属性是生成器函数的返回值，默认值为 undefined，可以通过生成器函数的返回值指定：</p>
<pre><code class="language-js">function* generatorFn() {
  return 'foo'
}
let generatorObject = generatorFn()
console.log(generatorObject) // generatorFn {&lt;suspended&gt;}
console.log(generatorObject.next()) // { done: true, value: 'foo' }
</code></pre>
<p>生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的：</p>
<pre><code class="language-js">function* generatorFn() {}
console.log(generatorFn) // f* generatorFn() {}

console.log(generatorFn()[Symbol.iterator]) // f [Symbol.iterator]() {native code}

console.log(generatorFn()) // generatorFn {&lt;suspended&gt;}

console.log(generatorFn()[Symbol.iterator]()) // generatorFn {&lt;suspended&gt;}

const g = generatorFn()
console.log(g === g[Symbol.iterator]()) // true
</code></pre>
<h3 id="13-yeild-语句"><a class="header" href="#13-yeild-语句">1.3 yeild 语句</a></h3>
<p>生成器最重要的地方是：可以通过 yeild 关键字让生成器开始、停止执行！生成器函数在遇到 yield 之前会正常执行，遇到该关键字则停止执行，函数的作用域状态会被保留，重新调用 next() 之后可以恢复执行！停止执行的生成器函数只能通过在生成器对象上调用 next()方法来恢复执行!</p>
<p><code>yeild</code> 语句可以看做函数代码的分隔符，将函数拆分成了多个部分，每个 <code>yeild</code> 将会由一个 next 执行：</p>
<pre><code class="language-js">function* gen() {
  console.log('hello world!')
  yield 'hello 1'
  yield
  yield 'hello 3'
  return 'world'
}

let y = gen()

console.log(y.next()) // hello world! { value: 'hello 1', done: false }
console.log(y.next()) // { value: undefined, done: false }
console.log(y.next()) // { value: 'hello 3', done: false }
console.log(y.next()) // { value: 'world', done: true }
console.log(y.next()) // { value: undefined, done: true }
</code></pre>
<p>yield 关键字有点像函数的中间返回语句，它生成的值会出现在 next() 方法返回的对象里，通过 yield 关键字退出的生成器函数会处在 done: false 状态；通过 return 关键字退出的生成器函数会处于 done: true 状态。</p>
<p>贴士：</p>
<ul>
<li>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 next() 不会影响其他生成器的。</li>
<li>yield 关键字只能在生成器函数内使用</li>
</ul>
<h2 id="二-生成器的使用"><a class="header" href="#二-生成器的使用">二 生成器的使用</a></h2>
<h3 id="21-生成器对象作为可迭代对象"><a class="header" href="#21-生成器对象作为可迭代对象">2.1 生成器对象作为可迭代对象</a></h3>
<p>在生成器对象上显式调用 next()方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便：</p>
<pre><code class="language-js">function* generatorFn() {
  yield 1
  yield 2
  yield 3
}

for (const x of generatorFn()) {
  console.log(x) // 1 2 3
}
</code></pre>
<p>在需要自定义迭代对象时，这样使用生成器对象会特别有用。比如，我们需要定义一个可迭代对象，而它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环来实现：</p>
<pre><code class="language-js">function* nTimes(n) {
  while (n--) {
    yield
  }
}

for (let _ of nTimes(3)) {
  console.log('foo')
}
</code></pre>
<h3 id="22-使用-yield-实现输入和输出"><a class="header" href="#22-使用-yield-实现输入和输出">2.2 使用 yield 实现输入和输出</a></h3>
<p>除了可以作为函数的中间返回语句使用， yield 关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的 yield 关键字会接收到传给 next()方法的第一个值。这里有个地方不太好理解——第一次调用 next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：</p>
<pre><code class="language-js">function* generatorFn(initial) {
  console.log(initial)
  console.log(yield)
  console.log(yield)
}

let generatorObject = generatorFn('foo')
generatorObject.next('bar') // foo
generatorObject.next('baz') // baz
generatorObject.next('qux') // qux
</code></pre>
<p>yield 关键字可以同时用于输入和输出，如下例所示：</p>
<pre><code class="language-js">function* generatorFn() {
  return yield 'foo'
}
let generatorObject = generatorFn()
console.log(generatorObject.next()) // { done: false, value: 'foo' }
console.log(generatorObject.next('bar')) // { done: true, value: 'bar' }
</code></pre>
<p>因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到 yield 关键字时暂停执行并计算出要产生的值： &quot;foo&quot;。下一次调用 next()传入&quot;bar&quot;，作为交给同一个 yield 的值。然后这个值被确定为本次生成器函数要返回的值。yield 关键字并非只能使用一次。比如，以下代码就定义了一个无穷计数生成器函数：</p>
<pre><code class="language-js">function* generatorFn() {
  for (let i = 0; ; ++i) {
    yield i
  }
}

let generatorObject = generatorFn()
console.log(generatorObject.next().value) // 0
console.log(generatorObject.next().value) // 1
console.log(generatorObject.next().value) // 2
console.log(generatorObject.next().value) // 3
console.log(generatorObject.next().value) // 4
console.log(generatorObject.next().value) // 5
// ...
</code></pre>
<p>假设我们想定义一个生成器函数，它会根据配置的值迭代相应次数并产生迭代的索引。初始化一个新数组可以实现这个需求，但不用数组也可以实现同样的行为：</p>
<pre><code class="language-js">function* nTimes(n) {
  for (let i = 0; i &lt; n; ++i) {
    yield i
  }
}
for (let x of nTimes(3)) {
  console.log(x)
}
</code></pre>
<p>另外，使用 while 循环也可以，而且代码稍微简洁一点：</p>
<pre><code class="language-js">function* nTimes(n) {
  let i = 0
  while (n--) {
    yield i++
  }
}
for (let x of nTimes(3)) {
  console.log(x) // 0 1 2
}
</code></pre>
<p>这样使用生成器也可以实现范围和填充数组：</p>
<pre><code class="language-js">function* range(start, end) {
  while (end &gt; start) {
    yield start++
  }
}
for (const x of range(4, 7)) {
  console.log(x) // 4 5 6
}

function* zeroes(n) {
  while (n--) {
    yield 0
  }
}
console.log(Array.from(zeroes(8))) // [0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<h3 id="23-产生可迭代对象"><a class="header" href="#23-产生可迭代对象">2.3 产生可迭代对象</a></h3>
<p>可以使用星号增强 yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：</p>
<pre><code class="language-js">// 等价的 generatorFn：
// function* generatorFn() {
//  for (const x of [1, 2, 3]) {
//    yield x;
//  }
// }
function* generatorFn() {
  yield* [1, 2, 3]
}
let generatorObject = generatorFn()
for (const x of generatorFn()) {
  console.log(x) // 1 2 3
}
</code></pre>
<p>贴士：yield 星号两侧的空格不影响其行为。</p>
<p>因为 <code>yield*</code> 实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把 yield 放到一个循环里没什么不同。下面两个生成器函数的行为是等价的：</p>
<pre><code class="language-js">function* generatorFnA() {
  for (const x of [1, 2, 3]) {
    yield x
  }
}
for (const x of generatorFnA()) {
  console.log(x) // 1 2 3
}

function* generatorFnB() {
  yield* [1, 2, 3]
}
for (const x of generatorFnB()) {
  console.log(x) // 1 2 3
}
</code></pre>
<p><code>yield*</code> 的值是关联迭代器返回 done: true 时的 value 属性。对于普通迭代器来说，这个值是 undefined：</p>
<pre><code class="language-js">function* generatorFn() {
  console.log('iter value:', yield* [1, 2, 3])
}
for (const x of generatorFn()) {
  console.log('value:', x) // value: 1  value: 2  value: 3  iter value: undefined
}
</code></pre>
<p>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值：</p>
<pre><code class="language-js">function* innerGeneratorFn() {
  yield 'foo'
  return 'bar'
}
function* outerGeneratorFn(genObj) {
  console.log('iter value:', yield* innerGeneratorFn())
}
for (const x of outerGeneratorFn()) {
  console.log('value:', x) // value: foo iter value: bar
}
</code></pre>
<h3 id="24-生成器作为默认迭代器"><a class="header" href="#24-生成器作为默认迭代器">2.4 生成器作为默认迭代器</a></h3>
<p>因为生成器对象实现了 Iterable 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容：</p>
<pre><code class="language-js">class Foo {
  constructor() {
    this.values = [1, 2, 3]
  }

  *[Symbol.iterator]() {
    yield* this.values
  }
}

// for-of 循环调用了默认迭代器（它恰好又是一个生成器函数）并产生了一个生成器对象。这个生成器对象是可迭代的，所以完全可以在迭代中使用。
const f = new Foo()
for (const x of f) {
  console.log(x) // 1 2 3
}
</code></pre>
<h3 id="25-生成器提前终止"><a class="header" href="#25-生成器提前终止">2.5 生成器提前终止</a></h3>
<p>与迭代器类似，生成器也支持“可关闭”的概念。一个实现 Iterator 接口的对象一定有 next() 方法，还有一个可选的 return() 方法用于提前终止迭代器。生成器对象除了有这两个方法，还有第三个方法：throw()。</p>
<pre><code class="language-js">function* generatorFn() {}
const g = generatorFn()
console.log(g) // generatorFn {&lt;suspended&gt;}
console.log(g.next) // f next() { [native code] }
console.log(g.return) // f return() { [native code] }
console.log(g.throw) // f throw() { [native code] }
</code></pre>
<p>return() 和 throw() 方法都可以用于强制生成器进入关闭状态：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x
  }
}
const g = generatorFn()
console.log(g) // generatorFn {&lt;suspended&gt;}
console.log(g.return(4)) // { done: true, value: 4 }
console.log(g) // generatorFn {&lt;closed&gt;}
</code></pre>
<p>与迭代器不同，所有生成器对象都有 return() 方法，只要通过它进入关闭状态，就无法恢复了。后续调用 next() 会显示 done: true 状态，而提供的任何返回值都不会被存储或传播：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x
  }
}

const g = generatorFn()
console.log(g.next()) // { done: false, value: 1 }
console.log(g.return(4)) // { done: true, value: 4 }
console.log(g.next()) // { done: true, value: undefined }
console.log(g.next()) // { done: true, value: undefined }
console.log(g.next()) // { done: true, value: undefined }
</code></pre>
<p>for-of 循环等内置语言结构会忽略状态为 done: true 的 IteratorObject 内部返回的值。</p>
<p>throw() 方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x
  }
}
const g = generatorFn()
console.log(g) // generatorFn {&lt;suspended&gt;}
try {
  g.throw('foo')
} catch (e) {
  console.log(e) // foo
}
console.log(g) // generatorFn {&lt;closed&gt;}
</code></pre>
<p>不过，假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的 yield，因此在这个例子中会跳过一个值。比如：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    try {
      yield x
    } catch (e) {}
  }
}

const g = generatorFn()
console.log(g.next()) // { done: false, value: 1}
g.throw('foo')
console.log(g.next()) // { done: false, value: 3}
</code></pre>
<h2 id="三-生成器的应用"><a class="header" href="#三-生成器的应用">三 生成器的应用</a></h2>
<h3 id="31-生成器函数在异步中的应用"><a class="header" href="#31-生成器函数在异步中的应用">3.1 生成器函数在异步中的应用</a></h3>
<p>三个异步函数的实例：</p>
<pre><code class="language-js">function fn1() {
  setTimeout(() =&gt; {
    console.log(1111)
  }, 1000)
}

function fn2() {
  setTimeout(() =&gt; {
    console.log(2222)
  }, 1100)
}

function fn3() {
  setTimeout(() =&gt; {
    console.log(3333)
  }, 1200)
}
</code></pre>
<p>如果要让其按照 fn1、fn2、fn3 的顺序执行，那么按照回调函数的做法应该是：</p>
<pre><code class="language-js">setTimeout(){
  setTimeout(){
    setTimeout(){

    }
  }
}
</code></pre>
<p>这显然形成了回调地狱，现在利用生成器函数可以写为：</p>
<pre><code class="language-js">function fn1() {
  setTimeout(() =&gt; {
    console.log(1111)
    iterator.next()
  }, 1000)
}

function fn2() {
  setTimeout(() =&gt; {
    console.log(2222)
    iterator.next()
  }, 1100)
}

function fn3() {
  setTimeout(() =&gt; {
    console.log(3333)
    iterator.next()
  }, 1200)
}

// 如果我们想让 fn1、fn2、fn3 按顺序执行
function* gen() {
  yield fn1()
  yield fn2()
  yield fn3()
}

let iterator = gen()
iterator.next()
</code></pre>
<h3 id="32-使用-yield-实现递归算法"><a class="header" href="#32-使用-yield-实现递归算法">3.2 使用 <code>yield*</code> 实现递归算法</a></h3>
<p><code>yield*</code> 最有用的地方是实现递归操作，此时生成器可以产生自身：</p>
<pre><code class="language-js">function* nTimes(n) {
  if (n &gt; 0) {
    yield* nTimes(n - 1)
    yield n - 1
  }
}
for (const x of nTimes(3)) {
  console.log(x) // 0 1 2
}
</code></pre>
<p>在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象。从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数。</p>
<p>使用递归生成器结构和 <code>yield*</code> 可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：</p>
<pre><code class="language-js">class Node {
  constructor(id) {
    this.id = id
    this.neighbors = new Set()
  }
  connect(node) {
    if (node !== this) {
      this.neighbors.add(node)
      node.neighbors.add(this)
    }
  }
}

class RandomGraph {
  constructor(size) {
    this.nodes = new Set()
    // 创建节点
    for (let i = 0; i &lt; size; ++i) {
      this.nodes.add(new Node(i))
    }
    // 随机连接节点
    const threshold = 1 / size
    for (const x of this.nodes) {
      for (const y of this.nodes) {
        if (Math.random() &lt; threshold) {
          x.connect(y)
        }
      }
    }
  }
  // 这个方法仅用于调试
  print() {
    for (const node of this.nodes) {
      const ids = [...node.neighbors].map((n) =&gt; n.id).join(',')
      console.log(`${node.id}: ${ids}`)
    }
  }
}

const g = new RandomGraph(6)
g.print()
</code></pre>
<p>图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：</p>
<pre><code class="language-js">class Node {
  constructor(id) {
    // ...
  }
  connect(node) {
    // ...
  }
}

class RandomGraph {
  constructor(size) {
    // ...
  }
  print() {
    // ...
  }
  isConnected() {
    const visitedNodes = new Set()
    function* traverse(nodes) {
      for (const node of nodes) {
        if (!visitedNodes.has(node)) {
          yield node
          yield* traverse(node.neighbors)
        }
      }
    }
    // 取得集合中的第一个节点
    const firstNode = this.nodes[Symbol.iterator]().next().value
    // 使用递归生成器迭代每个节点
    for (const node of traverse([firstNode])) {
      visitedNodes.add(node)
    }
    return visitedNodes.size === this.nodes.size
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-异步编程-promise-基础"><a class="header" href="#061-异步编程-promise-基础">06.1-异步编程-Promise 基础</a></h1>
<h2 id="一-异步编程与回调地狱"><a class="header" href="#一-异步编程与回调地狱">一 异步编程与回调地狱</a></h2>
<p>同步行为和异步行为的对立统一是计算机科学的一个基本概念。特别是在 JavaScript 这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作，这样可以在等待其他操作完成的同时运行其他指令。</p>
<blockquote>
<p>同步：对应内存中的顺序执行的指令，每条指令会严格按照出现顺序执行，程序执行的每一步都可以推断出程序执行的状态
异步：类似于系统中断，即当前进程外部的实体可以触发代码执行。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。</p>
</blockquote>
<p>看一个基础的异步编程示例：</p>
<pre><code class="language-js">function double(value) {
  setTimeout(() =&gt; {
    console.log(value)
  }, 1000)
}

// 先打印 last，再打印数值
double(3)
console.log('last')
</code></pre>
<p>异步行为虽然解决了高延迟资源访问时的等待问题，但是在实际开发中，会带来相当的不便，产生回调地狱的代码在可维护性上是相当差的：</p>
<pre><code class="language-js">XHR.onreadystatechange = function(){
    if(){
        XHR2.onreadystatechange = function(){

            if(){

                XHR2.onreadystatechange = function(){

                    if(){
                        XHR2.onreadystatechange = function(){

                        }
                    }
                }
            }
        }
    }
}
</code></pre>
<p>异步的失败处理也同样不方便，因为要考虑成功回调、失败回调</p>
<pre><code class="language-js">function double(value, success, failure) {
  setTimeout(() =&gt; {
    try {
      if (typeof value !== 'number') {
        throw 'Must provide number as first argument'
      }
      success(2 * value)
    } catch (e) {
      failure(e)
    }
  }, 1000)
}

const successCallback = (x) =&gt; console.log(`Success: ${x}`)
const failureCallback = (e) =&gt; console.log(`Failure: ${e}`)
double(3, successCallback, failureCallback) // Success: 6（大约 1000 毫秒之后）
double('b', successCallback, failureCallback) // Failure: Must provide number as first argument（大约 1000 毫秒之后）
</code></pre>
<p>异步的优化方案很多，包括将回调函数命名、全部采用函数名方式调用、优化代码结构、Node 中的第三方库 Async 等，但是这些在书写上都是治标不治本。</p>
<p>ECMAScript 提出了三个解决方案：</p>
<ul>
<li>Promise 方案：基本的异步解决方案</li>
<li>generator 生成器方案：ES6 过渡方案</li>
<li>async/await 方案：ES7 提出的方案，配合 Promise 能够完美解决 JS 异步问题</li>
</ul>
<h2 id="二-期约-promise-对象"><a class="header" href="#二-期约-promise-对象">二 期约 Promise 对象</a></h2>
<h3 id="21-期约-promise-基本概念"><a class="header" href="#21-期约-promise-基本概念">2.1 期约 Promise 基本概念</a></h3>
<p>期约 Promise 名字最早起源于 1976 年，描述了一种异步程序的执行机制。到了 2010 年，CommonJS 实现的 Promises/A 规范开始流行。</p>
<p>ES6 对市面流行的第三方 Promise/A+ 规范提供了完善支持，即 Promise 引用类型。Promise 是现在异步编程的核心机制，得到了所有现代浏览器的支持。</p>
<p>Promise 类是一个实现了 Thenable 接口的对象，示例如下：</p>
<pre><code class="language-js">// 构造函数必须传参，否则报错，一般该参数称为执行器 executor
// 传入的函数用来修改 Promise 的执行结果，正确与错误的结果分别位于 resolve、reject 中
let p = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    // 模拟 ajax
    let err = null
    let data = { uid: 1001 }
    if (err) {
      reject('发生了错误：', null)
    }
    resolve(data)
  })
})

// 实例方法 then：用于处理状态改变后的业务
p.then(
  (data) =&gt; {
    console.log(data)
  },
  (err) =&gt; {
    console.log(err)
  }
)

// 输出结果：{ uid: 1001 }
</code></pre>
<p>从上看出，<strong>期约的作用其实是抽象的表示了一个异步操作</strong>。</p>
<h3 id="22-实例方法-then"><a class="header" href="#22-实例方法-then">2.2 实例方法 then()</a></h3>
<p>Promise.prototype.then()方法接收两个可选的参数： onResolved 处理程序和 onRejected 处理程序，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行：</p>
<pre><code class="language-js">function onResolved(id) {
  setTimeout(console.log, 0, id, 'resolved')
}

function onRejected(id) {
  setTimeout(console.log, 0, id, 'rejected')
}

let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000))
let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000))

p1.then(
  () =&gt; onResolved('p1'),
  () =&gt; onRejected('p1')
)

p2.then(
  () =&gt; onResolved('p2'),
  () =&gt; onRejected('p2')
)

//（ 3 秒后）
// p1 resolved
// p2 rejected
</code></pre>
<p>传给 then()的任何非函数类型的参数都会被静默忽略。如果想只提供 onRejected 参数，那就要在 onResolved 参数的位置上传入 undefined。这
样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。</p>
<h3 id="23-实例方法-catch"><a class="header" href="#23-实例方法-catch">2.3 实例方法 catch()</a></h3>
<p>Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype.then(null, onRejected)。</p>
<pre><code class="language-js">let p = Promise.reject()
let onRejected = function (e) {
  setTimeout(console.log, 0, 'rejected')
}
// 这两种添加拒绝处理程序的方式是一样的：
p.then(null, onRejected) // rejected
p.catch(onRejected) // rejected
</code></pre>
<p>Promise.prototype.catch()返回一个新的期约实例：</p>
<pre><code class="language-js">let p1 = new Promise(() =&gt; {})
let p2 = p1.catch()
setTimeout(console.log, 0, p1) // Promise &lt;pending&gt;
setTimeout(console.log, 0, p2) // Promise &lt;pending&gt;
setTimeout(console.log, 0, p1 === p2) // false
</code></pre>
<p>then() 方法返回的仍然是一个 Promise 实例，所以可以使用 then 方法进行链式调用：</p>
<pre><code class="language-js">let flag = false

// 在该函数内执行异步操作，并修改结果的状态值。
let p = new Promise(function (resolve, reject) {
  if (flag) {
    resolve('true...')
  } else {
    reject('false...')
  }
})

p.then((data) =&gt; {
  console.log('处理成功，结果为：', data)
}).catch((err) =&gt; {
  // 实例方法 catch：用于捕获错误
  console.log('处理失败，错误为：', err)
})
</code></pre>
<h3 id="24-finally-方法"><a class="header" href="#24-finally-方法">2.4 finally() 方法</a></h3>
<p>Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。</p>
<pre><code class="language-js">let p1 = Promise.resolve()
let p2 = Promise.reject()
let onFinally = function () {
  setTimeout(console.log, 0, 'Finally!')
}
p1.finally(onFinally) // Finally
p2.finally(onFinally) // Finally
</code></pre>
<p>Promise.prototype.finally()方法返回一个新的期约实例：</p>
<pre><code class="language-js">let p1 = new Promise(() =&gt; {})
let p2 = p1.finally()
setTimeout(console.log, 0, p1) // Promise &lt;pending&gt;
setTimeout(console.log, 0, p2) // Promise &lt;pending&gt;
setTimeout(console.log, 0, p1 === p2) // false
</code></pre>
<p>这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally 被设计为一个状态无关的方法， 所以在大多数情况下它将表现为父期约的传递。对于已解决状态和被拒绝状态都是如此。</p>
<pre><code class="language-js">let p1 = Promise.resolve('foo')

let p2 = p1.finally()
let p3 = p1.finally(() =&gt; undefined)
let p4 = p1.finally(() =&gt; {})
let p5 = p1.finally(() =&gt; Promise.resolve())
let p6 = p1.finally(() =&gt; 'bar')
let p7 = p1.finally(() =&gt; Promise.resolve('bar'))
let p8 = p1.finally(() =&gt; Error('qux'))
setTimeout(console.log, 0, p2) // Promise &lt;resolved&gt;: foo
setTimeout(console.log, 0, p3) // Promise &lt;resolved&gt;: foo
setTimeout(console.log, 0, p4) // Promise &lt;resolved&gt;: foo
setTimeout(console.log, 0, p5) // Promise &lt;resolved&gt;: foo
setTimeout(console.log, 0, p6) // Promise &lt;resolved&gt;: foo
setTimeout(console.log, 0, p7) // Promise &lt;resolved&gt;: foo
setTimeout(console.log, 0, p8) // Promise &lt;resolved&gt;: foo
</code></pre>
<p>如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示：</p>
<pre><code class="language-js">// Promise.resolve()保留返回的期约
let p9 = p1.finally(() =&gt; new Promise(() =&gt; {}))
let p10 = p1.finally(() =&gt; Promise.reject())
// Uncaught (in promise): undefined
setTimeout(console.log, 0, p9) // Promise &lt;pending&gt;
setTimeout(console.log, 0, p10) // Promise &lt;rejected&gt;: undefined
let p11 = p1.finally(() =&gt; {
  throw 'baz'
})
// Uncaught (in promise) baz
setTimeout(console.log, 0, p11) // Promise &lt;rejected&gt;: baz]
</code></pre>
<p>返回待定期约的情形并不常见，这是因为只要期约一解决，新期约仍然会原样后传初始的期约：</p>
<pre><code class="language-js">let p1 = Promise.resolve('foo')
// 忽略解决的值
let p2 = p1.finally(
  () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve('bar'), 100))
)
setTimeout(console.log, 0, p2) // Promise &lt;pending&gt;
setTimeout(() =&gt; setTimeout(console.log, 0, p2), 200)
// 200 毫秒后：
// Promise &lt;resolved&gt;: foo
</code></pre>
<h2 id="三-期约-promise-状态"><a class="header" href="#三-期约-promise-状态">三 期约 Promise 状态</a></h2>
<h3 id="31-期约状态机"><a class="header" href="#31-期约状态机">3.1 期约状态机</a></h3>
<p>直接把一个期约实例传递打印出来时控制台输出表示该实例处于待定（pending）状态：</p>
<pre><code class="language-js">let p = new Promise(() =&gt; {})
console.log(p) // Promise &lt;pending&gt;)
</code></pre>
<p>这说明期约是一个有状态的对象，可能处于如下 3 种状态之一：</p>
<ul>
<li>待定（pending）：表示尚未开始或者正在执行中</li>
<li>兑现（fulfilled）：表示已经成功完成，有时也称为解决（resolved）</li>
<li>拒绝（rejected）：表示没有成功完成</li>
</ul>
<p>期约的状态代表期约是否完成。待定（ pending）是期约的最初始状态。在待定状态下，期约可以落定（ settled）为代表成功的兑现（ fulfilled）状态，或者代表失败的拒绝（ rejected）状态。无论落定为哪种状态都是不可逆的，但是转换为兑现或拒绝并不能保证期约必然会脱离待定状态。</p>
<p>某些情况下，这个状态机就是期约可以提供的最有用的信息。在代码中能够得知异步代码已经完成是很重要的信息，比如：期约要向服务器发送一个 HTTP 请求，请求返回 200~299 范围内的状态码就足以让期约的状态变为“兑现”。类似地，如果请求返回的状态码不在 200~299 这个范围内，那么就会把期约状态切换为“拒绝”。</p>
<p>在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。比如，假设期约向服务器发送一个 HTTP 请求并预定会返回一个 JSON，如果请求返回范围在 200~299 的状态码，则足以让期约的状态变为兑现。此时期约内部就可以收到一个 JSON 字符串。类似地，如果请求返回的状态码不在 200~299 这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个 Error 对象，包含着 HTTP 状态码及相关错误消息。</p>
<p>为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（ value）。类似地，每个期约只要状态切换为拒绝，就会有一个私有的内部理由（ reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 undefined。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。</p>
<h3 id="32-执行器函数"><a class="header" href="#32-执行器函数">3.2 执行器函数</a></h3>
<p><strong>期约的状态是私有的，不能直接通过 JavaScript 检测到，而且期约的状态也不能被外部 JavaScript 代码修改</strong>，这样做才能有效隔离外部的同步代码。也因此只能在期约的执行器函数中完成状态改变。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是
通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用 resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错误。</p>
<p>状态转换为解决：</p>
<pre><code class="language-js">let p = new Promise((resolve, reject) =&gt; {
  resolve()
})
setTimeout(console.log, 0, p) // Promise {&lt;fulfilled&gt;: undefined}
</code></pre>
<p>状态转换为拒绝：</p>
<pre><code class="language-js">let p = new Promise((resolve, reject) =&gt; {
  reject()
})
setTimeout(console.log, 0, p) // 报错Promise {&lt;rejected&gt;: undefined}
</code></pre>
<p>无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示：</p>
<pre><code class="language-js">let p = new Promise((resolve, reject) =&gt; {
  resolve()
  reject() // 没有效果
})
setTimeout(console.log, 0, p) // Promise &lt;resolved&gt;
</code></pre>
<p>为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过 setTimeout 设置一个 10 秒钟后无论如何都会拒绝期约的回调：</p>
<pre><code class="language-js">let p = new Promise((resolve, reject) =&gt; {
  setTimeout(reject, 10000) // 10 秒后调用 reject()
  // 执行函数的逻辑
})
setTimeout(console.log, 0, p) // Promise &lt;pending&gt;
setTimeout(console.log, 11000, p) // 11 秒后再检查状态
// (After 10 seconds) Uncaught error
// (After 11 seconds) Promise &lt;rejected&gt;
</code></pre>
<p>因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败。</p>
<h3 id="33-同步异步执行的二元性"><a class="header" href="#33-同步异步执行的二元性">3.3 同步/异步执行的二元性</a></h3>
<pre><code class="language-js">try {
  throw new Error('foo')
} catch (e) {
  console.log(e) // Error: foo
}

// Uncaught (in promise) Error: bar
try {
  Promise.reject(new Error('bar'))
} catch (e) {
  console.log(e)
}
</code></pre>
<p>第一个 try/catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到，因为后者没有通过异步模式捕获错误。从这里可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。</p>
<p>代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。</p>
<h2 id="四-promise-对象的静态方法"><a class="header" href="#四-promise-对象的静态方法">四 Promise 对象的静态方法</a></h2>
<h3 id="41-promiseresolve"><a class="header" href="#41-promiseresolve">4.1 Promise.resolve()</a></h3>
<p>除了执行器函数可以转换为落定状态，通过调用 Promise.resolve() 静态方法，也可以实例化一个解决的期约：</p>
<pre><code class="language-js">// 二者没有区别
let p1 = new Promise((resolve, reject) =&gt; resolve())
let p2 = Promise.resolve()
</code></pre>
<p>这个解决的期约的值对应着传给 Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约：</p>
<pre><code class="language-js">setTimeout(console.log, 0, Promise.resolve()) // Promise &lt;resolved&gt;: undefined
setTimeout(console.log, 0, Promise.resolve(3)) // Promise &lt;resolved&gt;: 3

// 多余的参数会忽略
setTimeout(console.log, 0, Promise.resolve(4, 5, 6)) // Promise &lt;resolved&gt;: 4
</code></pre>
<p>如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve() 可以说是一个幂等方法，如下所示：</p>
<pre><code class="language-js">let p = Promise.resolve(7)
setTimeout(console.log, 0, p === Promise.resolve(p)) // true

setTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p))) // true
</code></pre>
<p>这个幂等性会保留传入期约的状态：</p>
<pre><code class="language-js">let p = new Promise(() =&gt; {})
setTimeout(console.log, 0, p) // Promise &lt;pending&gt;
setTimeout(console.log, 0, Promise.resolve(p)) // Promise &lt;pending&gt;
setTimeout(console.log, 0, p === Promise.resolve(p)) // true
</code></pre>
<p>这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为：</p>
<pre><code class="language-js">let p = Promise.resolve(new Error('foo'))
setTimeout(console.log, 0, p) // Promise &lt;resolved&gt;: Error: foo
</code></pre>
<h3 id="42-promisereject"><a class="header" href="#42-promisereject">4.2 Promise.reject()</a></h3>
<p>Promise.reject() 会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的：</p>
<pre><code class="language-js">let p1 = new Promise((resolve, reject) =&gt; reject())
let p2 = Promise.reject()
</code></pre>
<p>这个拒绝的期约的理由就是传给 Promise.reject() 的第一个参数。这个参数也会传给后续的拒绝处理程序：</p>
<pre><code class="language-js">let p = Promise.reject(3)
setTimeout(console.log, 0, p) // Promise &lt;rejected&gt;: 3
p.then(null, (e) =&gt; setTimeout(console.log, 0, e)) // 3
</code></pre>
<p>注意：Promise.reject() 并没有照搬 Promise.resolve() 的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：</p>
<pre><code class="language-js">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;
setTimeout(console.log, 0, Promise.reject(Promise.resolve()))
</code></pre>
<h3 id="43-promise-其他-api"><a class="header" href="#43-promise-其他-api">4.3 Promise 其他 API</a></h3>
<p>期约还有一些连锁反应相关的 API，如： <code>Promise.all()</code> 见下一节</p>
<h2 id="五-promise-的连锁反应"><a class="header" href="#五-promise-的连锁反应">五 Promise 的连锁反应</a></h2>
<h3 id="51-期约连锁"><a class="header" href="#51-期约连锁">5.1 期约连锁</a></h3>
<p>多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。</p>
<p>把期约逐个地串联起来是一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方法（ then()、 catch()和 finally()）都会返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。比如：</p>
<pre><code class="language-js">let p = new Promise((resolve, reject) =&gt; {
  console.log('first')
  resolve()
})
p.then(() =&gt; console.log('second'))
  .then(() =&gt; console.log('third'))
  .then(() =&gt; console.log('fourth'))
// first
// second
// third
// fourth
</code></pre>
<p>这个实现最终执行了一连串同步任务。正因为如此，这种方式执行的任务没有那么有用，毕竟分别使用 4 个同步函数也可以做到：</p>
<pre><code class="language-js">;(() =&gt; console.log('first'))()
;(() =&gt; console.log('second'))()
;(() =&gt; console.log('third'))()
;(() =&gt; console.log('fourth'))()
</code></pre>
<p>要真正执行异步任务，可以改写前面的例子，让每个执行器都返回一个期约实例。这样就可以让每个后续期约都等待之前的期约，也就是串行化异步任务。比如，可以像下面这样让每个期约在一定时间后解决：</p>
<pre><code class="language-js">let p1 = new Promise((resolve, reject) =&gt; {
  console.log('p1 executor')
  setTimeout(resolve, 1000)
})
p1.then(
  () =&gt;
    new Promise((resolve, reject) =&gt; {
      console.log('p2 executor')
      setTimeout(resolve, 1000)
    })
)
  .then(
    () =&gt;
      new Promise((resolve, reject) =&gt; {
        console.log('p3 executor')
        setTimeout(resolve, 1000)
      })
  )
  .then(
    () =&gt;
      new Promise((resolve, reject) =&gt; {
        console.log('p4 executor')
        setTimeout(resolve, 1000)
      })
  )
// p1 executor（ 1 秒后）
// p2 executor（ 2 秒后）
// p3 executor（ 3 秒后）
// p4 executor（ 4 秒后）
</code></pre>
<p>把生成期约的代码提取到一个工厂函数中，就可以写成这样：</p>
<pre><code class="language-js">function delayedResolve(str) {
  return new Promise((resolve, reject) =&gt; {
    console.log(str)
    setTimeout(resolve, 1000)
  })
}
delayedResolve('p1 executor')
  .then(() =&gt; delayedResolve('p2 executor'))
  .then(() =&gt; delayedResolve('p3 executor'))
  .then(() =&gt; delayedResolve('p4 executor'))
// p1 executor（ 1 秒后）
// p2 executor（ 2 秒后）
// p3 executor（ 3 秒后）
// p4 executor（ 4 秒后）
</code></pre>
<p>每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简洁地将异步任务串行化，解决之前依赖回调的难题。假如这种情况下不使用期约，那么前面的代码可能就要这样写了：</p>
<pre><code class="language-js">function delayedExecute(str, callback = null) {
  setTimeout(() =&gt; {
    console.log(str)
    callback &amp;&amp; callback()
  }, 1000)
}
delayedExecute('p1 callback', () =&gt; {
  delayedExecute('p2 callback', () =&gt; {
    delayedExecute('p3 callback', () =&gt; {
      delayedExecute('p4 callback')
    })
  })
})
// p1 callback（ 1 秒后）
// p2 callback（ 2 秒后）
// p3 callback（ 3 秒后）
// p4 callback（ 4 秒后）
</code></pre>
<p>这里其实就解决了回调地狱问题吗，由于 then()、 catch()和 finally()都返回期约，所以串联这些方法也很直观。下面的例子同时使用这 3 个实例方法：</p>
<pre><code class="language-js">let p = new Promise((resolve, reject) =&gt; {
  console.log('initial promise rejects')
  reject()
})
p.catch(() =&gt; console.log('reject handler'))
  .then(() =&gt; console.log('resolve handler'))
  .finally(() =&gt; console.log('finally handler'))
// initial promise rejects
// reject handler
// resolve handler
// finally handler
</code></pre>
<h3 id="52-期约图"><a class="header" href="#52-期约图">5.2 期约图</a></h3>
<p>因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。</p>
<pre><code class="language-js">let A = new Promise((resolve, reject) =&gt; {
  console.log('A')
  resolve()
})
let B = A.then(() =&gt; console.log('B'))
let C = A.then(() =&gt; console.log('C'))
B.then(() =&gt; console.log('D'))
B.then(() =&gt; console.log('E'))
C.then(() =&gt; console.log('F'))
C.then(() =&gt; console.log('G'))
// A
// B
// C
// D
// E
// F
// G
</code></pre>
<p>注意，日志的输出语句是对二叉树的层序遍历。如前所述，期约的处理程序是按照它们添加的顺序执行的。由于期约的处理程序是先添加到消息队列， 然后才逐个执行，因此构成了层序遍历。树只是期约图的一种形式。考虑到根节点不一定唯一，且多个期约也可以组合成一个期约（通过下一节介绍的 Promise.all()和 Promise.race()），所以有向非循环图是体现期约连锁可能性的最准确表达。</p>
<h3 id="53-promiseall"><a class="header" href="#53-promiseall">5.3 Promise.all()</a></h3>
<p>Promise 类提供两个将多个期约实例组合成一个期约的静态方法： Promise.all()和 Promise.race()。而合成后期约的行为取决于内部期约的行为。</p>
<p>Promise.all()静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约：</p>
<pre><code class="language-js">let p1 = Promise.all([Promise.resolve(), Promise.resolve()])
// 可迭代对象中的元素会通过 Promise.resolve()转换为期约
let p2 = Promise.all([3, 4])
// 空的可迭代对象等价于 Promise.resolve()
let p3 = Promise.all([])
// 无效的语法
let p4 = Promise.all()
// TypeError: cannot read Symbol.iterator of undefined
</code></pre>
<p>合成的期约只会在每个包含的期约都解决之后才解决：</p>
<pre><code class="language-js">let p = Promise.all([
  Promise.resolve(),
  new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)),
])
setTimeout(console.log, 0, p) // Promise &lt;pending&gt;
p.then(() =&gt; setTimeout(console.log, 0, 'all() resolved!'))
// all() resolved!（大约 1 秒后）
</code></pre>
<p>如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝：</p>
<pre><code class="language-js">// 永远待定
let p1 = Promise.all([new Promise(() =&gt; {})])
setTimeout(console.log, 0, p1) // Promise &lt;pending&gt;
// 一次拒绝会导致最终期约拒绝
let p2 = Promise.all([Promise.resolve(), Promise.reject(), Promise.resolve()])
setTimeout(console.log, 0, p2) // Promise &lt;rejected&gt;
// Uncaught (in promise) undefined
</code></pre>
<p>如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序：</p>
<pre><code class="language-js">let p = Promise.all([Promise.resolve(3), Promise.resolve(), Promise.resolve(4)])
p.then((values) =&gt; setTimeout(console.log, 0, values)) // [3, undefined, 4]
</code></pre>
<p>如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作，如下所示：</p>
<pre><code class="language-js">// 虽然只有第一个期约的拒绝理由会进入
// 拒绝处理程序，第二个期约的拒绝也
// 会被静默处理，不会有错误跑掉
let p = Promise.all([
  Promise.reject(3),
  new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)),
])
p.catch((reason) =&gt; setTimeout(console.log, 0, reason)) // 3
// 没有未处理的错误
</code></pre>
<h3 id="54-promiserace"><a class="header" href="#54-promiserace">5.4 Promise.race()</a></h3>
<p>Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约：</p>
<pre><code class="language-js">let p1 = Promise.race([Promise.resolve(), Promise.resolve()])
// 可迭代对象中的元素会通过 Promise.resolve()转换为期约
let p2 = Promise.race([3, 4])
// 空的可迭代对象等价于 new Promise(() =&gt; {})
let p3 = Promise.race([])
// 无效的语法
let p4 = Promise.race()
// TypeError: cannot read Symbol.iterator of undefined
</code></pre>
<p>Promise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约， Promise.race()就会包装其解决值或拒绝理由并返回新期约：</p>
<pre><code class="language-js">// 解决先发生，超时后的拒绝被忽略
let p1 = Promise.race([
  Promise.resolve(3),
  new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)),
])
setTimeout(console.log, 0, p1) // Promise &lt;resolved&gt;: 3
// 拒绝先发生，超时后的解决被忽略
let p2 = Promise.race([
  Promise.reject(4),
  new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000)),
])
setTimeout(console.log, 0, p2) // Promise &lt;rejected&gt;: 4
// 迭代顺序决定了落定顺序
let p3 = Promise.race([
  Promise.resolve(5),
  Promise.resolve(6),
  Promise.resolve(7),
])
setTimeout(console.log, 0, p3) // Promise &lt;resolved&gt;: 5
</code></pre>
<p>如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与 Promise.all()类似，合成的期约会静默处理所有包含期约的拒绝操作，如下所示：</p>
<pre><code class="language-js">// 虽然只有第一个期约的拒绝理由会进入
// 拒绝处理程序，第二个期约的拒绝也
// 会被静默处理，不会有错误跑掉
let p = Promise.race([
  Promise.reject(3),
  new Promise((resolve, reject) =&gt; setTimeout(reject, 1000)),
])
p.catch((reason) =&gt; setTimeout(console.log, 0, reason)) // 3
// 没有未处理的错误
</code></pre>
<h3 id="55-串行期约合成"><a class="header" href="#55-串行期约合成">5.5 串行期约合成</a></h3>
<p>在异步产生值并传递给处理程序场景下，基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像函数合成，即将多个函数合成为一个函数：</p>
<pre><code class="language-js">function addTwo(x) {
  return x + 2
}
function addThree(x) {
  return x + 3
}
function addFive(x) {
  return x + 5
}
function addTen(x) {
  return addFive(addTwo(addThree(x)))
}
console.log(addTen(7)) // 17
</code></pre>
<p>在这个例子中，有 3 个函数基于一个值合成为一个函数。类似地，期约也可以像这样合成起来，渐进地消费一个值，并返回一个结果：</p>
<pre><code class="language-js">function addTwo(x) {
  return x + 2
}
function addThree(x) {
  return x + 3
}
function addFive(x) {
  return x + 5
}
function addTen(x) {
  return Promise.resolve(x).then(addTwo).then(addThree).then(addFive)
}
addTen(8).then(console.log) // 18
</code></pre>
<p>使用 Array.prototype.reduce()可以写成更简洁的形式：</p>
<pre><code class="language-js">function addTwo(x) {
  return x + 2
}
function addThree(x) {
  return x + 3
}
function addFive(x) {
  return x + 5
}
function addTen(x) {
  return [addTwo, addThree, addFive].reduce(
    (promise, fn) =&gt; promise.then(fn),
    Promise.resolve(x)
  )
}
addTen(8).then(console.log) // 18
</code></pre>
<p>这种模式可以提炼出一个通用函数，可以把任意多个函数作为处理程序合成一个连续传值的期约连锁。这个通用的合成函数可以这样实现：</p>
<pre><code class="language-js">function addTwo(x) {
  return x + 2
}
function addThree(x) {
  return x + 3
}
function addFive(x) {
  return x + 5
}
function compose(...fns) {
  return (x) =&gt;
    fns.reduce((promise, fn) =&gt; promise.then(fn), Promise.resolve(x))
}
let addTen = compose(addTwo, addThree, addFive)
addTen(8).then(console.log) // 18
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="062-异步编程-promise-其他设置"><a class="header" href="#062-异步编程-promise-其他设置">06.2-异步编程-Promise 其他设置</a></h1>
<h2 id="一-非重入期约方法"><a class="header" href="#一-非重入期约方法">一 非重入期约方法</a></h2>
<p>当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（ non-reentrancy）
特性。下面的例子演示了这个特性：</p>
<pre><code class="language-js">// 创建解决的期约
let p = Promise.resolve()
// 添加解决处理程序
// 直觉上，这个处理程序会等期约一解决就执行
p.then(() =&gt; console.log('onResolved handler'))
// 同步输出，证明 then()已经返回
console.log('then() returns')
// 实际的输出：
// then() returns
// onResolved handler
</code></pre>
<p>在这个例子中，在一个解决期约上调用 then()会把 onResolved 处理程序推进消息队列。但这个处理程序在当前线程上的同步代码执行完成前不会执行。因此，跟在 then()后面的同步代码一定先于处理程序执行。</p>
<p>先添加处理程序后解决期约也是一样的。如果添加处理程序后，同步代码才改变期约状态，那么处理程序仍然会基于该状态变化表现出非重入特性。下面的例子展示了即使先添加了 onResolved 处理程序，再同步调用 resolve()，处理程序也不会进入同步线程执行：</p>
<pre><code class="language-js">let synchronousResolve
// 创建一个期约并将解决函数保存在一个局部变量中
let p = new Promise((resolve) =&gt; {
  synchronousResolve = function () {
    console.log('1: invoking resolve()')
    resolve()
    console.log('2: resolve() returns')
  }
})
p.then(() =&gt; console.log('4: then() handler executes'))
synchronousResolve()
console.log('3: synchronousResolve() returns')

// 实际的输出：
// 1: invoking resolve()
// 2: resolve() returns
// 3: synchronousResolve() returns
// 4: then() handler executes
</code></pre>
<p>非重入适用于 onResolved/onRejected 处理程序、 catch()处理程序和 finally()处理程序。下面的例子演示了这些处理程序都只能异步执行：</p>
<pre><code class="language-js">let p1 = Promise.resolve()
p1.then(() =&gt; console.log('p1.then() onResolved'))
console.log('p1.then() returns')
let p2 = Promise.reject()
p2.then(null, () =&gt; console.log('p2.then() onRejected'))
console.log('p2.then() returns')
let p3 = Promise.reject()
p3.catch(() =&gt; console.log('p3.catch() onRejected'))
console.log('p3.catch() returns')
let p4 = Promise.resolve()
p4.finally(() =&gt; console.log('p4.finally() onFinally'))
console.log('p4.finally() returns')
// p1.then() returns
// p2.then() returns
// p3.catch() returns
// p4.finally() returns
// p1.then() onResolved
// p2.then() onRejected
// p3.catch() onRejected
// p4.finally() onFinally
</code></pre>
<h2 id="二-邻近处理程序的执行顺序"><a class="header" href="#二-邻近处理程序的执行顺序">二 邻近处理程序的执行顺序</a></h2>
<p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是 then()、 catch()还是 finally()添加的处理程序都是如此：</p>
<pre><code class="language-js">let p1 = Promise.resolve()
let p2 = Promise.reject()
p1.then(() =&gt; setTimeout(console.log, 0, 1))
p1.then(() =&gt; setTimeout(console.log, 0, 2))
// 1
// 2
p2.then(null, () =&gt; setTimeout(console.log, 0, 3))
p2.then(null, () =&gt; setTimeout(console.log, 0, 4))
// 3
// 4
p2.catch(() =&gt; setTimeout(console.log, 0, 5))
p2.catch(() =&gt; setTimeout(console.log, 0, 6))
// 5
// 6
p1.finally(() =&gt; setTimeout(console.log, 0, 7))
p1.finally(() =&gt; setTimeout(console.log, 0, 8))
// 7
// 8
</code></pre>
<h2 id="三-传递解决值和拒绝理由"><a class="header" href="#三-传递解决值和拒绝理由">三 传递解决值和拒绝理由</a></h2>
<p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。</p>
<p>在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一参数。下面的例子展示了上述传递过程：</p>
<pre><code class="language-js">let p1 = new Promise((resolve, reject) =&gt; resolve('foo'))
p1.then((value) =&gt; console.log(value)) // foo
let p2 = new Promise((resolve, reject) =&gt; reject('bar'))
p2.catch((reason) =&gt; console.log(reason)) // bar
</code></pre>
<p>Promise.resolve()和 Promise.reject()在被调用时就会接收解决值和拒绝理由。同样地，它们返回的期约也会像执行器一样把这些值传给 onResolved 或 onRejected 处理程序：</p>
<pre><code class="language-js">let p1 = Promise.resolve('foo')
p1.then((value) =&gt; console.log(value)) // foo
let p2 = Promise.reject('bar')
p2.catch((reason) =&gt; console.log(reason)) // bar
</code></pre>
<h2 id="四-拒绝期约与拒绝错误处理"><a class="header" href="#四-拒绝期约与拒绝错误处理">四 拒绝期约与拒绝错误处理</a></h2>
<p>拒绝期约类似于 throw()表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。因此以下这些期约都会以一个错误对象为由被拒绝：</p>
<pre><code class="language-js">let p1 = new Promise((resolve, reject) =&gt; reject(Error('foo')))
let p2 = new Promise((resolve, reject) =&gt; {
  throw Error('foo')
})
let p3 = Promise.resolve().then(() =&gt; {
  throw Error('foo')
})
let p4 = Promise.reject(Error('foo'))
setTimeout(console.log, 0, p1) // Promise &lt;rejected&gt;: Error: foo
setTimeout(console.log, 0, p2) // Promise &lt;rejected&gt;: Error: foo
setTimeout(console.log, 0, p3) // Promise &lt;rejected&gt;: Error: foo
setTimeout(console.log, 0, p4) // Promise &lt;rejected&gt;: Error: foo
// 也会抛出 4 个未捕获错误
</code></pre>
<p>期约可以以任何理由拒绝，包括 undefined，但最好统一使用错误对象。这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。例如，前面例子中抛出的 4 个错误的栈追踪信息如下：</p>
<pre><code class="language-js">Uncaught (in promise) Error: foo
at Promise (test.html:5)
at new Promise (&lt;anonymous&gt;)
at test.html:5
Uncaught (in promise) Error: foo
at Promise (test.html:6)
at new Promise (&lt;anonymous&gt;)
at test.html:6
Uncaught (in promise) Error: foo
at test.html:8
Uncaught (in promise) Error: foo
at Promise.resolve.then (test.html:7)
</code></pre>
<p>所有错误都是异步抛出且未处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径。注意错误的顺序： Promise.resolve().then()的错误最后才出现，这是因为它需要在运行时消息队列中添加处理程序；也就是说，在最终抛出未捕获错误之前它还会创建另一个期约。</p>
<p>这个例子同样揭示了异步错误有意思的副作用。正常情况下，在通过 throw()关键字抛出错误时，JavaScript 运行时的错误处理机制会停止执行抛出错误之后的任何指令：</p>
<pre><code class="language-js">throw Error('foo')
console.log('bar') // 这一行不会执行
// Uncaught Error: foo
</code></pre>
<p>但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令：</p>
<pre><code class="language-js">Promise.reject(Error('foo'))
console.log('bar')
// bar
// Uncaught (in promise) Error: foo
</code></pre>
<p>如本章前面的 Promise.reject()示例所示，异步错误只能通过异步的 onRejected 处理程序捕获：</p>
<pre><code class="language-js">// 正确
Promise.reject(Error('foo')).catch((e) =&gt; {})
// 不正确
try {
  Promise.reject(Error('foo'))
} catch (e) {}
</code></pre>
<p>这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用 try/catch 在执行函数中捕获错误：</p>
<pre><code class="language-js">let p = new Promise((resolve, reject) =&gt; {
  try {
    throw Error('foo')
  } catch (e) {}
  resolve('bar')
})
setTimeout(console.log, 0, p) // Promise &lt;resolved&gt;: bar
</code></pre>
<p>then()和 catch()的 onRejected 处理程序在语义上相当于 try/catch。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此， onRejected 处理程序的任务应该是在捕获异步错误之后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理：</p>
<pre><code class="language-js">console.log('begin synchronous execution')
try {
  throw Error('foo')
} catch (e) {
  console.log('caught error', e)
}
console.log('continue synchronous execution')
// begin synchronous execution
// caught error Error: foo
// continue synchronous execution
new Promise((resolve, reject) =&gt; {
  console.log('begin asynchronous execution')
  reject(Error('bar'))
})
  .catch((e) =&gt; {
    console.log('caught error', e)
  })
  .then(() =&gt; {
    console.log('continue asynchronous execution')
  })
// begin asynchronous execution
// caught error Error: bar
// continue asynchronous execution
</code></pre>
<h2 id="五-期约取消"><a class="header" href="#五-期约取消">五 期约取消</a></h2>
<p>ES6 的期约不支持取消，可以利用令牌机制取消：</p>
<pre><code class="language-html">&lt;button id=&quot;start&quot;&gt;Start&lt;/button&gt;
&lt;button id=&quot;cancel&quot;&gt;Cancel&lt;/button&gt;
&lt;script&gt;
  class CancelToken {
    constructor(cancelFn) {
      this.promise = new Promise((resolve, reject) =&gt; {
        cancelFn(() =&gt; {
          setTimeout(console.log, 0, 'delay cancelled')
          resolve()
        })
      })
    }
  }
  const startButton = document.querySelector('#start')
  const cancelButton = document.querySelector('#cancel')
  function cancellableDelayedResolve(delay) {
    setTimeout(console.log, 0, 'set delay')
    return new Promise((resolve, reject) =&gt; {
      const id = setTimeout(() =&gt; {
        setTimeout(console.log, 0, 'delayed resolve')
        resolve()
      }, delay)
      const cancelToken = new CancelToken((cancelCallback) =&gt;
        cancelButton.addEventListener('click', cancelCallback)
      )
      cancelToken.promise.then(() =&gt; clearTimeout(id))
    })
  }
  startButton.addEventListener('click', () =&gt; cancellableDelayedResolve(1000))
&lt;/script&gt;
</code></pre>
<p>每次单击“Start”按钮都会开始计时，并实例化一个新的 CancelToken 的实例。此时，“Cancel”按钮一旦被点击，就会触发令牌实例中的期约解决。而解决之后，单击“Start”按钮设置的超时也会被取消。</p>
<h2 id="六-期约的进度通知"><a class="header" href="#六-期约的进度通知">六 期约的进度通知</a></h2>
<p>执行中的期约可能会有不少离散的“阶段”，在最终解决之前必须依次经过。某些情况下，监控期约的执行进度会很有用。 ECMAScript 6 期约并不支持进度追踪，但是可以通过扩展来实现。</p>
<p>一种实现方式是扩展 Promise 类，为它添加 notify()方法：</p>
<pre><code class="language-js">class TrackablePromise extends Promise {
  constructor(executor) {
    const notifyHandlers = []
    super((resolve, reject) =&gt; {
      return executor(resolve, reject, (status) =&gt; {
        notifyHandlers.map((handler) =&gt; handler(status))
      })
    })
    this.notifyHandlers = notifyHandlers
  }
  notify(notifyHandler) {
    this.notifyHandlers.push(notifyHandler)
    return this
  }
}

let p = new TrackablePromise((resolve, reject, notify) =&gt; {
  function countdown(x) {
    if (x &gt; 0) {
      notify(`${20 * x}% remaining`)
      setTimeout(() =&gt; countdown(x - 1), 1000)
    } else {
      resolve()
    }
  }
  countdown(5)
})
</code></pre>
<p>这个期约会连续 5 次递归地设置 1000 毫秒的超时。每个超时回调都会调用 notify()并传入状态值。假设通知处理程序简单地这样写：</p>
<pre><code class="language-js">let p = new TrackablePromise((resolve, reject, notify) =&gt; {
  function countdown(x) {
    if (x &gt; 0) {
      notify(`${20 * x}% remaining`)
      setTimeout(() =&gt; countdown(x - 1), 1000)
    } else {
      resolve()
    }
  }
  countdown(5)
})
p.notify((x) =&gt; setTimeout(console.log, 0, 'progress:', x))
p.then(() =&gt; setTimeout(console.log, 0, 'completed'))
// （约 1 秒后） 80% remaining
// （约 2 秒后） 60% remaining
// （约 3 秒后） 40% remaining
// （约 4 秒后） 20% remaining
// （约 5 秒后） completed
</code></pre>
<p>notify()函数会返回期约，所以可以连缀调用，连续添加处理程序。多个处理程序会针对收到的
每条消息分别执行一遍，如下所示：</p>
<pre><code class="language-js">p.notify((x) =&gt; setTimeout(console.log, 0, 'a:', x)).notify((x) =&gt;
  setTimeout(console.log, 0, 'b:', x)
)
p.then(() =&gt; setTimeout(console.log, 0, 'completed'))
// （约 1 秒后） a: 80% remaining
// （约 1 秒后） b: 80% remaining
// （约 2 秒后） a: 60% remaining
// （约 2 秒后） b: 60% remaining
// （约 3 秒后） a: 40% remaining
// （约 3 秒后） b: 40% remaining
// （约 4 秒后） a: 20% remaining
// （约 4 秒后） b: 20% remaining
// （约 5 秒后） completed
</code></pre>
<p>以上只是简单实现了通知报告进度。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="063-异步编程-async-与-await"><a class="header" href="#063-异步编程-async-与-await">06.3-异步编程-async 与 await</a></h1>
<h2 id="一-es7-的-asyncawait"><a class="header" href="#一-es7-的-asyncawait">一 ES7 的 async/await</a></h2>
<h3 id="10-用法示例"><a class="header" href="#10-用法示例">1.0 用法示例</a></h3>
<p>Promise 虽然给异步编程带来了便利，但是在大型项目上用起来仍然较为繁琐，ES6 的生成器过渡方案并不简洁。ES7 引入了 async/await，被大众接受，并在 ES8 正式发布。</p>
<p>async/await 语法：</p>
<pre><code class="language-js">async function(){

    // await 是等待的意思，等待异步操作返回的结果，会阻塞代码
    let res1 = await 异步操作1(Promise/generator/async);

    // 这时候异步操作 2 需要等待 res1 的结果获取后才能执行
    let res2 = await 异步操作2(Promise/generator/async);
}
</code></pre>
<p>基本示例：</p>
<pre><code class="language-js">async function show(params) {
  console.log('阶段一')

  await new Promise(function (resolve, rejec) {
    setTimeout(function () {
      resolve()
    }, 3000)
  })

  console.log('阶段二')

  await new Promise(function (resolve, rejec) {
    setTimeout(function () {
      resolve()
    }, 2000)
  })

  console.log('阶段三')
}

show() // 阶段一  阶段二  阶段三
</code></pre>
<p>上面的写法已经符合正常人的顺序思维了，不过要理解的是：async/await 不过是语法糖，并未真正将异步代码同步化！</p>
<h3 id="11-async-关键字"><a class="header" href="#11-async-关键字">1.1 async 关键字</a></h3>
<p>async 关键字用于声明异步函数，可以用在函数声明、函数表达式、箭头函数：</p>
<pre><code class="language-js">async function foo() {}

let bar = async function () {}

let baz = async () =&gt; {}

class Qux {
  async qux() {}
}
</code></pre>
<p>使用 async 声明的函数具有异步的特征，不过其求值仍然是同步求值的，不过如果函数内部使用 return 返回，则返回的值则会被 <code>Promise.resolve()</code> 包装成一个期约对象：</p>
<pre><code class="language-js">// 第一种情况
async function foo() {
  return 3 // 与 return Promise.resolve(3) 效果一致
}

// 返回值由 then 函数解包
foo().then((data) =&gt; {
  console.log('后打印：', data) // 3
})

console.log('先打印') // 1

// 第二种情况：返回一个实现了 thenable 接口的非期约对象
async function baz() {
  const thenable = {
    then(callback) {
      callback('baz')
    },
  }
  return thenable
}

// 由 then() 解包
baz().then(console.log) // baz
</code></pre>
<h3 id="12-await"><a class="header" href="#12-await">1.2 await</a></h3>
<p>使用 await 关键字可以暂停异步函数代码的执行，等待期约解决：</p>
<pre><code class="language-js">// 纯 Promise 解决方案：
let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000, 3))
p.then((x) =&gt; console.log(x)) // 3

// 使用 async/await 可以写成这样：
async function foo() {
  let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000, 3))
  console.log(await p)
}
foo() // 3
</code></pre>
<p>await 关键字会暂停执行异步函数后面的代码，让出 JavaScript 运行时的执行线程。这个行为与生成器函数中的 yield 关键字是一样的。await 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。</p>
<p>await 的用法与一元操作一样，可以单独使用，也可以在表达式中使用：</p>
<pre><code class="language-js">// 异步打印&quot;foo&quot;
async function foo() {
  console.log(await Promise.resolve('foo'))
}
foo() // foo

// 异步打印&quot;bar&quot;
async function bar() {
  return await Promise.resolve('bar')
}
bar().then(console.log) // bar

// 1000 毫秒后异步打印&quot;baz&quot;
async function baz() {
  await new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000))
  console.log('baz')
}
baz() // baz（1000 毫秒后）
</code></pre>
<p>await 关键字期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。如果是实现 thenable 接口的对象，则这个对象可以由 await 来“解包”。如果不是，则这个值就被当作已经解决的期约。</p>
<h3 id="13-await-的限制"><a class="header" href="#13-await-的限制">1.3 await 的限制</a></h3>
<p>await 关键字必须在异步函数中使用，不能在顶级上下文如<code>&lt;script&gt;&lt;/script&gt;</code>标签或模块中使用：</p>
<pre><code class="language-js">async function foo() {
  console.log(await Promise.resolve(3))
}
foo() // 3

// 立即调用的异步函数表达式
;(async function () {
  console.log(await Promise.resolve(3))
})() // 3
</code></pre>
<p>await 错误示例：</p>
<pre><code class="language-js">// 不允许：await 出现在了箭头函数中
function foo() {
  const syncFn = () =&gt; {
    return await Promise.resolve('foo')
  }
  console.log(syncFn())
}

// 不允许：await 出现在了同步函数声明中
function bar() {
  function syncFn() {
    return await Promise.resolve('bar')
  }
  console.log(syncFn())
}

// 不允许：await 出现在了同步函数表达式中
function baz() {
  const syncFn = function () {
    return await Promise.resolve('baz')
  }
  console.log(syncFn())
}

// 不允许：IIFE 使用同步函数表达式或箭头函数
function qux() {
  ;(function () {
    console.log(await Promise.resolve('qux'))
  })()
  ;(() =&gt; console.log(await Promise.resolve('qux')))()
}
</code></pre>
<h2 id="二-错误处理"><a class="header" href="#二-错误处理">二 错误处理</a></h2>
<p>拒绝期约的错误不会被异步函数捕获：</p>
<pre><code class="language-js">async function foo() {
  console.log(1)
  Promise.reject(3)
}
// Attach a rejected handler to the returned promise
foo().catch(console.log)
console.log(2)
// 1
// 2
// Uncaught (in promise): 3
</code></pre>
<p>等待会抛出错误的同步操作，会返回拒绝的期约：</p>
<pre><code class="language-js">async function foo() {
  console.log(1)
  await (() =&gt; {
    throw 3
  })()
}

// 给返回的期约添加一个拒绝处理程序，输出 1 2 3
foo().catch(console.log)
console.log(2)
</code></pre>
<p>对拒绝的期约使用 await 则会释放（unwrap）错误值（将拒绝期约返回）：</p>
<pre><code class="language-js">async function foo() {
  console.log(1)
  await Promise.reject(3)
  console.log(4) // 这行代码不会执行
}
// 给返回的期约添加一个拒绝处理程序
foo().catch(console.log)
console.log(2)
</code></pre>
<h2 id="三-停止和恢复执行"><a class="header" href="#三-停止和恢复执行">三 停止和恢复执行</a></h2>
<p>异步函数如果不包含 await 关键字，其执行基本上跟普通函数没有什么区别，不过加上 await 上之后：</p>
<pre><code class="language-js">async function foo() {
  console.log(await Promise.resolve('foo'))
}
async function bar() {
  console.log(await 'bar')
}
async function baz() {
  console.log('baz')
}
foo()
bar()
baz()
// baz
// bar
// foo
</code></pre>
<p>JavaScript 运行时在碰到 await 关键字时，会记录在哪里暂停执行。等到 await 右边的值可用了，JavaScript 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。</p>
<p>即使 await 后面跟着一个立即可用的值，函数的其余部分也会被异步求值：</p>
<pre><code class="language-js">async function foo() {
  console.log(2)
  await null
  console.log(4)
}
console.log(1)
foo()
console.log(3)

// 1
// 2
// 3
// 4
</code></pre>
<p>运行过程：</p>
<pre><code class="language-txt">(1) 打印 1；
(2) 调用异步函数 foo()；
(3)（在 foo() 中）打印 2；
(4)（在 foo() 中）await 关键字暂停执行，为立即可用的值 null 向消息队列中添加一个任务；
(5) foo() 退出；
(6) 打印 3；
(7) 同步线程的代码执行完毕；
(8) JavaScript 运行时从消息队列中取出任务，恢复异步函数执行；
(9)（在 foo() 中）恢复执行，await 取得 null 值（这里并没有使用）；
(10)（在 foo() 中）打印 4；
(11) foo() 返回。
</code></pre>
<p>如果 await 后面是一个期约，为了执行异步函数，实际上会有两个任务被添加到消息队列并被异步求值：</p>
<pre><code class="language-js">async function foo() {
  console.log(2)
  console.log(await Promise.resolve(8))
  console.log(9)
}
async function bar() {
  console.log(4)
  console.log(await 6)
  console.log(7)
}
console.log(1)
foo()
console.log(3)
bar()
console.log(5)
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
</code></pre>
<p>执行步骤：</p>
<pre><code class="language-txt">(1) 打印 1；
(2) 调用异步函数 foo()；
(3)（在 foo() 中）打印 2；
(4)（在 foo() 中）await 关键字暂停执行，向消息队列中添加一个期约在落定之后执行的任务；
(5) 期约立即落定，把给 await 提供值的任务添加到消息队列；
(6) foo() 退出；
(7) 打印 3；
(8) 调用异步函数 bar()；
(9)（在 bar() 中）打印 4；
(10)（在 bar() 中）await 关键字暂停执行，为立即可用的值 6 向消息队列中添加一个任务；
(11) bar() 退出；
(12) 打印 5；
(13) 顶级线程执行完毕；
(14) JavaScript 运行时从消息队列中取出解决 await 期约的处理程序，并将解决的值 8 提供给它；
(15) JavaScript 运行时向消息队列中添加一个恢复执行 foo() 函数的任务；
(16) JavaScript 运行时从消息队列中取出恢复执行 bar() 的任务及值 6；
(17)（在 bar() 中）恢复执行，await 取得值 6；
(18)（在 bar() 中）打印 6；
(19)（在 bar() 中）打印 7；
(20) bar() 返回；
(21) 异步任务完成，JavaScript 从消息队列中取出恢复执行 foo() 的任务及值 8；
(22)（在 foo() 中）打印 8；
(23)（在 foo() 中）打印 9；
(24) foo() 返回
</code></pre>
<h2 id="四-异步实践"><a class="header" href="#四-异步实践">四 异步实践</a></h2>
<h3 id="41-实现-sleep"><a class="header" href="#41-实现-sleep">4.1 实现 sleep()</a></h3>
<p>利用异步函数实现类似 Java 中的 <code>Thread.sleep()</code>：</p>
<pre><code class="language-js">async function sleep(delay) {
  return new Promise((resolve) =&gt; setTimeout(resolve, delay))
}
async function foo() {
  const t0 = Date.now()
  await sleep(1500) // 暂停约 1500 毫秒
  console.log(Date.now() - t0)
}
foo()
// 1502
</code></pre>
<h3 id="42-利用平行执行"><a class="header" href="#42-利用平行执行">4.2 利用平行执行</a></h3>
<p>示例中，顺序等待了 5 个随机的超时：</p>
<pre><code class="language-js">async function randomDelay(id) {
  // 延迟 0~1000 毫秒
  const delay = Math.random() * 1000
  return new Promise((resolve) =&gt;
    setTimeout(() =&gt; {
      console.log(`${id} finished`)
      resolve()
    }, delay)
  )
}
async function foo() {
  const t0 = Date.now()
  await randomDelay(0)
  await randomDelay(1)
  await randomDelay(2)
  await randomDelay(3)
  await randomDelay(4)
  console.log(`${Date.now() - t0}ms elapsed`)
}
foo()
// 0 finished
// 1 finished
// 2 finished
// 3 finished
// 4 finished
// 877ms elapsed
</code></pre>
<p>用 for 重写：</p>
<pre><code class="language-js">async function randomDelay(id) {
  // 延迟 0~1000 毫秒
  const delay = Math.random() * 1000
  return new Promise((resolve) =&gt;
    setTimeout(() =&gt; {
      console.log(`${id} finished`)
      resolve()
    }, delay)
  )
}
async function foo() {
  const t0 = Date.now()
  for (let i = 0; i &lt; 5; ++i) {
    await randomDelay(i)
  }
  console.log(`${Date.now() - t0}ms elapsed`)
}
foo()
</code></pre>
<p>就算这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序，但总执行时间会变长。如果顺序不是必需保证的，那么可以先一次性初始化所有期约，然后再分别等待它们的结果：</p>
<pre><code class="language-js">async function randomDelay(id) {
  // 延迟 0~1000 毫秒
  const delay = Math.random() * 1000
  return new Promise((resolve) =&gt;
    setTimeout(() =&gt; {
      setTimeout(console.log, 0, `${id} finished`)
      resolve()
    }, delay)
  )
}
async function foo() {
  const t0 = Date.now()
  const p0 = randomDelay(0)
  const p1 = randomDelay(1)
  const p2 = randomDelay(2)
  const p3 = randomDelay(3)
  const p4 = randomDelay(4)
  await p0
  await p1
  await p2
  await p3
  await p4
  setTimeout(console.log, 0, `${Date.now() - t0}ms elapsed`)
}
foo()
</code></pre>
<p>用数组和 for 循环再包装一下就是：</p>
<pre><code class="language-js">async function randomDelay(id) {
  // 延迟 0~1000 毫秒
  const delay = Math.random() * 1000
  return new Promise((resolve) =&gt;
    setTimeout(() =&gt; {
      console.log(`${id} finished`)
      resolve()
    }, delay)
  )
}
async function foo() {
  const t0 = Date.now()
  const promises = Array(5)
    .fill(null)
    .map((_, i) =&gt; randomDelay(i))
  for (const p of promises) {
    await p
  }
  console.log(`${Date.now() - t0}ms elapsed`)
}
foo()
</code></pre>
<p>虽然期约没有按照顺序执行，但 await 按顺序收到了每个期约的值：</p>
<pre><code class="language-js">async function randomDelay(id) {
  // 延迟 0~1000 毫秒
  const delay = Math.random() * 1000
  return new Promise((resolve) =&gt;
    setTimeout(() =&gt; {
      console.log(`${id} finished`)
      resolve(id)
    }, delay)
  )
}
async function foo() {
  const t0 = Date.now()
  const promises = Array(5)
    .fill(null)
    .map((_, i) =&gt; randomDelay(i))
  for (const p of promises) {
    console.log(`awaited ${await p}`)
  }
  console.log(`${Date.now() - t0}ms elapsed`)
}
foo()
</code></pre>
<h3 id="43-串行执行期约"><a class="header" href="#43-串行执行期约">4.3 串行执行期约</a></h3>
<p>使用 async/await 实现期约连锁：</p>
<pre><code class="language-js">function addTwo(x) {
  return x + 2
}
function addThree(x) {
  return x + 3
}
function addFive(x) {
  return x + 5
}
async function addTen(x) {
  for (const fn of [addTwo, addThree, addFive]) {
    x = await fn(x)
  }
  return x
}
addTen(9).then(console.log) // 19
</code></pre>
<p>await 直接传递了每个函数的返回值，结果通过迭代产生。当然，这个例子并没有使用期约，如果要使用期约，则可以把所有函数都改成异步函数。这样它们就都返回期约了：</p>
<pre><code class="language-js">async function addTwo(x) {
  return x + 2
}
async function addThree(x) {
  return x + 3
}
async function addFive(x) {
  return x + 5
}
async function addTen(x) {
  for (const fn of [addTwo, addThree, addFive]) {
    x = await fn(x)
  }
  return x
}
addTen(9).then(console.log) // 19
</code></pre>
<h3 id="44-栈追踪与内存管理"><a class="header" href="#44-栈追踪与内存管理">4.4 栈追踪与内存管理</a></h3>
<p>期约与异步函数的功能有相当程度的重叠，但它们在内存中的表示则差别很大：</p>
<pre><code class="language-js">// 拒绝期约栈追踪
function fooPromiseExecutor(resolve, reject) {
  setTimeout(reject, 1000, 'bar')
}
function foo() {
  new Promise(fooPromiseExecutor)
}

foo()
// Uncaught (in promise) bar
// setTimeout
// setTimeout (async)
// fooPromiseExecutor
// foo
</code></pre>
<p>在超时处理程序执行时和拒绝期约时，我们看到的错误信息包含嵌套函数的标识符，那是被调用以创建最初期约实例的函数。可是，我们知道这些函数已经返回了，因此栈追踪信息中不应该看到它们。这是因为 JavaScript 引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时，调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。当然，这意味着栈追踪信息会占用内存，从而带来一些计算和存储成本。</p>
<pre><code class="language-js">function fooPromiseExecutor(resolve, reject) {
  setTimeout(reject, 1000, 'bar')
}
async function foo() {
  await new Promise(fooPromiseExecutor)
}
foo()
// Uncaught (in promise) bar
// foo
// async function (async)
// foo
</code></pre>
<p>这时栈追踪信息就准确地反映了当前的调用栈。fooPromiseExecutor() 已经返回，所以它不在错误信息中。但 foo() 此时被挂起了，并没有退出。JavaScript 运行时可以简单地在嵌套函数中存储指向包含函数的指针，就跟对待同步函数调用栈一样。这个指针实际上存储在内存中，可用于在出错时生成栈追踪信息。这样就不会像之前的例子那样带来额外的消耗，因此在重视性能的应用中是可以优先考虑的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="064-异步编程-异步迭代"><a class="header" href="#064-异步编程-异步迭代">06.4-异步编程-异步迭代</a></h1>
<h2 id="一-使用异步迭代器"><a class="header" href="#一-使用异步迭代器">一 使用异步迭代器</a></h2>
<p>同步迭代器在每次调用 next() 时都会返回{ value, done }对象。当然，这要求确定这个对象内容的计算和资源获取在 next() 调用退出时必须完成，否则这些值就无法确定。在使用同步迭代器迭代异步确定的值时，主执行线程会被阻塞，以等待异步操作完成。</p>
<p>有了异步迭代器，这个问题就迎刃而解了。异步迭代器在每次调用 next() 时会提供解决为{ value,done }对象的期约。这样，执行线程可以释放并在当前这步循环完成之前执行其他任务。</p>
<p>示例：</p>
<pre><code class="language-js">// 该类包含一个同步生成器函数，该函数会产生一个同步迭代器
class Emitter {
  constructor(max) {
    this.max = max
    this.syncIdx = 0
  }
  *[Symbol.iterator]() {
    while (this.syncIdx &lt; this.max) {
      yield this.syncIdx++
    }
  }
}

const emitter = new Emitter(5)
function syncCount() {
  const syncCounter = emitter[Symbol.iterator]()
  for (const x of syncCounter) {
    console.log(x)
  }
}
syncCount()
// 0
// 1
// 2
// 3
// 4
</code></pre>
<p>这个例子之所以可以运行起来，主要是因为迭代器可以立即产生下一个值。假如你不想在确定下一个产生的值时阻塞主线程执行，也可以定义异步迭代器函数，让它产生期约包装的值。</p>
<p>为此，要使用迭代器和生成器的异步版本。ECMAScript 2018 为此定义了 Symbol.asyncIterator，以便定义和调用输出期约的生成器函数。同时，这一版规范还为异步迭代器增加了 for-await-of 循环，用于使用异步迭代器。</p>
<p>相应地，前面的例子可以扩展为同时支持同步和异步迭代：</p>
<pre><code class="language-js">class Emitter {
  constructor(max) {
    this.max = max
    this.syncIdx = 0
    this.asyncIdx = 0
  }
  *[Symbol.iterator]() {
    while (this.syncIdx &lt; this.max) {
      yield this.syncIdx++
    }
  }
  async *[Symbol.asyncIterator]() {
    // *[Symbol.asyncIterator]() {
    while (this.asyncIdx &lt; this.max) {
      // yield new Promise((resolve) =&gt; resolve(this.asyncIdx++));
      yield this.asyncIdx++
    }
  }
}

const emitter = new Emitter(5)
function syncCount() {
  const syncCounter = emitter[Symbol.iterator]()
  for (const x of syncCounter) {
    console.log(x)
  }
}
async function asyncCount() {
  const asyncCounter = emitter[Symbol.asyncIterator]()
  for await (const x of asyncCounter) {
    console.log(x)
  }
}
syncCount()
// 0
// 1
// 2
// 3
// 4
asyncCount()
// 0
// 1
// 2
// 3
// 4
</code></pre>
<p>可以把前面例子中的同步生成器传给 for-await-of 循环：</p>
<pre><code class="language-js">const emitter = new Emitter(5)
async function asyncIteratorSyncCount() {
  const syncCounter = emitter[Symbol.iterator]()
  for await (const x of syncCounter) {
    console.log(x)
  }
}
asyncIteratorSyncCount()
// 0
// 1
// 2
// 3
// 4
</code></pre>
<p>虽然这里迭代的是同步生成器产生的原始值，但 for-await-of 循环仍像它们被包装在期约中一样处理它们。这说明 for-await-of 循环可以流畅地处理同步和异步可迭代对象。但是常规 for 循环就不能处理异步迭代器了：</p>
<pre><code class="language-js">function syncIteratorAsyncCount() {
  const asyncCounter = emitter[Symbol.asyncIterator]()
  for (const x of asyncCounter) {
    console.log(x)
  }
}
syncIteratorAsyncCount()
// TypeError: asyncCounter is not iterable
</code></pre>
<p>Symbol.asyncIterator 符号不会改变生成器函数的行为或者消费生成器的方式。注意在前面的例子中，生成器函数加上了 async 修饰符成为异步函数，又加上了星号成为生成器函数。Symbol.asyncIterator 在这里只起一个提示的作用，告诉将
来消费这个迭代器的外部结构如 for-await-of 循环，这个迭代器会返回期约对象的序列。</p>
<h2 id="二-处理异步迭代器"><a class="header" href="#二-处理异步迭代器">二 处理异步迭代器</a></h2>
<p>前面的例子是假想的，因为迭代器返回的期约都会立即解决，所以跟同步迭代器的区别很难看出来。想象一下迭代器返回的期约会在不确定的时间解决，而且它们返回的顺序是乱的。异步迭代器应该尽可能模拟同步迭代器，包括每次迭代时代码的按顺序执行。为此，异步迭代器会维护一个回调队列，以保证早期值的迭代器处理程序总是会在处理晚期值之前完成，即使后面的值早于之前的值解决。</p>
<p>为验证这一点，下面的例子中的异步迭代器以随机时长返回期约。异步迭代队列可以保证期约解决的顺序不会干扰迭代顺序。结果应该按顺序打印一组整数（但间隔时间随机）：</p>
<pre><code class="language-js">class Emitter {
  constructor(max) {
    this.max = max
    this.syncIdx = 0
    this.asyncIdx = 0
  }
  *[Symbol.iterator]() {
    while (this.syncIdx &lt; this.max) {
      yield this.syncIdx++
    }
  }
  async *[Symbol.asyncIterator]() {
    while (this.asyncIdx &lt; this.max) {
      yield new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
          resolve(this.asyncIdx++)
        }, Math.floor(Math.random() * 1000))
      })
    }
  }
}
const emitter = new Emitter(5)
function syncCount() {
  const syncCounter = emitter[Symbol.iterator]()
  for (const x of syncCounter) {
    console.log(x)
  }
}
async function asyncCount() {
  const asyncCounter = emitter[Symbol.asyncIterator]()
  for await (const x of asyncCounter) {
    console.log(x)
  }
}
syncCount()
// 0
// 1
// 2
// 3
// 4
asyncCount()
// 0
// 1
// 2
// 3
// 4
</code></pre>
<h2 id="三-处理异步迭代器的-reject"><a class="header" href="#三-处理异步迭代器的-reject">三 处理异步迭代器的 reject()</a></h2>
<p>因为异步迭代器使用期约来包装返回值，所以必须考虑某个期约被拒绝的情况。由于异步迭代会按顺序完成，而在循环中跳过被拒绝的期间是不合理的。因此，被拒绝的期约会强制退出迭代器：</p>
<pre><code class="language-js">class Emitter {
  constructor(max) {
    this.max = max
    this.asyncIdx = 0
  }
  async *[Symbol.asyncIterator]() {
    while (this.asyncIdx &lt; this.max) {
      if (this.asyncIdx &lt; 3) {
        yield this.asyncIdx++
      } else {
        throw 'Exited loop'
      }
    }
  }
}
const emitter = new Emitter(5)
async function asyncCount() {
  const asyncCounter = emitter[Symbol.asyncIterator]()
  for await (const x of asyncCounter) {
    console.log(x)
  }
}
asyncCount()
// 0
// 1
// 2
// Uncaught (in promise) Exited loop
</code></pre>
<h2 id="四-使用-next-手动异步迭代"><a class="header" href="#四-使用-next-手动异步迭代">四 使用 next() 手动异步迭代</a></h2>
<p>for-await-of 循环提供了两个有用的特性：一是利用异步迭代器队列保证按顺序执行，二是隐藏异步迭代器的期约。不过，使用这个循环会隐藏很多底层行为。</p>
<p>因为异步迭代器仍遵守迭代器协议，所以可以使用 next() 逐个遍历异步可迭代对象。如前所述，next() 返回的值会包含一个期约，该期约可解决为{ value, done }这样的迭代结果。这意味着必须使用期约 API 获取方法，同时也意味着可以不使用异步迭代器队列。</p>
<pre><code class="language-js">const emitter = new Emitter(5)
const asyncCounter = emitter[Symbol.asyncIterator]()
console.log(asyncCounter.next())
// Promise&lt;{value, done}&gt;
</code></pre>
<h2 id="五-顶级异步循环"><a class="header" href="#五-顶级异步循环">五 顶级异步循环</a></h2>
<p>一般来说，包括 for-await-of 循环在内的异步行为不能出现在异步函数外部。不过，有时候可能确实需要在这样的上下文使用异步行为。为此可以通过创建异步 IIFE 来达到目的：</p>
<pre><code class="language-js">class Emitter {
  constructor(max) {
    this.max = max
    this.asyncIdx = 0
  }
  async *[Symbol.asyncIterator]() {
    while (this.asyncIdx &lt; this.max) {
      yield new Promise((resolve) =&gt; resolve(this.asyncIdx++))
    }
  }
}
const emitter = new Emitter(5)
;(async function () {
  const asyncCounter = emitter[Symbol.asyncIterator]()
  for await (const x of asyncCounter) {
    console.log(x)
  }
})()
// 0
// 1
// 2
// 3
// 4
</code></pre>
<h2 id="六-实现可观察对象"><a class="header" href="#六-实现可观察对象">六 实现可观察对象</a></h2>
<p>异步迭代器可以耐心等待下一次迭代而不会导致计算成本，那么这也为实现可观察对象（Observable）接口提供了可能。总体上看，这涉及捕获事件，将它们封装在期约中，然后把这些事件提供给迭代器，而处理程序可以利用这些异步迭代器。在某个事件触发时，异步迭代器的下一个期约会解决为该事件。</p>
<p>下面这个简单的例子会捕获浏览器事件的可观察流。这需要一个期约的队列，每个期约对应一个事件。该队列也会保持事件生成的顺序，对这种问题来说保持顺序也是合理的。</p>
<pre><code class="language-js">class Observable {
  constructor() {
    this.promiseQueue = []
    // 保存用于解决队列中下一个期约的程序
    this.resolve = null
    // 把最初的期约推到队列
    // 该期约会解决为第一个观察到的事件
    this.enqueue()
  }
  // 创建新期约，保存其解决方法
  // 再把它保存到队列中
  enqueue() {
    this.promiseQueue.push(new Promise((resolve) =&gt; (this.resolve = resolve)))
  }
  // 从队列前端移除期约
  // 并返回它
  dequeue() {
    return this.promiseQueue.shift()
  }
}
</code></pre>
<p>要利用这个期约队列，可以在这个类上定义一个异步生成器方法。该生成器可用于任何类型的事件：</p>
<pre><code class="language-js">class Observable {
  constructor() {
    this.promiseQueue = []
    // 保存用于解决队列中下一个期约的程序
    this.resolve = null
    // 把最初的期约推到队列
    // 该期约会解决为第一个观察到的事件
    this.enqueue()
  }
  // 创建新期约，保存其解决方法
  // 再把它保存到队列中
  enqueue() {
    this.promiseQueue.push(new Promise((resolve) =&gt; (this.resolve = resolve)))
  }
  // 从队列前端移除期约
  // 并返回它
  dequeue() {
    return this.promiseQueue.shift()
  }
  async *fromEvent(element, eventType) {
    // 在有事件生成时，用事件对象来解决队列头部的期约
    // 同时把另一个期约加入队列
    element.addEventListener(eventType, (event) =&gt; {
      this.resolve(event)
      this.enqueue()
    })
    // 每次解决队列前面的期约
    // 都会向异步迭代器返回相应的事件对象
    while (1) {
      yield await this.dequeue()
    }
  }
}
</code></pre>
<p>这样，这个类就定义完了。接下来在 DOM 元素上定义可观察对象就很简单了。假设页面上有一个<code>&lt;button&gt;</code>元素，可以像下面这样捕获该按钮上的一系列 click 事件，然后在控制台把它们打印出来：</p>
<pre><code class="language-js">class Observable {
  constructor() {
    this.promiseQueue = []
    // 保存用于解决队列中下一个期约的程序
    this.resolve = null
    // 把最初的期约推到队列
    // 该期约会解决为第一个观察到的事件
    this.enqueue()
  }
  // 创建新期约，保存其解决方法
  // 再把它保存到队列中
  enqueue() {
    this.promiseQueue.push(new Promise((resolve) =&gt; (this.resolve = resolve)))
  }
  // 从队列前端移除期约
  // 并返回它
  dequeue() {
    return this.promiseQueue.shift()
  }
  async *fromEvent(element, eventType) {
    // 在有事件生成时，用事件对象来解决 队列头部的期约
    // 同时把另一个期约加入队列
    element.addEventListener(eventType, (event) =&gt; {
      this.resolve(event)
      this.enqueue()
    })
    // 每次解决队列前面的期约
    // 都会向异步迭代器返回相应的事件对象
    while (1) {
      yield await this.dequeue()
    }
  }
}
;(async function () {
  const observable = new Observable()
  const button = document.querySelector('button')
  const mouseClickIterator = observable.fromEvent(button, 'click')
  for await (const clickEvent of mouseClickIterator) {
    console.log(clickEvent)
  }
})()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="071-代理与反射-代理"><a class="header" href="#071-代理与反射-代理">07.1-代理与反射-代理</a></h1>
<h2 id="一-代理概念"><a class="header" href="#一-代理概念">一 代理概念</a></h2>
<p>在 ES5 中，如果要深入数据操作，只有 <code>Object.defineProperty()</code> 等有限的几个方法。ES6 引入了代理 Proxy 构造函数，<strong>对目标对象进行抽象</strong>，从而拦截并改变 JS 引擎的底层操作。</p>
<p>可以直接操作目标对象，也可以通过 Proxy 代理来操作目标对象。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象，因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。目标对象和代理对象双方属性的改变，都会影响到对方：</p>
<pre><code class="language-js">// 目标对象
let target = {
  name: 'Ww',
}

// 创建空代理对象：参数一为目标对象，参数二为处理程序对象
let proxy = new Proxy(target, {})

// 直接操作源对象
target.name = 'Li'
console.log('目标对象 name：', target.name) // Li
console.log('代理对象 name：', proxy.name) // Li

// 通过代理对象操作源对象
proxy.name = 'Zh'
console.log('目标对象 name：', target.name) // Zh
console.log('代理对象 name：', proxy.name) // Zh
</code></pre>
<p>使用 <code>hasOwnProperty()</code> 可以看到代理对象和目标对象拥有的属性相同，但是不能认为代理对象和目标对象是相等的：</p>
<pre><code class="language-js">let target = {
  name: 'ls'
}
let proxy = new Proxy(target, {})

// hasOwnProperty() 都适用于二者
console.log(target.hasOwnProperty('name')) // true
console.log(proxy.hasOwnProperty('name')) // true

// 代理对象和目标对象不相等
console.log(target == proxy) // false
</code></pre>
<p>重点：Proxy 对象 的 prototype 属性是 undefined，所以代理对象不支持 instanceof 操作。</p>
<h2 id="二-捕获器"><a class="header" href="#二-捕获器">二 捕获器</a></h2>
<h3 id="21-捕获器作用"><a class="header" href="#21-捕获器作用">2.1 捕获器作用</a></h3>
<p><strong>代理的核心作用：定义捕获器（trap）作为对象操作的拦截器</strong>。每个捕获器都对应一个对象的基本操作，每个处理对象都可以包含零到多个捕获器。</p>
<p>捕获器的触发只能依赖于代理对象：在代理对象上调用目标对象的基本操作时，代理会在这些操作传播到目标对象之前先调用捕获器函数，从而产生拦截、修改等行为。</p>
<p>示例：定义一个 getter 捕获器：</p>
<pre><code class="language-js">const target = {
  foo: 'bar',
}

// 定义捕获器
const handler = {
  // 捕获器在处理程序对象中是以方法名为键的
  get() {
    console.log('handler override')
    return 'override result'
  },
}

const proxy = new Proxy(target, handler)

// 通过代理对象执行 get()操作时，就会触发定义的 get()捕获器。
let res = proxy.foo // handler override
console.log(res) // override result
</code></pre>
<p>贴士：只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。</p>
<h3 id="22-捕获器参数"><a class="header" href="#22-捕获器参数">2.2 捕获器参数</a></h3>
<p>捕获器可以接收参数，比如 get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数：</p>
<pre><code class="language-js">const target = {
  foo: 'bar',
}

const handler = {
  get(trapTarget, property, receiver) {
    // 重建被捕获方法的原始行为
    console.log('handler override')
    // console.log(trapTarget === target) // true
    // console.log(property)  // foo
    // console.log(receiver === proxy) true
    return trapTarget[property]
  },
}

const proxy = new Proxy(target, handler)

// 捕获器必须由代理对象触发：直接访问目标对象不会触发代理行为（捕获器行为）
let res = proxy.foo // 'handler override'
console.log(res) // bar
</code></pre>
<p>并非所有捕获器行为都像 get()那么简单，这样手动重建原始行为是很不方便的，可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建，这在反射章节 优雅地书写捕获器 有讲解。</p>
<h3 id="23-捕获器的不变式"><a class="header" href="#23-捕获器的不变式">2.3 捕获器的不变式</a></h3>
<p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 ECMAScript 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”。</p>
<p>“捕获器不变式”（trap invariant）用来防止一些非法行为，如给一个只读属性进行数据变更，则会抛出 TypeError：</p>
<pre><code class="language-js">const target = {}
Object.defineProperty(target, 'foo', {
  configurable: false,
  writable: false,
  value: 'bar',
})

const handler = {
  get() {
    return 'qux'
  },
}

const proxy = new Proxy(target, handler)
console.log(proxy.foo) // TypeError
</code></pre>
<h2 id="三-撤销代理"><a class="header" href="#三-撤销代理">三 撤销代理</a></h2>
<p>使用 new Proxy() 创建的普通代理与目标对象的联系伴随着整个代理对象的生命周期。但是有时候需要中断代理对象与目标对象的联系，这时候需要借助 Proxy 的 <code>revocable()</code> 方法。</p>
<p>撤销代理操作是不可逆的：</p>
<pre><code class="language-js">const target = {
  foo: 'bar',
}
const handler = {
  get() {
    return 'intercepted'
  },
}

const { proxy, revoke } = Proxy.revocable(target, handler)

// 撤销函数`revoke()` 是幂等的，多次调用结果一致
revoke()

// 撤销撤销代理之后再调用代理会报错
console.log(proxy.foo) // TypeError
</code></pre>
<h2 id="四-代理的缺陷"><a class="header" href="#四-代理的缺陷">四 代理的缺陷</a></h2>
<h3 id="41-代理中的-this"><a class="header" href="#41-代理中的-this">4.1 代理中的 this</a></h3>
<p>代理潜在的一个问题来源是 this 值。我们知道，方法中的 this 通常指向调用这个方法的对象：</p>
<pre><code class="language-js">const target = {
  thisValEqualsProxy() {
    return this === proxy
  },
}
const proxy = new Proxy(target, {})
console.log(target.thisValEqualsProxy()) // false
console.log(proxy.thisValEqualsProxy()) // true
</code></pre>
<p>从直觉上讲，这样完全没有问题：调用代理上的任何方法。现在看一个案例：</p>
<pre><code class="language-js">const wm = new WeakMap()

class User {
  constructor(userId) {
    wm.set(this, userId)
  }
  set id(userId) {
    wm.set(this, userId)
  }
  get id() {
    return wm.get(this)
  }
}

const user = new User(123)
const proxy = new Proxy(user, {})
console.log(user.id) // 123
console.log(proxy.id) // undefined
</code></pre>
<p>这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实例。</p>
<p>要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代理的实例就会以代理实例作为 WeakMap 的键了：</p>
<pre><code class="language-js">const proxy = new Proxy(User, {})
const userClassProxy = new UserClassProxy(456)
console.log(userClassProxy.id)
</code></pre>
<h3 id="42-代理与内部槽位"><a class="header" href="#42-代理与内部槽位">4.2 代理与内部槽位</a></h3>
<p>代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。</p>
<p>一个典型的例子就是 Date 类型。根据 ECMAScript 规范， Date 类型方法的执行依赖 this 值上的内部槽位 <code>[[NumberDate]]</code> 。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：</p>
<pre><code class="language-js">const target = new Date()
const proxy = new Proxy(target, {})
console.log(proxy instanceof Date) // true
proxy.getDate() // TypeError: 'this' is not a Date object
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="072-代理与反射-反射"><a class="header" href="#072-代理与反射-反射">07.2-代理与反射-反射</a></h1>
<h2 id="一-反射的基本使用"><a class="header" href="#一-反射的基本使用">一 反射的基本使用</a></h2>
<h3 id="11-反射概念"><a class="header" href="#11-反射概念">1.1 反射概念</a></h3>
<p>在 JS 运行时，能够知道这个对象的成员，并能够调用这些成员，这种动态获取信息、动态调用对象方法的功能称为反射。</p>
<p>反射 API 范围很广，可以用于代理中的捕获处理程序。大多的反射 API 方法在 Object 类型上都有对应的方法。相比 Object 直接操作，反射更适合用于细粒度的对象控制。</p>
<h3 id="12-反射的状态标记"><a class="header" href="#12-反射的状态标记">1.2 反射的状态标记</a></h3>
<p>很多反射方法返回一个布尔值，表示意图执行的操作是否成功，称作“状态标记”的布尔值。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 API 方法更有用。</p>
<p>例如在定义新属性时如果发生问题， Reflect.defineProperty()会返回 false，而不是抛出错误，以下是使用 Object 原生方法的实现该需求：</p>
<pre><code class="language-js">// 使用 Object 原生方法：
const o = {}

try {
  Object.defineProperty(o, 'foo', { value: 'bar' })
  console.log('success')
} catch (e) {
  console.log('failure')
}
</code></pre>
<p>可以使用反射 API 对下面的代码进行重构：</p>
<pre><code class="language-js">const o = {}

if (Reflect.defineProperty(o, 'foo', { value: 'bar' })) {
  console.log('success')
} else {
  console.log('failure')
}
</code></pre>
<p>以下反射方法都会提供状态标记：</p>
<pre><code class="language-js">Reflect.defineProperty()
Reflect.preventExtensions()
Reflect.setPrototypeOf()
Reflect.set()
Reflect.deleteProperty()
</code></pre>
<h3 id="13-替代操作符的方法"><a class="header" href="#13-替代操作符的方法">1.3 替代操作符的方法</a></h3>
<p>以下反射方法提供只有通过操作符才能完成操作：</p>
<pre><code class="language-js">// 可以替代对象属性访问操作符
Reflect.get()

// 可以替代=赋值操作符
Reflect.set()

// 可以替代 in 操作符或 with()
Reflect.has()

// 可以替代 delete 操作符
Reflect.deleteProperty()

// 可以替代 new 操作符
Reflect.construct()
</code></pre>
<h3 id="14-函数安全应用"><a class="header" href="#14-函数安全应用">1.4 函数安全应用</a></h3>
<p>在通过 apply 方法调用函数时，被调用的函数可能也定义了自己的 apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法，比如：</p>
<pre><code class="language-js">Function.prototype.apply.call(myFunc, thisVal, argumentList)
</code></pre>
<p>使用反射可以解决上述问题：</p>
<pre><code class="language-js">Reflect.apply(myFunc, thisVal, argumentsList)
</code></pre>
<h2 id="二-代理与反射的配合"><a class="header" href="#二-代理与反射的配合">二 代理与反射的配合</a></h2>
<h3 id="21-优雅地书写捕获器"><a class="header" href="#21-优雅地书写捕获器">2.1 优雅地书写捕获器</a></h3>
<p>代理的捕获器并不是都像 get() 这么简单，手动重建原始行为是不现实的，可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。</p>
<p>处理程序对象中所有可以捕获的方法都有对应的反射（ Reflect） API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射 API 也可以像下面这样定义出空代理对象：</p>
<pre><code class="language-js">const target = {
  foo: 'bar',
}

const handler = {
  get() {
    console.log('handler override')
    return Reflect.get //  Reflect.get(...arguments) 的简写
  },
}

const proxy = new Proxy(target, handler)

console.log(proxy.foo) // 'handler override' bar
</code></pre>
<p>如果直接将全局反射对象作为处理程序对象，那么所有可捕获的方法将被捕获：</p>
<pre><code class="language-js">const target = {
  foo: 'bar',
}

const proxy = new Proxy(target, Reflect)

console.log(proxy.foo) // bar
</code></pre>
<p>反射 API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。 比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：</p>
<pre><code class="language-js">const target = {
  foo: 'bar',
  baz: 'qux',
}

const handler = {
  get(trapTarget, property, receiver) {
    let decoration = ''
    if (property === 'foo') {
      decoration = '!!!'
    }
    return Reflect.get + decoration
  },
}

const proxy = new Proxy(target, handler)
console.log(proxy.foo) // bar!!!
console.log(target.foo) // bar
console.log(proxy.baz) // qux
console.log(target.baz) // qux
</code></pre>
<h3 id="22-代理另外一个代理"><a class="header" href="#22-代理另外一个代理">2.2 代理另外一个代理</a></h3>
<p>代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：</p>
<pre><code class="language-js">const target = {
  foo: 'bar',
}

const firstProxy = new Proxy(target, {
  get() {
    console.log('first proxy')
    return Reflect.get(...arguments)
  },
})

const secondProxy = new Proxy(firstProxy, {
  get() {
    console.log('second proxy')
    return Reflect.get(...arguments)
  },
})

// second proxy   first proxy  bar
console.log(secondProxy.foo)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="073-代理与反射-捕获器-api"><a class="header" href="#073-代理与反射-捕获器-api">07.3-代理与反射-捕获器 API</a></h1>
<h2 id="一-捕获器-api-列表"><a class="header" href="#一-捕获器-api-列表">一 捕获器 API 列表</a></h2>
<h3 id="11-construct"><a class="header" href="#11-construct">1.1 construct()</a></h3>
<p>construct()捕获器会在 new 操作符中被调用。对应的反射 API 方法为 Reflect.construct()：</p>
<pre><code class="language-js">const myTarget = function () {}
const proxy = new Proxy(myTarget, {
  construct(target, argumentsList, newTarget) {
    console.log('construct()')
    return Reflect.construct(...arguments)
  },
})
new proxy() // construct()
</code></pre>
<ol>
<li>返回值
construct()必须返回一个对象。</li>
<li>拦截的操作
<ul>
<li>new proxy(...argumentsList)</li>
<li>Reflect.construct(target, argumentsList, newTarget)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标构造函数。</li>
</ul>
</li>
</ol>
<h3 id="12-get"><a class="header" href="#12-get">1.2 get()</a></h3>
<p>get() 捕获器会在获取属性值的操作中被调用，set() 捕获器会在设置属性值的操作中被调用，has() 捕获器会在 in 操作符中被调用：</p>
<pre><code class="language-js">const myTarget = {}
const proxy = new Proxy(myTarget, {
  get(target, property, receiver) {
    console.log('get()')
    return Reflect.get(...arguments)
  },
})
proxy.foo // get()
</code></pre>
<ol>
<li>返回值
返回值无限制。</li>
<li>拦截的操作
<ul>
<li>proxy.property</li>
<li>proxy[property]</li>
<li>Object.create(proxy)[property]</li>
<li>Reflect.get(proxy, property, receiver)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
<li>property：引用的目标对象上的字符串键属性。 ①</li>
<li>receiver：代理对象或继承代理对象的对象。</li>
</ul>
</li>
<li>捕获器不变式
如果 target.property 不可写且不可配置，则处理程序返回的值必须与 target.property 匹配。
如果 target.property 不可配置且<code>[[Get]]</code>特性为 undefined， 处理程序的返回值也必须是 undefined。</li>
</ol>
<h3 id="13-set"><a class="header" href="#13-set">1.3 set()</a></h3>
<p>set()捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 Reflect.set()。</p>
<pre><code class="language-js">const myTarget = {}
const proxy = new Proxy(myTarget, {
  set(target, property, value, receiver) {
    console.log('set()')
    return Reflect.set(...arguments)
  },
})
proxy.foo = 'bar' // set()
</code></pre>
<ol>
<li>返回值
返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。</li>
<li>拦截的操作
<ul>
<li>proxy.property = value</li>
<li>proxy[property] = value</li>
<li>Object.create(proxy)[property] = value</li>
<li>Reflect.set(proxy, property, value, receiver)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
<li>property：引用的目标对象上的字符串键属性。</li>
<li>value：要赋给属性的值。</li>
<li>receiver：接收最初赋值的对象。</li>
</ul>
</li>
<li>捕获器不变式
如果 target.property 不可写且不可配置，则不能修改目标属性的值。
如果 target.property 不可配置且<code>[[Set]]</code>特性为 undefined，则不能修改目标属性的值。
在严格模式下，处理程序中返回 false 会抛出 TypeError。</li>
</ol>
<h3 id="14-has"><a class="header" href="#14-has">1.4 has()</a></h3>
<p>has()捕获器会在 in 操作符中被调用。对应的反射 API 方法为 Reflect.has()。</p>
<pre><code class="language-js">const myTarget = {}
const proxy = new Proxy(myTarget, {
  has(target, property) {
    console.log('has()')
    return Reflect.has(...arguments)
  },
})
'foo' in proxy // has()
</code></pre>
<ol>
<li>返回值
has()必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作
<ul>
<li>property in proxy</li>
<li>property in Object.create(proxy)</li>
<li>with(proxy) {(property);}</li>
<li>Reflect.has(proxy, property)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
<li>property：引用的目标对象上的字符串键属性。</li>
</ul>
</li>
<li>捕获器不变式
如果 target.property 存在且不可配置，则处理程序必须返回 true。
如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true。</li>
</ol>
<h3 id="15-defineproperty"><a class="header" href="#15-defineproperty">1.5 defineProperty()</a></h3>
<p>defineProperty()捕获器会在 Object.defineProperty()中被调用。对应的反射 API 方法为</p>
<pre><code class="language-js">Reflect.defineProperty()。
const myTarget = {};
const proxy = new Proxy(myTarget, {
defineProperty(target, property, descriptor) {
console.log('defineProperty()');
return Reflect.defineProperty(...arguments)
}
});
Object.defineProperty(proxy, 'foo', { value: 'bar' });// defineProperty()
</code></pre>
<ol>
<li>返回值
defineProperty()必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作
<ul>
<li>Object.defineProperty(proxy, property, descriptor)</li>
<li>Reflect.defineProperty(proxy, property, descriptor)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
<li>property：引用的目标对象上的字符串键属性。</li>
<li>descriptor：包含可选的 enumerable、 configurable、 writable、 value、 get 和 set 定义的对象。</li>
</ul>
</li>
<li>捕获器不变式
如果目标对象不可扩展，则无法定义属性。
如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。
如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。</li>
</ol>
<h3 id="16-getownpropertydescriptor"><a class="header" href="#16-getownpropertydescriptor">1.6 getOwnPropertyDescriptor()</a></h3>
<p>getOwnPropertyDescriptor()捕获器会在 Object.getOwnPropertyDescriptor()中被调用。对应的反射 API 方法为 Reflect.getOwnPropertyDescriptor()。</p>
<pre><code class="language-js">const myTarget = {}
const proxy = new Proxy(myTarget, {
  getOwnPropertyDescriptor(target, property) {
    console.log('getOwnPropertyDescriptor()')
    return Reflect.getOwnPropertyDescriptor(...arguments)
  },
})
Object.getOwnPropertyDescriptor(proxy, 'foo') // getOwnPropertyDescriptor()
</code></pre>
<ol>
<li>返回值
getOwnPropertyDescriptor()必须返回对象，或者在属性不存在时返回 undefined。</li>
<li>拦截的操作
<ul>
<li>Object.getOwnPropertyDescriptor(proxy, property)</li>
<li>Reflect.getOwnPropertyDescriptor(proxy, property)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
<li>property：引用的目标对象上的字符串键属性。</li>
</ul>
</li>
<li>捕获器不变式
如果自有的 target.property 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。
如果自有的 target.property 存在且可配置，则处理程序必须返回表示该属性可配置的对象。
如果自有的 target.property 存在且 target 不可扩展，则处理程序必须返回一个表示该属性存在的对象。
如果 target.property 不存在且 target 不可扩展，则处理程序必须返回 undefined 表示该属性不存在。
如果 target.property 不存在，则处理程序不能返回表示该属性可配置的对象。</li>
</ol>
<h3 id="17-deleteproperty"><a class="header" href="#17-deleteproperty">1.7 deleteProperty()</a></h3>
<p>deleteProperty()捕获器会在 delete 操作符中被调用。对应的反射 API 方法为 Reflect.deleteProperty()。</p>
<pre><code class="language-js">const myTarget = {}
const proxy = new Proxy(myTarget, {
  deleteProperty(target, property) {
    console.log('deleteProperty()')
    return Reflect.deleteProperty(...arguments)
  },
})
delete proxy.foo // deleteProperty()
</code></pre>
<ol>
<li>返回值
deleteProperty()必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作
<ul>
<li>delete proxy.property</li>
<li>delete proxy[property]</li>
<li>Reflect.deleteProperty(proxy, property)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
<li>property：引用的目标对象上的字符串键属性。</li>
</ul>
</li>
<li>捕获器不变式
如果自有的 target.property 存在且不可配置，则处理程序不能删除这个属性。</li>
</ol>
<h3 id="18-ownkeys"><a class="header" href="#18-ownkeys">1.8 ownKeys()</a></h3>
<p>ownKeys()捕获器会在 Object.keys()及类似方法中被调用。对应的反射 API 方法为 Reflect.ownKeys()。</p>
<pre><code class="language-js">const myTarget = {}
const proxy = new Proxy(myTarget, {
  ownKeys(target) {
    console.log('ownKeys()')
    return Reflect.ownKeys(...arguments)
  },
})
Object.keys(proxy) // ownKeys()
</code></pre>
<ol>
<li>返回值
ownKeys()必须返回包含字符串或符号的可枚举对象。</li>
<li>拦截的操作
<ul>
<li>Object.getOwnPropertyNames(proxy)</li>
<li>Object.getOwnPropertySymbols(proxy)</li>
<li>Object.keys(proxy)</li>
<li>Reflect.ownKeys(proxy)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
</ul>
</li>
<li>捕获器不变式
返回的可枚举对象必须包含 target 的所有不可配置的自有属性。
如果 target 不可扩展，则返回可枚举对象必须准确地包含自有属性键。</li>
</ol>
<h3 id="19-getprototypeof"><a class="header" href="#19-getprototypeof">1.9 getPrototypeOf()</a></h3>
<p>getPrototypeOf()捕获器会在 Object.getPrototypeOf()中被调用。对应的反射 API 方法为 Reflect.getPrototypeOf()。</p>
<pre><code class="language-js">const myTarget = {}
const proxy = new Proxy(myTarget, {
  getPrototypeOf(target) {
    console.log('getPrototypeOf()')
    return Reflect.getPrototypeOf(...arguments)
  },
})
Object.getPrototypeOf(proxy) // getPrototypeOf()
</code></pre>
<ol>
<li>返回值
getPrototypeOf()必须返回对象或 null。</li>
<li>拦截的操作
<ul>
<li>Object.getPrototypeOf(proxy)</li>
<li>Reflect.getPrototypeOf(proxy)</li>
<li><code>proxy.__proto__</code></li>
<li>Object.prototype.isPrototypeOf(proxy)</li>
<li>proxy instanceof Object</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
</ul>
</li>
<li>捕获器不变式
如果 target 不可扩展，则 Object.getPrototypeOf(proxy)唯一有效的返回值就是 Object.getPrototypeOf(target)的返回值。</li>
</ol>
<h3 id="110-setprototypeof"><a class="header" href="#110-setprototypeof">1.10 setPrototypeOf()</a></h3>
<p>setPrototypeOf()捕获器会在 Object.setPrototypeOf()中被调用。对应的反射 API 方法为 Reflect.setPrototypeOf()。</p>
<pre><code class="language-js">const myTarget = {}
const proxy = new Proxy(myTarget, {
  setPrototypeOf(target, prototype) {
    console.log('setPrototypeOf()')
    return Reflect.setPrototypeOf(...arguments)
  },
})
Object.setPrototypeOf(proxy, Object) // setPrototypeOf()
</code></pre>
<ol>
<li>返回值
setPrototypeOf()必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作
<ul>
<li>Object.setPrototypeOf(proxy)</li>
<li>Reflect.setPrototypeOf(proxy)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
<li>prototype： target 的替代原型，如果是顶级原型则为 null。</li>
</ul>
</li>
<li>捕获器不变式
如果 target 不可扩展，则唯一有效的 prototype 参数就是 Object.getPrototypeOf(target)
的返回值。</li>
</ol>
<h3 id="111-isextensible"><a class="header" href="#111-isextensible">1.11 isExtensible()</a></h3>
<p>isExtensible()捕获器会在 Object.isExtensible()中被调用。对应的反射 API 方法为 Reflect.isExtensible()。</p>
<pre><code class="language-js">const myTarget = {}
const proxy = new Proxy(myTarget, {
  isExtensible(target) {
    console.log('isExtensible()')
    return Reflect.isExtensible(...arguments)
  },
})
Object.isExtensible(proxy) // isExtensible()
</code></pre>
<ol>
<li>返回值
isExtensible()必须返回布尔值，表示 target 是否可扩展。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作
<ul>
<li>Object.isExtensible(proxy)</li>
<li>Reflect.isExtensible(proxy)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
</ul>
</li>
<li>捕获器不变式
如果 target 可扩展，则处理程序必须返回 true。
如果 target 不可扩展，则处理程序必须返回 false。</li>
</ol>
<h3 id="112-preventextensions"><a class="header" href="#112-preventextensions">1.12 preventExtensions()</a></h3>
<p>preventExtensions()捕获器会在 Object.preventExtensions()中被调用。对应的反射 API 方法为 Reflect.preventExtensions()。</p>
<pre><code class="language-js">const myTarget = {}
const proxy = new Proxy(myTarget, {
  preventExtensions(target) {
    console.log('preventExtensions()')
    return Reflect.preventExtensions(...arguments)
  },
})
Object.preventExtensions(proxy) // preventExtensions()
</code></pre>
<ol>
<li>返回值
preventExtensions()必须返回布尔值，表示 target 是否已经不可扩展。返回非布尔值会被转
型为布尔值。</li>
<li>拦截的操作
<ul>
<li>Object.preventExtensions(proxy)</li>
<li>Reflect.preventExtensions(proxy)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
</ul>
</li>
<li>捕获器不变式
如果 Object.isExtensible(proxy)是 false，则处理程序必须返回 true。</li>
</ol>
<h3 id="113-apply"><a class="header" href="#113-apply">1.13 apply()</a></h3>
<p>apply()捕获器会在调用函数时中被调用。对应的反射 API 方法为 Reflect.apply()。</p>
<pre><code class="language-js">const myTarget = () =&gt; {}
const proxy = new Proxy(myTarget, {
  apply(target, thisArg, ...argumentsList) {
    console.log('apply()')
    return Reflect.apply(...arguments)
  },
})
proxy() // apply()
</code></pre>
<ol>
<li>返回值
返回值无限制。</li>
<li>拦截的操作
<ul>
<li>proxy(...argumentsList)</li>
<li>Function.prototype.apply(thisArg, argumentsList)</li>
<li>Function.prototype.call(thisArg, ...argumentsList)</li>
<li>Reflect.apply(target, thisArgument, argumentsList)</li>
</ul>
</li>
<li>捕获器处理程序参数
<ul>
<li>target：目标对象。</li>
<li>thisArg：调用函数时的 this 参数。</li>
<li>argumentsList：调用函数时的参数列表</li>
</ul>
</li>
<li>捕获器不变式
target 必须是一个函数对象。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="074-代理与反射-代理的常见使用场景"><a class="header" href="#074-代理与反射-代理的常见使用场景">07.4-代理与反射-代理的常见使用场景</a></h1>
<h2 id="一-跟踪属性访问"><a class="header" href="#一-跟踪属性访问">一 跟踪属性访问</a></h2>
<p>通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、被查询，把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：</p>
<pre><code class="language-js">const user = {
  name: 'Jake',
}

const proxy = new Proxy(user, {
  get(target, property, receiver) {
    console.log(`Getting ${property}`)
    return Reflect.get(...arguments)
  },
  set(target, property, value, receiver) {
    console.log(`Setting ${property}=${value}`)
    return Reflect.set(...arguments)
  },
})

proxy.name // Getting name
proxy.age = 27 // Setting age=27
</code></pre>
<h2 id="二-隐藏属性"><a class="header" href="#二-隐藏属性">二 隐藏属性</a></h2>
<p>代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举：</p>
<pre><code class="language-js">const hiddenProperties = ['foo', 'bar']
const targetObject = {
  foo: 1,
  bar: 2,
  baz: 3,
}
const proxy = new Proxy(targetObject, {
  get(target, property) {
    if (hiddenProperties.includes(property)) {
      return undefined
    } else {
      return Reflect.get(...arguments)
    }
  },
  has(target, property) {
    if (hiddenProperties.includes(property)) {
      return false
    } else {
      return Reflect.has(...arguments)
    }
  },
})

// get()
console.log(proxy.foo) // undefined
console.log(proxy.bar) // undefined
console.log(proxy.baz) // 3

// has()
console.log('foo' in proxy) // false
console.log('bar' in proxy) // false
console.log('baz' in proxy) // true
</code></pre>
<h2 id="三-属性验证"><a class="header" href="#三-属性验证">三 属性验证</a></h2>
<p>因为所有赋值操作都会触发 set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值，从而进行属性验证：</p>
<pre><code class="language-js">const target = {
  onlyNumbersGoHere: 0,
}
const proxy = new Proxy(target, {
  set(target, property, value) {
    if (typeof value !== 'number') {
      return false
    } else {
      return Reflect.set(...arguments)
    }
  },
})

proxy.onlyNumbersGoHere = 1
console.log(proxy.onlyNumbersGoHere) // 1
proxy.onlyNumbersGoHere = '2'
console.log(proxy.onlyNumbersGoHere) // 1
</code></pre>
<h2 id="四-函数与构造函数参数验证"><a class="header" href="#四-函数与构造函数参数验证">四 函数与构造函数参数验证</a></h2>
<p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：</p>
<pre><code class="language-js">function median(...nums) {
  return nums.sort()[Math.floor(nums.length / 2)]
}

const proxy = new Proxy(median, {
  apply(target, thisArg, argumentsList) {
    for (const arg of argumentsList) {
      if (typeof arg !== 'number') {
        throw 'Non-number argument provided'
      }
    }
    return Reflect.apply(...arguments)
  },
})
console.log(proxy(4, 7, 1)) // 4
console.log(proxy(4, '7', 1)) // Error: Non-number argument provided
</code></pre>
<p>类似地，可以要求实例化时必须给构造函数传参：</p>
<pre><code class="language-js">class User {
  constructor(id) {
    this.id = id
  }
}
const proxy = new Proxy(User, {
  construct(target, argumentsList, newTarget) {
    if (argumentsList[0] === undefined) {
      throw 'User cannot be instantiated without id'
    } else {
      return Reflect.construct(...arguments)
    }
  },
})
new proxy(1)
new proxy() // Error: User cannot be instantiated without id
</code></pre>
<h2 id="五-数据绑定"><a class="header" href="#五-数据绑定">五 数据绑定</a></h2>
<p>通过代理可以把运行时原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。</p>
<p>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：</p>
<pre><code class="language-js">const userList = []
class User {
  constructor(name) {
    this.name_ = name
  }
}
const proxy = new Proxy(User, {
  construct() {
    const newUser = Reflect.construct(...arguments)
    userList.push(newUser)
    return newUser
  },
})
new proxy('John')
new proxy('Jacob')
new proxy('Jingleheimerschmidt')
console.log(userList) // [User {}, User {}, User{}]
</code></pre>
<p>另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：</p>
<pre><code class="language-js">const userList = []
function emit(newValue) {
  console.log(newValue)
}
const proxy = new Proxy(userList, {
  set(target, property, value, receiver) {
    const result = Reflect.set(...arguments)
    if (result) {
      emit(Reflect.get(target, property, receiver))
    }
    return result
  },
})
proxy.push('John') // John
proxy.push('Jacob') // Jacob
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附-es-规范"><a class="header" href="#附-es-规范">附-ES 规范</a></h1>
<h2 id="一-es2017"><a class="header" href="#一-es2017">一 ES2017</a></h2>
<h3 id="11-objectvalues-objectentries"><a class="header" href="#11-objectvalues-objectentries">1.1 Object.values Object.entries</a></h3>
<h3 id="12-asyncawait"><a class="header" href="#12-asyncawait">1.2 async/await</a></h3>
<h2 id="二-es2018"><a class="header" href="#二-es2018">二 ES2018</a></h2>
<h3 id="21-对象支持扩展"><a class="header" href="#21-对象支持扩展">2.1 对象支持扩展</a></h3>
<h3 id="22-promisefinally"><a class="header" href="#22-promisefinally">2.2 Promise.finally</a></h3>
<h3 id="23-for-await"><a class="header" href="#23-for-await">2.3 for await</a></h3>
<h2 id="三-es2019"><a class="header" href="#三-es2019">三 ES2019</a></h2>
<h3 id="31-arrayflatarrayflatmap"><a class="header" href="#31-arrayflatarrayflatmap">3.1 Array.flat、Array.flatMap</a></h3>
<h3 id="32-objectfromentries"><a class="header" href="#32-objectfromentries">3.2 Object.fromEntries</a></h3>
<h3 id="33-stringtrimstart-stringtrimend"><a class="header" href="#33-stringtrimstart-stringtrimend">3.3 String.trimStart String.trimEnd</a></h3>
<h2 id="四-es2020"><a class="header" href="#四-es2020">四 ES2020</a></h2>
<h3 id="41-stringprototypematchall"><a class="header" href="#41-stringprototypematchall">4.1 String.prototype.matchAll</a></h3>
<h3 id="42-动态导入-dynamic-import"><a class="header" href="#42-动态导入-dynamic-import">4.2 动态导入 dynamic import</a></h3>
<h3 id="43-bigint"><a class="header" href="#43-bigint">4.3 Bigint</a></h3>
<h3 id="44-可选操作符-optional-chaining"><a class="header" href="#44-可选操作符-optional-chaining">4.4 可选操作符 Optional Chaining</a></h3>
<p>?运算符，也是链判断运算符，支持开发者读取深度嵌套在对象链中的属性，却不必验证每个属性都是否存在，引用为空时，返回 undefined：</p>
<pre><code class="language-js">const obj = {
  name: 'zs',
  info: {
    age: 14,
    sex: 1,
  },
}

console.log(obj.sex?)// undefined
console.log(obj.info?.school)// undefined
</code></pre>
<h3 id="45-空位操作符-nullish-coalescing"><a class="header" href="#45-空位操作符-nullish-coalescing">4.5 空位操作符 Nullish coalescing</a></h3>
<p>??操作符下，可以不想让 0、空字符串、false 当成假，只把 null 、undefined 当成假：</p>
<pre><code class="language-js">console.log(false ?? true) // false
console.log(0 ?? 1) // 0
console.log(undefined ?? []) // []
</code></pre>
<h3 id="46-promiseallsettled"><a class="header" href="#46-promiseallsettled">4.6 Promise.allSettled</a></h3>
<h3 id="47-globalthis"><a class="header" href="#47-globalthis">4.7 globalThis</a></h3>
<pre><code class="language-js">// ES2020 前使用下列封装方法获取环境的this
const getGlobalThis = () =&gt; {
  // webworker
  if (typeof self !== 'undefined') return self

  // browser
  if (typeof window !== 'undefined') return window

  // node
  if (typeof global !== 'undefined') return global

  // js shell
  if (typeof this !== 'undefined') return this

  // 没找到
  throw new Error('unable to locate global object')
}
</code></pre>
<h3 id="48-模块命名空间导出"><a class="header" href="#48-模块命名空间导出">4.8 模块命名空间导出</a></h3>
<pre><code class="language-js">import * as utils from './util'
export { utils }
</code></pre>
<h2 id="五-es2021"><a class="header" href="#五-es2021">五 ES2021</a></h2>
<h3 id="51-stringprototypereplaceall"><a class="header" href="#51-stringprototypereplaceall">5.1 String.prototype.replaceAll</a></h3>
<h3 id="52-逻辑运算符---"><a class="header" href="#52-逻辑运算符---">5.2 逻辑运算符 ||= &amp;&amp;= ??=</a></h3>
<pre><code class="language-js">a ||= b // 等价于 a || (a = b)
a &amp;&amp;= b // 等价于 a &amp;&amp; (a = b)
a ??= b // 等价于 a ?? (a = b)
</code></pre>
<h3 id="53-weaksetweakmap"><a class="header" href="#53-weaksetweakmap">5.3 WeakSet、WeakMap</a></h3>
<h3 id="53-数字分隔符"><a class="header" href="#53-数字分隔符">5.3 数字分隔符</a></h3>
<p>数字分隔符便于阅读，如：</p>
<pre><code class="language-js">100000000000000
100_000_000_000_000
</code></pre>
<h3 id="54-promiseany"><a class="header" href="#54-promiseany">5.4 Promise.any</a></h3>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-javascript-在-html-中的使用"><a class="header" href="#011-javascript-在-html-中的使用">01.1-JavaScript 在 HTML 中的使用</a></h1>
<h2 id="一-script-标签标签"><a class="header" href="#一-script-标签标签">一 script 标签标签</a></h2>
<h3 id="11-在-html-中使用-javascript"><a class="header" href="#11-在-html-中使用-javascript">1.1 在 HTML 中使用 JavaScript</a></h3>
<p>要在 HTML 文档中使用 JavaScript，需要插入 <code>&lt;script&gt;</code> 标签，有三种书写方式：</p>
<pre><code class="language-html">&lt;!-- 直接在 html 网页中书写代码，HelloWorld 中使用了内嵌式 --&gt;
&lt;script&gt;
  console.log('Hello World!')
&lt;/script&gt;

&lt;!-- 推荐方式。代码位于专门的 js 文件，由脚本标签引入 --&gt;
&lt;script src=&quot;./hello.js&quot;&gt;&lt;/script&gt;

&lt;!-- 极度不推荐。代码直接书写于 html 标签中 --&gt;
&lt;button onclick=&quot;fn()&quot;&gt;登录&lt;/button&gt;
</code></pre>
<p>一般推荐使用外联式，因为这样可以显著<strong>提升代码的可维护性</strong>，并能<strong>让 JS 文件在浏览器中获得缓存</strong>（多个页面用到了同一个 JS 文件时，JS 文件只需要下载一次！）。</p>
<p>注意：script 标签中的代码不能出现 <code>&lt;/script&gt;</code>，需要转义为：<code>&lt;\/script&gt;</code></p>
<h3 id="12-script-标签属性"><a class="header" href="#12-script-标签属性">1.2 script 标签属性</a></h3>
<p>script 标签常用的属性有：</p>
<ul>
<li>src：表示要包含的外部文件</li>
<li>type：表示脚本语言类型（MIME），默认都是 <code>type=&quot;application/javascript&quot;</code>，该属性已经替代了 <code>language</code> 属性，如果值为 <code>application/module</code> 则代表代码是 ES6 模块，代码中可以出现 import 和 export 关键字</li>
<li>crossorigin：可选。默认值为 <code>anonymous</code>，即不使用 CORS，值为 <code>use-credentials</code> 表示需要设置凭据，即出站请求会包含凭据</li>
<li>integrity：可选。允许比对接收到的资源和指定的加密签名，以验证子资源完整性，若不匹配，则页面报错。该属性常用于确保 CDN 不会提供恶意内容</li>
</ul>
<p>script 上设置文件加载行为的属性（只对外部文件有效）：defer、async。</p>
<ul>
<li>defer：可选，表示立即下载脚本，但脚本延迟到文档解析、显示后再执行。写法：<code>defer=&quot;defer&quot;</code>，H5 中简写为：<code>defer</code>。</li>
<li>async：可选，表示立即下载脚本，且不阻止其他页面动作如：下载资源、等待其他脚本加载。这是 H5 新增属性，写法：<code>sync=sync</code></li>
</ul>
<p>其他废弃或无用属性有：<code>charset</code>、<code>language</code>，浏览器几乎不会在意这些值。</p>
<p>贴士：src 属性指定的路径文件内容会以 GET 请求结果形式返回，且该请求不受浏览器的同源策略影响，这是 script 标签还有一个极其强大的能力，可以用来加载外部代码，但是我们必须确保域是自己的，或者域是可信来源，<code>integrity</code> 属性就是用来防范这个问题的。</p>
<p>页面中也可以插入多个 script 标签，当没有 <code>defer</code>、<code>async</code> 属性限制时，这些脚本代码会被从上到下解析，下一个脚本必须等待上一个脚本执行完毕后才会执行，依次类推。</p>
<h2 id="二-script-脚本的执行"><a class="header" href="#二-script-脚本的执行">二 script 脚本的执行</a></h2>
<h3 id="21-script-元素的位置"><a class="header" href="#21-script-元素的位置">2.1 script 元素的位置</a></h3>
<p>在传统做法中，所有的 script 元素都放在页面的 head 元素中，如下所示：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;./demo1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./demo2.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在 head 中引入 JS 外部文件，将会导致必须等到所有 JS 代码都被下载解析、执行完成后，才能呈现页面内容（body 标签），这样会严重影响用户体验，如果脚本文件过大，会导致网页打开时候出现一片空白。</p>
<p>为了避免上述现象，可以将 script 元素放在页面的底部：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;

  &lt;body&gt;
    &lt;script src=&quot;./demo1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./demo2.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="22-defer-延迟脚本"><a class="header" href="#22-defer-延迟脚本">2.2 defer 延迟脚本</a></h3>
<p>defer 属性告诉浏览器立即下载 JS 外部文件并延迟执行，脚本会被延迟到整个页面都解析完毕后再运行，这样做不会改变页面的结构：</p>
<pre><code class="language-html">&lt;!--XHTML--&gt;
&lt;script src=&quot;./demo1.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;
&lt;!--HTML5--&gt;
&lt;script src=&quot;./demo2.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
<p>此时这个 script 元素即使在 head 元素中，脚本的执行仍然需要等到网页完全呈现后才会执行。</p>
<p>在 HTML5 规范中，上述 2 个脚本会在 DOMContentLoaded 事件触发前按照顺序执行，但是现实往往不尽人意，他们的执行顺序并不固定，也并不一定都在 DOMContentLoaded 事件触发前执行，所以在使用延迟脚本时，推荐 html 页面中只包含一个延迟脚本。</p>
<h3 id="23-async-异步脚本"><a class="header" href="#23-async-异步脚本">2.3 async 异步脚本</a></h3>
<p><strong>async 属性的作用是告诉浏览器不必等待脚本的下载、执行，可以直接加载页面！</strong></p>
<p>异步脚本 async 属性是 H5 中的规范，该属性与 defer 类似，会告诉浏览器立即下载文件，但是 async 脚本用于不让页面等待两个脚本的下载执行，同时也不保证执行的顺序。所以如果要引入多个异步脚本，要确保脚本之间没有依赖关系！也建议异步脚本不要在加载期间修改 DOM。</p>
<pre><code class="language-html">&lt;!--XHTML--&gt;
&lt;script src=&quot;./demo1.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;
&lt;!--HTML5--&gt;
&lt;script src=&quot;./demo2.js&quot; async&gt;&lt;/script&gt;
</code></pre>
<p>async 脚本会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发前、后都有可能执行。</p>
<h2 id="三-动态加载脚本"><a class="header" href="#三-动态加载脚本">三 动态加载脚本</a></h2>
<p>利用 DOM 的 API，可以动态插入一个脚本：</p>
<pre><code class="language-js">let script = document.createElement('script')
script.src = 'demo.js'
// 兼容设置：防止浏览器不支持async
script.async = false
//追加脚本
document.head.appendChild(script)
</code></pre>
<p>浏览器的预加载机制无法识别以这种方式获取到的资源，如果影响到了性能，则可以在文档头部显式声明：</p>
<pre><code class="language-html">&lt;link rel=&quot;preload&quot; href=&quot;demo.js&quot; /&gt;
</code></pre>
<h2 id="四-noscript-标签"><a class="header" href="#四-noscript-标签">四 noscript 标签</a></h2>
<p>浏览器目前都已支持 JS，所以 noscript 标签的使用场景基本没有了，但是如果浏览器禁用了 JS，则该标签仍然有用，此时浏览器会渲染该标签内的内容：</p>
<pre><code class="language-html">&lt;noscript&gt; &lt;p&gt;浏览器不支持JavaScript&lt;/p&gt;&lt;/noscript&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-dom-与-bom-概述"><a class="header" href="#021-dom-与-bom-概述">02.1-DOM 与 BOM 概述</a></h1>
<h2 id="一-理解浏览器内的-javascript"><a class="header" href="#一-理解浏览器内的-javascript">一 理解浏览器内的 JavaScript</a></h2>
<p>ECMAScript 是 JavaScript 的语法核心，但是仅仅有语法，没有一些运行时平台的接口帮助，JS 也只是一个语言玩具。作为 JavaScript 最主要的运行时，浏览器为 JavaScript 提供了两大对象 DOM、BOM，让 JavaScript 能够游刃有余地操作浏览器相关特性。如图所示：</p>
<p><img src="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/javascript/02-1-01-01.svg" alt="JavaScript 组成" /></p>
<p>从图中看出，JavaScript 包含三个方面：</p>
<ul>
<li>ECMAScript：JavaScript 语法标准，如：类型、关键字、基本对象等，有 ES5、ES6(即 ES2015)、ES7(即 ES2016)，后续皆以年代为规范的名称</li>
<li>DOM：文档对象模型（Document Object Model），JavaScript 操作网页内容的 API</li>
<li>BOM：浏览器对象模型（Browser Object Model），JavaScript 操作浏览器的 API</li>
</ul>
<p>但由于浏览器厂商、版本的不同，DOM 和 BOM 对象的一些 API 往往使用方式不同，或者不兼容，不过好在现在 DOM 和 BOM 已经被纳入 HTML5 规范，相信未来会逐渐统一。</p>
<blockquote>
<p>HTML5：HTML5 并不仅仅是 HTML4 的升级改进，而是设定了专门针对 Web 平台 API 的一系列规范，包括：视频、音频、图像、动画以及与设备的交互，将 Web 带入了一个成熟的应用平台。</p>
</blockquote>
<h2 id="二-dom-与-bom"><a class="header" href="#二-dom-与-bom">二 DOM 与 BOM</a></h2>
<h3 id="21-dom-概念"><a class="header" href="#21-dom-概念">2.1 DOM 概念</a></h3>
<p>HTML 加载完毕后，渲染引擎会在内存中把 HTML 文档，生成一个 DOM 树，即文档对象模型（DOM，Document Object Model）。DOM 是针对 HTML、XML 的 API 接口，描绘了一个层次化的树，允许开发人员对其进行增删改查。</p>
<p>书写示例：</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;!-- script 的位置推荐位于 body 标签的最后位置 --&gt;
  &lt;script&gt;
    // 入口函数：页面的结构、样式、节点等加载完毕后才去执行函数体。
    window.onload = function () {
      console.log('hello DOM')
      console.log(document) // 查看 document 文档对象
    }
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>上述示例中输出的 document 对象，其实就是整个 HTML 文档，如图所示：</p>
<p><img src="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/dom/01.png" alt="dom" /></p>
<p>注意：DOM 中所有的 API 都挂载在了 <code>window</code> 这个对象上，为了方便，window 可以忽略不写。</p>
<p>DOM 的标准从 DOM1 已经到了 DOM4，不过 W3C 也不再按照 Level 来维护 DOM 了，而是作为 DOM Living Strandard 来维护，主要维护的子集有：</p>
<ul>
<li>DOM Core：在 DOM1 核心部分的基础上，为节点增加方法和属性。</li>
<li>DOM Views：定义基于样式信息的不同视图。</li>
<li>DOM Events：定义通过事件实现 DOM 文档交互。</li>
<li>DOM Style：定义以编程方式访问和修改 CSS 样式的接口。</li>
<li>DOM Traversal and Range：新增遍历 DOM 文档及选择文档内容的接口。</li>
<li>DOM HTML：在 DOM1 HTML 部分的基础上，增加属性、方法和新接口。</li>
<li>DOM Mutation Observers：DOM4 级模块，定义基于 DOM 变化触发回调的接口。</li>
</ul>
<p>当然，除了 DOMCore 和 DOM HTML 接口，一些语言也发布的独立的 DOM 标准，如：SVG、SMIL 等。</p>
<h2 id="22-bom-概念"><a class="header" href="#22-bom-概念">2.2 BOM 概念</a></h2>
<p>BOM 是浏览器为开发者提供的 JavaScript 浏览器对象模型（Browser Object Modle），BOM 与网页无关，主要针对浏览器窗口、子窗口（frame）。</p>
<p>BOM 提供的一些常见操作有：</p>
<ul>
<li>弹出新浏览器窗口</li>
<li>移动、缩放、关闭浏览器窗口</li>
<li>navigator 对象：提供浏览器本身的信息</li>
<li>location 对象：提供加载页面的信息</li>
<li>screen 对象：提供关于用户屏幕分辨率的信息</li>
<li>performance 对象：提供浏览器内存占用、时间统计等信息</li>
<li>支持 cookie</li>
<li>支持其他自定义对象，如：XMLHttpRequest 等</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-bom-核心对象-window"><a class="header" href="#031-bom-核心对象-window">03.1-BOM-核心对象 window</a></h1>
<h2 id="一-window-对象概述"><a class="header" href="#一-window-对象概述">一 window 对象概述</a></h2>
<p>BOM 的核心对象是 window，代表了浏览器的一个实例，也是浏览器的顶级对象，包括 DOM 的实例 document 也挂载在该对象上。</p>
<p>window 对象有两重身份：</p>
<ul>
<li>ECMAScript 中的 Global 对象</li>
<li>浏览器窗口的 JS 接口</li>
</ul>
<p>window 对象上挂载的主要对象有：document、location、navigation、screen、history。在书写挂载在 window 上的成员时，window 可以省略。</p>
<h2 id="二-window-的基本使用"><a class="header" href="#二-window-的基本使用">二 window 的基本使用</a></h2>
<h3 id="21-作为-global-作用域"><a class="header" href="#21-作为-global-作用域">2.1 作为 Global 作用域</a></h3>
<p>由于 window 是 ECMAScript 的 Glonal 对象，所以 var 声明的全局变量、函数都会成为 window 对象的属性和方法：</p>
<pre><code class="language-js">var age = 29

function sayAge() {
  alert(this.age)
}

console.log(window.age) //29
window.sayAge() //29
</code></pre>
<p>let/const 声明的变量不会添加给全局对象：</p>
<pre><code class="language-js">let age = 20
console.log(window.age) //undefined
</code></pre>
<p>访问未声明变量会报错：</p>
<pre><code class="language-js">var newVal = oldVal
console.log(olVal)
</code></pre>
<h3 id="22-窗口关系与-frame"><a class="header" href="#22-窗口关系与-frame">2.2 窗口关系与 frame</a></h3>
<p>window 对象上绑定了一些属性，可以访问与自己有关的窗口：</p>
<ul>
<li>window.self：自己</li>
<li>window.top：最外层的窗口，即浏览器窗口本身</li>
<li>window.parent：当前窗口的父窗口</li>
</ul>
<p>如果页面中包含框架，则每个框架都有自己的 window 对象，并且保存在 frames 集合中：</p>
<pre><code class="language-js">&lt;frameset rows=&quot;160,*&quot;&gt;
    &lt;frame src=&quot;frame.htm&quot; name=&quot;topFrame&quot;&gt;
    &lt;frameset cols=&quot;50%,50%&quot;&gt;
        &lt;frame src=&quot;anotherframe.htm&quot; name=&quot;leftFrame&quot;&gt;
        &lt;frame src=&quot;yetanotherframe.htm&quot; name=&quot;rightFrame&quot;&gt;
    &lt;/frameset&gt;
&lt;/frameset&gt;
</code></pre>
<p>上述页面可以通过
window.frames[0] 或者 window.frames[&quot;topFrame&quot;] 来引用上方的框架。</p>
<h3 id="23-window-成员的删除"><a class="header" href="#23-window-成员的删除">2.3 window 成员的删除</a></h3>
<p>在 window 上定义的属性可以使用 delete 删除，但是直接定义的全局变量不能使用 delete 删除。</p>
<pre><code class="language-js">var age = 29
window.color = 'red'

//在 IE 8 中抛出错误，在其他所有浏览器中都返回 false
delete window.age

//在 IE 8 中抛出错误，在其他所有浏览器中都返回 true
delete window.color //returns true

alert(window.age) //29
alert(window.color) //undefined
</code></pre>
<p>使用 var 语句添加的 window 属性有一个名为 [[Configurable]] 的特性，这个特性的值被设置为 false，因此这样定义的属性不可以通过 delete 操作符删除，所以 IE8 中使用 delete 删除 window 属性的语句会抛出错误，IE9 及更高版本不会抛出错误。</p>
<h2 id="三-window-对象的常见事件"><a class="header" href="#三-window-对象的常见事件">三 window 对象的常见事件</a></h2>
<h3 id="31-窗口加载事件-load"><a class="header" href="#31-窗口加载事件-load">3.1 窗口加载事件 load</a></h3>
<p>我们推荐 <code>&lt;script&gt;</code> 标签卸载页面的底部，这是因为网页是从上往下加载的，DOM 对象未加载完毕，就直接在脚本内操作 DOM 会造成异常。</p>
<p>但是 window 对象提供了 onload 事件，即页面加载完毕触发该事件，可以让脚本代码的位置更灵活随意，但是相应的，所有的脚本代码就需要在该事件的回调函数中书写了：</p>
<pre><code class="language-js">// onlaod：加载完图像、脚本、css 等后调用
window.onload = function () {
  // 当前页面的所有业务代码
}
</code></pre>
<p>注意：load 事件只能写一次，多次书写只会以最后一个 onload 事件的回调函数为准。如果不想受到这个限制，可以使用 addEventListener。</p>
<h3 id="32-dom-加载事件-domcontentloaded"><a class="header" href="#32-dom-加载事件-domcontentloaded">3.2 DOM 加载事件 DOMContentLoaded</a></h3>
<p>DOMContentLoaded 事件只会在 DOM 加载完成时触发，不包括 CSS、图片、flash 等。可以用于图片很多的页面（load 事件触发慢）。</p>
<p>注意：该事件不支持 IE8。</p>
<h3 id="33-窗口大小改变事件-resize"><a class="header" href="#33-窗口大小改变事件-resize">3.3 窗口大小改变事件 resize</a></h3>
<pre><code class="language-js">widnow.onresize = function () {}
</code></pre>
<h2 id="四-window-常见成员"><a class="header" href="#四-window-常见成员">四 window 常见成员</a></h2>
<h3 id="41-定时器-settimeout-settimeinterval"><a class="header" href="#41-定时器-settimeout-settimeinterval">4.1 定时器 setTimeout setTimeinterval</a></h3>
<p>setTimeout：多少毫秒后执行参数函数</p>
<pre><code class="language-js">setTimeout(() =&gt; {}, 1000)
</code></pre>
<p>setTimeinterval：每多少毫秒执行一次参数函数</p>
<pre><code class="language-js">setTimeinterval(() =&gt; {}, 1000)
</code></pre>
<p>贴士：依据常理，参数函数支持函数名的方式传入，但是这里还可以传入 <code>函数名 ()</code> 的形式，笔者匪夷所思，更不提倡。</p>
<p>定时器可以以表达式方式进行取名，用于区分不同的定时器，也能更好的实现定时器的清除：</p>
<pre><code class="language-js">let timer = setTimeout(() =&gt; {}, 1000)
clearTimeout(timer) // 对应的还有 clearInterval()
</code></pre>
<blockquote>
<p>回调函数：类似定时器里的参数函数，只有在执行了一系列操作后，才会调用的函数。</p>
</blockquote>
<h3 id="42-console"><a class="header" href="#42-console">4.2 console</a></h3>
<p>控制台的三个打印方法：</p>
<pre><code class="language-js">console.log('打印日志')
console.warn('打印警告')
console.error('打印错误')
</code></pre>
<h3 id="43-open-打开窗口"><a class="header" href="#43-open-打开窗口">4.3 open() 打开窗口</a></h3>
<pre><code class="language-js">//等同于&lt; a href=&quot;http://www.wrox.com&quot; target=&quot;topFrame&quot;&gt;&lt;/a&gt;
window.open('http://www.wrox.com/', 'topFrame')
</code></pre>
<h3 id="44-系统对话框"><a class="header" href="#44-系统对话框">4.4 系统对话框</a></h3>
<p>下列三个方法可以让浏览器调用系统对话框向用户显示消息：</p>
<ul>
<li>alert()：弹出警告框</li>
<li>confirm()：弹出确认框</li>
<li>prompt()：弹出提示输入框</li>
</ul>
<h3 id="45-窗口位置-screenleft-和-screentop"><a class="header" href="#45-窗口位置-screenleft-和-screentop">4.5 窗口位置 screenLeft 和 screenTop</a></h3>
<p>大部分浏览器都提供了 screenLeft 和 screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。火狐在 screenX 和 screenY 属性提供相同的窗口位置信息。</p>
<p>使用下列兼容代码可以跨浏览器取得窗口左边和上边的位置：</p>
<pre><code class="language-js">let leftPos =
  typeof window.screenLeft == 'number' ? window.screenLeft : window.screenX

let topPos =
  typeof window.screenTop == 'number' ? window.screenTop : window.screenY
</code></pre>
<p>IE 中，screenLeft 和 screenTop 中保存的是从屏幕左边和上边到由 window 对象表示的页面可见区域的距离。换句话说，如果 window 对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即 y 轴坐标为 0，那么 screenTop 的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在 Chrome、Firefox 和 Safari 中，screenY 或 screenTop 中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的 y 轴坐标为 0 时返回 0。</p>
<p>Firefox、Safari 和 Chrome 始终返回页面中每个框架的 top.screenX 和 top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于 window 对象使用 screenX 和 screenY 每次也都会返回相同的值。而 IE 和 Opera 则会给出框架相对于屏幕边界的精确坐标值。</p>
<p>所以无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。moveTo() 和 moveBy() 方法有可能将窗口精确地移动到一个新位置：</p>
<pre><code class="language-js">//将窗口移动到屏幕左上角
window.moveTo(0, 0)
//将窗向下移动 100 像素
window.moveBy(0, 100)
//将窗口移动到 (200,300)
window.moveTo(200, 300)
//将窗口向左移动 50 像素
window.moveBy(-50, 0)
</code></pre>
<p>注意：这两个方法可能会被浏览器禁用，在 Opera 和 IE 7（及更高版本）中默认就是禁用的。另外，这两个方法都不适用于框架，只能对最外层的 window 对象使用。</p>
<h3 id="46-窗口大小"><a class="header" href="#46-窗口大小">4.6 窗口大小</a></h3>
<p>所有现代浏览器都支持 4 个属性：</p>
<ul>
<li>返回浏览器窗口自身大小： outerWidth 、 outerHeight</li>
<li>返回浏览器窗口中页面视口大小（不包含浏览器边框和工具栏）：innerWidth、 innerHeight</li>
</ul>
<p>document.documentElement.clientWidth 和 document.documentElement.clientHeight 返回页面视口的宽度和高度。</p>
<p>浏览器窗口自身的精确尺寸不好确定，但可以确定页面视口的大小，如下所示：</p>
<pre><code class="language-js">let pageWidth = window.innerWidth,
  pageHeight = window.innerHeight
if (typeof pageWidth != 'number') {
  if (document.compatMode == 'CSS1Compat') {
    pageWidth = document.documentElement.clientWidth
    pageHeight = document.documentElement.clientHeight
  } else {
    pageWidth = document.body.clientWidth
    pageHeight = document.body.clientHeight
  }
}
</code></pre>
<p>这里，先将 pageWidth 和 pageHeight 的值分别设置为 window.innerWidth 和 window.innerHeight。然后，检查 pageWidth 是不是一个数值，如果不是则通过 document.compatMode 来检查页面是否处于标准模式。如果是，则使用 document.documentElement.clientWidth 和 document.documentElement.clientHeight；否则，就使用 document.body.clientWidth 和 document.body.clientHeight。</p>
<p>在移动设备上， window.innerWidth 和 window.innerHeight 返回视口的大小，也就是屏幕上页面可视区域的大小。 Mobile Internet Explorer 支持这些属性，但在 document.documentElement.clientWidth 和 document.documentElement.clientHeight 中提供了相同的信息。在放大或缩小页面时，这些值也会相应变化。</p>
<p>在其他移动浏览器中， document.documentElement.clientWidth 和 document.documentElement.clientHeight 返回的布局视口的大小，即渲染页面的实际大小。布局视口是相对于可见视口的概念，可见视口只能显示整个页面的一小部分 。 Mobile Internet Explorer 把布局视口的信息保存在 document.body.clientWidth 和 document.body.clientHeight 中。在放大或缩小页面时，这些值也会相应变化。</p>
<p>可以使用 resizeTo()和 resizeBy()方法调整窗口大小。这两个方法都接收两个参数， resizeTo()接收新的宽度和高度值，而 resizeBy()接收宽度和高度各要缩放多少。下面看个例子：</p>
<pre><code class="language-js">// 缩放到 100×100
window.resizeTo(100, 100)
// 缩放到 200×150
window.resizeBy(100, 50)
// 缩放到 300×300
window.resizeTo(300, 300)
</code></pre>
<p>与移动窗口的方法一样，缩放窗口的方法可能会被浏览器禁用，而且在某些浏览器中默认是禁用的。同样，缩放窗口的方法只能应用到最上层的 window 对象。</p>
<h3 id="47-视口位置"><a class="header" href="#47-视口位置">4.7 视口位置</a></h3>
<p>浏览器窗口尺寸通常无法满足完整显示整个页面，为此用户可以通过滚动在有限的视口中查看文档。度量文档相对于视口滚动距离的属性有两对，返回相等的值： window.pageXoffset/window.scrollX 和 window.pageYoffset/window.scrollY。</p>
<p>可以使用 scroll()、 scrollTo()和 scrollBy()方法滚动页面。这 3 个方法都接收表示相对视口距离的 x 和 y 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。</p>
<pre><code class="language-js">// 相对于当前视口向下滚动 100 像素
window.scrollBy(0, 100)
// 相对于当前视口向右滚动 40 像素
window.scrollBy(40, 0)
// 滚动到页面左上角
window.scrollTo(0, 0)
// 滚动到距离屏幕左边及顶边各 100 像素的位置
window.scrollTo(100, 100)
</code></pre>
<p>这几个方法也都接收一个 ScrollToOptions 字典，除了提供偏移值，还可以通过 behavior 属性告诉浏览器是否平滑滚动。</p>
<pre><code class="language-js">// 正常滚动
window.scrollTo({
  left: 100,
  top: 100,
  behavior: 'auto',
})
// 平滑滚动
window.scrollTo({
  left: 100,
  top: 100,
  behavior: 'smooth',
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>#03.2-BOM-BOM 的常见对象</p>
<h2 id="一-location-对象"><a class="header" href="#一-location-对象">一 location 对象</a></h2>
<h3 id="11location-基础使用"><a class="header" href="#11location-基础使用">1.1location 基础使用</a></h3>
<p>location 提供了当前窗口加载的文档信息以及导航功能，它既是 window 的属性，也是 document 的属性。也就是说，window.location 和 document.location 指向同一个对象。</p>
<p>location 上常用的成员：</p>
<pre><code class="language-js">location.host //&quot;www.demo.com:80&quot;服务器名及端口号
location.hostname //&quot;www.demo.com&quot;服务器名
location.href //&quot;http:/www.demo.com&quot;URL的触发地址
location.origin //&quot;http://www.demo.com&quot;URL的只读源地址
location.pathname ///user/order
location.search //&quot;?name=lisi&quot;
location.hash //&quot;#contents&quot;
location.assign() //重定向
location.replace() //不记录历史，直接替换当前页面
location.reload() //重载页面，也可能是从缓存加载
location.reload(true) //重载页面，从服务器加载
</code></pre>
<h3 id="12-解析查询参数"><a class="header" href="#12-解析查询参数">1.2 解析查询参数</a></h3>
<p>自定义一个解析函数：</p>
<pre><code class="language-js">let getQueryStringArgs = function () {
  // 取得没有开头问号的查询字符串
  let qs = location.search.length &gt; 0 ? location.search.substring(1) : '',
    // 保存数据的对象
    args = {}
  // 把每个参数添加到 args 对象
  for (let item of qs.split('&amp;').map((kv) =&gt; kv.split('='))) {
    let name = decodeURIComponent(item[0]),
      value = decodeURIComponent(item[1])
    if (name.length) {
      args[name] = value
    }
  }
  return args
}

// 假设查询字符串为?q=javascript&amp;num=10
let args = getQueryStringArgs()
alert(args['q']) // &quot;javascript&quot;
alert(args['num']) // &quot;10&quot;
</code></pre>
<p>浏览器也提供了标准的 url 参数构造对象 URLSearchParams：</p>
<pre><code class="language-js">let qs = '?q=javascript&amp;num=10'
let searchParams = new URLSearchParams(qs)
alert(searchParams.toString()) // &quot; q=javascript&amp;num=10&quot;
searchParams.has('num') // true
searchParams.get('num') // 10
searchParams.set('page', '3')
alert(searchParams.toString()) // &quot; q=javascript&amp;num=10&amp;page=3&quot;
searchParams.delete('q')
alert(searchParams.toString()) // &quot; num=10&amp;page=3&quot;
</code></pre>
<p>大多数支持 URLSearchParams 的浏览器也支持将 URLSearchParams 的实例用作可迭代对象：</p>
<pre><code class="language-js">let qs = '?q=javascript&amp;num=10'
let searchParams = new URLSearchParams(qs)
for (let param of searchParams) {
  console.log(param)
}
// [&quot;q&quot;, &quot;javascript&quot;]
// [&quot;num&quot;, &quot;10&quot;]
</code></pre>
<h3 id="13-操作浏览器地址"><a class="header" href="#13-操作浏览器地址">1.3 操作浏览器地址</a></h3>
<p>可以通过修改 location 对象修改浏览器的地址。首先，最常见的是使用 assign()方法并传入一个 URL，如下所示：</p>
<pre><code class="language-js">location.assign('http://www.github.com')
</code></pre>
<p>这行代码会立即启动导航到新 URL 的操作，同时在浏览器历史记录中增加一条记录。如果给 location.href 或 window.location 设置一个 URL，也会以同一个 URL 值调用 assign()方法。比如，下面两行代码都会执行与显式调用 assign()一样的操作：</p>
<pre><code class="language-js">window.location = 'http://www.wrox.com'
location.href = 'http://www.wrox.com'
</code></pre>
<p>在这 3 种修改浏览器地址的方法中，设置 location.href 是最常见的。</p>
<p>修改 location 对象的属性也会修改当前加载的页面。其中， hash、 search、 hostname、 pathname 和 port 属性被设置为新值之后都会修改当前 URL。除了 hash 之外，只要修改 location 的一个属性，就会导致页面重新加载新 URL。</p>
<p>在以前面提到的方式修改 URL 之后，浏览器历史记录中就会增加相应的记录。当用户单击“后退”按钮时，就会导航到前一个页面。如果不希望增加历史记录，可以使用 replace()方法。这个方法接收一个 URL 参数，但重新加载后不会增加历史记录。调用 replace()之后，用户不能回到前一页。比如下面的例子：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;You won't be able to get back here&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Enjoy this page for a second, because you won't be coming back here.&lt;/p&gt;
    &lt;script&gt;
      setTimeout(() =&gt; location.replace('http://www.wrox.com/'), 1000)
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>浏览器加载这个页面 1 秒之后会重定向到 www.wrox.com。此时，“后退”按钮是禁用状态，即不能返回这个示例页面，除非手动输入完整的 URL。</p>
<p>最后一个修改地址的方法是 reload()，它能重新加载当前显示的页面。调用 reload()而不传参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面。如果想强制从服务器重新加载，可以像下面这样给 reload()传个 true：</p>
<pre><code class="language-js">location.reload() // 重新加载，可能是从缓存加载
location.reload(true) // 重新加载，从服务器加载
</code></pre>
<p>脚本中位于 reload()调用之后的代码可能执行也可能不执行，这取决于网络延迟和系统资源等因素。为此，最好把 reload()作为最后一行代码。</p>
<h2 id="二-navigator-对象"><a class="header" href="#二-navigator-对象">二 navigator 对象</a></h2>
<h3 id="21-基本使用"><a class="header" href="#21-基本使用">2.1 基本使用</a></h3>
<p>navigator 对象用于标识浏览器：</p>
<pre><code class="language-js">navigator.appCodeName //浏览器名称，通常为Mozilla
navigator.userAgent //用户代理字符串
navigator.plugins // 返回浏览器安装的插件数组
</code></pre>
<h3 id="22-注册处理程序"><a class="header" href="#22-注册处理程序">2.2 注册处理程序</a></h3>
<p>现代浏览器支持 navigator 上的（在 HTML5 中定义的） registerProtocolHandler()方法。这个方法可以把一个网站注册为处理某种特定类型信息应用程序。随着在线 RSS 阅读器和电子邮件客户端的流行，可以借助这个方法将 Web 应用程序注册为像桌面软件一样的默认应用程序。</p>
<p>要使用 registerProtocolHandler()方法，必须传入 3 个参数：要处理的协议（如&quot;mailto&quot;或&quot;ftp&quot;）、处理该协议的 URL，以及应用名称。比如，要把一个 Web 应用程序注册为默认邮件客户端，可以这样做：</p>
<pre><code class="language-js">navigator.registerProtocolHandler(
  'mailto',
  'http://www.somemailclient.com?cmd=%s',
  'Some Mail Client'
)
</code></pre>
<p>这个例子为&quot;mailto&quot;协议注册了一个处理程序，这样邮件地址就可以通过指定的 Web 应用程序打开。注意，第二个参数是负责处理请求的 URL， %s 表示原始的请求。</p>
<h3 id="23-h5-新增-geolocation-地理位置"><a class="header" href="#23-h5-新增-geolocation-地理位置">2.3 H5 新增 geolocation 地理位置</a></h3>
<p>HTML5 提供了 Geolocation 地理位置支持。目前大多数浏览器都可以支持（IE9+）。出于安全考虑，部分最新的浏览器只允许通过 HTTPS 协议使用 GeolocationAPI，在 http 协议下回跑出异常，当然本地开发不会有问题。</p>
<pre><code class="language-js">navigator.geolocation //会提示用户是否允许获取该API的权限
</code></pre>
<p>示例代码：</p>
<pre><code class="language-js">//判断浏览器是否兼容代码
if(!navigator.geolocation){
  //没有获取到地理位置执行的操作
  return
}

navigator.geolocation.getCurrentPosition(
  functionsuccess(position){
    console.log('获取位置成功，当前位置为：',position)
  },
  functionerrror(error){
    console.log('获取位置错误，错误为：',error)
  },
  {timeout:10000}
)
</code></pre>
<p>获取位置后返回的信息：</p>
<pre><code class="language-txt"># 获取成功，返回position参数对象，包含：
timestamp：获取位置时的时间戳
ciirds：坐标信息对象，内部包含：latitude（纬度），longitude（经度），accuracy（坐标精度，单位为米）

# 获取失败，返回错误对象，常见为：
code:错误标识，1为用户拒绝分享位置2为获取用户位置失败3为获取超时0为其他错误

# 传入的位置参数对象：
timeout:允许获取位置的超时时间，单位为毫秒
enableHighAccuracy：布尔值是否获取高精度信息
maximumAge：用户位置信息缓存的最大时间，默认为0，单位是毫秒
</code></pre>
<p>当用户位置发生变化时，可以通过 watchPostion 方法监听用户的位置信息，该方法和 getCurrentPosition 使用方式一致：</p>
<pre><code class="language-javascript">letwatchID = navigator.geolocation.watchPosition(success, error, option)
//取消监听
navigator.geolocation.clearWatch(watchID)
</code></pre>
<h2 id="三-screen-对象"><a class="header" href="#三-screen-对象">三 screen 对象</a></h2>
<p>screen 对象保存了客户端的能力信息，如像素宽度、像素高度，很少使用。</p>
<h2 id="四-history-状态管理对象"><a class="header" href="#四-history-状态管理对象">四 history 状态管理对象</a></h2>
<p>history 记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能：</p>
<pre><code class="language-js">//后退一页
history.go(-1)
//前进一页
history.go(1)
//前进两页
history.go(2)

//简写方法：后退一页
history.back()
//简写方法：前进一页
history.forward()
</code></pre>
<p>在以前，通过 hashchange 事件，可以知道 URL 的参数什么时候发生了变化，H5 的 history 对象额外提供了历史状态管理功能，通过状态管理，可以改变浏览器访问的历史：</p>
<pre><code class="language-js">history.pushState({ name: 'Nicholas' }, &quot;Nicholas'page&quot;, 'nicholas.html')
</code></pre>
<p>要更新当前状态，可以调用 replaceState()，传入的参数与 pushState()的前两个参数相同。调用这个方法不会在历史状态栈中创建新状态，只会重写当前状态。</p>
<pre><code class="language-js">history.replaceState({ name: 'Greg' }, &quot;Greg'spage&quot;)
</code></pre>
<h2 id="五-h5-新增-storage-存储机制"><a class="header" href="#五-h5-新增-storage-存储机制">五 H5 新增 Storage 存储机制</a></h2>
<p>传统 web 存储方式以<code>document.cookie</code>来进行，但是其存储大小只有 4k 左右，并且解析复杂。在 HTML5 规范中使用 Storage 存储，分别有两种存储方式：会话存储、本地存储。</p>
<p>会话存储：生命周期为关闭浏览器窗口，在同一个窗口下数据可以共享，可存储大约 5M，包含 API 有：</p>
<pre><code class="language-js">// 设置：
window.sessionStorage.setItem('name', 'lisi')
// 获取：
window.sessionStorage.getItem('name')
// 删除：
window.sessionStorage.removeItem('name')
// 清除：
window.sessionStorage.clear()
</code></pre>
<p>本地存储：永久生效，除非手动删除，可以多窗口共享，可存储大约 20M，包含 API 有：</p>
<pre><code class="language-js">// 获取：
window.localStorage
// 获取：
window.localStorage.getItem('name')
// 删除：
window.localStorage.removeItem('name')
// 清除：
window.localStorage.clear()
</code></pre>
<p>贴士：一些其他网络存储方案 WebSQL、IndexDB 已经被 w3c 放弃了。</p>
<h2 id="六-h5-新增-online-检测用户网络状态"><a class="header" href="#六-h5-新增-online-检测用户网络状态">六 H5 新增 onLine 检测用户网络状态</a></h2>
<p>我们可以通过 window.onLine 来检测，用户当前的网络状况，返回一个布尔值</p>
<pre><code class="language-js">window.online //用户网络连接时被调用
window.offline //用户网络断开时被调用
window.addEventListener('online', function () {
  console.log('已经建立了网络连接')
})
window.addEventListener('offline', function () {
  console.log('已经失去了网络连接')
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-客户端检测"><a class="header" href="#041-客户端检测">04.1-客户端检测</a></h1>
<h2 id="一-客户端检测概念"><a class="header" href="#一-客户端检测概念">一 客户端检测概念</a></h2>
<p>经过几次浏览器大战，不同的浏览器之间仍然有不小的差异，开发者需要使用各种方法检测客户端，尽量避免浏览器差异带来的问题。</p>
<p>对客户端的检测主要分为：</p>
<ul>
<li>能力检测：检测浏览器是否支持某个特性</li>
<li>用户代理检测</li>
<li>软硬件检测</li>
</ul>
<h2 id="二-能力检测"><a class="header" href="#二-能力检测">二 能力检测</a></h2>
<p>能力检测其实是对浏览器某个特性支持度的检测，开发者只需要关心该能力是否存在即可：</p>
<pre><code class="language-js">if (object.propertyInQuestion) {
  // 使用 object.propertyInQuestion
}
</code></pre>
<p><strong>能力检测最有效的场景是检测能力是否存在的同时，验证其是否能够展现出预期的行为</strong>。比如检测一个对象是否支持排序：</p>
<pre><code class="language-js">// 错误做法，当对象存在一个 sort 属性，该函数也会返回 true
function isSortable(obj) {
  return !!obj.sort
}

// 正确做法：检测 sort 是不是函数
function isSortable(object) {
  return typeof obj.sort == 'function'
}
</code></pre>
<p>对于 IE 来说，很多时候之后 typeof 检测让然不够，比如检测浏览器是否有<code>creatElement()</code>方法：</p>
<pre><code class="language-js">// 不适用于 IE8，因为 IE8 有该方法，但是返回的是 object
function hasCreatElementFunc() {
  return typeof document.createElement == 'function'
}
</code></pre>
<p>能力检测具有很大的局限性，因为浏览器的发展很快，对各种属性的支持、放弃也很快。比如下列方式就是错误示范：</p>
<pre><code class="language-js">// 不要这样做！不够特殊
let isFirefox = !!(navigator.vendor &amp;&amp; navigator.vendorSub)
// 不要这样做！假设太多
let isIE = !!(document.all &amp;&amp; document.uniqueID)
</code></pre>
<p>过去，Firefox 可以通过 navigator.vendor 和 navigator.vendorSub 来检测，但后来 Safari 也实现了同样的属性，于是这段代码就会产生误报。为确定 IE，这段代码检测了 document.all 和 document.uniqueID。这是假设 IE 将来的版本中还会继续存在这两个属性，而且其他浏览器也不会实现它们。</p>
<h2 id="三-用户代理检测"><a class="header" href="#三-用户代理检测">三 用户代理检测</a></h2>
<p>HTTP 协议要求浏览器应该向服务器发送包含浏览器名称和版本信息的简短字符串，如：</p>
<pre><code class="language-txt">Mozilla/Version (Platform; Encryption [; OS-or-CPU description])
</code></pre>
<p>在早起，很多服务器都会检测浏览器上的代理字符串来显示网页，如果一个新生的浏览器字符串不在服务器检测之列，就无法显示网页。为了应对这些局面，后起的浏览器就需要在代理字符串中“伪造”自己，比如早起的 IE 伪装自己为火狐的前身网景浏览器：</p>
<pre><code class="language-txt">Mozilla/2.0 (compatible; MSIE Version; Operating System)
</code></pre>
<p>获取浏览器代理的方式：</p>
<pre><code class="language-js">alert(navigator.userAgent) // 属性只读
</code></pre>
<p>这个代理是可以伪造的：</p>
<pre><code class="language-js">window.navigator.__defineGetter__('userAgent', () =&gt; 'foobar')
console.log(window.navigator.userAgent) // foobar
</code></pre>
<p>如果要确定浏览器信息，最好还是通过一些第三方库，如：Bowser、UAParser.js、Platform.js。</p>
<h2 id="四-软硬件检测"><a class="header" href="#四-软硬件检测">四 软硬件检测</a></h2>
<p>常见的一些属性、方法：</p>
<pre><code class="language-txt">navigator.oscpu：获取操作系统/架构信息
navigator.vendor：获取浏览器开发商信息
navigator.platform：获取浏览器操作系统信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-dom-基础-dom-节点"><a class="header" href="#051-dom-基础-dom-节点">05.1-DOM 基础-DOM 节点</a></h1>
<h2 id="一-节点概念"><a class="header" href="#一-节点概念">一 节点概念</a></h2>
<h3 id="11-树形结构"><a class="header" href="#11-树形结构">1.1 树形结构</a></h3>
<p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;hi&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>上述示例描述为树形结构则为：</p>
<p><a href="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/dom/dom-tree-01.svg">dom 树</a></p>
<p>document 节点表示每个文档的根节点。在这里，根节点的唯一子节点是 <code>&lt;html&gt;</code> 元素，我们称之为文档元素（ documentElement）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终是 <code>&lt;html&gt;</code> 元素。在 XML 文档中，则没有这样预定义的元素，任何元素都可能成为文档元素。</p>
<h3 id="12-节点类型"><a class="header" href="#12-节点类型">1.2 节点类型</a></h3>
<p>HTML 中的每段标记都可以表示为这个树形结构中的一个节点。元素节点表示 HTML 元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。</p>
<p>DOM Level 1 描述了名为 Node 的接口，这个接口是所有 DOM 节点类型都必须实现的。 Node 接口在 JavaScript 中被实现为 Node 类型，所有节点类型都继承 Node 类型，因此 DOM 中的 12 种节点类型都继承自 Node 类型，他们都共享相同的基本属性和方法。</p>
<p>每个节点都有一个 nodeType 属性，用于表明节点的类型，通常有 12 个节点类型，由 1-12 整数表示：</p>
<pre><code class="language-js">Node.ELEMENT_NODE(1)；                      // 元素节点
Node.ATTRIBUTE_NODE(2)；                    // 属性节点
Node.TEXT_NODE(3)；                         // 文本节点
Node.CDATA_SECTION_NODE(4)；
Node.ENTITY_REFERENCE_NODE(5)；
Node.ENTITY_NODE(6)；
Node.PROCESSING_INSTRUCTION_NODE(7)；
Node.COMMENT_NODE(8)；
Node.DOCUMENT_NODE(9)；
Node.DOCUMENT_TYPE_NODE(10)；
Node.DOCUMENT_FRAGMENT_NODE(11)；
Node.NOTATION_NODE(12)
</code></pre>
<p>开发中推荐使用数字，因为名称在 IE 中往往不兼容：</p>
<pre><code class="language-js">if (someNode.nodeType == Node.ELEMENT_NODE) {
  //在 IE 中无效
  alert('Node is an element.')
}

// 推荐写法
if (someNode.nodeType == 1) {
  //适用于所有浏览器
  alert('Node is an element.')
}
</code></pre>
<p>实际开发中，主要操作的节点类型是：元素节点！</p>
<p>一般节点至少拥有三个基本属性：</p>
<ul>
<li>nodeType：节点类型，是个整数值，为 1 是元素节点，为 2 是属性节点，为 3 是文本节点（文字、空格、换行等）</li>
<li>nodeName：节点名称</li>
<li>nodeValue：节点值</li>
</ul>
<pre><code class="language-html">&lt;div id=&quot;div&quot;&gt;111&lt;/div&gt;
&lt;script&gt;
  let div = document.getElementById('div')
  console.log(div.nodeType) // 1
  console.log(div.nodeName) // DIV，元素标签名
  console.log(div.nodeValue) // null，始终为 null
&lt;/script&gt;
</code></pre>
<h3 id="13-节点关系"><a class="header" href="#13-节点关系">1.3 节点关系</a></h3>
<p>文档中的所有节点都与其他节点有关系，整个 HTML 文档形成了类似树一样的关系结构。这些节点列表使用一个名为 NodeList 的类数组对象表示。</p>
<p>每个节点都有一个 <strong>childNodes</strong> 的属性，其中包含一个 NodeList 的实例：</p>
<pre><code class="language-js">// 中括号或使用 item() 方法可以访问 NodeList 中的元素：
let firstChild = someNode.childNodes[0]
let secondChild = someNode.childNodes.item(1)
let count = someNode.childNodes.length
</code></pre>
<p>可以把 NodeList 整个类数组对象转换为数组之后使用</p>
<pre><code class="language-js">let arrayOfNodes = Array.prototype.slice.call(someNode.childNodes, 0)
// 推荐使用 ES6 方式
let arrayOfNodes = Array.from(someNode.childNodes)
</code></pre>
<p>每个节点都有一个 parentNode 属性，指向其 DOM 树中的父元素。childNodes 中的所有节点都有同一个父元素，因此它们的 parentNode 属性都指向同一个节点。childNodes 列表中的每个节点都是同一列表中其他节点的同胞节点。而 previousSibling 和 nextSibling 可以在这个列表的节点间导航。这个列表中第一个节点的 previousSibling 属性是 null，最后一个节点的 nextSibling 属性也是 null，如下所示：</p>
<pre><code class="language-js">if (someNode.nextSibling === null) {
  alert(&quot;Last node in the parent's childNodes list.&quot;)
} else if (someNode.previousSibling === null) {
  alert(&quot;First node in the parent's childNodes list.&quot;)
}
</code></pre>
<p>注意：如果 childNodes 中只有一个节点，则它的 previousSibling 和 nextSibling 属性都是 null。</p>
<p>父节点和它的第一个及最后一个子节点也有专门属性：firstChild 和 lastChild 分别指向 childNodes 中的第一个和最后一个子节点。</p>
<h2 id="二-常见节点类型"><a class="header" href="#二-常见节点类型">二 常见节点类型</a></h2>
<h3 id="21-document-类型"><a class="header" href="#21-document-类型">2.1 Document 类型</a></h3>
<p>Document 类型是 JavaScript 中表示文档节点的类型。在浏览器中，文档对象 document 是 HTML 页面对象 HTMLDocument 的实例，挂载在 window 对象上作为一个全局对象，该对象的第一个子节点便是 html 标签。</p>
<p>Document 类型的节点特征有：</p>
<ul>
<li>nodeType 等于 9；</li>
<li>nodeName 值为&quot;#document&quot;；</li>
<li>nodeValue 值为 null；</li>
<li>parentNode 值为 null；</li>
<li>ownerDocument 值为 null；</li>
<li>子节点可以是 DocumentType（最多一个）、 Element（最多一个）、 ProcessingInstruction 或 Comment 类型。</li>
</ul>
<p>Document 类型可以表示 HTML 页面或其他 XML 文档，但最常用的还是通过 HTMLDocument 的实例取得 document 对象。</p>
<p>DOM 规范规定 Document 节点的子节点可以是 DocumentType、 Element、 ProcessingInstruction 或 Comment。</p>
<p>通过 document.childNodes 可以访问起所有子节点，不过也提供了 document.documentElement 这个 <code>&lt;html&gt;</code> 元素的快速访问方式：</p>
<pre><code class="language-js">let html = document.documentElement // 取得对&lt;html&gt;的引用
alert(html === document.childNodes[0]) // true
alert(html === document.firstChild) // true
</code></pre>
<p>此外，document 对象还有一个 body 属性，直接指向 <code>&lt;body&gt;</code>元素。</p>
<p><code>document.doctype</code>可以访问<code>&lt;!DOCTYPE&gt;</code>标签，但是该节点在不同浏览器中表现不同：</p>
<ul>
<li>IE8：会将该子节点错误的解释为一个注释并把它当作 Comment 节点，document.doctype 的值始终为 null。</li>
<li>IE9+/Firefox：被作为文档的第一个子节点</li>
<li>Chrome/Safari：不会被作为文档的子节点</li>
</ul>
<p>此外还有一些属性如下所示：</p>
<pre><code class="language-js">// 读取文档标题
let originalTitle = document.title
// 取得完整的 URL
let url = document.URL
// 取得域名：只有本属性是可写的，其他都是只读
let domain = document.domain
// 取得来源
let referrer = document.referrer
// 获取文档加载状态（H5新增）
document.readyState // loading，表示文档正在加载；complete，表示文档加载完成
// 获取文档加载模式
document.compatMode // 标准模式下 的值是&quot;CSS1Compat&quot;，而在混杂模式下的值是&quot;BackCompat&quot;
</code></pre>
<p>document 还支持获取页面元素的方法，见节点选择章节。</p>
<h3 id="22-element-类型"><a class="header" href="#22-element-类型">2.2 Element 类型</a></h3>
<p>元素类型即 HTML 中的元素，Element 类型的节点具有以下特征：</p>
<ul>
<li>nodeType 等于 1；</li>
<li>nodeName 值为元素的标签名；</li>
<li>nodeValue 值为 null；</li>
<li>parentNode 值为 Document 或 Element 对象；</li>
<li>子节点可以是 Element、 Text、 Comment、 ProcessingInstruction、 CDATASection、EntityReference 类型。</li>
</ul>
<h3 id="23-text-类型"><a class="header" href="#23-text-类型">2.3 Text 类型</a></h3>
<p>文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的 HTML 字符，但不能包含 HTML 代码。</p>
<p>Text 类型的节点具有以下特征：</p>
<ul>
<li>nodeType 等于 3；</li>
<li>nodeName 值为&quot;#text&quot;；</li>
<li>nodeValue 值为节点中包含的文本；</li>
<li>parentNode 值为 Element 对象；</li>
<li>不支持子节点。</li>
</ul>
<p>文本节点的创建：</p>
<pre><code class="language-js">let textNode = document.createTextNode('&lt;strong&gt;Hello&lt;/strong&gt; world!')
</code></pre>
<p>文本节点暴露了以下操作文本的方法：</p>
<ul>
<li>appendData(text)，向节点末尾添加文本 text；</li>
<li>deleteData(offset, count)，从位置 offset 开始删除 count 个字符；</li>
<li>insertData(offset, text)，在位置 offset 插入 text；</li>
<li>replaceData(offset, count, text)，用 text 替换从位置 offset 到 offset + count 的文本；</li>
<li>splitText(offset)，在位置 offset 将当前文本节点拆分为两个文本节点；</li>
<li>substringData(offset, count)，提取从位置 offset 到 offset + count 的文本。</li>
</ul>
<h3 id="24-comment-类型"><a class="header" href="#24-comment-类型">2.4 Comment 类型</a></h3>
<p>DOM 中的注释通过 Comment 类型表示。 Comment 类型的节点具有以下特征：</p>
<ul>
<li>nodeType 等于 8；</li>
<li>nodeName 值为&quot;#comment&quot;；</li>
<li>nodeValue 值为注释的内容；</li>
<li>parentNode 值为 Document 或 Element 对象；</li>
<li>不支持子节点
Comment 类型与 Text 类型继承同一个基类（ CharacterData），因此拥有除 splitText()之外 Text 节点所有的字符串操作方法。与 Text 类型相似，注释的实际内容可以通过 nodeValue 或 data 属性获得。</li>
</ul>
<p>注释节点可以作为父节点的子节点来访问。比如下面的 HTML 代码：</p>
<pre><code class="language-html">&lt;div id=&quot;myDiv&quot;&gt;&lt;!-- A comment --&gt;&lt;/div&gt;
</code></pre>
<p>这里的注释是<div>元素的子节点，这意味着可以像下面这样访问它：</p>
<pre><code class="language-html">let div = document.getElementById(&quot;myDiv&quot;); let comment = div.firstChild;
alert(comment.data); // &quot;A comment&quot;
</code></pre>
<p>可以使用 document.createComment()方法创建注释节点，参数为注释文本，如下所示：</p>
<pre><code class="language-js">let comment = document.createComment('A comment')
</code></pre>
<h3 id="25-cdatasection-类型"><a class="header" href="#25-cdatasection-类型">2.5 CDATASection 类型</a></h3>
<p>CDATASection 类型表示 XML 中特有的 CDATA 区块。</p>
<h3 id="26-documenttype-类型"><a class="header" href="#26-documenttype-类型">2.6 DocumentType 类型</a></h3>
<p>DocumentType 类型的节点包含文档的文档类型（ doctype）信息，具有以下特征：</p>
<ul>
<li>nodeType 等于 10；</li>
<li>nodeName 值为文档类型的名称；</li>
<li>nodeValue 值为 null；</li>
<li>parentNode 值为 Document 对象；</li>
<li>不支持子节点。</li>
</ul>
<h2 id="27-documentfragment-类型"><a class="header" href="#27-documentfragment-类型">2.7 DocumentFragment 类型</a></h2>
<p>在所有节点类型中， DocumentFragment 类型是唯一一个在标记中没有对应表示的类型。 DOM 将文档片段定义为 “轻量级” 文档， 能够包含和操作节点，却没有完整文档那样额外的消耗。</p>
<p>DocumentFragment 节点具有以下特征：</p>
<ul>
<li>nodeType 等于 11；</li>
<li>nodeName 值为&quot;#document-fragment&quot;；</li>
<li>nodeValue 值为 null；</li>
<li>parentNode 值为 null；</li>
<li>子节点可以是 Element、 ProcessingInstruction、 Comment、 Text、 CDATASection 或 EntityReference。</li>
</ul>
<p>不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库。可以使用 document.createDocumentFragment()方法像下面这样创建文档片段：</p>
<pre><code class="language-js">let fragment = document.createDocumentFragment()
</code></pre>
<p>文档片段从 Node 类型继承了所有文档类型具备的可以执行 DOM 操作的方法。如果文档中的一个节点被添加到一个文档片段，则该节点会从文档树中移除，不会再被浏览器渲染。添加到文档片段的新节点同样不属于文档树，不会被浏览器渲染。可以通过 appendChild()或 insertBefore()方法将文档片段的内容添加到文档。在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。文档片段本身永远不会被添加到文档树。以下面的 HTML 为例：</p>
<pre><code class="language-js">// &lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;
let fragment = document.createDocumentFragment()
let ul = document.getElementById('myList')
for (let i = 0; i &lt; 3; ++i) {
  let li = document.createElement('li')
  li.appendChild(document.createTextNode(`Item ${i + 1}`))
  fragment.appendChild(li)
}
ul.appendChild(fragment)
</code></pre>
<h2 id="28-attr-类型"><a class="header" href="#28-attr-类型">2.8 Attr 类型</a></h2>
<p>元素数据在 DOM 中通过 Attr 类型表示。 Attr 类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素 attributes 属性中的节点。 Attr 节点具有以下特征：</p>
<ul>
<li>nodeType 等于 2；</li>
<li>nodeName 值为属性名；</li>
<li>nodeValue 值为属性值；</li>
<li>parentNode 值为 null；</li>
<li>在 HTML 中不支持子节点；</li>
<li>在 XML 中子节点可以是 Text 或 EntityReference。</li>
</ul>
<p>属性节点尽管是节点，却不被认为是 DOM 文档树的一部分。 Attr 节点很少直接被引用，通常开发者更喜欢使用 getAttribute()、 removeAttribute()和 setAttribute()方法操作属性。</p>
<p>Attr 对象上有 3 个属性： name、 value 和 specified。其中， name 包含属性名（与 nodeName 一样）， value 包含属性值（与 nodeValue 一样），而 specified 是一个布尔值，表示属性使用的是默认值还是被指定的值。</p>
<p>可以使用 document.createAttribute()方法创建新的 Attr 节点，参数为属性名。比如，要给元素添加 align 属性，可以使用下列代码：</p>
<pre><code class="language-js">let attr = document.createAttribute('align')
attr.value = 'left'
element.setAttributeNode(attr)
alert(element.attributes['align'].value) // &quot;left&quot;
alert(element.getAttributeNode('align').value) // &quot;left&quot;
alert(element.getAttribute('align')) // &quot;left&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="052-dom-基础-元素的增删改查"><a class="header" href="#052-dom-基础-元素的增删改查">05.2-DOM 基础-元素的增删改查</a></h1>
<h2 id="一-element-类型的常见操作"><a class="header" href="#一-element-类型的常见操作">一 Element 类型的常见操作</a></h2>
<h3 id="11-节点选择"><a class="header" href="#11-节点选择">1.1 节点选择</a></h3>
<p>Element 类型就是 Web 开发中最常用的类型，对其的操作涉及大量的 API。</p>
<p>获取节点的方式有：</p>
<pre><code class="language-js">// 通用的 元素节点选择 API
document.getElementById('demo') //通过 id 找到 HTML 元素
document.getElementsByTagName('div')[0] //通过标签名找到 HTML 元素获得的是标签伪数组

// H5新增获取元素API：返回调用者内部所有匹配的NodeList。调用者可以是document，也可以是特定元素
element.getElementsByClassName('box') //，通过类名找到 HTML 元素，参数可以传入多个类名，空格隔开

// HTML5 中新增的 Selectors API
document.querySelector() // 可以传入 元素名CSS、选择符，返回与该模式匹配的第一个元素
document.querySelectorAll() // 可以传入 元素名CSS、选择符，返回的是一个 NodeList 的实例
/**
 * querySelectorAll()返回的 NodeList 实例一个属性和方法都不缺，但它是一个静态的“快照”，而非“实时”的查询。
 * 这样的底层实现避免了使用 NodeList 对象可能造成的性能问题。
 */

// 检测某个元素会不会被 querySelector() 或 querySelectorAll()方法返回
document.matches() // 可以传入 CSS 选择符，返回是否匹配的布尔
</code></pre>
<p>document 对象上还暴露了几个特殊集合，这些集合也都是 HTMLCollection 的实例。这些集合是访问文档中公共部分的快捷方式，列举如下。</p>
<ul>
<li>document.anchors 包含文档中所有带 name 属性的<code>&lt;a&gt;</code>元素。</li>
<li>document.applets 包含文档中所有<code>&lt;applet&gt;</code>元素（因为<code>&lt;applet&gt;</code>元素已经不建议使用，所
以这个集合已经废弃）。</li>
<li>document.forms 包含文档中所有<code>&lt;form&gt;</code>元素（与 document.getElementsByTagName (&quot;form&quot;)
返回的结果相同）。</li>
<li>document.images 包含文档中所有<code>&lt;img&gt;</code>元素（与 document.getElementsByTagName (&quot;img&quot;)
返回的结果相同）。</li>
<li>document.links 包含文档中所有带 href 属性的<code>&lt;a&gt;</code>元素。</li>
</ul>
<p>这些特殊集合始终存在于 HTMLDocument 对象上，而且与所有 HTMLCollection 对象一样，其内容也会实时更新以符合当前文档的内容</p>
<h3 id="12-通过元素关系获取指定元素"><a class="header" href="#12-通过元素关系获取指定元素">1.2 通过元素关系获取指定元素</a></h3>
<p>元素之间的父子关系获取：</p>
<pre><code class="language-js">// 获取父节点：一个节点只有一个父节点
element.parentNode

// 获取所有子节点
fatherElement.children // 只包含 Element 类型的子节点
fatherElement.childNodes //包括 空白节点
</code></pre>
<p>IE 浏览器在 IE9 之前不会把元素间的空格当成空白节点，而其他浏览器会，这会导致 childNodes 和 firstChild 等属性上的差异。为了弥补这个差异，同时不影响 DOM 规范， W3C 通过新的 ElementTraversal 规范定义了一组新属性：</p>
<pre><code class="language-js">// 获取特定子元素节点
// 下列 API 不支持 IE8，IE8 使用 firstChid，firstChild 在标准中获取的是第一个子节点，同理 lastChild
fatherElement.firstElementChild //获取第一个子元素节点
fatherElement.lastElementChild //获取最后一个子元素节点

// 获取前后同级元素节点
// 下列 API 不支持 IE8，IE8 使用 previousSibling，previousSibling 在标准中获取的是前一个节点，同理 nextSibling
element.previousElementSibling //获取前一个节点
element.nextElementSibling //获取下一个节点

// 获取子元素数量
element.childElementCount // 返回子元素数量（不包含文本节点和注释）
</code></pre>
<p>过去要以跨浏览器方式遍历特定元素的所有子元素示例：</p>
<pre><code class="language-js">// 旧版：没有子元素， firstChild 返回 null，跳过循环
// let parentElement = document.getElementById('parent')
// let currentChildNode = parentElement.firstChild
// while (currentChildNode) {
//   if (currentChildNode.nodeType === 1) {
//     // 如果有元素节点，则做相应处理
//     processChild(currentChildNode)
//   }
//   if (currentChildNode === parentElement.lastChild) {
//     break
//   }
//   currentChildNode = currentChildNode.nextSibling
// }

let parentElement = document.getElementById('parent')
let currentChildElement = parentElement.firstElementChild
// 没有子元素， firstElementChild 返回 null，跳过循环
while (currentChildElement) {
  // 这就是元素节点，做相应处理
  processChild(currentChildElement)
  if (currentChildElement === parentElement.lastElementChild) {
    break
  }
  currentChildElement = currentChildElement.nextElementSibling
}
</code></pre>
<p>contains()方法可以判断一个元素是否不是另外一个元素的后代，contains()应该在要搜索的祖先元素上调用，参数是待确定的目标节点：</p>
<pre><code class="language-js">console.log(document.documentElement.contains(document.body)) // true
</code></pre>
<p>使用 DOM Level 3 的 compareDocumentPosition()方法也可以确定节点间的关系，这个方法会返回表示两个节点关系的位掩码</p>
<pre><code class="language-txt">0x1 断开（传入的节点不在文档中）
0x2 领先（传入的节点在 DOM 树中位于参考节点之前）
0x4 随后（传入的节点在 DOM 树中位于参考节点之后）
0x8 包含（传入的节点是参考节点的祖先）
0x10 被包含（传入的节点是参考节点的后代）
</code></pre>
<p>要模仿 contains()方法，就需要用到掩码 16（ 0x10）。 compareDocumentPosition()方法的结果可以通过按位与来确定参考节点是否包含传入的节点，比如：</p>
<pre><code class="language-js">let result = document.documentElement.compareDocumentPosition(document.body)
console.log(!!(result &amp; 0x10))
</code></pre>
<h3 id="13-节点的增删改复制"><a class="header" href="#13-节点的增删改复制">1.3 节点的增、删、改、复制</a></h3>
<p>常见 API：</p>
<pre><code class="language-js">// 创建节点
document.createElement(&quot;节点与内容&quot;);

// 插入节点
fatherElement.appendChild(新节点);         // 父节点的最后插入一个新节点
fatherElement.insertBefore(新节点,参考节点); // 在参考节点前插入

// 删除节点
fatherElement.removeChild（子节点);      // 必须指定要删除的子节点

// 修改节点内容
element.innerHTML = &quot;HTML 内容&quot;;  // 内容修改为新的 HTML 文档
element.innerText = &quot;文本内容&quot;;    // 内容修改为纯文本
// 获取节点内容也支持：outerHTML outerText

// 复制节点
newElement=element.cloneNode(参数); //参数可选复制节点

// 直接修改文档
document.write(&quot;节点与内容&quot;);  // 会抹掉整个页面已加载的元素，基本不使用，一般使用 innerHTML() 方法，这样不会造成整个额页面的重绘
document.writeln(&quot;节点与内容&quot;); // 会加入换行符
</code></pre>
<p>新增的插入节点方法：insertAdjacentHTML()与 insertAdjacentText()，它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本。第一个参数
必须是下列值中的一个：</p>
<ul>
<li>&quot;beforebegin&quot;，插入当前元素前面，作为前一个同胞节点；</li>
<li>&quot;afterbegin&quot;，插入当前元素内部，作为新的子节点或放在第一个子节点前面；</li>
<li>&quot;beforeend&quot;，插入当前元素内部，作为新的子节点或放在最后一个子节点后面；</li>
<li>&quot;afterend&quot;，插入当前元素后面，作为下一个同胞节点。</li>
</ul>
<pre><code class="language-js">// 作为前一个同胞节点插入
element.insertAdjacentHTML('beforebegin', '&lt;p&gt;Hello world!&lt;/p&gt;')
element.insertAdjacentText('beforebegin', 'Hello world!')
// 作为第一个子节点插入
element.insertAdjacentHTML('afterbegin', '&lt;p&gt;Hello world!&lt;/p&gt;')
element.insertAdjacentText('afterbegin', 'Hello world!')
// 作为最后一个子节点插入
element.insertAdjacentHTML('beforeend', '&lt;p&gt;Hello world!&lt;/p&gt;')
element.insertAdjacentText('beforeend', 'Hello world!')
// 作为下一个同胞节点插入
element.insertAdjacentHTML('afterend', '&lt;p&gt;Hello world!&lt;/p&gt;')
element.insertAdjacentText('afterend', 'Hello world!')
</code></pre>
<h3 id="14-获取修改元素节点的属性"><a class="header" href="#14-获取修改元素节点的属性">1.4 获取、修改元素节点的属性</a></h3>
<p>修改元素节点属性的示例：</p>
<pre><code class="language-js">imgElement.src = 'images/new.jpg' // 修改图片元素的路径
inputElement.value = '123' // 修改表单数据
inputElement.disabled = true // 禁用表单可点击
</code></pre>
<p>上述示例中通过点语法即可获得元素的属性，还可以通过下列方式：</p>
<pre><code class="language-js">element.getAttribute('id') // 获取 id 属性值
element.getAttribute('backgroundColor') // 获取背景色
</code></pre>
<p>点语法只能获得元素自身的固有属性，<code>getAttribute()</code> 还能获得自定义属性：</p>
<pre><code class="language-html">&lt;div index=&quot;a&quot; id=&quot;box&quot;&gt;111&lt;/div&gt;
&lt;script&gt;
  let box = document.querySelector('#box')
  console.log(box.getAttribute('index')) // a
  box.setAttribute('index', 'b')
  console.log(box.getAttribute('index')) // b
&lt;/script&gt;
</code></pre>
<p>但是上述写法是不规范的，在 H5 中，约定自定义属性用 data- 开头，而且可以直接通过 dataset 属性获取：</p>
<pre><code class="language-html">&lt;div data-index=&quot;a&quot; id=&quot;box&quot;&gt;111&lt;/div&gt;
&lt;script&gt;
  let box = document.querySelector('#box')
  // dataset 只能获取 data- 开头的自定义属性，所以 getAttribute 的兼容性更好
  console.log(box.dataset.index) // 输出 a。也可以使用  dataset[&quot;index&quot;]
&lt;/script&gt;
</code></pre>
<h3 id="15-节点的-attributes-属性操作"><a class="header" href="#15-节点的-attributes-属性操作">1.5 节点的 attributes 属性操作</a></h3>
<p>Element 类型是唯一使用 attributes 属性的 DOM 节点类型。 attributes 属性包含一个 NamedNodeMap 实例，是一个类似 NodeList 的“实时”集合。元素的每个属性都表示为一个 Attr 节点，并保存在这个 NamedNodeMap 对象中。 NamedNodeMap 对象包含下列方法：</p>
<ul>
<li>getNamedItem(name)，返回 nodeName 属性等于 name 的节点；</li>
<li>removeNamedItem(name)，删除 nodeName 属性等于 name 的节点；</li>
<li>setNamedItem(node)，向列表中添加 node 节点，以其 nodeName 为索引；</li>
<li>item(pos)，返回索引位置 pos 处的节点。</li>
</ul>
<p>attributes 属性中的每个节点的 nodeName 是对应属性的名字， nodeValue 是属性的值。比如，要取得元素 id 属性的值，可以使用以下代码：</p>
<pre><code class="language-js">let id = element.attributes.getNamedItem('id').nodeValue
// 下面是使用中括号访问属性的简写形式：
let id = element.attributes['id'].nodeValue
</code></pre>
<p>同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其 nodeValue 设置为新值，如下所示：</p>
<pre><code class="language-js">element.attributes['id'].nodeValue = 'someOtherId'
</code></pre>
<p>removeNamedItem()方法与元素上的 removeAttribute()方法类似，也是删除指定名字的属性。下面的例子展示了这两个方法唯一的不同之处， 就是 removeNamedItem()返回表示被删除属性的 Attr 节点：</p>
<pre><code class="language-js">let oldAttr = element.attributes.removeNamedItem('id')
</code></pre>
<p>setNamedItem()方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示：</p>
<pre><code class="language-js">element.attributes.setNamedItem(newAttr)
</code></pre>
<p>一般来说，因为使用起来更简便，通常开发者更喜欢使用 getAttribute()、 removeAttribute()和 setAttribute()方法，而不是刚刚介绍的 NamedNodeMap 对象的方法。</p>
<h3 id="16-节点的样式操作"><a class="header" href="#16-节点的样式操作">1.6 节点的样式操作</a></h3>
<pre><code class="language-js">// 直接以行内样式方式修改：属性名一般是驼峰命名法
element.style.backgroundColor = 'red'
element.style.border = '1px solid black'

// 修改类名
element.className = '新的类名'

// 重写元素所有属性
element.style.cssText = 'width: 25px; height: 100px; background-color: green'

// 移除某个属性的样式，采用默认样式
element.style.removeProperty('border')

// 应用给元素的 CSS 属性数量
element.style.length

// 此外还有下列方法
getPropertyPriority(propertyName) // 如果 CSS 属性 propertyName 使用了!important则返回&quot;important&quot;，否则返回空字符串
getPropertyValue(propertyName) // 返回属性 propertyName 的字符串值。
item(index) // 返回索引为 index 的 CSS 属性名。
removeProperty(propertyName) // 从样式中删除 CSS 属性 propertyName。
setProperty(propertyName, value, priority) //设置 CSS 属性 propertyName 的值为value， priority 是&quot;important&quot;或空字符串
</code></pre>
<p>className 是一个字符串，当一个元素拥有较多 css 类名，对某个类名进行操作就变得复杂，H5 新增了集合类型 DOMTokenList 的实例 classList 属性，可以简单安全的实现操作多个类名：</p>
<ul>
<li>add(value)，向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。</li>
<li>contains(value)，返回布尔值，表示给定的 value 是否存在。</li>
<li>remove(value)，从类名列表中删除指定的字符串值 value。</li>
<li>toggle(value)，如果类名列表中已经存在指定的 value，则删除；如果不存在，则添加</li>
</ul>
<pre><code class="language-js">// 删除&quot;disabled&quot;类
div.classList.remove(&quot;disabled&quot;);
// 添加&quot;current&quot;类
div.classList.add(&quot;current&quot;);
// 切换&quot;user&quot;类
div.classList.toggle(&quot;user&quot;);
// 检测类名
if (div.classList.contains(&quot;bd&quot;) &amp;&amp; !div.classList.contains(&quot;disabled&quot;)){
// 执行操作
)
// 迭代类名
for (let class of div.classList){
doStuff(class);
}
</code></pre>
<h3 id="17-节点比较"><a class="header" href="#17-节点比较">1.7 节点比较</a></h3>
<p>isSameNode() 和 isEqualNode():</p>
<pre><code class="language-js">let div1 = document.createElement('div')
div1.setAttribute('class', 'box')

let div2 = document.createElement('div')
div2.setAttribute('class', 'box')

console.log(div1.isSameNode(div1)) // true
console.log(div1.isSameNode(div2)) // false

console.log(div1.isEqualNode(div2)) // true
</code></pre>
<h3 id="18-节点焦点"><a class="header" href="#18-节点焦点">1.8 节点焦点</a></h3>
<p>HTML5 增加了辅助 DOM 焦点管理的功能，确定文档是否获得了焦点，就可以帮助确定用户是否在操作页面：</p>
<ul>
<li>document.activeElement 可以用来查询文档，确定哪个元素拥有焦点</li>
<li>document.hasFocus()可以查询文档是否获得了焦点，</li>
</ul>
<p>document.activeElement 始终包含当前拥有焦点的 DOM 元素。页面加载时，可以通过用户输入（按 Tab 键或代码中使用 focus()方法）让某个元素自动获得焦点。例如：</p>
<pre><code class="language-js">let button = document.getElementById('myButton')
button.focus()
console.log(document.activeElement === button) // true
</code></pre>
<p>默认情况下， document.activeElement 在页面刚加载完之后会设置为 document.body。而在页面完全加载之前， document.activeElement 的值为 null。</p>
<p>document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点：</p>
<pre><code class="language-js">let button = document.getElementById('myButton')
button.focus()
console.log(document.hasFocus()) // true
</code></pre>
<h3 id="19-自定义属性"><a class="header" href="#19-自定义属性">1.9 自定义属性</a></h3>
<p>HTML5 允许通过 data- 前缀给元素指定非标准的属性：</p>
<pre><code class="language-js">;&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt;

let div = document.getElementById('myDiv')

// 取得自定义数据属性的值
let appId = div.dataset.appId
let myName = div.dataset.myname
// 设置自定义数据属性的值
div.dataset.appId = 23456
div.dataset.myname = 'Michael'
// 有&quot;myname&quot;吗？
if (div.dataset.myname) {
  console.log(`Hello, ${div.dataset.myname}`)
}
</code></pre>
<p>贴士：元素的每个 data-name 属性在 dataset 中都可以通过 data-后面的字符串作为键来访问（例如，属性 data-myname、 data-myName 可以通过 myname 访问，但要注意 data-my-name、 data-My-Name 要通过 myName 来访问）。</p>
<h3 id="110-滚动页面区域"><a class="header" href="#110-滚动页面区域">1.10 滚动页面区域</a></h3>
<p>HTML5 scrollIntoView()方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。这个方法的参数如下：</p>
<ul>
<li>alignToTop：true 时表示窗口滚动后元素的顶部与视口顶部对齐，false 表示窗口滚动后元素的底部与视口底部对齐。</li>
<li>scrollIntoViewOptions 是一个选项对象。
<ul>
<li>behavior：定义过渡动画，可取的值为&quot;smooth&quot;和&quot;auto&quot;，默认为&quot;auto&quot;。</li>
<li>block：定义垂直方向的对齐，可取的值为&quot;start&quot;、 &quot;center&quot;、 &quot;end&quot;和&quot;nearest&quot;，默认为 &quot;start&quot;。</li>
<li>inline：定义水平方向的对齐，可取的值为&quot;start&quot;、 &quot;center&quot;、 &quot;end&quot;和&quot;nearest&quot;，默认为 &quot;nearest&quot;。</li>
</ul>
</li>
<li>不传参数等同于 alignToTop 为 true。</li>
</ul>
<pre><code class="language-js">// 确保元素可见
document.forms[0].scrollIntoView()
// 同上
document.forms[0].scrollIntoView(true)
document.forms[0].scrollIntoView({ block: 'start' })
// 尝试将元素平滑地滚入视口
document.forms[0].scrollIntoView({ behavior: 'smooth', block: 'start' })
</code></pre>
<p>不同浏览器在滚动上仍然有专有方法，Safari、Chrome 实现了 scrollIntoViewIfNeeded()，该方法会在元素不可见的情况下，将其滚动到窗口或包含窗口中，使其可见；如果已经在视口中可见，则这个方法什么也不做。如果将可选的参数 alingCenter 设置为 true，则浏览器会尝试将其放在视口中央：</p>
<pre><code class="language-js">// 如果不可见，则将元素可见
document.images[0].scrollIntoViewIfNeeded()
</code></pre>
<h2 id="二-节点遍历"><a class="header" href="#二-节点遍历">二 节点遍历</a></h2>
<h3 id="20-深度优先遍历"><a class="header" href="#20-深度优先遍历">2.0 深度优先遍历</a></h3>
<p>DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构。这两个类型——NodeIterator 和 TreeWalker——从某个起点开始执行对 DOM 结构的深度优先遍历。</p>
<h3 id="21-nodeiterator"><a class="header" href="#21-nodeiterator">2.1 NodeIterator</a></h3>
<p>对下面文档中的 body 内的元素进行遍历示例：</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;div id=&quot;div&quot;&gt;
      &lt;p&gt;
        &lt;b&gt;Hello&lt;/b&gt;
        world!
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;List item 1&lt;/li&gt;
        &lt;li&gt;List item 2&lt;/li&gt;
        &lt;li&gt;List item 3&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script&gt;
      let div = document.getElementById('div')

      let iterator = document.createNodeIterator(
        div, // 从哪个节点开始遍历
        NodeFilter.SHOW_ELEMENT, // whatToShow 参数：应该访问哪些节点
        null, // filter 参数：是否接收或跳过特定节点
        false // 是否扩展实体引用，在 HTML 中无效！
      )

      let node = iterator.nextNode()
      while (node !== null) {
        console.log(node.tagName) // 输出标签名
        node = iterator.nextNode()
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意：nextNode() 和 previousNode() 方法共同维护 NodeIterator 对 DOM 结构的内部指针，因此修改 DOM 结构也会体现在遍历中。</p>
<p>第二个参数 whatToShow 是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点，常见定义有：</p>
<pre><code class="language-txt">NodeFilter.SHOW_ALL，所有节点。
NodeFilter.SHOW_ELEMENT，元素节点。
NodeFilter.SHOW_ATTRIBUTE，属性节点。由于 DOM 的结构，因此实际上用不上。
NodeFilter.SHOW_TEXT，文本节点。
NodeFilter.SHOW_COMMENT，注释节点。
NodeFilter.SHOW_DOCUMENT，文档节点。
NodeFilter.SHOW_DOCUMENT_TYPE，文档类型节点。
</code></pre>
<p>whatToShow 值可以组合使用：</p>
<pre><code class="language-js">let whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT
</code></pre>
<p>创建迭代器示例：</p>
<pre><code class="language-js">// 创建过滤器方式一
let filter1 = {
  acceptNode(node) {
    return node.tagName.toLowerCase() == 'p'
      ? NodeFilter.FILTER_ACCEPT
      : NodeFilter.FILTER_SKIP
  },
}

// 创建过滤器方式二
let filter2 = function (node) {
  return node.tagName.toLowerCase() == 'p'
    ? NodeFilter.FILTER_ACCEPT
    : NodeFilter.FILTER_SKIP
}

// 创建迭代器
let iterator1 = document.createNodeIterator(
  root,
  NodeFilter.SHOW_ELEMENT,
  filter,
  false
)

// 创建一个简单的遍历所有节点的迭代器
let iterator2 = document.createNodeIterator(
  document,
  NodeFilter.SHOW_ALL,
  null,
  false
)
</code></pre>
<h3 id="22-treewalker"><a class="header" href="#22-treewalker">2.2 TreeWalker</a></h3>
<p>TreeWalker 是 NodeIterator 的高级版，额外添加了遍历的方向，示例：</p>
<pre><code class="language-js">let div = document.getElementById('div1')

let filter = function (node) {
  return node.tagName.toLowerCase() == 'li'
    ? NodeFilter.FILTER_ACCEPT
    : NodeFilter.FILTER_SKIP
}

let walker = document.createTreeWalker(
  div,
  NodeFilter.SHOW_ELEMENT,
  filter,
  false
)
let node = iterator.nextNode()
while (node !== null) {
  console.log(node.tagName) // 输出标签名
  node = iterator.nextNode()
}
</code></pre>
<p>方向示例：</p>
<pre><code class="language-txt">parentNode()，遍历到当前节点的父节点。
firstChild()，遍历到当前节点的第一个子节点。
lastChild()，遍历到当前节点的最后一个子节点。
nextSibling()，遍历到当前节点的下一个同胞节点。
previousSibling()，遍历到当前节点的上一个同胞节点。
</code></pre>
<p>节点过滤器（filter）除了可以返回 NodeFilter.FILTER_ACCEPT 和 NodeFilter.FILTER_SKIP，还可以返回 NodeFilter.FILTER_REJECT。在使用 NodeIterator 时，NodeFilter.FILTER_SKIP 和 NodeFilter.FILTER_REJECT 是一样的。但在使用 TreeWalker 时，NodeFilter.FILTER_SKIP 表示跳过节点，访问子树中的下一个节点，而 NodeFilter.FILTER_REJECT 则表示跳过该节点以及该节点的整个子树。例如，如果把前面示例中的过滤器函数改为返回 NodeFilter.FILTER_REJECT（而不是 NodeFilter.FILTER_SKIP），则会导致遍历立即返回，不会访问任何节点。这是因为第一个返回的元素是<code>&lt;div&gt;</code>，其中标签名不是&quot;li&quot;，因此过滤函数返回 NodeFilter.FILTER_REJECT，表示要跳过整个子树。因为<code>&lt;div&gt;</code>本身就是遍历的根节点，所以遍历会就此结束。</p>
<h3 id="23-treewalker-节点跳跃"><a class="header" href="#23-treewalker-节点跳跃">2.3 TreeWalker 节点跳跃</a></h3>
<p>TreeWalker 真正的威力是可以在 DOM 结构中四处游走。如果不使用过滤器，单纯使用 TreeWalker 的漫游能力同样可以在 DOM 树中访问<code>&lt;li&gt;</code>元素：</p>
<pre><code class="language-js">let div = document.getElementById('div1')
let walker = document.createTreeWalker(
  div,
  NodeFilter.SHOW_ELEMENT,
  null,
  false
)
walker.firstChild() // 前往&lt;p&gt;
walker.nextSibling() // 前往&lt;ul&gt;
let node = walker.firstChild() // 前往第一个&lt;li&gt;
while (node !== null) {
  console.log(node.tagName)
  node = walker.nextSibling()
}
</code></pre>
<p>TreeWalker 类型也有一个名为 currentNode 的属性，表示遍历过程中上一次返回的节点（无论使用的是哪个遍历方法）。可以通过修改这个属性来影响接下来遍历的起点：</p>
<pre><code class="language-js">let node = walker.nextNode()
console.log(node === walker.currentNode) // true
walker.currentNode = document.body // 修改起点
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="053-dom-基础-dom-事件"><a class="header" href="#053-dom-基础-dom-事件">05.3-DOM 基础-DOM 事件</a></h1>
<h2 id="一-事件的基本概念"><a class="header" href="#一-事件的基本概念">一 事件的基本概念</a></h2>
<p>浏览器中的 JS 是以事件驱动为核心的一门语言，事件即是可以被 JavaScript 侦测到的行为，是一种触发-响应机制。</p>
<p>网页中的每个元素都可以通过行为触发相应的事件，如：点击按钮--&gt;产生事件---&gt;执行操作。</p>
<p>事件的三要素是：事件源、事件、事件处理程序，如下所示：</p>
<pre><code class="language-js">let btn = document.querySelector('#btn')

// btn 为事件源、click 为事件，绑定的函数为事件处理程序
btn.onclick = function () {
  console.log('btn 被点击了')
}
</code></pre>
<p>事件的触发一般对应 on 前缀开头，常见事件有：</p>
<pre><code class="language-txt">click       鼠标单击
dbclick     鼠标双击
mouseover   鼠标悬停
mouseout    鼠标移除
change      文本内容或下拉菜单中的选项发生改变
keyup       按下并释放键盘上的一个健
focus       获得焦点
blur        失去焦点
load        网页文档加载事件
unload      关闭网页时
submit      表单提交事件
reset       重置表单时

贴士：
mouseover/mouseout：会触发多次，每遇到一个子元素就会触发一次。
mouseenter/mouseleave：只会触发一次。
</code></pre>
<p>事件函数中的 this 代表调用者本身：</p>
<pre><code class="language-js">btn.onclick = function () {
  // btn.disabled = true;
  this.disabled = true // 作用同上
}
</code></pre>
<h2 id="二-事件绑定与取消"><a class="header" href="#二-事件绑定与取消">二 事件绑定与取消</a></h2>
<h3 id="21-dom0-和-dom2-级事件绑定与取消"><a class="header" href="#21-dom0-和-dom2-级事件绑定与取消">2.1 DOM0 和 DOM2 级事件绑定与取消</a></h3>
<p>有两种事件绑定方式：</p>
<pre><code class="language-js">// DOM0 级事件绑定方式：多次绑定会覆盖前一次事件执行函数
obj.onclick = function () {} // 绑定事件
obj.onclick = function () {} // 再次绑定会覆盖前者
obj.onclick = null // 取消绑定

// DOM2 级事件绑定方式（监听）：多次绑定多不会覆盖前一次事件执行函数，多个函数会依次触发
obj.addEventListener('click', function () {}, false) // 绑定事件
obj.removeEventListener('click', function () {}, false) // 取消绑定
</code></pre>
<h3 id="22-ie8-中的事件绑定与取消"><a class="header" href="#22-ie8-中的事件绑定与取消">2.2 IE8 中的事件绑定与取消</a></h3>
<p>现在的主流浏览器都已经支持 DOM2 级事件，但是 IE8 不支持，而是实现了类似的两个方法：<code>attachEvent()/detachEvent()</code></p>
<pre><code class="language-js">// 只有两个参数：参数一为事件，带 on；参数二为事件处理函数，但是该函数在全局作用域运行！！！，即其 this 为 window
// 多次绑定会按照相反的顺序执行！！！
// 这 2 个事件只支持事件冒泡！！！
obj.attachEvent('onclick', function () {
  console.log(this === window) // true
})
</code></pre>
<h3 id="23-兼容工具"><a class="header" href="#23-兼容工具">2.3 兼容工具</a></h3>
<p>下面的工具类可以做到兼容：</p>
<pre><code class="language-js">let EventUtil = {
  addHandler: function (element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false)
      return
    }

    if (element.attachEvent) {
      element.attachEvent('on' + type, handler)
      return
    }

    element['on' + type] = handler
  },
  removeHandler: function (element, type, handler) {
    if (element.removeEventListener) {
      element.addEventListener(type, handler, false)
      return
    }

    if (element.detacheEvent) {
      element.detacheEvent('on' + type, handler)
      handler.call(element)
      return
    }

    element['on' + type] = null
  },
}
</code></pre>
<h2 id="三-事件对象"><a class="header" href="#三-事件对象">三 事件对象</a></h2>
<p>当一个事件发生时，事件的详细信息（属性、方法）都会保存到一个对象中，这个事件对象即 event 对象。</p>
<pre><code class="language-html">&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  let div = document.querySelector('#div')
  div.onclick = function (e) {
    console.log(e)
  }
&lt;/script&gt;
</code></pre>
<p>只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完成，event 对象就会被销毁。</p>
<p>事件对象仍然有兼容问题，IE8 中，事件对象直接位于 window 中！兼容的写法如下：</p>
<pre><code class="language-js">// 事件处理函数
function(e){
  e = e || window.event
}
</code></pre>
<p><img src="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/dom/03.png" alt="常见事件对象属性" /></p>
<p>兼容事件对象：</p>
<pre><code class="language-js">const EventUtil = {
  addHandler: function (element, type, handler) {
    // 为节省版面，删除了之前的代码
  },
  getEvent: function (event) {
    return event ? event : window.event
  },
  getTarget: function (event) {
    return event.target || event.srcElement
  },
  preventDefault: function (event) {
    if (event.preventDefault) {
      event.preventDefault()
    } else {
      event.returnValue = false
    }
  },
  removeHandler: function (element, type, handler) {
    // 为节省版面，删除了之前的代码
  },
  stopPropagation: function (event) {
    if (event.stopPropagation) {
      event.stopPropagation()
    } else {
      event.cancelBubble = true
    }
  },
}
</code></pre>
<h2 id="四-事件调用者"><a class="header" href="#四-事件调用者">四 事件调用者</a></h2>
<p>在事件处理程序内部，this 其实是绑定事件的对象，即 <code>e.currentTarget</code>，而 <code>e.target</code> 则是触发事件的真实对象。</p>
<pre><code class="language-html">&lt;div id=&quot;div&quot;&gt;
  &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
  &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  let div = document.querySelector('#div1')
  div.onclick = function (e) {
    e = e || window.event
    // 本处示例点击 div1
    console.log(e.target === document.querySelector('#div1')) // true
    console.log(e.currentTarget === this) // true
    console.log(e.target === this) // false
  }
&lt;/script&gt;
</code></pre>
<h2 id="五-阻止事件的默认行为"><a class="header" href="#五-阻止事件的默认行为">五 阻止事件的默认行为</a></h2>
<p>当一个事件发生时，浏览器会默认做一些事情，比如点击链接就会发生跳转，这些默认行为也是可以阻止的：</p>
<ul>
<li>方式一：适用于 on 方式绑定的事件函数，在事件处理函数中使用 <code>return false</code></li>
<li>方式二：如果事件是以 addEventListner 绑定，那么在事件处理函数中添加：<code>event.preventDefault();</code></li>
</ul>
<p>注意：只有事件的 cancelable 属性为 true，才能使用 <code>preventDefault()</code> 方法取消默认行为。</p>
<h2 id="六-事件模拟"><a class="header" href="#六-事件模拟">六 事件模拟</a></h2>
<h3 id="61-dom-事件模拟概述"><a class="header" href="#61-dom-事件模拟概述">6.1 DOM 事件模拟概述</a></h3>
<p>可以通过 JavaScript 在任何时候触发任意事件，而这些事件会被当成浏览器创建的事件。这意味着同样会有事件冒泡，因而也会触发相应的事件处理程序。这种能力在测试 Web 应用时特别有用。 DOM3 规范指明了模拟特定类型事件的方式。</p>
<p>document.createEvent()方法可以创建一个 event 对象。这个方法接收一个参数，此参数是一个表示要创建事件类型的字符串。在 DOM2 中，所有这些字符串都是英文复数形式，但在 DOM3 中，又把它们改成了英文单数形式。可用的字符串值是以下值之一。</p>
<ul>
<li>&quot;UIEvents&quot;（ DOM3 中是&quot;UIEvent&quot;）：通用用户界面事件（鼠标事件和键盘事件都继承自这个事件）。</li>
<li>&quot;MouseEvents&quot;（ DOM3 中是&quot;MouseEvent&quot;）：通用鼠标事件。</li>
<li>&quot;HTMLEvents&quot;（ DOM3 中没有）：通用 HTML 事件（ HTML 事件已经分散到了其他事件大类中）</li>
</ul>
<p>注意，键盘事件不是在 DOM2 Events 中规定的，而是后来在 DOM3 Events 中增加的。</p>
<p>创建 event 对象之后，需要使用事件相关的信息来初始化。每种类型的 event 对象都有特定的方法，可以使用相应数据来完成初始化。方法的名字并不相同，这取决于调用 createEvent()时传入的参数。</p>
<p>事件模拟的最后一步是触发事件。为此要使用 dispatchEvent()方法，这个方法存在于所有支持事件的 DOM 节点之上。 dispatchEvent()方法接收一个参数，即表示要触发事件的 event 对象。调用 dispatchEvent()方法之后，事件就“转正”了，接着便冒泡并触发事件处理程序执行。</p>
<h3 id="62-模拟鼠标事件"><a class="header" href="#62-模拟鼠标事件">6.2 模拟鼠标事件</a></h3>
<p>模拟鼠标事件需要先创建一个新的鼠标 event 对象，然后再使用必要的信息对其进行初始化。要创建鼠标 event 对象，可以调用 createEvent()方法并传入&quot;MouseEvents&quot;参数。这样就会返回一个 event 对象，这个对象有一个 initMouseEvent()方法，用于为新对象指定鼠标的特定信息。</p>
<p>initMouseEvent()方法接收 15 个参数，分别对应鼠标事件会暴露的属性。这些参数列举如下：</p>
<ul>
<li>type（字符串）：要触发的事件类型，如&quot;click&quot;。</li>
<li>bubbles（布尔值）：表示事件是否冒泡。为精确模拟鼠标事件，应该设置为 true。</li>
<li>cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为 true。</li>
<li>view（ AbstractView）：与事件关联的视图。基本上始终是 document.defaultView。</li>
<li>detail（整数）：关于事件的额外信息。只被事件处理程序使用，通常为 0。</li>
<li>screenX（整数）：事件相对于屏幕的 x 坐标。</li>
<li>screenY（整数）：事件相对于屏幕的 y 坐标。</li>
<li>clientX（整数）：事件相对于视口的 x 坐标。</li>
<li>clientY（整数）：事件相对于视口的 y 坐标。</li>
<li>ctrlkey（布尔值）：表示是否按下了 Ctrl 键。默认为 false。</li>
<li>altkey（布尔值）：表示是否按下了 Alt 键。默认为 false。</li>
<li>shiftkey（布尔值）：表示是否按下了 Shift 键。默认为 false。</li>
<li>metakey（布尔值）：表示是否按下了 Meta 键。默认为 false。</li>
<li>button（整数）：表示按下了哪个按钮。默认为 0。</li>
<li>relatedTarget（对象）：与事件相关的对象。只在模拟 mouseover 和 mouseout 时使用。</li>
</ul>
<p>显然， initMouseEvent()方法的这些参数与鼠标事件的 event 对象属性是一一对应的。前 4 个参数是正确模拟事件唯一重要的几个参数，这是因为它们是浏览器要用的，其他参数则是事件处理程序要用的。 event 对象的 target 属性会自动设置为调用 dispatchEvent()方法时传入的节点。下面来看一个使用默认值模拟单击事件的例子：</p>
<pre><code class="language-js">let btn = document.getElementById('myBtn')
// 创建 event 对象
let event = document.createEvent('MouseEvents')
// 初始化 event 对象
event.initMouseEvent(
  'click',
  true,
  true,
  document.defaultView,
  0,
  0,
  0,
  0,
  0,
  false,
  false,
  false,
  false,
  0,
  null
)
// 触发事件
btn.dispatchEvent(event)
</code></pre>
<p>所有鼠标事件，包括 dblclick 都可以像这样在 DOM 合规的浏览器中模拟出来。</p>
<h3 id="63-模拟键盘事件"><a class="header" href="#63-模拟键盘事件">6.3 模拟键盘事件</a></h3>
<p>DOM2 Events 中没有定义键盘事件，因此模拟键盘事件并不直观。键盘事件曾在 DOM2 Events 的草案中提到过，但最终成为推荐标准前又被删掉了。要注意的是， DOM3 Events 中定义的键盘事件与 DOM2 Events 草案最初定义的键盘事件差别很大。</p>
<p>在 DOM3 中创建键盘事件的方式是给 createEvent()方法传入参数&quot;KeyboardEvent&quot;。这样会返回一个 event 对象，这个对象有一个 initKeyboardEvent()方法。这个方法接收以下参数。</p>
<ul>
<li>type（字符串）：要触发的事件类型，如&quot;keydown&quot;。</li>
<li>bubbles（布尔值）：表示事件是否冒泡。为精确模拟键盘事件，应该设置为 true。</li>
<li>cancelable（布尔值）：表示事件是否可以取消。为精确模拟键盘事件，应该设置为 true。</li>
<li>view（ AbstractView）：与事件关联的视图。基本上始终是 document.defaultView。</li>
<li>key（字符串）：按下按键的字符串代码。</li>
<li>location（整数）：按下按键的位置。 0 表示默认键， 1 表示左边， 2 表示右边， 3 表示数字键盘，4 表示移动设备（虚拟键盘）， 5 表示游戏手柄。</li>
<li>modifiers（字符串）：空格分隔的修饰键列表，如&quot;Shift&quot;。</li>
<li>repeat（整数）：连续按了这个键多少次</li>
</ul>
<p>注意， DOM3 Events 废弃了 keypress 事件，因此只能通过上述方式模拟 keydown 和 keyup 事件：</p>
<pre><code class="language-js">let textbox = document.getElementById('myTextbox'),
  event
// 按照 DOM3 的方式创建 event 对象
if (document.implementation.hasFeature('KeyboardEvents', '3.0')) {
  event = document.createEvent('KeyboardEvent')
  // 初始化 event 对象
  event.initKeyboardEvent(
    'keydown',
    true,
    true,
    document.defaultView,
    'a',
    0,
    'Shift',
    0
  )
}
// 触发事件
textbox.dispatchEvent(event)
</code></pre>
<p>这个例子模拟了同时按住 Shift 键和键盘上 A 键的 keydown 事件。在使用 document.createEvent(&quot;KeyboardEvent&quot;)之前，最好检测一下浏览器对 DOM3 键盘事件的支持情况，其他浏览器会返回非标准的 KeyboardEvent 对象。</p>
<p>Firefox 允许给 createEvent()传入&quot;KeyEvents&quot;来创建键盘事件。这时候返回的 event 对象包含的方法叫 initKeyEvent()，此方法接收以下 10 个参数。</p>
<ul>
<li>type（字符串）：要触发的事件类型，如&quot;keydown&quot;。</li>
<li>bubbles（布尔值）：表示事件是否冒泡。为精确模拟键盘事件，应该设置为 true。</li>
<li>cancelable（布尔值）：表示事件是否可以取消。为精确模拟键盘事件，应该设置为 true。</li>
<li>view（ AbstractView）：与事件关联的视图，基本上始终是 document.defaultView。</li>
<li>ctrlkey（布尔值）：表示是否按下了 Ctrl 键。默认为 false。</li>
<li>altkey（布尔值）：表示是否按下了 Alt 键。默认为 false。</li>
<li>shiftkey（布尔值）：表示是否按下了 Shift 键。默认为 false。</li>
<li>metakey（布尔值）：表示是否按下了 Meta 键。默认为 false。</li>
<li>keyCode（整数）：表示按下或释放键的键码。在 keydown 和 keyup 中使用。默认为 0。</li>
<li>charCode（整数）：表示按下键对应字符的 ASCII 编码。在 keypress 中使用。默认为 0</li>
</ul>
<p>键盘事件也可以通过调用 dispatchEvent()并传入 event 对象来触发，比如：</p>
<pre><code class="language-js">// 仅适用于 Firefox
let textbox = document.getElementById('myTextbox')
// 创建 event 对象
let event = document.createEvent('KeyEvents')
// 初始化 event 对象
event.initKeyEvent(
  'keydown',
  true,
  true,
  document.defaultView,
  false,
  false,
  true,
  false,
  65,
  65
)
// 触发事件
textbox.dispatchEvent(event)
</code></pre>
<p>这个例子模拟了同时按住 Shift 键和键盘上 A 键的 keydown 事件。同样也可以像这样模拟 keyup 和 keypress 事件。</p>
<p>对于其他浏览器，需要创建一个通用的事件，并为其指定特定于键盘的信息，如下面的例子所示：</p>
<pre><code class="language-js">let textbox = document.getElementById('myTextbox')
// 创建 event 对象
let event = document.createEvent('Events')
// 初始化 event 对象
event.initEvent(type, bubbles, cancelable)
event.view = document.defaultView
event.altKey = false
event.ctrlKey = false
event.shiftKey = false
event.metaKey = false
event.keyCode = 65
event.charCode = 65
// 触发事件
textbox.dispatchEvent(event)
</code></pre>
<p>以上代码创建了一个通用事件，然后使用 initEvent()方法初始化，接着又为它指定了键盘事件信息。这里必须使用通用事件而不是用户界面事件，因为用户界面事件不允许直接给 event 对象添加属性（ Safari 例外）。像这样模拟一个事件虽然会触发键盘事件，但文本框中不会输入任何文本，因为它并不能准确模拟键盘事件。</p>
<h3 id="64-模拟其他事件"><a class="header" href="#64-模拟其他事件">6.4 模拟其他事件</a></h3>
<p>鼠标事件和键盘事件是浏览器中最常见的模拟对象。不过，有时候可能也需要模拟 HTML 事件。模拟 HTML 事件要调用 createEvent()方法并传入&quot;HTMLEvents&quot;， 然后再使用返回对象的 initEvent()方法来初始化：</p>
<pre><code class="language-js">let event = document.createEvent('HTMLEvents')
event.initEvent('focus', true, false)
target.dispatchEvent(event)
</code></pre>
<p>这个例子模拟了在给定目标上触发 focus 事件。其他 HTML 事件也可以像这样来模拟。</p>
<h3 id="65-自定义-dom-事件"><a class="header" href="#65-自定义-dom-事件">6.5 自定义 DOM 事件</a></h3>
<p>DOM3 增加了自定义事件的类型。自定义事件不会触发原生 DOM 事件，但可以让开发者定义自己的事件 。 要创建自定义事件，需要调用 createEvent(&quot;CustomEvent&quot;) 。 返回的对象包含 initCustomEvent()方法，该方法接收以下 4 个参数：</p>
<ul>
<li>type（字符串）：要触发的事件类型，如&quot;myevent&quot;。</li>
<li>bubbles（布尔值）：表示事件是否冒泡。</li>
<li>cancelable（布尔值）：表示事件是否可以取消。</li>
<li>detail（对象）：任意值。作为 event 对象的 detail 属性。</li>
</ul>
<p>自定义事件可以像其他事件一样在 DOM 中派发，比如：</p>
<pre><code class="language-js">let div = document.getElementById('myDiv'),
  event
div.addEventListener('myevent', (event) =&gt; {
  console.log('DIV: ' + event.detail)
})
document.addEventListener('myevent', (event) =&gt; {
  console.log('DOCUMENT: ' + event.detail)
})
if (document.implementation.hasFeature('CustomEvents', '3.0')) {
  event = document.createEvent('CustomEvent')
  event.initCustomEvent('myevent', true, false, 'Hello world!')
  div.dispatchEvent(event)
}
</code></pre>
<p>这个例子创建了一个名为&quot;myevent&quot;的冒泡事件。 event 对象的 detail 属性就是一个简单的字符串， <code>&lt;div&gt;</code> 元素和 document 都为这个事件注册了事件处理程序。因为使用 initCustomEvent()初始化时将事件指定为可以冒泡，所以浏览器会负责把事件冒泡到 document。</p>
<h3 id="66-ie8-事件模拟"><a class="header" href="#66-ie8-事件模拟">6.6 IE8 事件模拟</a></h3>
<p>在 IE8 及更早版本中模拟事件的过程与 DOM 方式类似：创建 event 对象，指定相应信息，然后使用这个对象触发。当然， IE 实现每一步的方式都不一样。</p>
<p>首先，要使用 document 对象的 createEventObject()方法来创建 event 对象。与 DOM 不同，这个方法不接收参数，返回一个通用 event 对象。然后，可以手工给返回的对象指定希望该对象具备的所有属性。（没有初始化方法。）最后一步是在事件目标上调用 fireEvent()方法，这个方法接收两个参数：事件处理程序的名字和 event 对象。调用 fireEvent()时， srcElement 和 type 属性会自动指派到 event 对象（其他所有属性必须手工指定）。这意味着 IE 支持的所有事件都可以通过相同的方式来模拟。例如，下面的代码在一个按钮上模拟了 click 事件：</p>
<pre><code class="language-js">var btn = document.getElementById('myBtn')
// 创建 event 对象
var event = document.createEventObject()
/// 初始化 event 对象
event.screenX = 100
event.screenY = 0
event.clientX = 0
event.clientY = 0
event.ctrlKey = false
event.altKey = false
event.shiftKey = false
event.button = 0
// 触发事件
btn.fireEvent('onclick', event)
</code></pre>
<p>这个例子先创建 event 对象，然后用相关信息对其进行了初始化。注意，这里可以指定任何属性，包括 IE8 及更早版本不支持的属性。这些属性的值对于事件来说并不重要，因为只有事件处理程序才会使用它们。</p>
<p>同样的方式也可以用来模拟 keypress 事件，如下面的例子所示：</p>
<pre><code class="language-js">var textbox = document.getElementById('myTextbox')
// 创建 event 对象
var event = document.createEventObject()
// 初始化 event 对象
event.altKey = false
event.ctrlKey = false
event.shiftKey = false
event.keyCode = 65
// 触发事件
textbox.fireEvent('onkeypress', event)
</code></pre>
<p>由于鼠标事件、键盘事件或其他事件的 event 对象并没有区别，因此使用通用的 event 对象可以触发任何类型的事件。注意，与 DOM 方式模拟键盘事件一样，这里模拟的 keypress 虽然会触发，但文本框中也不会出现字符。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="054-dom-基础-事件流"><a class="header" href="#054-dom-基础-事件流">05.4-DOM 基础-事件流</a></h1>
<h2 id="一-事件流概念"><a class="header" href="#一-事件流概念">一 事件流概念</a></h2>
<p>事件发生时，会在元素节点之间按照一定的顺序进行向外、向内传播，页面接收事件的顺序即为事件流。</p>
<p>在早期的浏览器，事件流的表现不同。IE 认为事件是从最具体的元素（最深节点）触发，然后向外传播至没有那么具体的元素（文档），这便是<strong>事件冒泡</strong>。而网景团队认为最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件，这是<strong>事件捕获行为</strong>。</p>
<p>DOM2 规范了事件流，有三个阶段：</p>
<ul>
<li>第一阶段：捕获阶段 (event capturing)</li>
<li>第二阶段：当前目标阶段</li>
<li>第三阶段：冒泡阶段 (event bubbling)</li>
</ul>
<p>如图所示：
<img src="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/dom/02.png" alt="事件流" /></p>
<p>在 DOM 事件流中，实际的目标（ <code>&lt;div&gt;</code>元素）在捕获阶段不会接收到事件。这是因为捕获阶段从 document 到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>就结束了。下一阶段，即会在<code>&lt;div&gt;</code>元素上触发事件的“到达目标”阶段，通常在事件处理时被认为是冒泡阶段的一部分。</p>
<p>虽然 DOM2 Events 规范明确捕获阶段不命中事件目标，但现代浏览器都会在捕获阶段在事件目标上触发事件。最终结果是在事件目标上有两个机会来处理事件。</p>
<h2 id="二-事件捕获与事件冒泡"><a class="header" href="#二-事件捕获与事件冒泡">二 事件捕获与事件冒泡</a></h2>
<h3 id="21-事件捕获"><a class="header" href="#21-事件捕获">2.1 事件捕获</a></h3>
<p>如下示例中，给子元素添加了点击事件，第三个参数 true，即代表处于捕获阶段。当点击 son 元素后，document 开始捕获，但是 document 没有绑定点击事件函数，跳过依次进入 html 元素、body 元素、father 元素、son 元素，在 father、son 元素处发现了点击事件函数，则执行：</p>
<pre><code class="language-html">&lt;div id=&quot;father&quot; style=&quot;height: 200px; width: 200px; background-color: aqua&quot;&gt;
  &lt;div
    id=&quot;son&quot;
    style=&quot;height: 100px; width: 100px; background-color: coral&quot;
  &gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  let father = document.querySelector('#father')
  let son = document.querySelector('#son')
  father.addEventListener(
    'click',
    function () {
      console.log('father...')
    },
    true
  )
  son.addEventListener(
    'click',
    function () {
      console.log('son...')
    },
    true
  )
&lt;/script&gt;
</code></pre>
<p>点击 son 元素区域，则输出：</p>
<pre><code class="language-txt">father...
son...
</code></pre>
<p>贴士：浏览器都是从 window 对象开始捕获事件，而 DOM2 Events 规范规定的是从 document 开始。</p>
<h3 id="22-事件冒泡"><a class="header" href="#22-事件冒泡">2.2 事件冒泡</a></h3>
<p>事件冒泡：多个元素嵌套，都注册了相同的事件，那么如果里面的元素触发了事件，则外面的元素都会自动触发该事件。即：当一个元素接收到事件的时候，会把接收到的所有事件传播给父级，一直到顶级 window。</p>
<p>事件捕获的案例中，如果事件处理函数第三个参数改为 false，则支持冒泡，输出结果为：</p>
<pre><code class="language-txt">son...
father...
</code></pre>
<p>现代浏览器中的事件会一直冒泡到 window 对象。</p>
<p>注意：一些事件是没有冒泡的，如：oblur、onfocus、onmouseenter、onmouseleave</p>
<h2 id="三-阻止事件传播"><a class="header" href="#三-阻止事件传播">三 阻止事件传播</a></h2>
<h3 id="31-阻止事件传播方式"><a class="header" href="#31-阻止事件传播方式">3.1 阻止事件传播方式</a></h3>
<p>stopPropagation() 方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用 stopPropagation()，从而避免触发注册在 document.body 上面的事件处理程序：</p>
<pre><code class="language-js">let btn = document.querySelector('#myBtn')

btn.onclick = function (event) {
  alert('Clicked')
  event.stopPropagation()
}

document.body.onclick = function (event) {
  alert('Body clicked')
}
</code></pre>
<p>IE8 仍然有兼容问题，其阻止冒泡的方式为：<code>event.cancelBubble = true;</code>。</p>
<h3 id="32-阻止事件传播方式的兼容写法"><a class="header" href="#32-阻止事件传播方式的兼容写法">3.2 阻止事件传播方式的兼容写法</a></h3>
<p>在 IE 中，returnValue 属性设置为 false 可以用来阻止元素默认行为，cancelBubble 属性用来停止冒泡。</p>
<pre><code class="language-js">let EventUtil = {
  // ... 省略之前的 addHandler  removeHandler 代码

  getEvent: function (event) {
    return event ? event : window.event
  },

  getTarget: function (event) {
    return event.target || event.srcElement
  },

  preventDefault: function (event) {
    if (event.preventDefault) {
      event.preventDefault()
    } else {
      event.returnValue = false
    }
  },

  stopPropagation: function (event) {
    if (event.stopPropagation) {
      event.stopPropagation()
    } else {
      event.cancelBubble = true
    }
  },
}
</code></pre>
<h2 id="四-性能优化与事件委托"><a class="header" href="#四-性能优化与事件委托">四 性能优化与事件委托</a></h2>
<p>在网页中，如果添加大量的事件处理程序，会影响页面的性能，事件委托能很好的解决该问题。</p>
<blockquote>
<p>事件委托：只指定一个事件处理程序，就可以管理某一类型的所有事件，背后原理是事件冒泡</p>
</blockquote>
<pre><code class="language-html">&lt;div id=&quot;div&quot;&gt;
  &lt;div id=&quot;div1&quot;&gt;111&lt;/div&gt;
  &lt;div id=&quot;div2&quot;&gt;222&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  // 如果要为 div1，div2 都添加相同的点击事件，显然是不合理的
  // 只需要在 DOM 的最高层级添加事件处理程序即可
  let div = document.querySelector('#div')
  div.onclick = function (e) {
    if (e.target.id == 'div1') {
      console.log('div1 click....')
      return
    }

    if (e.target.id == 'div2') {
      console.log('div2 click....')
      return
    }

    console.log('div click...')
  }
&lt;/script&gt;
</code></pre>
<p>事件委托的好处即解决了性能问题：</p>
<ul>
<li>函数即对象，大量函数会占用较高内存，事件委托可以明显减少函数数量</li>
<li>事件处理函数位于更高等级的 DOM 中，比如 document，可以很快访问到</li>
</ul>
<p>最适合使用事件委托的事件包括： click、 mousedown、 mouseup、 keydown 和 keypress。mouseover 和 mouseout 事件冒泡，但很难适当处理，且经常需要计算元素位置（因为 mouseout 会在光标从一个元素移动到它的一个后代节点以及移出元素之外时触发）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="055-dom-基础-坐标操作"><a class="header" href="#055-dom-基础-坐标操作">05.5-DOM 基础-坐标操作</a></h1>
<h2 id="一-坐标相关操作"><a class="header" href="#一-坐标相关操作">一 坐标相关操作</a></h2>
<h3 id="11-偏移尺寸-offset"><a class="header" href="#11-偏移尺寸-offset">1.1 偏移尺寸 offset</a></h3>
<p>offset 即偏移量，可以用来动态获取元素的偏移位置、大小，主要属性包括：</p>
<pre><code class="language-txt">offsetWidth     返回自身的宽度（width + padding + boder），与他人无关。结果不带单位！
offsetHight     返回自身的高度（height + padding + boder），与他人无关。结果不带单位！
offsetTop       返回距离最近带定位父盒上方的偏移量，且从父亲的 padding 开始算，若父级没有定位则以 body 为准
offsetLeft      返回距离最近带定位父盒左侧的偏移量，且从父亲的 padding 开始算，若父级没有定位则以 body 为准
offsetParent    返回父级盒子中最近的带有定位的父盒子节点，若父级没有定位则以 body 为准。元素自身定位为 fixed，则为 null
</code></pre>
<p>如图所示：</p>
<p><img src="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/dom/offset-1.png" alt="offset" /></p>
<p>注意：<strong>元素.style.height 是无法获取高度的，因为元素还会有内容撑开，但是元素使用内嵌式设置高度可以获取:<code>&lt;div style=”height:50px;”&gt;</code></strong></p>
<p>offset 与 style 区别：</p>
<ul>
<li>offset 系列可以返回没有定位盒子的距离上/左的位置（四舍五入取整），<code>style.</code> 不可以（因为只有定位的盒子才有 left、top 之类的值）；</li>
<li>offset 系列返回的是数字，而 <code>style.</code> 返回的是字符串 + 单位 px；</li>
<li>offset 系列只可获取值，而 <code>style.</code> 还可以赋值；</li>
<li>如果没有给 HTML 元素指定过 类似 top 样式，则类似 <code>style.top</code> 返回的是空字符串。</li>
</ul>
<p>要确定一个元素在页面中的偏移量，可以把它的 offsetLeft 和 offsetTop 属性分别与 offsetParent 的相同属性相加，一直加到根元素：</p>
<pre><code class="language-js">function getElementLeft(element) {
  let actualLeft = element.offsetLeft
  let current = element.offsetParent
  while (current !== null) {
    actualLeft += current.offsetLeft
    current = current.offsetParent
  }
  return actualLeft
}

function getElementTop(element) {
  let actualTop = element.offsetTop
  let current = element.offsetParent
  while (current !== null) {
    actualTop += current.offsetTop
    current = current.offsetParent
  }
  return actualTop
}
</code></pre>
<h3 id="12-客户端尺寸-client"><a class="header" href="#12-客户端尺寸-client">1.2 客户端尺寸 client</a></h3>
<p>client 的相关属性用来获取元素的可视区信息，如元素的边框大小、元素大小等：</p>
<pre><code class="language-txt">clientWidth     返回自身包括 padding、内容宽度。数值不带单位。
clientHight     返回自身包括 padding、内容高度。数值不带单位。
clientTop       返回元素上边框大小
clientLeft      返回元素左边框大小
</code></pre>
<p>如图所示：</p>
<p><img src="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/dom/client-1.png" alt="offset" /></p>
<h3 id="13-滚动尺寸-scroll"><a class="header" href="#13-滚动尺寸-scroll">1.3 滚动尺寸 scroll</a></h3>
<p>scroll 用来动态获取元素大小、滚动距离：</p>
<pre><code class="language-txt">scrollWidth     返回自身实际宽度，不含边框，数值不带单位
scrollHight     返回自身实际高度，不含边框，数值不带单位
scrollTop       返回被卷去的上侧距离，数值不带单位
scrollLeft      返回被卷去的左侧距离，数值不带单位
</code></pre>
<p>如图所示：</p>
<p><img src="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/dom/scroll-1.png" alt="scroll" /></p>
<p>scrollWidth 和 scrollHeight 可以用来确定给定元素内容的实际尺寸。例如， <code>&lt;html&gt;</code>元素是浏览器中滚动视口的元素。因此，document.documentElement.scrollHeight 就是整个页面垂直方向的总高度。</p>
<p>scrollWidth 和 scrollHeight 与 clientWidth 和 clientHeight 之间的关系在不需要滚动的文档上是分不清的。如果文档尺寸超过视口尺寸，则在所有主流浏览器中这两对属性都不相等，scrollWidth 和 scollHeight 等于文档内容的宽度，而 clientWidth 和 clientHeight 等于视口的大小。</p>
<p>scrollLeft 和 scrollTop 属性可以用于确定当前元素滚动的位置，或者用于设置它们的滚动位置。元素在未滚动时，这两个属性都等于 0。如果元素在垂直方向上滚动，则 scrollTop 会大于 0，表示元素顶部不可见区域的高度。如果元素在水平方向上滚动，则 scrollLeft 会大于 0，表示元素左侧不可见区域的宽度。因为这两个属性也是可写的，所以把它们都设置为 0 就可以重置元素的滚动位置。</p>
<p>下面这个函数检测元素是不是位于顶部，如果不是则把它滚动回顶部，可以利用 scrollTop 获取并设置值：</p>
<pre><code class="language-js">function scrollToTop(element) {
  if (element.scrollTop != 0) {
    element.scrollTop = 0
  }
}
</code></pre>
<p>window 对象提供了 <code>window.scrollTo()</code>方法。</p>
<h3 id="14-总结对比"><a class="header" href="#14-总结对比">1.4 总结对比</a></h3>
<pre><code class="language-txt">获取元素距离：如 offsetWidth，返回自身包括 padding、内容区宽度、边框，数值不带单位
获取元素大小：如 clientWitdh，返回自身包括 padding、内容区宽度，数值不带单位
获取滚动距离：如 scrollWidth，返回自身实际宽度，不喊边框，数值不带单位
</code></pre>
<h2 id="二-page"><a class="header" href="#二-page">二 page</a></h2>
<pre><code class="language-txt">pageY/pageX:
    以文档的左上角为基准点，很类似绝对定位，IE6/7/8 不支持。
screenY/screenX:
    以电脑屏幕为基准点；鼠标位于屏幕的上方和左侧的距离。
clientX/clientY:
    以可视区为基准点，很类似固定定位。鼠标位于浏览器的左侧和顶部的距离。（浏览器大小和位置）
</code></pre>
<p>pageY 和 pageX 的兼容写法：在页面位置就等于 = 看得见的 + 看不见的</p>
<pre><code class="language-js">pageX = event.clientX + scroll().left
pageY = event.clientY + scroll().top
</code></pre>
<h2 id="三-制作缓动动画脚本"><a class="header" href="#三-制作缓动动画脚本">三 制作缓动动画脚本</a></h2>
<pre><code class="language-js">// 缓动动画库
function slowAnimation(box, end) {
  // 防止重复点击造成定时器变化
  clearInterval(box.timer)
  // 设置定时器
  box.timer = setInterval(() =&gt; {
    if (box.offsetLeft === end) {
      clearInterval(box.timer)
      return
    }

    // 缓动公式：步长 = （结束值 - 起始值） / 系数
    let step = (end - box.offsetLeft) / 20
    // 步长大于 0，物体向左走，小于 0 物体向右走
    step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)

    // 设置元素位置
    box.style.left = box.offsetLeft + step + 'px'
  }, 30)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="056-dom-基础-范围操作"><a class="header" href="#056-dom-基础-范围操作">05.6-DOM 基础-范围操作</a></h1>
<h2 id="一-范围操作概念"><a class="header" href="#一-范围操作概念">一 范围操作概念</a></h2>
<p>为了支持对页面更细致的控制，DOM2 Traversal and Range 模块定义了范围接口。范围可用于在文档中选择内容，而不用考虑节点之间的界限，使用方式：</p>
<pre><code class="language-js">let range = document.createRange()
</code></pre>
<p>每个范围都是 Range 类型的实例，拥有相应的属性和方法：</p>
<pre><code class="language-txt">startContainer：范围起点所在的节点（选区中第一个子节点的父节点）。
startOffset：范围起点在 startContainer 中的偏移量。
            如果 startContainer 是文本节点、注释节点，指范围起点之前跳过的字符数；
            否则，表示范围中第一个节点的索引。
endContainer：范围终点所在的节点（选区中最后一个子节点的父节点）。
endOffset：范围起点在 startContainer 中的偏移量（与 startOffset 中偏移量的含义相同）。
commonAncestorContainer：文档中以 startContainer 和 endContainer 为后代的最深的节点。
</code></pre>
<h2 id="二-常见范围操作"><a class="header" href="#二-常见范围操作">二 常见范围操作</a></h2>
<h3 id="21-简单选择"><a class="header" href="#21-简单选择">2.1 简单选择</a></h3>
<p>选择文档中某个部分：</p>
<ul>
<li>selectNode()：选择整个节点，包括其后代节点</li>
<li>selectNodeContents()：只选择节点的后代</li>
</ul>
<p>示例：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;p id=&quot;p1&quot;&gt;
      &lt;b&gt;Hello&lt;/b&gt;
      world!
    &lt;/p&gt;
    &lt;script&gt;
      let p1 = document.getElementById('p1')

      let range1 = document.createRange()
      let range2 = document.createRange()

      range1.selectNode(p1)
      range2.selectNodeContents(p1)
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如图所示：
<img src="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/dom/04.png" alt="DOM 范围" /></p>
<p>调用 selectNode() 时，startContainer、endContainer 和 commonAncestorContainer 都等于传入节点的父节点。在这个例子中，这几个属性都等于 document.body。startOffset 属性等于传入节点在其父节点 childNodes 集合中的索引（在这个例子中，startOffset 等于 1，因为 DOM 的合规实现把空格当成文本节点），而 endOffset 等于 startOffset 加 1（因为只选择了一个节点）。</p>
<p>在调用 selectNodeContents() 时，startContainer、endContainer 和 commonAncestor Container 属性就是传入的节点，在这个例子中是 <code>&lt;p&gt;</code> 元素。startOffset 属性始终为 0，因为范围从传入 节点的第一个子节点开始，而 endOffset 等于传入节点的子节点数量（node.childNodes.length），在这个例子中等于 2。</p>
<p>还可以在范围上调用相应的方法：</p>
<pre><code class="language-txt">setStartBefore(refNode)：把范围的起点设置到 refNode 之前，从而让 refNode 成为选区的第一个子节点                       startContainer 属性被设置为 refNode.parentNode，而 startOffset
                        属性被设置为 refNode 在其父节点 childNodes 集合中的索引。

setStartAfter(refNode)：把范围的起点设置到 refNode 之后，从而将 refNode 排除在选区之外，
                        让其下一个同胞节点成为选区的第一个子节点。startContainer 属性被设置为 refNode.parentNode，
                        startOffset 属性被设置为 refNode 在其父节点 childNodes 集合中的索引加 1。

setEndBefore(refNode)：把范围的终点设置到 refNode 之前。
                        从而将 refNode 排除在选区之外、让其上一个同胞节点成为选区的最后一个子节点。
                        endContainer 属性被设置为 refNode.parentNode，endOffset 属性被设置为 refNode 在其父节点 childNodes 集合中的索引。

setEndAfter(refNode)：把范围的终点设置到 refNode 之后，从而让 refNode 成为选区的最后一个子节点。
                        endContainer 属性被设置为 refNode.parentNode
                        endOffset 属性被设置为 refNode 在其父节点 childNodes 集合中的索引加 1。
</code></pre>
<h3 id="22-复杂选择"><a class="header" href="#22-复杂选择">2.2 复杂选择</a></h3>
<p>要创建复杂的范围，需要使用 setStart() 和 setEnd() 方法。这两个方法都接收两个参数：参照节点和偏移量。对 setStart() 来说，参照节点会成为 startContainer，而偏移量会赋值给 startOffset。对 setEnd() 而言，参照节点会成为 endContainer，而偏移量会赋值给 endOffset。</p>
<p>使用这两个方法，可以模拟 selectNode() 和 selectNodeContents() 的行为：</p>
<pre><code class="language-js">let range1 = document.createRange(),
  range2 = document.createRange(),
  p1 = document.getElementById('p1'),
  p1Index = -1,
  i,
  len
for (i = 0, len = p1.parentNode.childNodes.length; i &lt; len; i++) {
  if (p1.parentNode.childNodes[i] === p1) {
    p1Index = i
    break
  }
}

range1.setStart(p1.parentNode, p1Index)
range1.setEnd(p1.parentNode, p1Index + 1)
range2.setStart(p1, 0)
range2.setEnd(p1, p1.childNodes.length)
</code></pre>
<p>要选择节点（使用 range1），必须先确定给定节点（p1）在其父节点 childNodes 集合中的索引。而要选择节点的内容（使用 range2），则不需要这样计算，因为可以直接给 setStart() 和 setEnd() 传默认值。虽然可以模拟 selectNode() 和 selectNodeContents()，但 setStart() 和 setEnd() 真正的威力还是选择节点中的某个部分。</p>
<p>假设我们想通过范围从前面示例中选择从&quot;Hello&quot;中的&quot;llo&quot;到&quot; world!&quot;中的&quot;o&quot;的部分。很简单，第一步是取得所有相关节点的引用，如下面的代码所示：</p>
<pre><code class="language-js">let p1 = document.getElementById('p1'),
  helloNode = p1.firstChild.firstChild,
  worldNode = p1.lastChild
</code></pre>
<p>文本&quot;Hello&quot;其实是 <code>&lt;p&gt;</code>的孙子节点，因为它是<code>&lt;b&gt;</code>的子节点。为此可以使用 p1.firstChild 取得<code>&lt;b&gt;</code>，而使用 p1.firstChild.firstChild 取得&quot;Hello&quot;这个文本节点。文本节点&quot; world!&quot;是<code>&lt;p&gt;</code>的第二个（也是最后一个）子节点，因此可以使用 p1.lastChild 来取得它。然后，再创建范围，指定其边界，如下所示：</p>
<pre><code class="language-js">let range = document.createRange()
range.setStart(helloNode, 2)
range.setEnd(worldNode, 3)
</code></pre>
<p>因为选区起点在&quot;Hello&quot;中的字母&quot;e&quot;之后，所以要给 setStart() 传入 helloNode 和偏移量 2（ &quot;e&quot;后面的位置， &quot;H&quot;的位置是 0）。要设置选区终点，则要给 setEnd() 传入 worldNode 和偏移量 3，即不属于选区的第一个字符的位置，也就是&quot;r&quot;的位置 3（位置 0 是一个空格），如下所示：</p>
<p><img src="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/dom/05.png" alt="DOM 范围" /></p>
<h3 id="23-操作范围"><a class="header" href="#23-操作范围">2.3 操作范围</a></h3>
<p>创建范围之后，浏览器会在内部创建一个文档片段节点，用于包含范围选区中的节点。为操作范围的内容，选区中的内容必须格式完好。在前面的例子中，因为范围的起点和终点都在文本节点内部，并不是完好的 DOM 结构，所以无法在 DOM 中表示。不过，范围能够确定缺失的开始和结束标签，从而可以重构出有效的 DOM 结构，以便后续操作。</p>
<p>仍以前面例子中的范围来说，范围发现选区中缺少一个开始的<code>&lt;b&gt;</code>标签，于是会在后台动态补上这个标签，同时还需要补上封闭&quot;He&quot;的结束标签<code>&lt;/b&gt;</code>，结果会把 DOM 修改为这样：</p>
<pre><code class="language-js">&lt;p&gt;
  &lt;b&gt;He&lt;/b&gt;
  &lt;b&gt;llo&lt;/b&gt; world!
&lt;/p&gt;
</code></pre>
<p>而且， &quot; world!&quot;文本节点会被拆分成两个文本节点，一个包含&quot; wo&quot;，另一个包含&quot;rld!&quot;。最终的 DOM 树如图：</p>
<p><img src="03-BOM%E4%B8%8EDOM%E7%BC%96%E7%A8%8B/../images/dom/06.png" alt="DOM 范围" /></p>
<p>这样创建了范围之后，就可以使用很多方法来操作范围的内容。（注意，范围对应文档片段中的所有节点，都是文档中相应节点的指针。）第一个方法最容易理解和使用：deleteContents()。顾名思义，这个方法会从文档中删除范围包含的节点。</p>
<pre><code class="language-js">let p1 = document.getElementById('p1'),
  helloNode = p1.firstChild.firstChild,
  worldNode = p1.lastChild,
  range = document.createRange()
range.setStart(helloNode, 2)
range.setEnd(worldNode, 3)
range.deleteContents()

// 执行结果：&lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt;
</code></pre>
<p>另一个方法 extractContents() 跟 deleteContents() 类似，也会从文档中移除范围选区。但不同的是，extractContents() 方法返回范围对应的文档片段。这样，就可以把范围选中的内容插入文档中其他地方：</p>
<pre><code class="language-js">let p1 = document.getElementById('p1'),
  helloNode = p1.firstChild.firstChild,
  worldNode = p1.lastChild,
  range = document.createRange()
range.setStart(helloNode, 2)
range.setEnd(worldNode, 3)
let fragment = range.extractContents()
p1.parentNode.appendChild(fragment)

// 结果：&lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt;&lt;b&gt;llo&lt;/b&gt; wo
</code></pre>
<p>如果不想把范围从文档中移除，也可以使用 cloneContents() 创建一个副本，然后把这个副本插入到文档其他地方：</p>
<pre><code class="language-js">let p1 = document.getElementById('p1'),
  helloNode = p1.firstChild.firstChild,
  worldNode = p1.lastChild,
  range = document.createRange()
range.setStart(helloNode, 2)
range.setEnd(worldNode, 3)
let fragment = range.cloneContents()
p1.parentNode.appendChild(fragment)

// 执行结果：&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt;&lt;b&gt;llo&lt;/b&gt; wo
</code></pre>
<h3 id="24-范围插入"><a class="header" href="#24-范围插入">2.4 范围插入</a></h3>
<p>使用 insertNode() 方法可以在范围选区的开始位置插入一个节点：</p>
<pre><code class="language-js">// &lt;span style=&quot;color: red&quot;&gt;Inserted text&lt;/span&gt;

let p1 = document.getElementById('p1'),
  helloNode = p1.firstChild.firstChild,
  worldNode = p1.lastChild,
  range = document.createRange()
range.setStart(helloNode, 2)
range.setEnd(worldNode, 3)
let span = document.createElement('span')
span.style.color = 'red'
span.appendChild(document.createTextNode('Inserted text'))
range.insertNode(span)
</code></pre>
<p>除了向范围中插入内容，还可以使用 surroundContents() 方法插入包含范围的内容，这种功能适合在网页中高亮显示某些关键词：</p>
<pre><code class="language-js">let p1 = document.getElementById('p1'),
  helloNode = p1.firstChild.firstChild,
  worldNode = p1.lastChild,
  range = document.createRange()
range.selectNode(helloNode)
let span = document.createElement('span')
span.style.backgroundColor = 'yellow'
range.surroundContents(span)
</code></pre>
<h3 id="25-范围折叠"><a class="header" href="#25-范围折叠">2.5 范围折叠</a></h3>
<p>如果范围并没有选择文档的任何部分，则称为折叠（collapsed）。折叠范围有点类似文本框：如果文本框中有文本，那么可以用鼠标选中以高亮显示全部文本。这时候，如果再单击鼠标，则选区会被移除，光标会落在某两个字符中间。而在折叠范围时，位置会被设置为范围与文档交界的地方，可能是范围选区的开始处，也可能是结尾处。</p>
<p>折叠范围可以使用 collapse() 方法，这个方法接收一个参数：布尔值，表示折叠到范围哪一端。true 表示折叠到起点，false 表示折叠到终点。要确定范围是否已经被折叠，可以检测范围的 collapsed 属性：</p>
<pre><code class="language-js">range.collapse(true) // 折叠到起点
console.log(range.collapsed) // 输出 true
</code></pre>
<p>测试范围是否被折叠，能够帮助确定范围中的两个节点是否相邻。例如有以下 HTML 代码：</p>
<pre><code class="language-js">// &lt;p id=&quot;p1&quot;&gt;Paragraph 1&lt;/p&gt;&lt;pid=&quot;p2&quot;&gt;Paragraph 2&lt;/pid&gt;
// 如果事先并不知道标记的结构（比如自动生成的标记），则可以像下面这样创建一个范围：
let p1 = document.getElementById('p1'),
  p2 = document.getElementById('p2'),
  range = document.createRange()
range.setStartAfter(p1)
range.setStartBefore(p2)
console.log(range.collapsed) // true
</code></pre>
<h3 id="26-范围比较"><a class="header" href="#26-范围比较">2.6 范围比较</a></h3>
<p>如果有多个范围，则可以使用 compareBoundaryPoints() 方法确定范围之间是否存在公共的边界（起点或终点）。</p>
<pre><code class="language-js">let range1 = document.createRange()
let range2 = document.createRange()
let p1 = document.getElementById('p1')
range1.selectNodeContents(p1)
range2.selectNodeContents(p1)
range2.setEndBefore(p1.lastChild)
console.log(range1.compareBoundaryPoints(Range.START_TO_START, range2)) // 0
console.log(range1.compareBoundaryPoints(Range.END_TO_END, range2)) // 1
</code></pre>
<h3 id="27-复制范围"><a class="header" href="#27-复制范围">2.7 复制范围</a></h3>
<p>调用范围的 cloneRange()方法可以复制范围。这个方法会创建调用它的范围的副本：</p>
<pre><code class="language-js">let newRange = range.cloneRange()
</code></pre>
<p>新范围包含与原始范围一样的属性，修改其边界点不会影响原始范围。</p>
<h3 id="28-清理"><a class="header" href="#28-清理">2.8 清理</a></h3>
<p>在使用完范围之后，最好调用 detach()方法把范围从创建它的文档中剥离。调用 detach()之后，就可以放心解除对范围的引用，以便垃圾回收程序释放它所占用的内存：</p>
<pre><code class="language-js">range.detach() // 从文档中剥离范围
range = null // 解除引用
</code></pre>
<p>这两步是最合理的结束使用范围的方式。剥离之后的范围就不能再使用了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="057-dom-基础-mutationobserver"><a class="header" href="#057-dom-基础-mutationobserver">05.7-DOM 基础-MutationObserver</a></h1>
<h2 id="一-mutationobserver-接口基本用法"><a class="header" href="#一-mutationobserver-接口基本用法">一 MutationObserver 接口基本用法</a></h2>
<h3 id="11-创建-mutationobserver-与-observe-方法"><a class="header" href="#11-创建-mutationobserver-与-observe-方法">1.1 创建 MutationObserver 与 observe 方法</a></h3>
<p>MutationObserver 是 H5 新增的接口，可以在 DOM 被修改时异步执行回调，用来观察整个文档、DOM 树、某个元素、元素属性等变化。该接口可以取代以前的 MutationEvent。</p>
<pre><code class="language-js">// 创建一个MutationObserver 的实例
let observer = new MutationObserver(
  (mutationRecords) =&gt; console.log('监控到改变：', mutationRecords) // 监控到变化后输出
)

// 实例方法 observe用来接收两个参数：要观察变化的DOM节点、MutationObserverInit 对象
observer.observe(document.body, { attributes: true })

// 测试属性变化
document.body.className = 'foo'
console.log('属性改变了') // 先输出
</code></pre>
<p>创建 MutationObserver 的实例的回调函数有两个参数：</p>
<ul>
<li>参数一：MutationRecord 数组包含顺序入队的触发事件，而且连续的修改会生成多个 MutationRecord 实例。</li>
<li>参数二：是观察变化的 MutationObserver 的实例</li>
</ul>
<p>MutationRecord 实例的属性有：</p>
<ul>
<li>target：被修改影响的目标节点</li>
<li>type 字符串：表示变化的类型： &quot;attributes&quot;、 &quot;characterData&quot;或&quot;childList&quot;</li>
<li>oldValue：如果在 MutationObserverInit 对象中启用（ attributeOldValue 或 characterData OldValue 为 true）， &quot;attributes&quot;或&quot;characterData&quot;的变化事件会设置这个属性为被替代的值&quot;childList&quot;类型的变化始终将这个属性设置为 null</li>
<li>attributeName 对于&quot;attributes&quot;类型的变化，这里保存被修改属性的名字，其他变化事件会将这个属性设置为 null</li>
<li>attributeNamespace 对于使用了命名空间的&quot;attributes&quot;类型的变化，这里保存被修改属性的名字，其他变化事件会将这个属性设置为 null</li>
<li>addedNodes 对于&quot;childList&quot;类型的变化，返回包含变化中添加节点的 NodeList，默认为空 NodeList</li>
<li>removedNodes 对于&quot;childList&quot;类型的变化，返回包含变化中删除节点的 NodeList，默认为空 NodeList</li>
<li>previousSibling 对于&quot;childList&quot;类型的变化，返回变化节点的前一个同胞 Node，默认为 null</li>
<li>nextSibling 对于&quot;childList&quot;类型的变化，返回变化节点的后一个同胞 Node，默认为 null</li>
</ul>
<h3 id="12-disconnect方法"><a class="header" href="#12-disconnect方法">1.2 disconnect()方法</a></h3>
<p>被观察的元素如果没有被垃圾回收，在默认情况下监控到的 DOM 变化事件都会响应。但是使用 disconnect() 方法可以提前终止回调：</p>
<pre><code class="language-js">let observer = new MutationObserver(() =&gt;
  console.log('&lt;body&gt; attributes changed')
)
observer.observe(document.body, { attributes: true })

// 示例没有输出
document.body.className = 'foo'
observer.disconnect()
document.body.className = 'bar'
</code></pre>
<p>要想让已经加入任务队列的回调执行，可以使用 setTimeout() 让已经入列的回调执行完毕再调用 disconnect()：</p>
<pre><code class="language-js">let observer = new MutationObserver(() =&gt;
  console.log('&lt;body&gt; attributes changed')
)
observer.observe(document.body, { attributes: true })

// 示例：&lt;body&gt; attributes changed
document.body.className = 'foo'
setTimeout(() =&gt; {
  observer.disconnect()
  document.body.className = 'bar'
}, 0)
</code></pre>
<h2 id="二-mutationobserver-优化"><a class="header" href="#二-mutationobserver-优化">二 MutationObserver 优化</a></h2>
<h3 id="21-复用-mutationobserver"><a class="header" href="#21-复用-mutationobserver">2.1 复用 MutationObserver</a></h3>
<p>多次调用 observe() 方法，可以复用一个 MutationObserver 对象观察多个不同的目标节点。此时，MutationRecord 的 target 属性可以标识发生变化事件的目标节点：</p>
<pre><code class="language-js">// 向页面主体添加两个子节点
let childA = document.createElement('div')
let childB = document.createElement('span')
document.body.appendChild(childA)
document.body.appendChild(childB)

// 观察两个子节点
let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords.map((x) =&gt; x.target))
)
observer.observe(childA, { attributes: true })
observer.observe(childB, { attributes: true })

// 示例输出：[&lt;div&gt;, &lt;span&gt;]
childA.setAttribute('foo', 'bar')
childB.setAttribute('foo', 'bar')
</code></pre>
<p>贴士：disconnect()方法是一个“一刀切”的方案，调用它会停止观察所有目标。</p>
<h3 id="22-重用-mutationobserver"><a class="header" href="#22-重用-mutationobserver">2.2 重用 MutationObserver</a></h3>
<p>调用 disconnect() 并不会结束 MutationObserver 的生命。还可以重新使用这个观察者，再将它关联到新的目标节点：</p>
<pre><code class="language-js">let observer = new MutationObserver(() =&gt;
  console.log('&lt;body&gt; attributeschanged')
)
observer.observe(document.body, { attributes: true })

// 这行代码会触发变化事件
document.body.setAttribute('foo', 'bar')

// 断开后不会触发变化事件
setTimeout(() =&gt; {
  observer.disconnect()
  document.body.setAttribute('bar', 'baz')
}, 0)

// 再次重用，可以再次监听
setTimeout(() =&gt; {
  observer.observe(document.body, { attributes: true })
  document.body.setAttribute('baz', 'qux')
}, 0)
</code></pre>
<h2 id="三-mutationobserverinit-与观察范围"><a class="header" href="#三-mutationobserverinit-与观察范围">三 MutationObserverInit 与观察范围</a></h2>
<h3 id="30-观察者可观察范围"><a class="header" href="#30-观察者可观察范围">3.0 观察者可观察范围</a></h3>
<p>观察者可以观察的事件包括属性变化、文本变化和子节点变化：</p>
<pre><code class="language-txt">subtree 布尔值，表示除了目标节点，是否观察目标节点的子树（后代）
        默认为 false，只观察目标节点的变化；如果是 true，则观察目标节点及其整个子树

attributes 布尔值，表示是否观察目标节点的属性变化，默认为 false

attributeFilter 字符串数组，表示要观察哪些属性的变化，默认为观察所有属性
        把这个值设置为 true 也会将 attributes 的值转换为 true

attributeOldValue 布尔值，默认为 false，表示 MutationRecord 是否记录变化之前的属性值
        把这个值设置为 true 也会将 attributes 的值转换为 true

characterData 布尔值，默认为 false，表示修改字符数据是否触发变化事件

characterDataOldValue 布尔值，默认为 false，表示 MutationRecord 是否记录变化之前的字符数据
        把这个值设置为 true 也会将 characterData 的值转换为 true

childList 布尔值，默认为 false，表示修改目标节点的子节点是否触发变化事件
</code></pre>
<h3 id="31-观察属性"><a class="header" href="#31-观察属性">3.1 观察属性</a></h3>
<p>MutationObserver 可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在 MutationObserverInit 对象中将 attributes 属性设置为 true，如下所示：</p>
<pre><code class="language-js">let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords)
)
observer.observe(document.body, { attributes: true })
// 添加属性
document.body.setAttribute('foo', 'bar')
// 修改属性
document.body.setAttribute('foo', 'baz')
// 移除属性
document.body.removeAttribute('foo')
// 以上变化都被记录下来了
// [MutationRecord, MutationRecord, MutationRecord]
</code></pre>
<p>把 attributes 设置为 true 的默认行为是观察所有属性，但不会在 MutationRecord 对象中记录原来的属性值。如果想观察某个或某几个属性，可以使用 attributeFilter 属性来设置白名单，即一个属性名字符串数组：</p>
<pre><code class="language-js">let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords)
)
observer.observe(document.body, { attributeFilter: ['foo'] })
// 添加白名单属性
document.body.setAttribute('foo', 'bar')
// 添加被排除的属性
document.body.setAttribute('baz', 'qux')
// 只有 foo 属性的变化被记录了
// [MutationRecord]
</code></pre>
<p>如果想在变化记录中保存属性原来的值，可以将 attributeOldValue 属性设置为 true：</p>
<pre><code class="language-js">let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords.map((x) =&gt; x.oldValue))
)
observer.observe(document.body, { attributeOldValue: true })
document.body.setAttribute('foo', 'bar')
document.body.setAttribute('foo', 'baz')
document.body.setAttribute('foo', 'qux')
// 每次变化都保留了上一次的值
// [null, 'bar', 'baz']
</code></pre>
<h3 id="32-观察字符数据"><a class="header" href="#32-观察字符数据">3.2 观察字符数据</a></h3>
<p>MutationObserver 可以观察文本节点（如 Text、 Comment 或 ProcessingInstruction 节点）中字符的添加、删除和修改。要为字符数据注册回调，需要在 MutationObserverInit 对象中将 characterData 属性设置为 true，如下所示：</p>
<pre><code class="language-js">let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords)
)
// 创建要观察的文本节点
document.body.firstChild.textContent = 'foo'
observer.observe(document.body.firstChild, { characterData: true })
// 赋值为相同的字符串
document.body.firstChild.textContent = 'foo'
// 赋值为新字符串
document.body.firstChild.textContent = 'bar'
// 通过节点设置函数赋值
document.body.firstChild.textContent = 'baz'
// 以上变化都被记录下来了
// [MutationRecord, MutationRecord, MutationRecord]
</code></pre>
<p>将 characterData 属性设置为 true 的默认行为不会在 MutationRecord 对象中记录原来的字符数据。如果想在变化记录中保存原来的字符数据， 可以将 characterDataOldValue 属性设置为 true：</p>
<pre><code class="language-js">let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords.map((x) =&gt; x.oldValue))
)
document.body.innerText = 'foo'
observer.observe(document.body.firstChild, { characterDataOldValue: true })
document.body.innerText = 'foo'
document.body.innerText = 'bar'
document.body.firstChild.textContent = 'baz'
// 每次变化都保留了上一次的值
// [&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;]
</code></pre>
<h3 id="33-观察子节点"><a class="header" href="#33-观察子节点">3.3 观察子节点</a></h3>
<p>MutationObserver 可以观察目标节点子节点的添加和移除。要观察子节点，需要在 MutationObserverInit 对象中将 childList 属性设置为 true。</p>
<p>下面的例子演示了添加子节点：</p>
<pre><code class="language-js">// 清空主体
document.body.innerHTML = ''
let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords)
)
observer.observe(document.body, { childList: true })
document.body.appendChild(document.createElement('div'))
// [
// {
// addedNodes: NodeList[div],
// attributeName: null,
// attributeNamespace: null,
// oldValue: null,
// nextSibling: null,
// previousSibling: null,
// removedNodes: NodeList[],
// target: body,
// type: &quot;childList&quot;,
// }
// ]
</code></pre>
<p>对子节点重新排序（尽管调用一个方法即可实现）会报告两次变化事件，因为从技术上会涉及先移除和再添加：</p>
<pre><code class="language-js">// 清空主体
document.body.innerHTML = ''
let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords)
)
// 创建两个初始子节点
document.body.appendChild(document.createElement('div'))
document.body.appendChild(document.createElement('span'))
observer.observe(document.body, { childList: true })
// 交换子节点顺序
document.body.insertBefore(document.body.lastChild, document.body.firstChild)
// 发生了两次变化：第一次是节点被移除，第二次是节点被添加
// [
// {
// addedNodes: NodeList[],
// attributeName: null,
// attributeNamespace: null,
// oldValue: null,
// nextSibling: null,
// previousSibling: div,
// removedNodes: NodeList[span],
// target: body,
// type: childList,
// },
// {
// addedNodes: NodeList[span],
// attributeName: null,
// attributeNamespace: null,
// oldValue: null,
// nextSibling: div,
// previousSibling: null,
// removedNodes: NodeList[],
// target: body,
// type: &quot;childList&quot;,
// }
// ]
</code></pre>
<h3 id="34-观察子树"><a class="header" href="#34-观察子树">3.4 观察子树</a></h3>
<p>默认情况下， MutationObserver 将观察的范围限定为一个元素及其子节点的变化。可以把观察的范围扩展到这个元素的子树（所有后代节点）， 这需要在 MutationObserverInit 对象中将 subtree 属性设置为 true。</p>
<p>下面的代码展示了观察元素及其后代节点属性的变化：</p>
<pre><code class="language-js">// 清空主体
document.body.innerHTML = ''
let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords)
)
// 创建一个后代
document.body.appendChild(document.createElement('div'))

// 观察&lt;body&gt;元素及其子树
observer.observe(document.body, { attributes: true, subtree: true })
// 修改&lt;body&gt;元素的子树
document.body.firstChild.setAttribute('foo', 'bar')
// 记录了子树变化的事件
// [
// {
// addedNodes: NodeList[],
// attributeName: &quot;foo&quot;,
// attributeNamespace: null,
// oldValue: null,
// nextSibling: null,
// previousSibling: null,
// removedNodes: NodeList[],
// target: div,
// type: &quot;attributes&quot;,
// }
// ]
</code></pre>
<p>注意：被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。下面的代码演示了这种情况：</p>
<pre><code class="language-js">// 清空主体
document.body.innerHTML = ''
let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords)
)
let subtreeRoot = document.createElement('div'),
  subtreeLeaf = document.createElement('span')
// 创建包含两层的子树
document.body.appendChild(subtreeRoot)
subtreeRoot.appendChild(subtreeLeaf)
// 观察子树
observer.observe(subtreeRoot, { attributes: true, subtree: true })
// 把节点转移到其他子树
document.body.insertBefore(subtreeLeaf, subtreeRoot)
subtreeLeaf.setAttribute('foo', 'bar')
// 移出的节点仍然触发变化事件
// [MutationRecord]
</code></pre>
<h2 id="四-异步回调与记录队列"><a class="header" href="#四-异步回调与记录队列">四 异步回调与记录队列</a></h2>
<h3 id="41-记录队列"><a class="header" href="#41-记录队列">4.1 记录队列</a></h3>
<p>MutationObserver 接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在 MutationRecord 实例中，然后添加到记录队列。这个队列对每个 MutationObserver 实例都是唯一的，是所有 DOM 变化事件的有序列表。</p>
<p>每次 MutationRecord 被添加到 MutationObserver 的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化 MutationObserver 时传入）作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。</p>
<p>不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一个 MutationRecord 实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些 MutationRecord 就用不着了，因此记录队列会被清空，其内容会被丢弃。</p>
<h3 id="42-takerecords方法"><a class="header" href="#42-takerecords方法">4.2 takeRecords()方法</a></h3>
<p>调用 MutationObserver 实例的 takeRecords()方法可以清空记录队列，取出并返回其中的所有 MutationRecord 实例。看这个例子：</p>
<pre><code class="language-js">let observer = new MutationObserver((mutationRecords) =&gt;
  console.log(mutationRecords)
)
observer.observe(document.body, { attributes: true })
document.body.className = 'foo'
document.body.className = 'bar'
document.body.className = 'baz'
console.log(observer.takeRecords())
console.log(observer.takeRecords())
// [MutationRecord, MutationRecord, MutationRecord]
// []
</code></pre>
<p>这在希望断开与观察目标的联系，但又希望处理由于调用 disconnect()而被抛弃的记录队列中的 MutationRecord 实例时比较有用。</p>
<h2 id="四-mutationobserver-机制与性能问题"><a class="header" href="#四-mutationobserver-机制与性能问题">四 MutationObserver 机制与性能问题</a></h2>
<h3 id="41-mutationobserver-的引用"><a class="header" href="#41-mutationobserver-的引用">4.1 MutationObserver 的引用</a></h3>
<p>DOM Level 2 规范中描述的 MutationEvent 定义了一组会在各种 DOM 变化时触发的事件。由于浏览器事件的实现机制，这个接口出现了严重的性能问题。因此， DOM Level 3 规定废弃了这些事件。MutationObserver 接口就是为替代这些事件而设计的更实用、性能更好的方案。</p>
<p>将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为 MutationObserver 而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。</p>
<p>无论如何，使用 MutationObserver 仍然不是没有代价的。因此理解什么时候避免出现这种情况就很重要了。</p>
<p>MutationObserver 实例与目标节点之间的引用关系是非对称的。 MutationObserver 拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。</p>
<p>然而，目标节点却拥有对 MutationObserver 的强引用。如果目标节点从 DOM 中被移除，随后被垃圾回收，则关联的 MutationObserver 也会被垃圾回收。</p>
<h3 id="42-mutationrecord-的引用"><a class="header" href="#42-mutationrecord-的引用">4.2 MutationRecord 的引用</a></h3>
<p>记录队列中的每个 MutationRecord 实例至少包含对已有 DOM 节点的一个引用。如果变化是 childList 类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个 MutationRecord，然后让它们超出作用域并被垃圾回收。</p>
<p>有时候可能需要保存某个观察者的完整变化记录。保存这些 MutationRecord 实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个 MutationRecord 中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 MutationRecord。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-表单-表单基础操作"><a class="header" href="#061-表单-表单基础操作">06.1-表单-表单基础操作</a></h1>
<h2 id="一-表单基础"><a class="header" href="#一-表单基础">一 表单基础</a></h2>
<h3 id="11-表单元素-form"><a class="header" href="#11-表单元素-form">1.1 表单元素 form</a></h3>
<p>Web 表单在 HTML 中以 <code>&lt;form&gt;</code> 元素表示，在 JavaScript 中则以 HTMLFormElement 类型表示，HTMLFormElement 类型继承自 HTMLElement 类型，因此拥有与其他 HTML 元素一样的默认属性，常用成员有：</p>
<ul>
<li>acceptCharset：服务器可以接收的字符集，等价于 HTML 的 accept-charset 属性。</li>
<li>action：请求的 URL，等价于 HTML 的 action 属性。</li>
<li>elements：表单中所有控件的 HTMLCollection。</li>
<li>enctype：请求的编码类型，等价于 HTML 的 enctype 属性。</li>
<li>length：表单中控件的数量。</li>
<li>method： HTTP 请求的方法类型，通常是&quot;get&quot;或&quot;post&quot;，等价于 HTML 的 method 属性。</li>
<li>name：表单的名字，等价于 HTML 的 name 属性。</li>
<li>reset()：把表单字段重置为各自的默认值。</li>
<li>submit()：提交表单。</li>
<li>target：用于发送请求和接收响应的窗口的名字，等价于 HTML 的 target 属性</li>
</ul>
<p>除了以常见的 <code>selector</code> 等方式获取表单元素外， document.forms 集合可以获取页面上所有的表单元素。然后，可以进一步使用数字索引或表单的名字（ name）来访问特定的表单：</p>
<pre><code class="language-js">// 取得页面中的第一个表单
let firstForm = document.forms[0]
// 取得名字为&quot;form2&quot;的表单
let myForm = document.forms['form2']
</code></pre>
<h3 id="12-提交表单"><a class="header" href="#12-提交表单">1.2 提交表单</a></h3>
<p>表单提交操作涉及信息较多，单独罗列了一章，见 06.4</p>
<h3 id="13-重置表单"><a class="header" href="#13-重置表单">1.3 重置表单</a></h3>
<p>用户单击重置按钮可以重置表单。重置按钮可以使用 type 属性为&quot;reset&quot;的<code>&lt;input&gt;</code>或<code>&lt;button&gt;</code>元素来创建，比如：</p>
<pre><code class="language-html">&lt;!-- 通用重置按钮 --&gt;
&lt;input type=&quot;reset&quot; value=&quot;Reset Form&quot; /&gt;
&lt;!-- 自定义重置按钮 --&gt;
&lt;button type=&quot;reset&quot;&gt;Reset Form&lt;/button&gt;
</code></pre>
<p>表单重置后，所有表单字段都会重置回页面第一次渲染时各自拥有的值。如果字段原来是空的，就会变成空的；如果字段有默认值，则恢复为默认值。</p>
<p>用户单击重置按钮重置表单会触发 reset 事件，可以利用该事件取消重置：</p>
<pre><code class="language-js">let form = document.getElementById('myForm')
form.addEventListener('reset', (event) =&gt; {
  event.preventDefault()
})
</code></pre>
<p>与表单提交一样，重置表单也可以通过 JavaScript 调用 reset()方法来完成，如下面的例子所示：</p>
<pre><code class="language-js">let form = document.getElementById('myForm')
// 重置表单
form.reset()
</code></pre>
<p>与 submit()方法的功能不同，调用 reset()方法会像单击了重置按钮一样触发 reset 事件。</p>
<p>注意：表单设计中通常不提倡重置表单，因为重置表单经常会导致用户迷失方向，如果意外触发则会令人感到厌烦。实践中几乎没有重置表单的需求。一般来说，提供一个取消按钮，让用户点击返回前一个页面，而不是恢复表单中所有的值来得更直观。</p>
<h2 id="二-表单字段操作"><a class="header" href="#二-表单字段操作">二 表单字段操作</a></h2>
<h3 id="21-表单常用字段"><a class="header" href="#21-表单常用字段">2.1 表单常用字段</a></h3>
<p>所有表单元素都是表单 elements 属性（元素集合）中包含的一个值。这个 elements 集合是一个有序列表，包含对表单中所有字段的引用，包括所有<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code>、 <code>&lt;button&gt;</code>、 <code>&lt;select&gt;</code>和<code>&lt;fieldset&gt;</code>元素。 elements 集合中的每个字段都以它们在 HTML 标记中出现的次序保存，可以通过索引位置和 name 属性来访问：</p>
<pre><code class="language-js">let form = document.getElementById('form1')
// 取得表单中的第一个字段
let field1 = form.elements[0]
// 取得表单中名为&quot;textbox1&quot;的字段
let field2 = form.elements['textbox1']
// 取得字段的数量
let fieldCount = form.elements.length
</code></pre>
<p>如果多个表单控件使用了同一个 name，比如像单选按钮那样，则会返回包含所有同名元素的 HTMLCollection：</p>
<pre><code class="language-html">&lt;form method=&quot;post&quot; id=&quot;myForm&quot;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;input type=&quot;radio&quot; name=&quot;color&quot; value=&quot;red&quot; /&gt;Red&lt;/li&gt;
    &lt;li&gt;&lt;input type=&quot;radio&quot; name=&quot;color&quot; value=&quot;green&quot; /&gt;Green&lt;/li&gt;
    &lt;li&gt;&lt;input type=&quot;radio&quot; name=&quot;color&quot; value=&quot;blue&quot; /&gt;Blue&lt;/li&gt;
  &lt;/ul&gt;
&lt;/form&gt;

&lt;script&gt;
  let form = document.getElementById('myForm')
  let colorFields = form.elements['color']
  console.log(colorFields.length) // 3
  let firstColorField = colorFields[0]
  let firstFormField = form.elements[0]
  console.log(firstColorField === firstFormField) // true
&lt;/script&gt;
</code></pre>
<p>也可以通过表单属性的方式访问表单字段，比如 <code>form[0]</code> 这种使用索引和 <code>form[&quot;color&quot;]</code> 这种使用字段名字的方式，这是为了向后兼容旧版本浏览器而提供的，实际开发中应该使用 elements。</p>
<h3 id="22-表单字段的公共属性"><a class="header" href="#22-表单字段的公共属性">2.2 表单字段的公共属性</a></h3>
<p>除<code>&lt;fieldset&gt;</code>元素以外，所有表单字段都有一组同样的属性。由于<code>&lt;input&gt;</code>类型可以表示多种表
单字段，因此某些属性只适用于特定类型的字段。除此之外的属性可以在任何表单字段上使用。以下列
出了这些表单字段的公共属性和方法。</p>
<ul>
<li>disabled：布尔值，表示表单字段是否禁用。</li>
<li>form：指针，指向表单字段所属的表单。这个属性是只读的。</li>
<li>name：字符串，这个字段的名字。</li>
<li>readOnly：布尔值，表示这个字段是否只读。</li>
<li>tabIndex：数值，表示这个字段在按 Tab 键时的切换顺序。</li>
<li>type：字符串，表示字段类型，如&quot;checkbox&quot;、 &quot;radio&quot;等。</li>
<li>value：要提交给服务器的字段值。对文件输入字段来说，这个属性是只读的，仅包含计算机上某个文件的路径。</li>
</ul>
<pre><code class="language-js">let form = document.getElementById('myForm')
let field = form.elements[0]
// 修改字段的值
field.value = 'Another value'
// 检查字段所属的表单
console.log(field.form === form) // true
// 给字段设置焦点
field.focus()
// 禁用字段
field.disabled = true
// 改变字段的类型（不推荐，但对&lt;input&gt;来说是可能的）
field.type = 'checkbox'
</code></pre>
<h3 id="23-表单字段的公共方法"><a class="header" href="#23-表单字段的公共方法">2.3 表单字段的公共方法</a></h3>
<p>每个表单字段都有两个公共方法：</p>
<ul>
<li>focus()</li>
<li>blur()</li>
</ul>
<p>focus()方法把浏览器焦点设置到表单字段，这意味着该字段会变成活动字段并可以响应键盘事件。例如，文本框在获得焦点时会在内部显示闪烁的光标，表示可以接收输入。常用方式是在页面加载后把焦点定位到表单中第一个字段，实现方法是监听 load 事件，然后在第一个字段上调用 focus()，如下所示：</p>
<pre><code class="language-js">window.addEventListener('load', (event) =&gt; {
  document.forms[0].elements[0].focus()
})
</code></pre>
<p>注意，如果表单中第一个字段是 type 为&quot;hidden&quot;的<code>&lt;input&gt;</code>元素，或者该字段被 CSS 属性 display 或 visibility 隐藏了，以上代码就会出错。</p>
<p>HTML5 为表单字段增加了 autofocus 属性，支持的浏览器会自动为带有该属性的元素设置焦点，而无须使用 JavaScript：</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; autofocus /&gt;
</code></pre>
<p>focus()的反向操作是 blur()，其用于从元素上移除焦点。调用 blur()时，焦点不会转移到任何特定元素，仅仅只是从调用这个方法的元素上移除了。</p>
<h3 id="24-表单字段的公共事件"><a class="header" href="#24-表单字段的公共事件">2.4 表单字段的公共事件</a></h3>
<p>除了鼠标、键盘、变化和 HTML 事件外，所有字段还支持以下 3 个事件：</p>
<ul>
<li>blur：在字段失去焦点时触发。</li>
<li>change：在<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>元素的 value 发生变化且失去焦点时触发，或者在<code>&lt;select&gt;</code>元素中选中项发生变化时触发。</li>
<li>focus：在字段获得焦点时触发</li>
</ul>
<p>blur 和 focus 事件会因为用户手动改变字段焦点或者调用 blur()或 focus()方法而触发。这两个事件对所有表单都会一视同仁。</p>
<p>change 事件会因控件不同而在不同时机触发。对于<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>元素， change 事件会在字段失去焦点，同时 value 自控件获得焦点后发生变化时触发。对于<code>&lt;select&gt;</code>元素， change 事件会在用户改变了选中项时触发，不需要控件失去焦点。</p>
<pre><code class="language-js">let textbox = document.forms[0].elements[0]

textbox.addEventListener('focus', (event) =&gt; {
  let target = event.target
  if (target.style.backgroundColor != 'red') {
    target.style.backgroundColor = 'yellow'
  }
})

textbox.addEventListener('blur', (event) =&gt; {
  let target = event.target
  target.style.backgroundColor = /[^\d]/.test(target.value) ? 'red' : ''
})

textbox.addEventListener('change', (event) =&gt; {
  let target = event.target
  target.style.backgroundColor = /[^\d]/.test(target.value) ? 'red' : ''
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="062-表单-文本框-input-与-textarea"><a class="header" href="#062-表单-文本框-input-与-textarea">06.2-表单-文本框 input 与 textarea</a></h1>
<h2 id="一-文本框基本使用"><a class="header" href="#一-文本框基本使用">一 文本框基本使用</a></h2>
<h3 id="11-input-基本使用"><a class="header" href="#11-input-基本使用">1.1 input 基本使用</a></h3>
<p>在 HTML 中有两种表示文本框的方式：单行使用<code>&lt;input&gt;</code>元素，多行使用<code>&lt;textarea&gt;</code>元素。</p>
<p><code>&lt;input&gt;</code>元素的常见属性：</p>
<ul>
<li>type：默认值为 &quot;text&quot;</li>
<li>size：指定文本框的宽度，该宽度以字符数来计量</li>
<li>value：指定文本框的初始值</li>
<li>maxLength：用于指定文本框允许的最多字符数</li>
</ul>
<p>示例：</p>
<pre><code class="language-html">&lt;!--创建一个一次可显示 25 个字符，但最多允许显示 50 个字符的文本框--&gt;
&lt;input type=&quot;text&quot; size=&quot;25&quot; maxlength=&quot;50&quot; value=&quot;initial value&quot; /&gt;
</code></pre>
<h3 id="12-textarea-基础使用"><a class="header" href="#12-textarea-基础使用">1.2 textarea 基础使用</a></h3>
<p><code>&lt;textarea&gt;</code>元素总是会创建多行文本框，拥有属性有：</p>
<ul>
<li>rows：指定这个文本框的高度，以字符数计量</li>
<li>cols：指定以字符数计量的文本框宽度，类似于<code>&lt;input&gt;</code>元素的 size 属性</li>
</ul>
<p><code>&lt;textarea&gt;</code>的初始值必须包含在<code>&lt;textarea&gt;</code>和<code>&lt;/textarea&gt;</code>之间，且不能在 HTML 中指定最大允许的字符数。</p>
<p>示例：</p>
<pre><code class="language-html">&lt;!--  --&gt;
&lt;textarea rows=&quot;25&quot; cols=&quot;5&quot;&gt;initial value&lt;/textarea&gt;
</code></pre>
<h3 id="13-value-属性读写文本框的值"><a class="header" href="#13-value-属性读写文本框的值">1.3 value 属性读写文本框的值</a></h3>
<p>通过 value 属性可以读取、设置文本框的值：</p>
<pre><code class="language-js">let textbox = document.forms[0].elements['textbox1']
console.log(textbox.value)
textbox.value = 'Some new value'
</code></pre>
<p>应该使用 value 属性，而不是标准 DOM 方法读写文本框的值。比如，不要使用 setAttribute()设置<code>&lt;input&gt;</code>元素 value 属性的值，也不要尝试修改<code>&lt;textarea&gt;</code>元素的第一个子节点。对 value 属性的修改也不会总体现在 DOM 中，因此在处理文本框值的时候最好不要使用 DOM 方法。</p>
<h2 id="二-选择文本操作"><a class="header" href="#二-选择文本操作">二 选择文本操作</a></h2>
<h3 id="21-全部选中方法-select"><a class="header" href="#21-全部选中方法-select">2.1 全部选中方法 select()</a></h3>
<p>全部选中文本框内文本的方法：select()，调用后自动将焦点设置到文本框。</p>
<pre><code class="language-js">let textbox = document.forms[0].elements['textbox1']
textbox.select()
</code></pre>
<p>在文本框获得焦点时选中所有文本是非常常见的，特别是在文本框有默认值的情况下。这样做的出发点是让用户能够一次性删除所有默认内容。可以通过以下代码来实现：</p>
<pre><code class="language-js">textbox.addEventListener('focus', (event) =&gt; {
  event.target.select()
})
</code></pre>
<h3 id="22-select-事件"><a class="header" href="#22-select-事件">2.2 select 事件</a></h3>
<p>当选中文本框中的文本时，或者调用 select()方法也会触发 select 事件：</p>
<pre><code class="language-js">let textbox = document.forms[0].elements['textbox1']

textbox.addEventListener('select', (event) =&gt; {
  console.log(`Text selected: ${textbox.value}`)

  // H5新增属性：用来获得文本选取的起点、终点
  console.log(
    textbox.value.substring(textbox.selectionStart, textbox.selectionEnd)
  )

  // 兼容贴士：老版本IE拥有 document.secection对象，用来获取事件触发的选择文本
  if (document.selection) {
    console.log(document.selection.createRange().text)
  }
})
</code></pre>
<h3 id="23-部分选中方法-setselectionrange"><a class="header" href="#23-部分选中方法-setselectionrange">2.3 部分选中方法 setSelectionRange()</a></h3>
<p>setSelectionRange()方法可以实现获取部分选中文本，该方法接收两个参数：要选择的第一个字符的索引和停止选择的字符的索引（与字符串的 substring()方法一样）：</p>
<pre><code class="language-js">textbox.value = 'Hello world!'

// 如果想看到选择，则必须在调用 setSelectionRange()之前或之后给文本框设置焦点

// 选择所有文本
textbox.setSelectionRange(0, textbox.value.length) // &quot;Hello world!&quot;
// 选择前 3 个字符
textbox.setSelectionRange(0, 3) // &quot;Hel&quot;
// 选择第 4~6 个字符
textbox.setSelectionRange(4, 7) // &quot;o w&quot;
</code></pre>
<p>IE8 只能使用 createTextRange()方法创建一个范围，并使用 moveStart()和 moveEnd()范围方法把这个范围放到正确的位置上：</p>
<pre><code class="language-js">textbox.value = 'Hello world!'
var range = textbox.createTextRange()

// 如果想要看到选中的效果，则必须让文本框获得焦点

// 选择所有文本
range.collapse(true) // 需要先调用 collapse()方法把范围折叠到文本框的开始
range.moveStart('character', 0)
range.moveEnd('character', textbox.value.length) // &quot;Hello world!&quot;
range.select()
// 选择前 3 个字符
range.collapse(true)
range.moveStart('character', 0)
range.moveEnd('character', 3)
range.select() // &quot;Hel&quot;
// 选择第 4~6 个字符
range.collapse(true)
range.moveStart('character', 4)
range.moveEnd('character', 6)
range.select() // &quot;o w
</code></pre>
<h2 id="三-文本框输入过滤"><a class="header" href="#三-文本框输入过滤">三 文本框输入过滤</a></h2>
<h3 id="31-内容过滤实现"><a class="header" href="#31-内容过滤实现">3.1 内容过滤实现</a></h3>
<p>文本框并未提供一些验证功能，无法直接保证输入的数据拥有特性类型或格式，所以需要 JavaScript 实现输入过滤。</p>
<p>比如屏蔽输入框中的特定字符，可以通过检查事件的 charCode 属性实现，示例演示了只允许输入数字：</p>
<pre><code class="language-js">textbox.addEventListener('keypress', (event) =&gt; {
  if (!/\d/.test(String.fromCharCode(event.charCode))) {
    event.preventDefault()
  }
})

// 考虑到兼容性，比如某些浏览器上下键也是数字，比如Ctrl+C这种组合键在上述代码也会被屏蔽，可以优化为：
textbox.addEventListener('keypress', (event) =&gt; {
  if (
    !/\d/.test(String.fromCharCode(event.charCode)) &amp;&amp;
    event.charCode &gt; 9 &amp;&amp;
    !event.ctrlKey
  ) {
    event.preventDefault()
  }
})
</code></pre>
<h3 id="32-剪贴板输入过滤"><a class="header" href="#32-剪贴板输入过滤">3.2 剪贴板输入过滤</a></h3>
<p>剪贴板事件有：</p>
<ul>
<li>beforecopy：复制操作发生前触发。</li>
<li>copy：复制操作发生时触发。</li>
<li>beforecut：剪切操作发生前触发。</li>
<li>cut：剪切操作发生时触发。</li>
<li>beforepaste：粘贴操作发生前触发。</li>
<li>paste：粘贴操作发生时触发。</li>
</ul>
<p>事件的行为及相关对象会因浏览器而异。在 Safari、Chrome 和 Firefox 中， beforecopy、 beforecut 和 beforepaste 事件只会在显示文本框的上下文菜单（预期会发生剪贴板事件）时触发，但 IE 不仅在这种情况下触发，也会在 copy、 cut 和 paste 事件之前触发。无论是在上下文菜单中做出选择还是使用键盘快捷键， copy、 cut 和 paste 事件在所有浏览器中都会按预期触发。</p>
<p>通过 beforecopy、 beforecut 和 beforepaste 事件可以在向剪贴板发送或从中检索数据前修改数据。不过，取消这些事件并不会取消剪贴板操作。要阻止实际的剪贴板操作，必须取消 copy、 cut 和 paste 事件。</p>
<p>剪贴板上的数据可以通过 window 对象（ IE）或 event 对象（ Firefox、 Safari 和 Chrome）上的 clipboardData 对象来获取。在 Firefox、 Safari 和 Chrome 中，为防止未经授权访问剪贴板，只能在剪贴板事件期间访问 clipboardData 对象； IE 则在任何时候都会暴露 clipboardData 对象。为了跨浏览器兼容，最好只在剪贴板事件期间使用这个对象。</p>
<p>clipboardData 对象上有 3 个方法： getData()、 setData()和 clearData()，其中 getData()方法从剪贴板检索字符串数据，并接收一个参数，该参数是要检索的数据的格式。 IE 为此规定了两个选项： &quot;text&quot;和&quot;URL&quot;。 Firefox、 Safari 和 Chrome 则期待 MIME 类型，不过会将&quot;text&quot;视为等价于
&quot;text/plain&quot;。</p>
<p>setData()方法也类似，其第一个参数用于指定数据类型，第二个参数是要放到剪贴板上的文本。同样， IE 支持&quot;text&quot;和&quot;URL&quot;， Safari 和 Chrome 则期待 MIME 类型。不过，与 getData()不同的是，Safari 和 Chrome 不认可&quot;text&quot;类型。只有在 IE8 及更早版本中调用 setData()才有效，其他浏览器会
忽略对这个方法的调用。为抹平差异，可以使用以下跨浏览器的方法：</p>
<pre><code class="language-js">function getClipboardText(event) {
  var clipboardData = event.clipboardData || window.clipboardData
  return clipboardData.getData('text')
}
function setClipboardText(event, value) {
  if (event.clipboardData) {
    return event.clipboardData.setData('text/plain', value)
  } else if (window.clipboardData) {
    return window.clipboardData.setData('text', value)
  }
}
</code></pre>
<p>如果文本框期待某些字符或某种格式的文本，那么从剪贴板中读取文本是有帮助的。比如，如果文本框只允许输入数字，那么就必须检查粘贴过来的值，确保其中只包含数字。在 paste 事件中，可以确定剪贴板上的文本是否无效，如果无效就取消默认行为，如下面的例子所示：</p>
<pre><code class="language-js">textbox.addEventListener('paste', (event) =&gt; {
  let text = getClipboardText(event)
  if (!/^\d*$/.test(text)) {
    event.preventDefault()
  }
})
</code></pre>
<h2 id="四-文本框自动切换"><a class="header" href="#四-文本框自动切换">四 文本框自动切换</a></h2>
<p>JavaScript 可以通过很多方式来增强表单字段的易用性。最常用的是在当前字段完成时自动切换到下一个字段。对于要收集数据的长度已知（比如电话号码）的字段是可以这样处理的。在美国，电话号码通常分为 3 个部分：区号、交换局号，外加 4 位数字。在网页中，可以通过 3 个文本框来表示这几个部分，比如：</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; name=&quot;tel1&quot; id=&quot;txtTel1&quot; maxlength=&quot;3&quot; /&gt;
&lt;input type=&quot;text&quot; name=&quot;tel2&quot; id=&quot;txtTel2&quot; maxlength=&quot;3&quot; /&gt;
&lt;input type=&quot;text&quot; name=&quot;tel3&quot; id=&quot;txtTel3&quot; maxlength=&quot;4&quot; /&gt;
</code></pre>
<p>为增加这个表单的易用性并加速数据输入，可以在每个文本框输入到最大允许字符数时自动把焦点切换到下一个文本框。因此，当用户在第一个文本框中输入 3 个字符后，就把焦点移到第二个文本框，当用户在第二个文本框中输入 3 个字符后，把焦点再移到第三个文本框。这种自动切换文本框的行为可以通过如下代码实现：</p>
<pre><code class="language-js">function tabForward(event) {
  let target = event.target
  if (target.value.length == target.maxLength) {
    let form = target.form
    for (let i = 0, len = form.elements.length; i &lt; len; i++) {
      if (form.elements[i] == target) {
        if (form.elements[i + 1]) {
          form.elements[i + 1].focus()
        }
        return
      }
    }
  }
}
let inputIds = ['txtTel1', 'txtTel2', 'txtTel3']
for (let id of inputIds) {
  let textbox = document.getElementById(id)
  textbox.addEventListener('keyup', tabForward)
}
let textbox1 = document.getElementById('txtTel1')
let textbox2 = document.getElementById('txtTel2')
let textbox3 = document.getElementById('txtTel3')
</code></pre>
<p>这个 tabForward()函数是实现自动切换的关键。它通过比较用户输入文本的长度与 maxlength 属性的值来检测输入是否达到了最大长度。如果两者相等（因为浏览器会强制最大字符数，所以不可能出现多的情况），那么就要通过循环表单中的元素集合找到当前文本框，并把焦点设置到下一个元素。这个函数接着给每一个文本框都指定了 onkeyup 事件处理程序。因为 keyup 事件会在每个新字符被插入到文本框中时触发，所以此时应该是检测文本框内容长度的最佳时机。在填写这个简单的表单时，用户不用按 Tab 键切换字段和提交表单。不过要注意，上面的代码只适用于之前既定的标记，没有考虑可能存在的隐藏字段。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="063-表单-选择框-select"><a class="header" href="#063-表单-选择框-select">06.3-表单-选择框 select</a></h1>
<h2 id="一-选择框基础使用"><a class="header" href="#一-选择框基础使用">一 选择框基础使用</a></h2>
<h3 id="11-select-元素属性"><a class="header" href="#11-select-元素属性">1.1 select 元素属性</a></h3>
<p>选择框是使用 <code>&lt;select&gt;</code>和<code>&lt;option&gt;</code>元素创建的。为方便交互， HTMLSelectElement 类型在所有表单字段的公共能力之外又提供了以下属性和方法：</p>
<ul>
<li>add(newOption, relOption)：在 relOption 之前向控件中添加新的<code>&lt;option&gt;</code>。</li>
<li>multiple：布尔值，表示是否允许多选，等价于 HTML 的 multiple 属性。</li>
<li>options：控件中所有<code>&lt;option&gt;</code>元素的 HTMLCollection。</li>
<li>remove(index)：移除给定位置的选项。</li>
<li>selectedIndex：选中项基于 0 的索引值，如果没有选中项则为–1。对于允许多选的列表，始终是第一个选项的索引。</li>
<li>size：选择框中可见的行数，等价于 HTML 的 size 属性。</li>
</ul>
<p>选择框的 type 属性可能是&quot;select-one&quot;或&quot;select-multiple&quot;，具体取决于 multiple 属性是否存在。当前选中项根据以下规则决定选择框的 value 属性：</p>
<ul>
<li>如果没有选中项，则选择框的值是空字符串。</li>
<li>如果有一个选中项，且其 value 属性有值，则选择框的值就是选中项 value 属性的值。即使 value 属性的值是空字符串也是如此。</li>
<li>如果有一个选中项，且其 value 属性没有指定值，则选择框的值是该项的文本内容。</li>
<li>如果有多个选中项，则选择框的值根据前两条规则取得第一个选中项的值。</li>
</ul>
<pre><code class="language-html">&lt;select name=&quot;location&quot; id=&quot;selLocation&quot;&gt;
  &lt;option value=&quot;Sunnyvale, CA&quot;&gt;Sunnyvale&lt;/option&gt;
  &lt;option value=&quot;Los Angeles, CA&quot;&gt;Los Angeles&lt;/option&gt;
  &lt;option value=&quot;Mountain View, CA&quot;&gt;Mountain View&lt;/option&gt;
  &lt;option value=&quot;&quot;&gt;China&lt;/option&gt;
  &lt;option&gt;Australia&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>如果选中这个选择框中的第一项，则字段的值就是&quot;Sunnyvale, CA&quot;。如果文本为&quot;China&quot;的项被选中，则字段的值是一个空字符串，因为该项的 value 属性是空字符串。如果选中最后一项，那么字段的值是&quot;Australia&quot;，因为该<code>&lt;option&gt;元</code>素没有指定 value 属性。</p>
<h3 id="12-option-元素属性"><a class="header" href="#12-option-元素属性">1.2 option 元素属性</a></h3>
<p>每个<code>&lt;option&gt;</code>元素在 DOM 中都由一个 HTMLOptionElement 对象表示。 HTMLOptionElement 类型为方便数据存取添加了以下属性：</p>
<ul>
<li>index：选项在 options 集合中的索引。</li>
<li>label：选项的标签，等价于 HTML 的 label 属性。</li>
<li>selected：布尔值，表示是否选中了当前选项。把这个属性设置为 true 会选中当前选项。</li>
<li>text：选项的文本。</li>
<li>value：选项的值（等价于 HTML 的 value 属性）。</li>
</ul>
<p>大多数<code>&lt;option&gt;</code>属性是为了方便存取选项数据。可以使用常规 DOM 功能存取这些信息，只是效率比较低，如下面的例子所示：</p>
<pre><code class="language-js">let selectbox = document.forms[0].elements['location']
// 不推荐
let text = selectbox.options[0].firstChild.nodeValue // 选项文本
let value = selectbox.options[0].getAttribute('value') // 选项值
</code></pre>
<p>以上代码使用标准的 DOM 技术获取了选择框中第一个选项的文本和值。下面再比较一下使用特殊选项属性的代码：</p>
<pre><code class="language-js">let selectbox = document.forms[0].elements['location']
// 推荐
let text = selectbox.options[0].text // 选项文本
let value = selectbox.options[0].value // 选项值
</code></pre>
<h3 id="13-select-的使用注意事项"><a class="header" href="#13-select-的使用注意事项">1.3 select 的使用注意事项</a></h3>
<p>在操作选项时，最好使用特定于选项的属性，因为这些属性得到了跨浏览器的良好支持。在操作 DOM 节点时，与表单控制实际的交互可能会因浏览器而异。不推荐使用标准 DOM 技术修改<code>&lt;option&gt;</code>元素的文本和值。</p>
<p>最后强调一下，选择框的 change 事件与其他表单字段是不一样的。其他表单字段会在自己的值改变后触发 change 事件，然后字段失去焦点。而选择框会在选中一项时立即触发 change 事件。</p>
<p>在 HTML 中没有指定 value 属性的情况下， IE8 及早期版本会返回空字符串，而 IE9 及之后版本、 Safari、 Firefox、 Chrome 和 Opera 会返回与 text 相同的值。</p>
<h2 id="二-选择框选项处理"><a class="header" href="#二-选择框选项处理">二 选择框选项处理</a></h2>
<p>对于只允许选择一项的选择框，获取选项最简单的方式是使用选择框的 selectedIndex 属性，如下面的例子所示：</p>
<pre><code class="language-js">let selectedOption = selectbox.options[selectbox.selectedIndex]
</code></pre>
<p>这样可以获取关于选项的所有信息，比如：</p>
<pre><code class="language-js">let selectedIndex = selectbox.selectedIndex
let selectedOption = selectbox.options[selectedIndex]

// 输出选中项的索引及其文本和值
console.log(
  `Selected index: ${selectedIndex}\n` +
    `Selected text: ${selectedOption.text}\n` +
    `Selected value: ${selectedOption.value}`
)
</code></pre>
<p>对于允许多选的选择框， selectedIndex 属性就像只允许选择一项一样。设置 selectedIndex 会移除所有选项，只选择指定的项，而获取 selectedIndex 只会返回选中的第一项的索引。</p>
<p>选项还可以通过取得选项的引用并将其 selected 属性设置为 true 来选中。例如，以下代码会选中选择框中的第一项：</p>
<pre><code class="language-js">selectbox.options[0].selected = true
</code></pre>
<p>与 selectedIndex 不同，设置选项的 selected 属性不会在多选时移除其他选项，从而可以动态选择任意多个选项。如果修改单选框中选项的 selected 属性，则其他选项会被移除。要注意的是，把 selected 属性设置为 false 对单选框没有影响。</p>
<p>通过 selected 属性可以确定选择框中哪个选项被选中。要取得所有选中项，需要循环选项集合逐一检测 selected 属性，比如：</p>
<pre><code class="language-js">function getSelectedOptions(selectbox) {
  let result = new Array()
  for (let option of selectbox.options) {
    if (option.selected) {
      result.push(option)
    }
  }
  return result
}
</code></pre>
<p>这个函数会返回给定选择框中所有选中项的数组。首先创建一个包含结果的数组，然后通过 for 循环迭代所有选项，检测每个选项的 selected 属性。如果选项被选中，就将其添加到 result 数组。最后是返回选中项数组。这个 getSelectedOptions()函数可以用于获取选中项的信息，比如：</p>
<pre><code class="language-js">// 既适用于单选框也适用于多选框
let selectbox = document.getElementById('selLocation')
let selectedOptions = getSelectedOptions(selectbox)
let message = ''
for (let option of selectedOptions) {
  message +=
    'Selected index: ${option.index}\n' +
    'Selected text: ${option.text}\n' +
    'Selected value: ${option.value}\n'
}
console.log(message)
</code></pre>
<h2 id="三-选择框添加选项"><a class="header" href="#三-选择框添加选项">三 选择框添加选项</a></h2>
<p>可以使用 JavaScript 动态创建选项并将它们添加到选择框。首先，可以使用 DOM 方法，如下所示：</p>
<pre><code class="language-js">let newOption = document.createElement('option')
newOption.appendChild(document.createTextNode('Option text'))
newOption.setAttribute('value', 'Option value')
selectbox.appendChild(newOption)
</code></pre>
<p>另外，也可以使用 Option 构造函数创建新选项，这个构造函数是 DOM 出现之前就已经得到浏览器支持的。 Option 构造函数接收两个参数： text 和 value，其中 value 是可选的。虽然这个构造函数通常会创建 Object 的实例，但 DOM 合规的浏览器都会返回一个<code>&lt;option&gt;</code>元素。这意味着仍然可
以使用 appendChild()方法把这样创建的选项添加到选择框。比如下面的例子：</p>
<pre><code class="language-js">let newOption = new Option('Option text', 'Option value')
selectbox.appendChild(newOption) // 在 IE8 及更低版本中有问题
</code></pre>
<p>这个方法在除 IE8 及更低版本之外的所有浏览器中都没有问题。由于实现问题， IE8 及更低版本在这种情况下不能正确设置新选项的文本。</p>
<p>另一种添加新选项的方式是使用选择框的 add()方法。 DOM 规定这个方法接收两个参数：要添加的新选项和要添加到其前面的参考选项。如果想在列表末尾添加选项，那么第二个参数应该是 null。</p>
<p>IE8 及更早版本对 add()方法的实现稍有不同，其第二个参数是可选的，如果要传入则必须是一个索引值，表示要在其前面添加新选项的选项。 DOM 合规的浏览器要求必须传入第二个参数，因此在跨浏览器方法中不能只使用一个参数（ IE9 是符合 DOM 规范的）。此时，传入 undefined 作为第二个参数可以保证在所有浏览器中都将选项添加到列表末尾。下面是一个例子：</p>
<pre><code class="language-js">let newOption = new Option('Option text', 'Option value')
selectbox.add(newOption, undefined) // 最佳方案
</code></pre>
<p>以上代码可以在所有版本的 IE 及 DOM 合规的浏览器中使用。如果不想在最后插入新选项，则应该使用 DOM 技术和 insertBefore()。</p>
<h2 id="四-选择框移除选项"><a class="header" href="#四-选择框移除选项">四 选择框移除选项</a></h2>
<p>与添加选项类似，移除选项的方法也不止一种。第一种方式是使用 DOM 的 removeChild()方法并传入要移除的选项，比如：</p>
<pre><code class="language-js">selectbox.removeChild(selectbox.options[0]) // 移除第一项
</code></pre>
<p>第二种方式是使用选择框的 remove()方法。这个方法接收一个参数，即要移除选项的索引，比如：</p>
<pre><code class="language-js">selectbox.remove(0) // 移除第一项
</code></pre>
<p>最后一种方式是直接将选项设置为等于 null。这同样也是 DOM 之前浏览器实现的方式：</p>
<pre><code class="language-js">selectbox.options[0] = null // 移除第一项
</code></pre>
<p>要清除选择框的所有选项，需要迭代所有选项并逐一移除它们，如下面例子所示：</p>
<pre><code class="language-js">function clearSelectbox(selectbox) {
  for (let option of selectbox.options) {
    selectbox.remove(0)
  }
}
</code></pre>
<p>这个函数可以逐一移除选择框中的每一项。因为移除第一项会自动将所有选项向前移一位，所以这样就可以移除所有选项。</p>
<h2 id="五-移动和重排选项"><a class="header" href="#五-移动和重排选项">五 移动和重排选项</a></h2>
<p>在 DOM 之前，从一个选择框向另一个选择框移动选项是非常麻烦的，要先从第一个选择框移除选项，然后以相同文本和值创建新选项，再将新选项添加到第二个选择框。 DOM 方法则可以直接将某个选项从第一个选择框移动到第二个选择框，只要对相应选项使用 appendChild()方法即可。如果给这个方法传入文档中已有的元素，则该元素会先从其父元素中移除，然后再插入指定位置。例如，下面的代码会从选择框中移除第一项并插入另一个选择框：</p>
<pre><code class="language-js">let selectbox1 = document.getElementById('selLocations1')
let selectbox2 = document.getElementById('selLocations2')
selectbox2.appendChild(selectbox1.options[0])
</code></pre>
<p>移动选项和移除选项都会导致每个选项的 index 属性重置。重排选项非常类似， DOM 方法同样是最佳途径。要将选项移动到选择框中的特定位置，
insertBefore()方法是最合适的。不过，要把选项移动到最后，还是 appendChild()方法比较方便。</p>
<p>下面的代码演示了将一个选项在选择框中前移一个位置：</p>
<pre><code class="language-js">let optionToMove = selectbox.options[1]
selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index - 1])
</code></pre>
<p>这个例子首先获得要移动选项的索引，然后将其插入之前位于它前面的选项之前，其中第二行代码适用于除第一个选项之外的所有选项。下面的代码则可以将选项向下移动一个位置：</p>
<pre><code class="language-js">let optionToMove = selectbox.options[1]
selectbox.insertBefore(optionToMove, selectbox.options[optionToMove.index + 2])
</code></pre>
<p>以上代码适用于选择框中的所有选项，包括最后一个。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="064-表单-表单提交操作"><a class="header" href="#064-表单-表单提交操作">06.4-表单-表单提交操作</a></h1>
<h2 id="一-如何提交表单"><a class="header" href="#一-如何提交表单">一 如何提交表单</a></h2>
<p>表单是通过用户点击提交按钮或图片按钮的方式提交的。提交按钮可以使用 type 属性为&quot;submit&quot;的<code>&lt;input&gt;</code>或<code>&lt;button&gt;</code>元素来定义，图片按钮可以使用 type 属性为&quot;image&quot;的<code>&lt;input&gt;</code>元素来定义。点击下面例子中定义的所有按钮都可以提交它们所在的表单：</p>
<pre><code class="language-html">&lt;!-- 通用提交按钮 --&gt;
&lt;input type=&quot;submit&quot; value=&quot;Submit Form&quot; /&gt;
&lt;!-- 自定义提交按钮 --&gt;
&lt;button type=&quot;submit&quot;&gt;Submit Form&lt;/button&gt;
&lt;!-- 图片按钮 --&gt;
&lt;input type=&quot;image&quot; src=&quot;graphic.gif&quot; /&gt;
</code></pre>
<p>如果表单中有上述任何一个按钮，且焦点在表单中某个控件上，则按回车键也可以提交表单。（ textarea 控件是个例外，当焦点在它上面时，按回车键会换行。）注意，没有提交按钮的表单在按回车键时不会提交。</p>
<p>以这种方式提交表单会在向服务器发送请求之前触发 submit 事件。这样就提供了一个验证表单数据的机会，可以根据验证结果决定是否真的要提交。阻止这个事件的默认行为可以取消提交表单。例如，下面的代码会阻止表单提交：</p>
<pre><code class="language-js">let form = document.getElementById('myForm')
form.addEventListener('submit', (event) =&gt; {
  // 阻止表单提交
  event.preventDefault()
})
</code></pre>
<p>当然，也可以通过编程方式在 JavaScript 中调用 submit()方法来提交表单。可以在任何时候调用这个方法来提交表单，而且表单中不存在提交按钮也不影响表单提交。下面是一个例子：</p>
<pre><code class="language-js">let form = document.getElementById('myForm')
// 提交表单
form.submit()
</code></pre>
<p>通过 submit()提交表单时， submit 事件不会触发。因此在调用这个方法前要先做数据验证。</p>
<p>表单提交的一个最大的问题是可能会提交两次表单。如果提交表单之后没有什么反应，那么没有耐心的用户可能会多次点击提交按钮，这样就会导致服务器接收到了重复请求。解决这个问题主要有两种方式：在表单提交后禁用提交按钮，或者通过 onsubmit 事件处理程序取消之后的表单提交。</p>
<pre><code class="language-js">form.addEventListener('submit', (event) =&gt; {
  let target = event.target
  // 取得提交按钮
  let btn = target.elements['submit-btn']
  // 禁用提交按钮
  btn.disabled = true
})
</code></pre>
<h2 id="二-html5-约束验证-api"><a class="header" href="#二-html5-约束验证-api">二 HTML5 约束验证 API</a></h2>
<h3 id="21-必填字段-required"><a class="header" href="#21-必填字段-required">2.1 必填字段 required</a></h3>
<p>任何带有 required 属性的字段都必须有值，否则无法提交表单。这个属性适用于<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>字段</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; name=&quot;username&quot; required /&gt;
</code></pre>
<p>如果要检测是否支持必填字段属性，则可以用以下示例：</p>
<pre><code class="language-js">// 方案一
let isUsernameRequired = document.forms[0].elements['username'].required
// 方案二
let isRequiredSupported = 'required' in document.createElement('input')
</code></pre>
<h3 id="22-特殊-type-校验"><a class="header" href="#22-特殊-type-校验">2.2 特殊 type 校验</a></h3>
<p>H5 也提供了一些特殊的 type，用以校验，如 email 等：</p>
<pre><code class="language-html">&lt;input type=&quot;email&quot; name=&quot;email&quot; /&gt; &lt;input type=&quot;url&quot; name=&quot;homepage&quot; /&gt;
</code></pre>
<h3 id="23-minmaxstep"><a class="header" href="#23-minmaxstep">2.3 min/max/step</a></h3>
<p>验证三：指定 min 属性（最小可能值）、 max 属性（最大可能值），以及 step 属性（从 min 到 max 的步长值）。</p>
<pre><code class="language-js">&lt;input type=&quot;number&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;5&quot; name=&quot;count&quot; /&gt;

// input.stepUp(); // 加 1
// input.stepUp(5); // 加 5
// input.stepDown(); // 减 1
// input.stepDown(10); // 减 10
</code></pre>
<h3 id="24-输入模式匹配"><a class="header" href="#24-输入模式匹配">2.4 输入模式匹配</a></h3>
<p>H5 文本字段新增了 pattern 属性，可以指定一个正则：</p>
<pre><code class="language-html">&lt;!-- 限制只能在文本字段中输入数字 --&gt;
&lt;input type=&quot;text&quot; pattern=&quot;\d+&quot; name=&quot;count&quot; /&gt;
</code></pre>
<h3 id="25-有效性检测"><a class="header" href="#25-有效性检测">2.5 有效性检测</a></h3>
<p>使用 checkValidity()方法可以检测表单中任意给定字段是否有效。这个方法在所有表单元素上都可以使用，如果字段值有效就会返回 true，否则返回 false：</p>
<pre><code class="language-js">if (document.forms[0].elements[0].checkValidity()) {
  // 字段有效，继续
} else {
  // 字段无效
}
</code></pre>
<p>要检查整个表单是否有效，可以直接在表单上调用 checkValidity()方法。这个方法会在所有字段都有效时返回 true，有一个字段无效就会返回 false：</p>
<pre><code class="language-js">if (document.forms[0].checkValidity()) {
  // 表单有效，继续
} else {
  // 表单无效
}
</code></pre>
<p>checkValidity()方法只会告诉我们字段是否有效，而 validity 属性会告诉我们字段为什么有效或无效。这个属性是一个对象，包含一系列返回布尔值的属性。</p>
<ul>
<li>customError：如果设置了 setCustomValidity()就返回 true，否则返回 false。</li>
<li>patternMismatch：如果字段值不匹配指定的 pattern 属性则返回 true。</li>
<li>rangeOverflow：如果字段值大于 max 的值则返回 true。</li>
<li>rangeUnderflow：如果字段值小于 min 的值则返回 true。</li>
<li>stepMisMatch：如果字段值与 min、 max 和 step 的值不相符则返回 true。</li>
<li>tooLong：如果字段值的长度超过了 maxlength 属性指定的值则返回 true。</li>
<li>typeMismatch：如果字段值不是&quot;email&quot;或&quot;url&quot;要求的格式则返回 true。</li>
<li>valid：如果其他所有属性的值都为 false 则返回 true。与 checkValidity()的条件一致。</li>
<li>valueMissing：如果字段是必填的但没有值则返回 true。</li>
</ul>
<p>通过 validity 属性可以检查表单字段的有效性，从而获取更具体的信息示例：</p>
<pre><code class="language-js">if (input.validity &amp;&amp; !input.validity.valid) {
  if (input.validity.valueMissing) {
    console.log('Please specify a value.')
  } else if (input.validity.typeMismatch) {
    console.log('Please enter an email address.')
  } else {
    console.log('Value is invalid.')
  }
}
</code></pre>
<h3 id="26-禁用验证"><a class="header" href="#26-禁用验证">2.6 禁用验证</a></h3>
<p>指定 novalidate 属性可以禁止对表单进行任何验证：</p>
<pre><code class="language-html">&lt;form method=&quot;post&quot; action=&quot;/signup&quot; novalidate&gt;
  &lt;!-- 表单元素 --&gt;
&lt;/form&gt;
</code></pre>
<p>这个值也可以通过 JavaScript 属性 noValidate 检索或设置，设置为 true 表示属性存在，设置为 false 表示属性不存在：</p>
<pre><code class="language-js">document.forms[0].noValidate = true // 关闭验证
</code></pre>
<p>如果一个表单中有多个提交按钮，那么可以给特定的提交按钮添加 formnovalidate 属性，指定通过该按钮无须验证即可提交表单：</p>
<pre><code class="language-html">&lt;form method=&quot;post&quot; action=&quot;/foo&quot;&gt;
  &lt;!-- 表单元素 --&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Regular Submit&quot; /&gt;
  &lt;input
    type=&quot;submit&quot;
    formnovalidate
    name=&quot;btnNoValidate&quot;
    value=&quot;Non-validating Submit&quot;
  /&gt;
&lt;/form&gt;
</code></pre>
<p>在这个例子中，第一个提交按钮会让表单像往常一样验证数据，第二个提交按钮则禁用了验证，可以直接提交表单。我们也可以使用 JavaScript 来设置这个属性：</p>
<pre><code class="language-js">// 关闭验证
document.forms[0].elements['btnNoValidate'].formNoValidate = true
</code></pre>
<h2 id="三-表单序列化"><a class="header" href="#三-表单序列化">三 表单序列化</a></h2>
<p>表单在 JavaScript 中可以使用表单字段的 type 属性连同其 name 属性和 value 属性来进行序列化。</p>
<p>在提交表单时，浏览器需要确定提交哪些内容，其实现依赖于：</p>
<ul>
<li>字段名和值是 URL 编码的并以和号（ &amp;）分隔。</li>
<li>禁用字段不会发送。</li>
<li>复选框或单选按钮只在被选中时才发送。</li>
<li>类型为&quot;reset&quot;或&quot;button&quot;的按钮不会发送。</li>
<li>多选字段的每个选中项都有一个值。</li>
<li>通过点击提交按钮提交表单时，会发送该提交按钮；否则，不会发送提交按钮。类型为&quot;image&quot;的<code>&lt;input&gt;</code>元素视同提交按钮。</li>
<li><code>&lt;select&gt;</code>元素的值是被选中<code>&lt;option&gt;</code>元素的 value 属性。如果<code>&lt;option&gt;</code>元素没有 value 属性，则该值是它的文本。</li>
</ul>
<p>表单序列化通常不包含任何按钮，因为序列化得到的字符串很可能以其他方式提交。除此之外其他规则都应该遵循。最终完成表单序列化的代码如下：</p>
<p>序列化函数实现：</p>
<pre><code class="language-js">function serialize(form) {
  let parts = [],
    field = null,
    len,
    optLen,
    option,
    optValue

  for (let i = 0, len = form.elements.length; i &lt; len; i++) {
    field = form.elements[i]
    switch (field.type) {
      case 'select-one':
      case 'select-multiple':
        if (field.name.length) {
          for (let j = 0, optLen = field.options.length; j &lt; optLen; j++) {
            option = field.options[j]
            if (option.selected) {
              optValue = ''
              if (option.hasAttribute) {
                optValue = option.hasAttribute('value')
                  ? option.value
                  : option.text
              } else {
                optValue = option.attributes['value'].specified
                  ? option.value
                  : option.text
              }
              parts.push(
                encodeURIComponent(field.name) +
                  '=' +
                  encodeURIComponent(optValue)
              )
            }
          }
        }
        break
      case undefined: //字段集
      case 'file': //文件输入
      case 'submit': //提交按钮
      case 'reset': //重置按钮
      case 'button': //自定义按钮
        break
      case 'radio': //单选按钮
      case 'checkbox': //复选框
        if (!field.checked) {
          break
        }
      /* 执行默认操作 */
      default:
        //不包含没有名字的表单字段
        if (field.name.length) {
          parts.push(
            encodeURIComponent(field.name) +
              '=' +
              encodeURIComponent(field.value)
          )
        }
    }
  }
  return parts.join('&amp;')
}
</code></pre>
<p>这个 serialize()函数一开始定义了一个名为 parts 的数组，用于保存要创建字符串的各个部分。接下来通过 for 循环迭代每个表单字段，将字段保存在 field 变量中。获得一个字段的引用后，再通过 switch 语句检测其 type 属性。最麻烦的是序列化<code>&lt;select&gt;</code>元素，包括单选和多选两种模式。在遍历选择框的每个选项时，只要有选项被选中，就将其添加到结果字符串。单选控件只会有一个选项被选中，多选控件则可能有零或多个选项被选中。同样的代码适用于两种选择类型，因为浏览器会限制可选项的数量。找到选中项时，需要确定使用哪个值。如果不存在 value 属性，则应该以选项文本代替，不过 value 属性为空字符串是完全有效的。为此需要使用 DOM 合规的浏览器支持的 hasAttribute()方法，而在 IE8 及更早版本中要使用值的 specified 属性。</p>
<p>表单中如果有<code>&lt;fieldset&gt;</code>元素，它就会出现在元素集合中，但应该没有 type 属性。因此，如果 type 属性是 undefined，则不必纳入序列化。各种类型的按钮以及文件输入字段也是如此。（文件输入字段在提交表单时包含文件的内容，但这些字段通常无法转换，因而也要排除在序列化之外。）对于单选按钮和复选框，会检测其 checked 属性。如果值为 false 就退出 switch 语句；如果值为 true，则继续执行 default 分支，将字段的名和值编码后添加到 parts 数组。注意，所有没有名字的表单字段都不会包含在序列化结果中以模拟浏览器的表单提交行为。这个函数的最后一步是使用 join()通过和号把所有字段的名值对拼接起来。</p>
<p>serialize()函数返回的结果是查询字符串格式。如果想要返回其他格式，修改起来也很简单。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="065-表单-富文本编辑"><a class="header" href="#065-表单-富文本编辑">06.5-表单-富文本编辑</a></h1>
<h2 id="一-富文本编辑创建方式"><a class="header" href="#一-富文本编辑创建方式">一 富文本编辑创建方式</a></h2>
<p>富文本编辑也就是所谓的“所见即所得”（ WYSIWYG， What You See Is What You Get）编辑。</p>
<h3 id="11-通过-iframe-方式创建"><a class="header" href="#11-通过-iframe-方式创建">1.1 通过 iframe 方式创建</a></h3>
<p>富文本编辑基本的技术就是在空白 HTML 文件中嵌入一个 iframe。通过 designMode 属性，可以将这个空白文档变成可以编辑的，实际编辑的则是<code>&lt;body&gt;</code>元素的 HTML。 designMode 属性有两个可能的值： &quot;off&quot;（默认值）和&quot;on&quot;。设置为&quot;on&quot;时，整个文档都会变成可以编辑的（显示插入光标），从而可以像使用文字处理程序一样编辑文本，通过键盘将文本标记为粗体、斜体，等等。</p>
<pre><code class="language-html">&lt;iframe name=&quot;richedit&quot; style=&quot;height: 100px; width: 100px&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
  window.addEventListener('load', () =&gt; {
    frames['richedit'].document.designMode = 'on'
  })
&lt;/script&gt;
</code></pre>
<h3 id="12-通过-contenteditable-属性创建"><a class="header" href="#12-通过-contenteditable-属性创建">1.2 通过 contenteditable 属性创建</a></h3>
<p>contenteditable 属性 也可以实现富文本处理。给页面中的任何元素指定 contenteditable 属性，然后该元素会立即被用户编辑。这种方式更受欢迎，因为
不需要额外的 iframe、空页面和 JavaScript，只给元素添加一个 contenteditable 属性即可，比如：</p>
<pre><code class="language-html">&lt;div class=&quot;editable&quot; id=&quot;richedit&quot; contenteditable&gt;&lt;/div&gt;
</code></pre>
<p>元素中包含的任何文本都会自动被编辑，元素本身类似于 <code>&lt;textarea&gt;</code> 元素。通过设置 contentEditable 属性，也可以随时切换元素的可编辑状态：</p>
<pre><code class="language-js">let div = document.getElementById('richedit')
richedit.contentEditable = 'true'
</code></pre>
<p>contentEditable 属性有 3 个可能的值： &quot;true&quot;表示开启， &quot;false&quot;表示关闭， &quot;inherit&quot;表示继承父元素的设置（因为在 contenteditable 元素内部会创建和删除元素）。</p>
<p>贴士：访问伪 URL data:text/html, <code>&lt;html contenteditable&gt;</code>可以把浏览器窗口转换为一个记事本。这是因为这样会临时创建 DOM 树并将整个文档变成可编辑区域。</p>
<h2 id="二-与富文本交互"><a class="header" href="#二-与富文本交互">二 与富文本交互</a></h2>
<p>与富文本编辑器交互的主要方法是使用 document.execCommand()，该方法接受 3 个参数：</p>
<ul>
<li>要执行的命令、</li>
<li>表示浏览器是否为命令提供用户界面的布尔值</li>
<li>执行命令必需的值（如果不需要则为 null）</li>
</ul>
<p>为了跨浏览器兼容，第二个参数应该始终为 false，因为 Firefox 会在其为 true 时抛出错误。</p>
<p>常用的命令有：</p>
<pre><code class="language-txt">命令                  值（第三个参数）          说 明
backcolor             颜色字符串              设置文档背景颜色
bold                  null                  切换选中文本的粗体样式
copy                  null                  将选中文本复制到剪贴板
createlink            URL 字符串             将当前选中文本转换为指向给定 URL 的链接
cut                   null                  将选中文本剪切到剪贴板
delete                null                  删除当前选中的文本
fontname              字体名                 将选中文本改为使用指定字体
fontsize              1~7                   将选中文本改为指定字体大小
forecolor             颜色字符串              将选中文本改为指定颜色
formatblock           HTML 标签，如&lt;h1&gt;       将选中文本包含在指定的 HTML 标签中
indent                null                  缩进文本
inserthorizontalrule  null                  在光标位置插入&lt;hr&gt;元素
insertimage           图片 URL               在光标位置插入图片
insertorderedlist     null                  在光标位置插入&lt;ol&gt;元素
insertparagraph       null                  在光标位置插入&lt;p&gt;元素
insertunorderedlist   null                  在光标位置插入&lt;ul&gt;元素
italic                null                  切换选中文本的斜体样式
justifycenter         null                  在光标位置居中文本块
justifyleft           null                  在光标位置左对齐文本块
outdent               null                  减少缩进
paste                 null                  在选中文本上粘贴剪贴板内容
removeformat          null                  移除包含光标所在位置块的 HTML 标签。这是 formatblock 的反操作
selectall             null                  选中文档中所有文本
underline             null                  切换选中文本的下划线样式
unlink                null                  移除文本链接。这是 createlink 的反操作
</code></pre>
<p>剪贴板相关的命令与浏览器关系密切。虽然这些命令并不都可以通过 document.execCommand()使用，但相应的键盘快捷键都是可以用的。</p>
<p>这些命令可以用于修改内嵌窗格（ iframe）中富文本区域的外观，如下面的例子所示：</p>
<pre><code class="language-js">// 在内嵌窗格中切换粗体文本样式
frames['richedit'].document.execCommand('bold', false, null)
// 在内嵌窗格中切换斜体文本样式
frames['richedit'].document.execCommand('italic', false, null)
// 在内嵌窗格中创建指向 www.wrox.com 的链接
frames['richedit'].document.execCommand(
  'createlink',
  false,
  'http://www.wrox.com'
)
// 在内嵌窗格中为内容添加&lt;h1&gt;标签
frames['richedit'].document.execCommand('formatblock', false, '&lt;h1&gt;')
</code></pre>
<p>同样的方法也可以用于页面中添加了 contenteditable 属性的元素，只不过要使用当前窗口而不是内嵌窗格中的 document 对象：</p>
<pre><code class="language-js">// 切换粗体文本样式
document.execCommand('bold', false, null)
// 切换斜体文本样式
document.execCommand('italic', false, null)
// 创建指向 www.wrox.com 的链接
document.execCommand('createlink', false, 'http://www.wrox.com')
// 为内容添加&lt;h1&gt;标签
document.execCommand('formatblock', false, '&lt;h1&gt;')
</code></pre>
<p>还有与命令相关的其他一些方法。第一个方法是 queryCommandEnabled()，此方法用于确定对当前选中文本或光标所在位置是否可以执行相关命令。它只接收一个参数，即要检查的命令名。如果可编辑区可以执行该命令就返回 true，否则返回 false。来看下面的例子：</p>
<pre><code class="language-js">let result = frames['richedit'].document.queryCommandEnabled('bold')
</code></pre>
<p>以上代码在当前选区可以执行&quot;bold&quot;命令时返回 true。不过要注意， queryCommandEnabled()返回 true 并不代表允许执行相关命令，只代表当前选区适合执行相关命令。在 Firefox 中，queryCommandEnabled(&quot;cut&quot;)即使默认不允许剪切也会返回 true。</p>
<p>另一个方法 queryCommandState()用于确定相关命令是否应用到了当前文本选区。例如，要确定当前选区的文本是否为粗体，可以这样：</p>
<pre><code class="language-js">let isBold = frames['richedit'].document.queryCommandState('bold')
</code></pre>
<p>如果之前给文本选区应用过&quot;bold&quot;命令，则以上代码返回 true。全功能富文本编辑器可以利用这个方法更新粗体、斜体等按钮。</p>
<p>最后一个方法是 queryCommandValue()，此方法可以返回执行命令时使用的值（即前面示例的 execCommand()中的第三个参数）。如果对一段选中文本应用了值为 7 的&quot;fontsize&quot;命令，则如下代码会返回 7：</p>
<pre><code class="language-js">// 这个方法可用于确定如何将命令应用于文本选区，从而进一步决定是否需要执行下一个命令
let fontSize = frames['richedit'].document.queryCommandValue('fontsize')
</code></pre>
<h2 id="三-富文本选择"><a class="header" href="#三-富文本选择">三 富文本选择</a></h2>
<p>在内嵌窗格中使用 getSelection()方法，可以获得富文本编辑器的选区。这个方法暴露在 document 和 window 对象上，返回表示当前选中文本的 Selection 对象。每个 Selection 对象都拥有以下属性。</p>
<ul>
<li>anchorNode：选区开始的节点。</li>
<li>anchorOffset：在 anchorNode 中，从开头到选区开始跳过的字符数。</li>
<li>focusNode：选区结束的节点。</li>
<li>focusOffset： focusNode 中包含在选区内的字符数。</li>
<li>isCollapsed：布尔值，表示选区起点和终点是否在同一个地方。</li>
<li>rangeCount：选区中包含的 DOM 范围数量。Selection 的属性并没有包含很多有用的信息。好在它的以下方法提供了更多信息，并允许操作选区。</li>
<li>addRange(range)：把给定的 DOM 范围添加到选区。</li>
<li>collapse(node, offset)：将选区折叠到给定节点中给定的文本偏移处。</li>
<li>collapseToEnd()：将选区折叠到终点。</li>
<li>collapseToStart()：将选区折叠到起点。</li>
<li>containsNode(node)：确定给定节点是否包含在选区中。</li>
<li>deleteFromDocument()：从文档中删除选区文本。 与执行 execCommand(&quot;delete&quot;, false,null)命令结果相同。</li>
<li>extend(node, offset)：通过将 focusNode 和 focusOffset 移动到指定值来扩展选区。</li>
<li>getRangeAt(index)：返回选区中指定索引处的 DOM 范围。</li>
<li>removeAllRanges()：从选区中移除所有 DOM 范围。这实际上会移除选区，因为选区中至少要包含一个范围。</li>
<li>removeRange(range)：从选区中移除指定的 DOM 范围。</li>
<li>selectAllChildren(node)：清除选区并选择给定节点的所有子节点。</li>
<li>toString()：返回选区中的文本内容。</li>
</ul>
<p>Selection 对象的这个方法极其强大，充分利用了 DOM 范围来管理选区。操纵 DOM 范围可以实现比 execCommand()更细粒度的控制，因为可以直接对选中文本的 DOM 内容进行操作：</p>
<pre><code class="language-js">let selection = frames['richedit'].getSelection()
// 取得选中的文本
let selectedText = selection.toString()
// 取得表示选区的范围
let range = selection.getRangeAt(0)
// 高亮选中的文本
let span = frames['richedit'].document.createElement('span')
span.style.backgroundColor = 'yellow'
range.surroundContents(span)
</code></pre>
<p>以上代码会在富文本编辑器中给选中文本添加黄色高亮背景。实现方式是在默认选区使用 DOM 范围，用 surroundContents()方法给选中文本添加背景为黄色的<code>&lt;span&gt;</code>标签。</p>
<p>IE8 及更早版本不支持 DOM 范围，不过它们允许通过专有的 selection 对象操作选中的文本。如 selection 对象是 document 的属性。要取得富文本编辑器中选中的文本，必须先创建一个文本范围，然后再访问其 text 属性：</p>
<pre><code class="language-js">let range = frames['richedit'].document.selection.createRange()
let selectedText = range.text
</code></pre>
<p>使用 IE 文本范围执行 HTML 操作不像使用 DOM 范围那么可靠，不过也是可以做到的。要实现与使用 DOM 范围一样的高亮效果，可以组合使用 htmlText 属性和 pasteHTML()方法：</p>
<pre><code class="language-js">let range = frames['richedit'].document.selection.createRange()
range.pasteHTML(
  '&lt;span style=&quot;background-color:yellow&quot;&gt;${range.htmlText}&lt;/span&gt;'
)
</code></pre>
<p>以上代码使用 htmlText 取得了当前选区的 HTML，然后用一个<code>&lt;span&gt;</code>标签将其包围起来并通过 pasteHTML()再把它插入选区中。</p>
<h2 id="四-通过表单提交富文本"><a class="header" href="#四-通过表单提交富文本">四 通过表单提交富文本</a></h2>
<p>因为富文本编辑是在内嵌窗格中或通过为元素指定 contenteditable 属性实现的，而不是在表单控件中实现，所以富文本编辑器技术上与表单没有关系。这意味着要把富文本编辑的结果提交给服务器，必须手工提取 HTML 并自己提交。通常的解决方案是在表单中添加一个隐藏字段，使用内嵌窗格或 contenteditable 元素的 HTML 更新它的值。在表单提交之前，从内嵌窗格或 contenteditable 元素中提取出 HTML 并插入隐藏字段中。例如，以下代码在使用内嵌窗格实现富文本编辑时，可以用在表单的 onsubmit 事件处理程序中：</p>
<pre><code class="language-js">form.addEventListener('submit', (event) =&gt; {
  let target = event.target
  target.elements['comments'].value = frames['richedit'].document.body.innerHTML
})
</code></pre>
<p>这里，代码使用文档主体的 innerHTML 属性取得了内嵌窗格的 HTML，然后将其插入名为&quot;comments&quot;的表单字段中。这样做可以确保在提交表单之前给表单字段赋值。如果使用 submit()方法手工提交表单，那么要注意在提交前先执行上述操作。对于 contenteditable 元素，执行这一操作的代码是类似的：</p>
<pre><code class="language-js">form.addEventListener('submit', (event) =&gt; {
  let target = event.target
  target.elements['comments'].value =
    document.getElementById('richedit').innerHTML
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="071-h5-中的-dom-操作变化"><a class="header" href="#071-h5-中的-dom-操作变化">07.1-H5 中的 DOM 操作变化</a></h1>
<h2 id="序-html5-概念"><a class="header" href="#序-html5-概念">序 HTML5 概念</a></h2>
<p>HTML 只是一个纯标记语言，JS 绑定事件都交给了 DOM 规范。但是 H5 规范包含了大量的 JS 的 API，其覆盖范围极广，甚至包括：通知、文件操作、流操作等等，这些新增的 JavaScriptAPI 如果与网络操作有关则会在网络编程章节中讲解。</p>
<p>最常见的 H5 相关的功能有：</p>
<ul>
<li>更规范简介的 HTML 文档</li>
<li>更多的标签语义化</li>
<li>针对 BOM 的变化：history 中的状态记录管理、localStorage 等存储机制、navigator.geolocation 地理位置等</li>
<li>针对 DOM 的变化：className/classList 对元素的 CSS 类名进行操作、focus() 方法获取焦点、标准化了 document.compatMode，可以获取渲染模式、标准化了自定义属性操作、标准化了 innerHTML 属性、标准化了滚动相关：scrollIntoView()</li>
<li>一些高级功能：跨文档通信、离线应用、多媒体应用、原生拖拽等等</li>
<li>一些高级 API：针对文件、流等操作的 API</li>
</ul>
<h2 id="一-对-html-的增强"><a class="header" href="#一-对-html-的增强">一 对 HTML 的增强</a></h2>
<p>更规范的 HTML 文档规范，更多的语义化标签。</p>
<h2 id="二-对-bom-的增强"><a class="header" href="#二-对-bom-的增强">二 对 BOM 的增强</a></h2>
<p>history 对象可以进行状态记录管理。</p>
<p>新增了 localStorage、sessionStorage 等存储机制。</p>
<p>navigator.geolocation 支持地理位置操作。</p>
<h2 id="三-dom-变化"><a class="header" href="#三-dom-变化">三 DOM 变化</a></h2>
<h3 id="31-通过-class-类名操作元素"><a class="header" href="#31-通过-class-类名操作元素">3.1 通过 class 类名操作元素</a></h3>
<p>document.getElementsByClassName() 是 H5 新增的方法。</p>
<p>className 属性 现在也可以直接通过元素获取：</p>
<pre><code class="language-js">// 要删除&quot;user&quot;类
let targetClass = 'user'
// 把类名拆成数组
let classNames = div.className.split(/\s+/)
// 找到要删除类名的索引
let idx = classNames.indexOf(targetClass)
// 如果有则删除
if (idx &gt; -1) {
  classNames.splice(i, 1)
}
// 重新设置类名
div.className = classNames.join(' ')
</code></pre>
<p>H5 为元素新增了 classList 属性，支持对类名进行增删改查：</p>
<pre><code class="language-js">// 删除&quot;disabled&quot;类
div.classList.remove('disabled')
// 添加&quot;current&quot;类
div.classList.add('current')
// 切换&quot;user&quot;类
div.classList.toggle(&quot;user&quot;);
// 检测类名
if (div.classList.contains(&quot;bd&quot;) &amp;&amp; !div.classList.contains(&quot;disabled&quot;)){
// 执行操作
)
// 迭代类名
for (let class of div.classList){
doStuff(class);
}
</code></pre>
<h3 id="32-自定义属性"><a class="header" href="#32-自定义属性">3.2 自定义属性</a></h3>
<p>H5 规定使用 data- 来描述元素的自定义属性：</p>
<pre><code class="language-html">&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  let div = document.getElementById('myDiv')
  // 取得自定义数据属性的值
  let appId = div.dataset.appId
  let myName = div.dataset.myname
  // 设置自定义数据属性的值
  div.dataset.appId = 23456
  div.dataset.myname = 'Michael'
&lt;/script&gt;
</code></pre>
<h3 id="33-插入标记-innerhtml-与-outerhtml"><a class="header" href="#33-插入标记-innerhtml-与-outerhtml">3.3 插入标记 innerHTML 与 outerHTML</a></h3>
<p>IE8 中使用 <code>元素.innerHTML=''</code> 时，如果内部包含 script 标签，且指定了 defer 属性，若 script 标签之前是非受控元素，脚本是可以执行的。</p>
<p>而当前的主流浏览器中 innerHTML 插入的脚本是不会执行的。</p>
<h3 id="34-焦点管理"><a class="header" href="#34-焦点管理">3.4 焦点管理</a></h3>
<pre><code class="language-js">button.focus()
alert(document.hasFocus()) //true 确定文档是否获得了焦点
alert(document.activeElement === button) //true
</code></pre>
<p>默认情况下，文档刚刚加载完成时，document.activeElement 中保存的是 document.body 元素的引用。文档加载期间，document.activeElement 的值为 null。</p>
<h3 id="36-htmldocument-变化"><a class="header" href="#36-htmldocument-变化">3.6 HTMLDocument 变化</a></h3>
<p>H5 规范了 readyState 属性，其值有：</p>
<ul>
<li>loading，正在加载文档；</li>
<li>complete，已经加载完文档</li>
</ul>
<p>H5 规范了 compatMode 属性，用于告知开发人员浏览器采用了哪种渲染模式：</p>
<pre><code class="language-js">if (document.compatMode == 'CSS1Compat') {
  // 标准模式
  alert('Standards mode')
} else {
  alert('Quirks mode') // 混杂模式
}
</code></pre>
<p>document.body 很好用，H5 又引入了 document.head 属性。</p>
<p>H5 引入了<code>document.charset = &quot;UTF-8&quot;;</code>用于设置字符集。如果文档没有使用默认的字符集，那 charset 和 defaultCharset 属性的值可能会不一样，例如：</p>
<pre><code class="language-js">if (document.charset != document.defaultCharset) {
  alert('Custom character set being used.')
}
</code></pre>
<h3 id="37-html5-新增属性"><a class="header" href="#37-html5-新增属性">3.7 HTML5 新增属性</a></h3>
<pre><code class="language-txt">hidden：hidden 属性可以代替 CSS 样式中的 display 属性
spellcheck：表单元素的该属性支持 true、false 属性值，以判断是否需要浏览器对文本进行校验，如：对拼错的单词进行提示。
disabled：新属性 disabled 直接就可以让 input 无法选择，而老版的 html 中要使用:disabled=&quot;disabled&quot;
</code></pre>
<h2 id="四-离线应用"><a class="header" href="#四-离线应用">四 离线应用</a></h2>
<p>离线应用可以帮助用户在没有网络时使用 web 程序，H5 的离线功能包含：离线资源缓存、在线状态监测、本地数据存储等。<br />
离线 web 应用比普通的 web 应用多了一个描述文件，该文件用来列出需要缓存和永不缓存的资源，描述文件的扩展名为：.manifest 或者 .appcache(推荐使用)。<br />
首先需要在项目目录下创建 offline.appcache 文件：</p>
<pre><code class="language-txt">CACHE MANIFEST      # 说明这是离线应用描述文件
CACHE:              # 会被缓存的资源列表
index.html
index.js
NETWORK:            # 总是从 web 获取的资源列表
test.js
</code></pre>
<p>html 文件需要添加如下配置：</p>
<pre><code class="language-html">&lt;html lmanifest=&quot;./offline.appcache&quot;&gt;&lt;/html&gt;
</code></pre>
<h2 id="五-page-visibility-api"><a class="header" href="#五-page-visibility-api">五 Page Visibility API</a></h2>
<p>Web 开发中一个常见的问题是开发者不知道用户什么时候真正在使用页面。如果页面被最小化或隐藏在其他标签页后面，那么轮询服务器或更新动画等功能可能就没有必要了。 Page Visibility API 旨在为开发者提供页面对用户是否可见的信息。</p>
<p>这个 API 本身非常简单，由 3 部分构成：</p>
<ul>
<li>document.visibilityState 值，表示下面 4 种状态之一。
<ul>
<li>页面在后台标签页或浏览器中最小化了。</li>
<li>页面在前台标签页中。</li>
<li>实际页面隐藏了，但对页面的预览是可见的（例如在 Windows 7 上，用户鼠标移到任务栏图标上会显示网页预览）。</li>
<li>页面在屏外预渲染。</li>
</ul>
</li>
<li>visibilitychange 事件，该事件会在文档从隐藏变可见（或反之）时触发。</li>
<li>document.hidden 布尔值，表示页面是否隐藏。这可能意味着页面在后台标签页或浏览器中被最小化了。这个值是为了向后兼容才继续被浏览器支持的，应该优先使用 document.visibilityState 检测页面可见性。</li>
</ul>
<p>要想在页面从可见变为隐藏或从隐藏变为可见时得到通知，需要监听 visibilitychange 事件。document.visibilityState 的值是以下三个字符串之一：</p>
<ul>
<li>&quot;hidden&quot;</li>
<li>&quot;visible&quot;</li>
<li>&quot;prerender&quot;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="072-h5-新功能-跨文档通信与通知"><a class="header" href="#072-h5-新功能-跨文档通信与通知">07.2-H5 新功能-跨文档通信与通知</a></h1>
<h2 id="一-跨文档通信"><a class="header" href="#一-跨文档通信">一 跨文档通信</a></h2>
<p>跨文档消息，有时候也简称为 XDM（ cross-document messaging），是一种在不同执行上下文（如不同工作者或不同源的页面）间传递信息的能力。例如， www.wrox.com 上的页面想要与包含在内嵌窗格中的 p2p.wrox.com 上面的页面通信。</p>
<p>在过去，跨文档通信（跨源、跨窗口，cross-document messaging）往往是与服务端进行数据交互来实现的，并且需要借助轮询或者 Connect 技术来监听消息。</p>
<p>XDM 主要用于实现安全的跨源通信，可以用在窗口之间通信、工作者之间通信。H5 提供了 PostMessages() 方法即可把数据传递到另一个位置</p>
<pre><code class="language-js">// 参数一：消息体
// 参数二：消息来自哪个域
// 参数三：可选。是一串和 message 同时传递的 Transferable 对象，这些对象的所有权将被转译给消息的接收方，而发送乙方将不再保有所有权

let iframeWindow = document.getElementById('myframe').contentWindow // 获取iframe
iframeWindow.postMessage('A secret', 'http://www.demo.com')
</code></pre>
<p>iframe 发送示例：</p>
<pre><code class="language-html">&lt;button id=&quot;btn&quot;&gt;点击发送消息给 iframe&lt;/button&gt;
&lt;iframe src=&quot;http:127.0.0.1/iframe.html&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
  let btn = document.querySelector('#btn')
  let data = ['周一', '周二', '周五']
  btn.onclick = function () {
    alert('执行发送数据给 iframe？')
    window.parent.postMessage(data, 'http:127.0.0.1/iframe.html')
  }
&lt;/script&gt;
</code></pre>
<p>iframe 接收数据示例：</p>
<pre><code class="language-js">// 接收到XDM消息后，window上异步触发 message事件
window.addEventListener('message', (event) =&gt; {
  // 确保来自预期发送者
  if (event.origin == 'http://www.wrox.com') {
    // 对数据进行一些处理
    processMessage(event.data)
    // 可选：向来源窗口发送一条消息
    event.source.postMessage('Received!', 'http://p2p.wrox.com')
  }
})
</code></pre>
<p>传给 onmessage 事件处理程序的 event 对象包含以下 3 方面重要信息。</p>
<ul>
<li>data：作为第一个参数传递给 postMessage()的字符串数据。</li>
<li>origin：发送消息的文档源，例如&quot;http://www.wrox.com&quot;。</li>
<li>source：发送消息的文档中 window 对象的代理。这个代理对象主要用于在发送上一条消息的窗口中执行 postMessage()方法。如果发送窗口有相同的源，那么这个对象应该就是 window 对象。</li>
</ul>
<p>大多数情况下， event.source 是某个 window 对象的代理，而非实际的 window 对象。因此不能通过它访问所有窗口下的信息。最好只使用 postMessage()，这个方法永远存在而且可以调用。</p>
<p>XDM 有一些怪异之处。首先， postMessage()的第一个参数的最初实现始终是一个字符串。后来，第一个参数改为允许任何结构的数据传入，不过并非所有浏览器都实现了这个改变。为此，最好就是只通过 postMessage() 发送字符串，如果需要传递结构化数据，那么最好先对该数据调用 JSON.stringify()，通过 postMessage()传过去之后，再在 onmessage 事件处理程序中调用 JSON.parse()。</p>
<h2 id="二-通知"><a class="header" href="#二-通知">二 通知</a></h2>
<h3 id="21-授权通知"><a class="header" href="#21-授权通知">2.1 授权通知</a></h3>
<p>Notifications API 用于向用户显示通知，比传统的 alert() 更灵活，常用于 Service Worker，使得网页看起来像一个应用。</p>
<p>Notifications API 有被滥用的可能，因此默认会开启两项安全措施：</p>
<ul>
<li>通知只能在运行在安全上下文的代码中被触发；</li>
<li>通知必须按照每个源的原则明确得到用户允许。</li>
</ul>
<pre><code class="language-js">Notification.requestPermission().then((permission) =&gt; {
  console.log('User responded to permission request:', permission)
})
</code></pre>
<p>&quot;granted&quot;值意味着用户明确授权了显示通知的权限。除此之外的其他值意味着显示通知会静默失败。如果用户拒绝授权，这个值就是&quot;denied&quot;。一旦拒绝，就无法通过编程方式挽回，因为不可能再触发授权提示。</p>
<h3 id="22-显示和隐藏通知"><a class="header" href="#22-显示和隐藏通知">2.2 显示和隐藏通知</a></h3>
<p>Notification 构造函数用于创建和显示通知。最简单的通知形式是只显示一个标题，这个标题内容可以作为第一个参数传给 Notification 构造函数。以下面这种方式调用 Notification，应该会立即显示通知：</p>
<pre><code class="language-js">new Notification('Title text!')
</code></pre>
<p>可以通过 options 参数对通知进行自定义，包括设置通知的主体、图片和振动等：</p>
<pre><code class="language-js">new Notification('Title text!', {
  body: 'Body text!',
  image: 'path/to/image.png',
  vibrate: true,
})
</code></pre>
<p>调用这个构造函数返回的 Notification 对象的 close()方法可以关闭显示的通知。下面的例子展示了显示通知后 1000 毫秒再关闭它：</p>
<pre><code class="language-js">const n = new Notification('I will close in 1000ms')
setTimeout(() =&gt; n.close(), 1000)
</code></pre>
<h3 id="23-通知生命周期"><a class="header" href="#23-通知生命周期">2.3 通知生命周期</a></h3>
<p>通知并非只用于显示文本字符串，也可用于实现交互。 Notifications API 提供了 4 个用于添加回调的生命周期方法：</p>
<ul>
<li>onshow 在通知显示时触发；</li>
<li>onclick 在通知被点击时触发；</li>
<li>onclose 在通知消失或通过 close()关闭时触发；</li>
<li>onerror 在发生错误阻止通知显示时触发。</li>
</ul>
<p>下面的代码将每个生命周期事件都通过日志打印了出来：</p>
<pre><code class="language-js">const n = new Notification('foo')
n.onshow = () =&gt; console.log('Notification was shown!')
n.onclick = () =&gt; console.log('Notification was clicked!')
n.onclose = () =&gt; console.log('Notification was closed!')
n.onerror = () =&gt; console.log('Notification experienced an error!')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="073-h5-新功能-媒体元素"><a class="header" href="#073-h5-新功能-媒体元素">07.3-H5 新功能-媒体元素</a></h1>
<h2 id="一-媒体元素基础使用"><a class="header" href="#一-媒体元素基础使用">一 媒体元素基础使用</a></h2>
<p>HTML5 新增了两个与媒体相关的元素：<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>，可以取代 flash，为浏览器提供了嵌入音频和视频的统一解决方案。</p>
<p>嵌入方案：</p>
<pre><code class="language-html">&lt;!-- 嵌入视频 --&gt;
&lt;video id=&quot;myVideo&quot;&gt;
  &lt;source src=&quot;conference.webm&quot; type=&quot;video/webm; codecs='vp8, vorbis'&quot; /&gt;
  &lt;source src=&quot;conference.ogv&quot; type=&quot;video/ogg; codecs='theora, vorbis'&quot; /&gt;
  &lt;source src=&quot;conference.mpg&quot; /&gt;
  Video player not available.
&lt;/video&gt;

&lt;!-- 嵌入音频 --&gt;
&lt;audio id=&quot;myAudio&quot;&gt;
  &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot; /&gt;
  &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;
  Audio player not available.
&lt;/audio&gt;
</code></pre>
<p>相关属性、事件请参考 MDN。</p>
<h2 id="二-自定义媒体播放器"><a class="header" href="#二-自定义媒体播放器">二 自定义媒体播放器</a></h2>
<p>使用<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>的 play()和 pause()方法，可以手动控制媒体文件的播放，综合使用属性、事件和这些方法，可以方便地创建自定义的媒体播放器：</p>
<pre><code class="language-html">&lt;div class=&quot;mediaplayer&quot;&gt;
  &lt;div class=&quot;video&quot;&gt;
    &lt;video
      id=&quot;player&quot;
      src=&quot;movie.mov&quot;
      poster=&quot;mymovie.jpg&quot;
      width=&quot;300&quot;
      height=&quot;200&quot;
    &gt;
      Video player not available.
    &lt;/video&gt;
  &lt;/div&gt;
  &lt;div class=&quot;controls&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;Play&quot; id=&quot;video-btn&quot; /&gt;
    &lt;span id=&quot;curtime&quot;&gt;0&lt;/span&gt;/&lt;span id=&quot;duration&quot;&gt;0&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>通过使用 JavaScript 创建一个简单的视频播放器，上面这个基本的 HTML 就可以被激活了，如下所示：</p>
<pre><code class="language-js">// 取得元素的引用
let player = document.getElementById('player'),
  btn = document.getElementById('video-btn'),
  curtime = document.getElementById('curtime'),
  duration = document.getElementById('duration')
// 更新时长
duration.innerHTML = player.duration
// 为按钮添加事件处理程序
btn.addEventListener('click', (event) =&gt; {
  if (player.paused) {
    player.play()
    btn.value = 'Pause'
  } else {
    player.pause()
    btn.value = 'Play'
  }
})
// 周期性更新当前时间
setInterval(() =&gt; {
  curtime.innerHTML = player.currentTime
}, 250)
</code></pre>
<h2 id="三-检测编解码器"><a class="header" href="#三-检测编解码器">三 检测编解码器</a></h2>
<p>并不是所有浏览器都支持<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>的所有编解码器，这通常意味着必须提供多个媒体源。为此，也有 JavaScript API 可以用来检测浏览器是否支持给定格式和编解码器。这两个媒体元素都有一个名为 canPlayType()的方法，该方法接收一个格式/编解码器字符串，返回一个字符串值： &quot;probably&quot;、 &quot;maybe&quot;或&quot;&quot;（空字符串），其中空字符串就是假值，意味着可以在 if 语句中像这样使用 canPlayType()：</p>
<pre><code class="language-js">if (audio.canPlayType('audio/mpeg')) {
  // 执行某些操作
}
</code></pre>
<p>&quot;probably&quot;和&quot;maybe&quot;都是真值，在 if 语句的上下文中可以转型为 true。在只给 canPlayType()提供一个 MIME 类型的情况下，最可能返回的值是&quot;maybe&quot;和空字符串。这是因为文件实际上只是一个包装音频和视频数据的容器，而真正决定文件是否可以播放的是编码。在同时提供 MIME 类型和编解码器的情况下，返回值的可能性会提高到&quot;probably&quot;。下面是几个例子：</p>
<pre><code class="language-js">let audio = document.getElementById('audio-player')
// 很可能是&quot;maybe&quot;
if (audio.canPlayType('audio/mpeg')) {
  // 执行某些操作
}
// 可能是&quot;probably&quot;
if (audio.canPlayType('audio/ogg; codecs=&quot;vorbis&quot;')) {
  // 执行某些操作
}
</code></pre>
<h2 id="四-音频类型"><a class="header" href="#四-音频类型">四 音频类型</a></h2>
<p><code>&lt;audio&gt;</code>元素还有一个名为 Audio 的原生 JavaScript 构造函数，支持在任何时候播放音频。</p>
<p>Audio 类型与 Image 类似，都是 DOM 元素的对等体，只是不需插入文档即可工作。要通过 Audio 播放音频，只需创建一个新实例并传入音频源文件：</p>
<pre><code class="language-js">let audio = new Audio('sound.mp3')
EventUtil.addHandler(audio, 'canplaythrough', function (event) {
  audio.play()
})
</code></pre>
<p>创建 Audio 的新实例就会开始下载指定的文件。下载完毕后，可以调用 play()来播放音频。</p>
<p>在 iOS 中调用 play()方法会弹出一个对话框，请求用户授权播放声音。为了连续播放，必须在 onfinish 事件处理程序中立即调用 play()。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="074-h5-新功能-原生拖放"><a class="header" href="#074-h5-新功能-原生拖放">07.4-H5 新功能-原生拖放</a></h1>
<h2 id="一-拖动相关基础"><a class="header" href="#一-拖动相关基础">一 拖动相关基础</a></h2>
<h3 id="11-可拖动能力"><a class="header" href="#11-可拖动能力">1.1 可拖动能力</a></h3>
<p>默认情况下，图片、链接和文本是可拖动的，这意味着无须额外代码用户便可以拖动它们。文本只有在被选中后才可以拖动，而图片和链接在任意时候都是可以拖动的。</p>
<p>我们也可以让其他元素变得可以拖动。 HTML5 在所有 HTML 元素上规定了一个 draggable 属性，表示元素是否可以拖动。图片和链接的 draggable 属性自动被设置为 true，而其他所有元素此属性的默认值为 false。如果想让其他元素可拖动，或者不允许图片和链接被拖动，都可以设置这个属性。例如：</p>
<pre><code class="language-html">&lt;!-- 禁止拖动图片 --&gt;
&lt;img src=&quot;smile.gif&quot; draggable=&quot;false&quot; alt=&quot;Smiley face&quot; /&gt;
&lt;!-- 让元素可以拖动 --&gt;
&lt;div draggable=&quot;true&quot;&gt;...&lt;/div&gt;
</code></pre>
<h3 id="12-拖放事件"><a class="header" href="#12-拖放事件">1.2 拖放事件</a></h3>
<p>在 H5 规范中，拖动元素时，被拖动的元素将依次触发：</p>
<ul>
<li>dragstart</li>
<li>drag</li>
<li>dragend</li>
</ul>
<p>在按住鼠标键不放并开始移动鼠标的那一刻，被拖动元素上会触发 dragstart 事件。此时光标会变成非放置符号（圆环中间一条斜杠），表示元素不能放到自身上。拖动开始时，可以在 ondragstart 事件处理程序中通过 JavaScript 执行某些操作。</p>
<p>dragstart 事件触发后，只要目标还被拖动就会持续触发 drag 事件。这个事件类似于 mousemove，即随着鼠标移动而不断触发。当拖动停止时（把元素放到有效或无效的放置目标上），会触发 dragend 事件。</p>
<p>在把元素拖动到一个有效的放置目标上时，会依次触发以下事件：</p>
<ul>
<li>dragenter</li>
<li>dragover</li>
<li>dragleave 或 drop</li>
</ul>
<p>只要一把元素拖动到放置目标上， dragenter 事件（类似于 mouseover 事件）就会触发。 dragenter 事件触发之后，会立即触发 dragover 事件，并且元素在放置目标范围内被拖动期间此事件会持续触发。当元素被拖动到放置目标之外， dragover 事件停止触发， dragleave 事件触发（类似于 mouseout 事件）。如果被拖动元素被放到了目标上，则会触发 drop 事件而不是 dragleave 事件。这些事件的目标是放置目标元素。</p>
<h3 id="13-自定义放置目标"><a class="header" href="#13-自定义放置目标">1.3 自定义放置目标</a></h3>
<p>在把某个元素拖动到无效放置目标上时，会看到一个特殊光标（圆环中间一条斜杠）表示不能放下。即使所有元素都支持放置目标事件，这些元素默认也是不允许放置的。如果把元素拖动到不允许放置的目标上，无论用户动作是什么都不会触发 drop 事件。不过，通过覆盖 dragenter 和 dragover 事件的默认行为，可以把任何元素转换为有效的放置目标。例如，如果有一个 ID 为&quot;droptarget&quot;的<code>&lt;div&gt;</code>元素，那么可以使用以下代码把它转换成一个放置目标：</p>
<pre><code class="language-js">let droptarget = document.getElementById('droptarget')
droptarget.addEventListener('dragover', (event) =&gt; {
  event.preventDefault()
})
droptarget.addEventListener('dragenter', (event) =&gt; {
  event.preventDefault()
})
</code></pre>
<p>执行上面的代码之后，把元素拖动到这个<code>&lt;div&gt;</code>上应该可以看到光标变成了允许放置的样子。 另外，drop 事件也会触发。</p>
<p>在 Firefox 中，放置事件的默认行为是导航到放在放置目标上的 URL。这意味着把图片拖动到放置目标上会导致页面导航到图片文件，把文本拖动到放置目标上会导致无效 URL 错误。为阻止这个行为，在 Firefox 中必须取消 drop 事件的默认行为：</p>
<pre><code class="language-js">droptarget.addEventListener('drop', (event) =&gt; {
  event.preventDefault()
})
</code></pre>
<h2 id="二-datatransfer-对象"><a class="header" href="#二-datatransfer-对象">二 dataTransfer 对象</a></h2>
<h3 id="21-datatransfer-对象传递数据"><a class="header" href="#21-datatransfer-对象传递数据">2.1 dataTransfer 对象传递数据</a></h3>
<p>event 对象上暴露了 dataTransfer 对象，用于从被拖动元素向放置目标传递字符串数据，在事件处理程序内部可以使用这个对象的属性和方法实现拖放功能：</p>
<pre><code class="language-js">// 传递文本
event.dataTransfer.setData('text', 'some text')
let text = event.dataTransfer.getData('text')
// 传递 URL
event.dataTransfer.setData('URL', 'http://www.wrox.com/')
let url = event.dataTransfer.getData('URL')
</code></pre>
<p>贴士：&quot;text&quot;和&quot;URL&quot;，会分别被映射到&quot;text/plain&quot;和&quot;text/uri-list&quot;。</p>
<p>dataTransfer 对象实际上可以包含每种 MIME 类型的一个值，也就是说可以同时保存文本和 URL，两者不会相互覆盖。存储在 dataTransfer 对象中的数据只能在放置事件中读取。如果没有在 ondrop 事件处理程序中取得这些数据， dataTransfer 对象就会被销毁，数据也会丢失。</p>
<p>在从文本框拖动文本时，浏览器会调用 setData()并将拖动的文本以&quot;text&quot;格式存储起来。类似地，在拖动链接或图片时，浏览器会调用 setData()并把 URL 存储起来。当数据被放置在目标上时，可以使用 getData()获取这些数据。当然，可以在 dragstart 事件中手动调用 setData()存储自定义数据，以便将来使用。</p>
<p>作为文本的数据和作为 URL 的数据有一个区别。当把数据作为文本存储时，数据不会被特殊对待。而当把数据作为 URL 存储时，数据会被作为网页中的一个链接，意味着如果把它放到另一个浏览器窗口，浏览器会导航到该 URL。</p>
<p>直到版本 5， Firefox 都不能正确地把&quot;url&quot;映射为&quot;text/uri-list&quot;或把&quot;text&quot;映射为&quot;text/plain&quot;。不过，它可以把&quot;Text&quot;（第一个字母大写）正确映射为&quot;text/plain&quot;。在通过 dataTransfer 获取数据时，为保持最大兼容性，需要对 URL 检测两个值并对文本使用&quot;Text&quot;：</p>
<pre><code class="language-js">let dataTransfer = event.dataTransfer
// 读取 URL
let url = dataTransfer.getData('url') || dataTransfer.getData('text/uri-list')
// 读取文本
let text = dataTransfer.getData('Text')
</code></pre>
<p>这里要注意，首先应该尝试短数据名。这是因为直到版本 10， IE 都不支持扩展的类型名，而且会在遇到无法识别的类型名时抛出错误。</p>
<h3 id="22-dropeffect-与-effectallowed"><a class="header" href="#22-dropeffect-与-effectallowed">2.2 dropEffect 与 effectAllowed</a></h3>
<p>dataTransfer 对象不仅可以用于实现简单的数据传输，还可以用于确定能够对被拖动元素和放置目标执行什么操作。为此，可以使用两个属性： dropEffect 与 effectAllowed。</p>
<p>dropEffect 属性可以告诉浏览器允许哪种放置行为。这个属性有以下 4 种可能的值。</p>
<ul>
<li>&quot;none&quot;：被拖动元素不能放到这里。这是除文本框之外所有元素的默认值。</li>
<li>&quot;move&quot;：被拖动元素应该移动到放置目标。</li>
<li>&quot;copy&quot;：被拖动元素应该复制到放置目标。</li>
<li>&quot;link&quot;：表示放置目标会导航到被拖动元素（仅在它是 URL 的情况下）。</li>
</ul>
<p>在把元素拖动到放置目标上时，上述每种值都会导致显示一种不同的光标。不过，是否导致光标示意的动作还要取决于开发者。换句话说，如果没有代码参与，则没有什么会自动移动、复制或链接。唯一不用考虑的就是光标自己会变。为了使用 dropEffect 属性，必须在放置目标的 ondragenter 事件处理程序中设置它。除非同时设置 effectAllowed，否则 dropEffect 属性也没有用。</p>
<p>effectAllowed 属性表示对被拖动元素是否允许 dropEffect。这个属性有如下几个可能的值：</p>
<ul>
<li>&quot;uninitialized&quot;：没有给被拖动元素设置动作。</li>
<li>&quot;none&quot;：被拖动元素上没有允许的操作。</li>
<li>&quot;copy&quot;：只允许&quot;copy&quot;这种 dropEffect。</li>
<li>&quot;link&quot;：只允许&quot;link&quot;这种 dropEffect。</li>
<li>&quot;move&quot;：只允许&quot;move&quot;这种 dropEffect。</li>
<li>&quot;copyLink&quot;：允许&quot;copy&quot;和&quot;link&quot;两种 dropEffect。</li>
<li>&quot;copyMove&quot;：允许&quot;copy&quot;和&quot;move&quot;两种 dropEffect。</li>
<li>&quot;linkMove&quot;：允许&quot;link&quot;和&quot;move&quot;两种 dropEffect。</li>
<li>&quot;all&quot;：允许所有 dropEffect。</li>
</ul>
<p>必须在 ondragstart 事件处理程序中设置这个属性。</p>
<p>假设我们想允许用户把文本从一个文本框拖动到一个<code>&lt;div&gt;</code>元素。那么必须同时把 dropEffect 和 effectAllowed 属性设置为&quot;move&quot;。因为<code>&lt;div&gt;</code>元素上放置事件的默认行为是什么也不做，所以文本不会自动地移动自己。如果覆盖这个默认行为，文本就会自动从文本框中被移除。然后是否把文本插入<code>&lt;div&gt;</code>元素就取决于你了。如果是把 dropEffect 和 effectAllowed 属性设置为&quot;copy&quot;，那么文本框中的文本不会自动被移除。</p>
<h2 id="23-其他成员"><a class="header" href="#23-其他成员">2.3 其他成员</a></h2>
<p>HTML5 规范还为 dataTransfer 对象定义了下列方法。</p>
<ul>
<li>addElement(element)：为拖动操作添加元素。这纯粹是为了传输数据，不会影响拖动操作的外观。</li>
<li>clearData(format)：清除以特定格式存储的数据。</li>
<li>setDragImage(element, x, y)：允许指定拖动发生时显示在光标下面的图片。这个方法接收 3 个参数：要显示的 HTML 元素及标识光标位置的图片上的 x 和 y 坐标。这里的 HTML 元素可以是一张图片，此时显示图片；也可以是其他任何元素，此时显示渲染后的元素。</li>
<li>types：当前存储的数据类型列表。这个集合类似数组，以字符串形式保存数据类型，比如&quot;text&quot;。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="075-h5-新功能-动画"><a class="header" href="#075-h5-新功能-动画">07.5-H5 新功能-动画</a></h1>
<h2 id="一-requestanimationframe-实现动画"><a class="header" href="#一-requestanimationframe-实现动画">一 requestAnimationFrame 实现动画</a></h2>
<h3 id="11-定时器实现动画"><a class="header" href="#11-定时器实现动画">1.1 定时器实现动画</a></h3>
<p>早期 JavaScript 创建动画依赖于定时器：</p>
<pre><code class="language-js">;(function () {
  function updateAnimations() {
    doAnimation1()
    doAnimation2()
    // 其他任务
  }
  setInterval(updateAnimations, 100)
})()
</code></pre>
<p>在定时器的帮助下，updateAnimations()方法会周期性运行注册的动画任务，并反映出每个任务的变化（例如，同时更新滚动新闻和进度条）。</p>
<h3 id="12-定时器动画问题"><a class="header" href="#12-定时器动画问题">1.2 定时器动画问题</a></h3>
<p>这种定时动画的问题在于无法准确知晓循环之间的延时。定时间隔必须足够短，这样才能让不同的动画类型都能平滑顺畅，但又要足够长，以便产生浏览器可以渲染出来的变化。一般计算机显示器的屏幕刷新率都是 60Hz，基本上意味着每秒需要重绘 60 次。大多数浏览器会限制重绘频率，使其不超出屏幕的刷新率，这是因为超过刷新率，用户也感知不到。</p>
<p>因此，实现平滑动画最佳的重绘间隔为 1000 毫秒/60，大约 17 毫秒。以这个速度重绘可以实现最平滑的动画，因为这已经是浏览器的极限了。如果同时运行多个动画，可能需要加以限流，以免 17 毫秒的重绘间隔过快，导致动画过早运行完。</p>
<p>贴士：setInterval 的毫秒延时并不是说何时这些代码会执行，而只是说到时候会把回调加到任务队列。知道何时绘制下一帧是创造平滑动画的关键。直到几年前，都没有办法确切保证何时能让浏览器把下一帧绘制出来，定时器有着极大问题，且浏览器自身也有计时器精度问题，以下是几个浏览器计时器的精度情况：</p>
<ul>
<li>IE8 及更早版本的计时器精度为 15.625 毫秒；</li>
<li>IE9 及更晚版本的计时器精度为 4 毫秒；</li>
<li>Firefox 和 Safari 的计时器精度为约 10 毫秒；</li>
<li>Chrome 的计时器精度为 4 毫秒。</li>
</ul>
<h3 id="13-requestanimationframe方法"><a class="header" href="#13-requestanimationframe方法">1.3 requestAnimationFrame()方法</a></h3>
<p>requestAnimationFrame()方法可以通知浏览器某些 JavaScript 代码要执行动画了，为了实现动画循环，可以把多个
requestAnimationFrame()调用串联起来，就像使用定时器一样：</p>
<pre><code class="language-js">// 参数为：要在重绘屏幕前调用的函数
function updateProgress() {
  const div = document.getElementById('status')
  div.style.width = parseInt(div.style.width, 10) + 5 + '%'
  if (div.style.left != '100%') {
    requestAnimationFrame(updateProgress)
  }
}
requestAnimationFrame(updateProgress)
</code></pre>
<p>因为 requestAnimationFrame()只会调用一次传入的函数，所以每次更新用户界面时需要再手动调用它一次。同样，也需要控制动画何时停止。结果就会得到非常平滑的动画。</p>
<p>目前为止， requestAnimationFrame()已经解决了浏览器不知道 JavaScript 动画何时开始的问题，以及最佳间隔是多少的问题，但是，不知道自己的代码何时实际执行的问题呢？这个方案同样也给出了解决方法。</p>
<p>传给 requestAnimationFrame()的函数实际上可以接收一个参数，此参数是一个 DOMHighResTimeStamp 的实例（比如 performance.now()返回的值），表示下次重绘的时间。这一点非常重要：requestAnimationFrame()实际上把重绘任务安排在了未来一个已知的时间点上，而且通过这个参数告诉了开发者。基于这个参数，就可以更好地决定如何调优动画了。</p>
<p>requestAnimationFrame()返回一个请求 ID，可以用于通过另一个方法 cancelAnimationFrame()来取消重绘任务。下面的例子展示了刚把一个任务加入队列又立即将其取消：</p>
<pre><code class="language-js">let requestID = window.requestAnimationFrame(() =&gt; {
  console.log('Repaint!')
})
window.cancelAnimationFrame(requestID)
</code></pre>
<h2 id="二-requestanimationframe-实现节流"><a class="header" href="#二-requestanimationframe-实现节流">二 requestAnimationFrame 实现节流</a></h2>
<p>requestAnimationFrame 会暴露出作为钩子的回调队列。所谓钩子（ hook），就是浏览器在执行下一次重绘之前的一个点。这个回调队列是一个可修改的函数列表，包含应该在重绘之前调用的函数。每次调用 requestAnimationFrame()都会在队列上推入一个回调函数，队列的长度没有限制。</p>
<p>这个回调队列的行为不一定跟动画有关。不过，通过 requestAnimationFrame()递归地向队列中加入回调函数，可以保证每次重绘最多只调用一次回调函数。这是一个非常好的节流工具。在频繁执行影响页面外观的代码时（比如滚动事件监听器），可以利用这个回调队列进行节流。</p>
<p>先来看一个原生实现，其中的滚动事件监听器每次触发都会调用名为 expensiveOperation()（耗时操作）的函数。当向下滚动网页时，这个事件很快就会被触发并执行成百上千次：</p>
<pre><code class="language-js">function expensiveOperation() {
  console.log('Invoked at', Date.now())
}
window.addEventListener('scroll', () =&gt; {
  expensiveOperation()
})
</code></pre>
<p>如果想把事件处理程序的调用限制在每次重绘前发生，那么可以像这样下面把它封装到 requestAnimationFrame()调用中：</p>
<pre><code class="language-js">function expensiveOperation() {
  console.log('Invoked at', Date.now())
}
window.addEventListener('scroll', () =&gt; {
  window.requestAnimationFrame(expensiveOperation)
})
</code></pre>
<p>这样会把所有回调的执行集中在重绘钩子，但不会过滤掉每次重绘的多余调用。此时，定义一个标志变量，由回调设置其开关状态，就可以将多余的调用屏蔽：</p>
<pre><code class="language-js">let enqueued = false
function expensiveOperation() {
  console.log('Invoked at', Date.now())
  enqueued = false
}
window.addEventListener('scroll', () =&gt; {
  if (!enqueued) {
    enqueued = true
    window.requestAnimationFrame(expensiveOperation)
  }
})
</code></pre>
<p>因为重绘是非常频繁的操作，所以这还算不上真正的节流。更好的办法是配合使用一个计时器来限制操作执行的频率。这样，计时器可以限制实际的操作执行间隔，而 requestAnimationFrame 控制在浏览器的哪个渲染周期中执行。下面的例子可以将回调限制为不超过 50 毫秒执行一次：</p>
<pre><code class="language-js">let enabled = true
function expensiveOperation() {
  console.log('Invoked at', Date.now())
}
window.addEventListener('scroll', () =&gt; {
  if (enabled) {
    enabled = false
    window.requestAnimationFrame(expensiveOperation)
    window.setTimeout(() =&gt; (enabled = true), 50)
  }
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="076-h5-新功能-计时-api"><a class="header" href="#076-h5-新功能-计时-api">07.6-H5 新功能-计时 API</a></h1>
<h2 id="一-页面性能度量"><a class="header" href="#一-页面性能度量">一 页面性能度量</a></h2>
<p>Performance 接口通过 JavaScript API 暴露了浏览器内部的度量指标，允许开发者直接访问这些信息并基于这些信息实现自己想要的功能。这个接口暴露在
window.performance 对象上。所有与页面相关的指标，包括已经定义和将来会定义的，都会存在于这个对象上。</p>
<p>Performance 接口由多个 API 构成：</p>
<ul>
<li>High Resolution Time API</li>
<li>Performance Timeline API</li>
<li>Navigation Timing API</li>
<li>User Timing API</li>
<li>Resource Timing API</li>
<li>Paint Timing API</li>
</ul>
<h2 id="二-high-resolution-time-api"><a class="header" href="#二-high-resolution-time-api">二 High Resolution Time API</a></h2>
<p>Date.now() 的时间精度很低，只有毫秒级。H5 额外规范了计时相关的 API：window.performance.now()，该方法返回一个微妙精度的浮点数，可以保证时间冲的单调增长：</p>
<pre><code class="language-js">const t0 = performance.now();
const t1 = performance.now();
console.log(t0); // 1768.625000026077
console.log(t1); // 1768.6300000059418
const duration = t1 – t0;
console.log(duration); // 0.004999979864805937
</code></pre>
<p>考虑如下 duration 会包含意外值的情况。</p>
<ul>
<li>duration 是 0。 Date.now()只有毫秒级精度， 如果 foo()执行足够快，则两个时间戳的值会相等。</li>
<li>duration 是负值或极大值。如果在 foo()执行时，系统时钟被向后或向前调整了（如切换到夏令时），则捕获的时间戳不会考虑这种情况，因此时间差中会包含这些调整。</li>
</ul>
<p>为此，必须使用不同的计时 API 来精确且准确地度量时间的流逝。 High Resolution Time API 定义了 window.performance.now()，这个方法返回一个微秒精度的浮点值。因此，使用这个方法先后捕获的时间戳更不可能出现相等的情况。而且这个方法可以保证时间戳单调增长。</p>
<pre><code class="language-js">const t0 = performance.now();
const t1 = performance.now();
console.log(t0); // 1768.625000026077
console.log(t1); // 1768.6300000059418
const duration = t1 – t0;
console.log(duration); // 0.004999979864805937
</code></pre>
<p>performance.now() 计时器采用相对度量。这个计时器在执行上下文创建时从 0 开始计时。例如，打开页面或创建工作者时，performance.now() 就会从 0 开始计时。由于这个计时器在不同上下文中初始化时可能存在时间差，因此不同上下文之间如果没有共享参照点则不可能直接比较 performance.now()。performance.timeOrigin 属性返回计时器初始化时全局系统时钟的值。</p>
<pre><code class="language-js">const relativeTimestamp = performance.now()
const absoluteTimestamp = performance.timeOrigin + relativeTimestamp
console.log(relativeTimestamp) // 244.43500000052154
console.log(absoluteTimestamp) // 1561926208892.4001
</code></pre>
<p>通过使用 performance.now()测量 L1 缓存与主内存的延迟差，幽灵漏洞（ Spectre）可以执行缓存推断攻击。为弥补这个安全漏洞，所有的主流浏览器有的选择降低 performance.now()的精度，有的选择在时间戳里混入一些随机性。</p>
<h2 id="三-performance-timeline-api"><a class="header" href="#三-performance-timeline-api">三 Performance Timeline API</a></h2>
<h3 id="30-performance-timeline-api-基础"><a class="header" href="#30-performance-timeline-api-基础">3.0 Performance Timeline API 基础</a></h3>
<p>Performance Timeline API 使用一套用于度量客户端延迟的工具扩展了 Performance 接口。性能度量将会采用计算结束与开始时间差的形式。这些开始和结束时间会被记录为 DOMHighResTimeStamp 值，而封装这个时间戳的对象是 PerformanceEntry 的实例。</p>
<p>浏览器会自动记录各种 PerformanceEntry 对象，而使用 performance.mark() 也可以记录自定义的 PerformanceEntry 对象。在一个执行上下文中被记录的所有性能条目可以通过 performance.getEntries() 获取：</p>
<pre><code class="language-js">console.log(performance.getEntries())
// [PerformanceNavigationTiming, PerformanceResourceTiming, ... ]
</code></pre>
<p>这个返回的集合代表浏览器的性能时间线（performance timeline）。每个 PerformanceEntry 对象都有 name、entryType、startTime 和 duration 属性：</p>
<pre><code class="language-js">const entry = performance.getEntries()[0]
console.log(entry.name) // &quot;https://foo.com&quot;
console.log(entry.entryType) // navigation
console.log(entry.startTime) // 0
console.log(entry.duration) // 182.36500001512468
</code></pre>
<p>不过，PerformanceEntry 实际上是一个抽象基类，比如录自定义性能条目要使用 performance.mark() 方法：</p>
<pre><code class="language-js">performance.mark('foo')
console.log(performance.getEntriesByType('mark')[0])
// PerformanceMark {
// name: &quot;foo&quot;,
// entryType: &quot;mark&quot;,
// startTime: 269.8800000362098,
// duration: 0
// }
</code></pre>
<h3 id="31-user-timing-api"><a class="header" href="#31-user-timing-api">3.1 User Timing API</a></h3>
<p>User Timing API 用于记录和分析自定义性能条目。如前所述，记录自定义性能条目要使用 performance.mark()方法：</p>
<pre><code class="language-js">performance.mark('foo')
console.log(performance.getEntriesByType('mark')[0])
// PerformanceMark {
// name: &quot;foo&quot;,
// entryType: &quot;mark&quot;,
// startTime: 269.8800000362098,
// duration: 0
// }
</code></pre>
<p>在计算开始前和结束后各创建一个自定义性能条目可以计算时间差。最新的标记（mark）会被推到 getEntriesByType() 返回数组的开始：</p>
<pre><code class="language-js">performance.mark('foo')
for (let i = 0; i &lt; 1e6; ++i) {}
performance.mark('bar')
const [endMark, startMark] = performance.getEntriesByType('mark')
console.log(startMark.startTime - endMark.startTime) // 1.3299999991431832
</code></pre>
<p>除了自定义性能条目，还可以生成 PerformanceMeasure（性能度量）条目，对应由名字作为标识的两个标记之间的持续时间。PerformanceMeasure 的实例由 performance.measure() 方法生成：</p>
<pre><code class="language-js">performance.mark('foo')
for (let i = 0; i &lt; 1e6; ++i) {}
performance.mark('bar')
performance.measure('baz', 'foo', 'bar')
const [differenceMark] = performance.getEntriesByType('measure')
console.log(differenceMark)
</code></pre>
<h3 id="32-navigation-timing-api"><a class="header" href="#32-navigation-timing-api">3.2 Navigation Timing API</a></h3>
<p>Navigation Timing API 提供了高精度时间戳，用于度量当前页面加载速度。浏览器会在导航事件发生时自动记录 PerformanceNavigationTiming 条目。这个对象会捕获大量时间戳，用于描述页面是何时以及如何加载的：</p>
<pre><code class="language-js">// 计算了 loadEventStart 和 loadEventEnd 时间戳之间的差
const [performanceNavigationTimingEntry] = performance.getEntriesByType('navigation');
console.log(performanceNavigationTimingEntry)

console.log(performanceNavigationTimingEntry.loadEventEnd –
performanceNavigationTimingEntry.loadEventStart);
// 0.805000017862767
</code></pre>
<h3 id="33-resource-timing-api"><a class="header" href="#33-resource-timing-api">3.3 Resource Timing API</a></h3>
<p>Resource Timing API 提供了高精度时间戳，用于度量当前页面加载时请求资源的速度。浏览器会在加载资源时自动记录 PerformanceResourceTiming。这个对象会捕获大量时间戳，用于描述资源加载的速度：</p>
<pre><code class="language-js">// 计算加载一个特定资源所花的时间
const pre = performance.getEntriesByType('resource')[0]
console.log(pre)

console.log(pre.responseEnd – pre.requestStart)
// 493.9600000507198
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="081-h5-组件化开发-html-模板"><a class="header" href="#081-h5-组件化开发-html-模板">08.1-H5 组件化开发-HTML 模板</a></h1>
<h2 id="一-html-模板"><a class="header" href="#一-html-模板">一 HTML 模板</a></h2>
<h3 id="10-以前的-html-模板方法"><a class="header" href="#10-以前的-html-模板方法">1.0 以前的 HTML 模板方法</a></h3>
<p>在 Web 组件出现之前，标准中没有基于 HTML 解析构建 DOM 子树，如果要渲染一个整体的 HTML 树，以前的方案是：</p>
<ul>
<li>方案一：使用<code>innerHTML</code>将字符串转换为 DOM 树，但是存在严重安全隐患。</li>
<li>方案二：使用<code>document.createElement()</code>构建每个元素，再逐个添加到根节点，该方式极度繁琐。</li>
</ul>
<h3 id="11-documentfragment"><a class="header" href="#11-documentfragment">1.1 DocumentFragment</a></h3>
<p>现在可以使用 <code>DocumentFragment</code> 节点，如下所示：</p>
<pre><code class="language-html">&lt;template id=&quot;foo&quot;&gt;
  #document-fragment
  &lt;p&gt;I'm inside a template!&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<p>示例中的 p 标签不会被渲染到页面上，选择器也不会查询到该 p 标签。这是因为<code>&lt;template&gt;&lt;/template&gt;</code> 的内容不属于活动文档，p 标签其实存在于 DocumentFragment 节点内。获取该引用方式：</p>
<pre><code class="language-js">const fragment = document.querySelector('#foo').content
console.log(fragment) // #document-fragment

// DocumentFragment 上的 DOM 匹配方法可以查询其子树中的节点
console.log(document.querySelector('p')) // null
console.log(fragment.querySelector('p')) // &lt;p&gt;...&lt;p&gt;
</code></pre>
<p>DocumentFragment 也是批量向 HTML 中添加元素的高效工具。比如，我们想以最快的方式给某个 HTML 元素添加多个子元素。如果连续调用 document.appendChild()，则不仅费事，还会导致多次布局重排。而使用 DocumentFragment 可以一次性添加所有子节点，最多只会有一次布局重排：</p>
<pre><code class="language-js">// 开始状态：
// &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;

// 期待的最终状态：
// &lt;div id=&quot;foo&quot;&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;/div&gt;

// 也可以使用 document.createDocumentFragment()
const fragment = new DocumentFragment()
const foo = document.querySelector('#foo')

// 为 DocumentFragment 添加子元素不会导致布局重排
fragment.appendChild(document.createElement('p'))
fragment.appendChild(document.createElement('p'))
fragment.appendChild(document.createElement('p'))
console.log(fragment.children.length) // 3

foo.appendChild(fragment)

console.log(fragment.children.length) // 0
console.log(document.body.innerHTML)
// &lt;div id=&quot;foo&quot;&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;/div&gt;
</code></pre>
<h3 id="12-使用template标签"><a class="header" href="#12-使用template标签">1.2 使用<code>&lt;template&gt;</code>标签</a></h3>
<p>在前面的例子中，DocumentFragment 的所有子节点都高效地转移到了 foo 元素上，转移之后 DocumentFragment 变空了。同样的过程也可以使用<code>&lt;template&gt;</code>标签重现：</p>
<pre><code class="language-js">const fooElement = document.querySelector('#foo')
const barTemplate = document.querySelector('#bar')
const barFragment = barTemplate.content
console.log(document.body.innerHTML)
// &lt;div id=&quot;foo&quot;&gt;
// &lt;/div&gt;
// &lt;template id=&quot;bar&quot;&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;/template&gt;

fooElement.appendChild(barFragment)
console.log(document.body.innerHTML)
// &lt;div id=&quot;foo&quot;&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;/div&gt;
// &lt;tempate id=&quot;bar&quot;&gt;&lt;/template&gt;
</code></pre>
<p>如果想要复制模板，可以使用 importNode() 方法克隆 DocumentFragment：</p>
<pre><code class="language-js">const fooElement = document.querySelector('#foo')
const barTemplate = document.querySelector('#bar')
const barFragment = barTemplate.content
console.log(document.body.innerHTML)
// &lt;div id=&quot;foo&quot;&gt;
// &lt;/div&gt;
// &lt;template id=&quot;bar&quot;&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;/template&gt;

fooElement.appendChild(document.importNode(barFragment, true))
console.log(document.body.innerHTML)
// &lt;div id=&quot;foo&quot;&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;/div&gt;
// &lt;template id=&quot;bar&quot;&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;p&gt;&lt;/p&gt;
// &lt;/template&gt;
</code></pre>
<h3 id="13-模板脚本"><a class="header" href="#13-模板脚本">1.3 模板脚本</a></h3>
<p>如果新添加的元素需要进行某些初始化，脚本执行可以推迟到将 DocumentFragment 的内容实际添加到 DOM 树：</p>
<pre><code class="language-js">// 页面 HTML：
//
// &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;
// &lt;template id=&quot;bar&quot;&gt;
// &lt;script&gt;console.log('Template script executed');&lt;/script&gt;
// &lt;/template&gt;
const fooElement = document.querySelector('#foo')
const barTemplate = document.querySelector('#bar')
const barFragment = barTemplate.content
console.log('About to add template')
fooElement.appendChild(barFragment)
console.log('Added template')
// About to add template
// Template script executed
// Added template
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="073-html5-组件化开发的-shawdowdom"><a class="header" href="#073-html5-组件化开发的-shawdowdom">07.3-HTML5-组件化开发的 ShawdowDOM</a></h1>
<h2 id="一-shadow-dom-概念"><a class="header" href="#一-shadow-dom-概念">一 shadow DOM 概念</a></h2>
<p>通过影子 DOM（shadow DOM），可以将一个完整的 DOM 树作为节点添加到父 DOM 树。这样可以实现 DOM 封装，意味着 CSS 样式和 CSS 选择符可以限制在影子 DOM 子树而不是整个顶级 DOM 树中。</p>
<p>影子 DOM 与 HTML 模板很相似，因为它们都是类似 document 的结构，并允许与顶级 DOM 有一定程度的分离。但是影子 DOM 的内容会实际渲染到页面上，而 HTML 模板的内容不会。</p>
<p>使用场景：</p>
<pre><code class="language-html">&lt;!-- 
3 个 DOM 子树会分别渲染为不同的颜色，一般会给每个子树添加一个唯一类名

 --&gt;
&lt;div class=&quot;red-text&quot;&gt;
  &lt;p&gt;Make me red!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;green-text&quot;&gt;
  &lt;p&gt;Make me green!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;blue-text&quot;&gt;
  &lt;p&gt;Make me blue!&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
  .red-text {
    color: red;
  }
  .green-text {
    color: green;
  }
  .blue-text {
    color: blue;
  }
&lt;/style&gt;
</code></pre>
<p>上述做法会让 CSS 样式应用到整个 DOM，理想情况下，应该把 CSS 限制在使用他们的 DOM 上。</p>
<p>常用可以添加影子 DOM 标签有：</p>
<pre><code class="language-txt">&lt;article&gt;
&lt;aside&gt;
&lt;blockquote&gt;
&lt;body&gt;
&lt;div&gt;
&lt;footer&gt;
&lt;h1&gt;
&lt;h2&gt;
&lt;h3&gt;
&lt;h4&gt;
&lt;h5&gt;
&lt;h6&gt;
&lt;header&gt;
&lt;main&gt;
&lt;nav&gt;
&lt;p&gt;
&lt;section&gt;
&lt;span&gt;
</code></pre>
<h2 id="二-影子-dom-的使用"><a class="header" href="#二-影子-dom-的使用">二 影子 DOM 的使用</a></h2>
<h3 id="21-创建影子-dom"><a class="header" href="#21-创建影子-dom">2.1 创建影子 DOM</a></h3>
<p>容纳影子 DOM 的元素被称为影子宿主（shadow host）。影子 DOM 的根节点被称为影子根（shadow root），使用示例：</p>
<pre><code class="language-js">document.body.innerHTML = `
&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;bar&quot;&gt;&lt;/div&gt;
`

const foo = document.querySelector('#foo')
const bar = document.querySelector('#bar')

const openShadowDOM = foo.attachShadow({ mode: 'open' })
const closedShadowDOM = bar.attachShadow({ mode: 'closed' })

console.log(openShadowDOM) // #shadow-root (open)
console.log(closedShadowDOM) // #shadow-root (closed)
console.log(foo.shadowRoot) // #shadow-root (open)
console.log(bar.shadowRoot) // null
</code></pre>
<p>贴士：对&quot;open&quot;影子 DOM 的引用可以通过 shadowRoot 属性在 HTML 元素上获得，而对&quot;closed&quot;影子 DOM 的引用无法这样获取，但是恶意代码仍然可以绕过，所以如果要保护独立的 DOM 树不受未信任代码影响，iframe 的方式更好。</p>
<h3 id="22-使用影子-dom"><a class="header" href="#22-使用影子-dom">2.2 使用影子 DOM</a></h3>
<p>把影子 DOM 添加到元素之后，可以像使用常规 DOM 一样使用影子 DOM：</p>
<pre><code class="language-js">for (let color of ['red', 'green', 'blue']) {
  const div = document.createElement('div')
  const shadowDOM = div.attachShadow({ mode: 'open' })
  document.body.appendChild(div)
  shadowDOM.innerHTML = `
        &lt;p&gt;Make me ${color}&lt;/p&gt;
        &lt;style&gt;
        p {
        color: ${color};
        }
        &lt;/style&gt;
    `
}

// 验证这些元素分别位于它们自己的影子 DOM 中：
function countP(node) {
  console.log(node.querySelectorAll('p').length)
}
countP(document) // 0
for (let element of document.querySelectorAll('div')) {
  countP(element.shadowRoot)
}
// 1
// 1
// 1
</code></pre>
<p>HTML 元素可以在 DOM 树间无限制移动：</p>
<pre><code class="language-js">document.body.innerHTML = `
&lt;div&gt;&lt;/div&gt;
&lt;p id=&quot;foo&quot;&gt;Move me&lt;/p&gt;
`
const divElement = document.querySelector('div')
const pElement = document.querySelector('p')
const shadowDOM = divElement.attachShadow({ mode: 'open' })
// 从父 DOM 中移除元素
divElement.parentElement.removeChild(pElement)
// 把元素添加到影子 DOM
shadowDOM.appendChild(pElement)
// 检查元素是否移动到了影子 DOM 中
console.log(shadowDOM.innerHTML) // &lt;p id=&quot;foo&quot;&gt;Move me&lt;/p&gt;
</code></pre>
<h3 id="23-合成与影子-dom-槽位"><a class="header" href="#23-合成与影子-dom-槽位">2.3 合成与影子 DOM 槽位</a></h3>
<p>位于影子宿主中的 HTML 需要一种机制以渲染到影子 DOM 中去，但这些 HTML 又不必属于影子 DOM 树。</p>
<p>默认情况下，嵌套内容会隐藏。来看下面的例子，其中的文本在 1000 毫秒后会被隐藏：</p>
<pre><code class="language-js">document.body.innerHTML = `
    &lt;div&gt;
    &lt;p&gt;Foo&lt;/p&gt;
    &lt;/div&gt;
    `

setTimeout(
  () =&gt; document.querySelector('div').attachShadow({ mode: 'open' }),
  1000
)
</code></pre>
<p>影子 DOM 一添加到元素中，浏览器就会赋予它最高优先级，优先渲染它的内容而不是原来的文本。在这个例子中，由于影子 DOM 是空的，因此<code>&lt;div&gt;</code>会在 1000 毫秒后变成空的。</p>
<p>为了显示文本内容，需要使用<code>&lt;slot&gt;</code>标签指示浏览器在哪里放置原来的 HTML。下面的代码修改了前面的例子，让影子宿主中的文本出现在了影子 DOM 中：</p>
<pre><code class="language-js">document.body.innerHTML = `
    &lt;div id=&quot;foo&quot;&gt;
    &lt;p&gt;Foo&lt;/p&gt;
    &lt;/div&gt;
    `

document
  .querySelector('div')
  .attachShadow({ mode: 'open' }).innerHTML = `&lt;div id=&quot;bar&quot;&gt;
        &lt;slot&gt;&lt;/slot&gt;
        &lt;div&gt;`
</code></pre>
<p>现在，投射进去的内容就像自己存在于影子 DOM 中一样。检查页面会发现原来的内容实际上替代了<code>&lt;slot&gt;</code>：</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;div id=&quot;foo&quot;&gt;
    #shadow-root (open)
    &lt;div id=&quot;bar&quot;&gt;
      &lt;p&gt;Foo&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>虽然在页面检查窗口中看到内容在影子 DOM 中，但这实际上只是 DOM 内容的投射（projection）。实际的元素仍然处于外部 DOM 中：</p>
<pre><code class="language-js">document.body.innerHTML = `
    &lt;div id=&quot;foo&quot;&gt;
    &lt;p&gt;Foo&lt;/p&gt;
    &lt;/div&gt;
    `

document.querySelector('div').attachShadow({ mode: 'open' }).innerHTML = `
    &lt;div id=&quot;bar&quot;&gt;
    &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;`

console.log(document.querySelector('p').parentElement)
// &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;
</code></pre>
<p>使用槽位（slot）改写的前面红/绿/蓝子树：</p>
<pre><code class="language-js">for (let color of ['red', 'green', 'blue']) {
  const divElement = document.createElement('div')
  divElement.innerText = `Make me ${color}`
  document.body.appendChild(divElement)
  divElement.attachShadow({ mode: 'open' }).innerHTML = `
        &lt;p&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/p&gt;
        &lt;style&gt;
        p {
        color: ${color};
        }
        &lt;/style&gt;
        `
}
</code></pre>
<p>除了默认槽位，还可以使用命名槽位（named slot）实现多个投射。这是通过匹配的 slot/name 属性对实现的。带有 slot=&quot;foo&quot;属性的元素会被投射到带有 name=&quot;foo&quot;的<code>&lt;slot&gt;</code>上。演示如何改变影子宿主子元素的渲染顺序：</p>
<pre><code class="language-js">document.body.innerHTML = `
    &lt;div&gt;
    &lt;p slot=&quot;foo&quot;&gt;Foo&lt;/p&gt;
    &lt;p slot=&quot;bar&quot;&gt;Bar&lt;/p&gt;
    &lt;/div&gt;
    `
document.querySelector('div').attachShadow({ mode: 'open' }).innerHTML = `
    &lt;slot name=&quot;bar&quot;&gt;&lt;/slot&gt;
    &lt;slot name=&quot;foo&quot;&gt;&lt;/slot&gt;
    `
// Renders:
// Bar
// Foo
</code></pre>
<h3 id="24-事件重定向"><a class="header" href="#24-事件重定向">2.4 事件重定向</a></h3>
<p>如果影子 DOM 中发生了浏览器事件（如 click），那么浏览器需要一种方式以让父 DOM 处理事件。不过，实现也必须考虑影子 DOM 的边界。为此，事件会逃出影子 DOM 并经过事件重定向（event retarget）在外部被处理。逃出后，事件就好像是由影子宿主本身而非真正的包装元素触发的一样：</p>
<pre><code class="language-js">// 创建一个元素作为影子宿主
document.body.innerHTML = `
    &lt;div onclick=&quot;console.log('Handled outside:', event.target)&quot;&gt;&lt;/div&gt;
    `
// 添加影子 DOM 并向其中插入 HTML
document.querySelector('div').attachShadow({ mode: 'open' }).innerHTML = `
    &lt;button onclick=&quot;console.log('Handled inside:', event.target)&quot;&gt;Foo&lt;/button&gt;
    `

// 点击按钮时：
// Handled inside: &lt;button onclick=&quot;...&quot;&gt;&lt;/button&gt;
// Handled outside: &lt;div onclick=&quot;...&quot;&gt;&lt;/div&gt;
</code></pre>
<p>事件重定向只会发生在影子 DOM 中实际存在的元素上。使用<code>&lt;slot&gt;</code>标签从外部投射进来的元素不会发生事件重定向，因为从技术上讲，这些元素仍然存在于影子 DOM 外部</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="083-h5-组件化开发-自定义元素"><a class="header" href="#083-h5-组件化开发-自定义元素">08.3-H5 组件化开发-自定义元素</a></h1>
<h2 id="一-创建自定义元素"><a class="header" href="#一-创建自定义元素">一 创建自定义元素</a></h2>
<p>自定义元素为 HTML 元素引入了面向对象编程的风格。浏览器会尝试将无法识别的元素作为通用元素整合进 DOM：</p>
<pre><code class="language-js">document.body.innerHTML = `
    &lt;x-foo &gt;I'm inside a nonsense element.&lt;/x-foo &gt;
    `
console.log(document.querySelector('x-foo') instanceof HTMLElement) // true
</code></pre>
<p>用自定义元素，可以在<code>&lt;x-foo&gt;</code>标签出现时为它定义复杂的行为，同样也可以在 DOM 中将其纳入元素生命周期管理。自定义元素要使用全局属性 customElements，这个属性会返回 CustomElementRegistry 对象：</p>
<pre><code class="language-js">// console.log(customElements); // CustomElementRegistry {}

class FooElement extends HTMLElement {}

// define() 方法可以创建自定义元素
customElements.define('x-foo', FooElement)

document.body.innerHTML = `
    &lt;x-foo &gt;I'm inside a nonsense element.&lt;/x-foo &gt;
    `
console.log(document.querySelector('x-foo') instanceof FooElement) // true
</code></pre>
<p>可以通过调用自定义元素的构造函数来控制这个类在 DOM 中每个实例的行为：</p>
<pre><code class="language-js">class FooElement extends HTMLElement {
  constructor() {
    super()
    console.log('x-foo')
  }
}
customElements.define('x-foo', FooElement)
document.body.innerHTML = `
    &lt;x-foo&gt;&lt;/x-foo&gt;
    &lt;x-foo&gt;&lt;/x-foo&gt;
    &lt;x-foo&gt;&lt;/x-foo&gt;
    `
// x-foo
// x-foo
// x-foo
</code></pre>
<p>如果自定义元素继承了一个元素类，那么可以使用 is 属性和 extends 选项将标签指定为该自定义元素的实例：</p>
<pre><code class="language-js">class FooElement extends HTMLDivElement {
  constructor() {
    super()
    console.log('x-foo')
  }
}
customElements.define('x-foo', FooElement, { extends: 'div' })
document.body.innerHTML = `
    &lt;div is=&quot;x-foo&quot;&gt;&lt;/div&gt;
    &lt;div is=&quot;x-foo&quot;&gt;&lt;/div&gt;
    &lt;div is=&quot;x-foo&quot;&gt;&lt;/div&gt;
    `
// x-foo
// x-foo
// x-foo
</code></pre>
<h2 id="二-添加-web-组件内容"><a class="header" href="#二-添加-web-组件内容">二 添加 Web 组件内容</a></h2>
<p>因为每次将自定义元素添加到 DOM 中都会调用其类构造函数，所以很容易自动给自定义元素添加子 DOM 内容。虽然不能在构造函数中添加子 DOM（会抛出 DOMException），但可以为自定义元素添加影子 DOM 并将内容添加到这个影子 DOM 中：</p>
<pre><code class="language-js">class FooElement extends HTMLElement {
  constructor() {
    super()
    // this 引用 Web 组件节点
    this.attachShadow({ mode: 'open' })
    this.shadowRoot.innerHTML = `
&lt;p&gt;I'm inside a custom element!&lt;/p&gt;
`
  }
}
customElements.define('x-foo', FooElement)
document.body.innerHTML += `&lt;x-foo&gt;&lt;/x-foo`
// 结果 DOM：
// &lt;body&gt;
// &lt;x-foo&gt;
// #shadow-root (open)
// &lt;p&gt;I'm inside a custom element!&lt;/p&gt;
// &lt;x-foo&gt;
// &lt;/body&gt;
</code></pre>
<p>为避免字符串模板和 innerHTML 不干净，可以使用 HTML 模板和 document.createElement() 重构这个例子：</p>
<pre><code class="language-js">//（初始的 HTML）
// &lt;template id=&quot;x-foo-tpl&quot;&gt;
// &lt;p&gt;I'm inside a custom element template!&lt;/p&gt;
// &lt;/template&gt;

const template = document.querySelector('#x-foo-tpl')
class FooElement extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
    this.shadowRoot.appendChild(template.content.cloneNode(true))
  }
}
customElements.define('x-foo', FooElement)
document.body.innerHTML += `&lt;x-foo&gt;&lt;/x-foo`
// 结果 DOM：
// &lt;body&gt;
// &lt;template id=&quot;x-foo-tpl&quot;&gt;
// &lt;p&gt;I'm inside a custom element template!&lt;/p&gt;
// &lt;/template&gt;
// &lt;x-foo&gt;
// #shadow-root (open)
// &lt;p&gt;I'm inside a custom element template!&lt;/p&gt;
// &lt;x-foo&gt;
// &lt;/body&gt;
</code></pre>
<h2 id="三-使用自定义元素生命周期方法"><a class="header" href="#三-使用自定义元素生命周期方法">三 使用自定义元素生命周期方法</a></h2>
<p>可以在自定义元素的不同生命周期执行代码。带有相应名称的自定义元素类的实例方法会在不同生命周期阶段被调用。自定义元素有以下 5 个生命周期方法：</p>
<pre><code class="language-txt">constructor()：在创建元素实例或将已有 DOM 元素升级为自定义元素时调用。
connectedCallback()：在每次将这个自定义元素实例添加到 DOM 中时调用。
disconnectedCallback()：在每次将这个自定义元素实例从 DOM 中移除时调用。
attributeChangedCallback()：每次可观察属性的值发生变化时调用。元素实例初始化时，初始值的定义也算一次。
adoptedCallback()：在通过 document.adoptNode() 将这个自定义元素实例移动到新文档对象时调用
</code></pre>
<p>示例演示些构建、连接和断开连接的回调：</p>
<pre><code class="language-js">class FooElement extends HTMLElement {
  constructor() {
    super()
    console.log('ctor')
  }
  connectedCallback() {
    console.log('connected')
  }
  disconnectedCallback() {
    console.log('disconnected')
  }
}

customElements.define('x-foo', FooElement)
const fooElement = document.createElement('x-foo')
// ctor
document.body.appendChild(fooElement)
// connected
document.body.removeChild(fooElement)
// disconnected
</code></pre>
<h2 id="四-反射自定义元素"><a class="header" href="#四-反射自定义元素">四 反射自定义元素</a></h2>
<p>自定义元素既是 DOM 实体又是 JavaScript 对象，因此两者之间应该同步变化。换句话说，对 DOM 的修改应该反映到 JavaScript 对象，反之亦然。要从 JavaScript 对象反射到 DOM，常见的方式是使用获取函数和设置函数。下面的例子演示了在 JavaScript 对象和 DOM 之间反射 bar 属性的过程：</p>
<pre><code class="language-js">document.body.innerHTML = `&lt;x-foo&gt;&lt;/x-foo&gt;`
class FooElement extends HTMLElement {
  constructor() {
    super()
    this.bar = true
  }
  get bar() {
    return this.getAttribute('bar')
  }
  set bar(value) {
    this.setAttribute('bar', value)
  }
}
customElements.define('x-foo', FooElement)
console.log(document.body.innerHTML)
// &lt;x-foo bar=&quot;true&quot;&gt;&lt;/x-foo&gt;
</code></pre>
<p>另一个方向的反射（从 DOM 到 JavaScript 对象）需要给相应的属性添加监听器。为此，可以使用
observedAttributes() 获取函数让自定义元素的属性值每次改变时都调用 attributeChangedCallback()：</p>
<pre><code class="language-js">class FooElement extends HTMLElement {
  static get observedAttributes() {
    // 返回应该触发 attributeChangedCallback() 执行的属性
    return ['bar']
  }
  get bar() {
    return this.getAttribute('bar')
  }
  set bar(value) {
    this.setAttribute('bar', value)
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      console.log(`${oldValue} -&gt; ${newValue}`)
      this[name] = newValue
    }
  }
}
customElements.define('x-foo', FooElement)
document.body.innerHTML = `&lt;x-foo bar=&quot;false&quot;&gt;&lt;/x-foo&gt;`
// null -&gt; false
document.querySelector('x-foo').setAttribute('bar', true)
// false -&gt; true
</code></pre>
<h2 id="五-升级自定义元素"><a class="header" href="#五-升级自定义元素">五 升级自定义元素</a></h2>
<p>并非始终可以先定义自定义元素，然后再在 DOM 中使用相应的元素标签。为解决这个先后次序问题，Web 组件在 CustomElementRegistry 上额外暴露了一些方法。这些方法可以用来检测自定义元素是否定义完成，然后可以用它来升级已有元素。</p>
<p>如果自定义元素已经有定义，那么 CustomElementRegistry.get() 方法会返回相应自定义元素的类。类似地，CustomElementRegistry.whenDefined() 方法会返回一个期约，当相应自定义元素有定义之后解决：</p>
<pre><code class="language-js">customElements.whenDefined('x-foo').then(() =&gt; console.log('defined!'))
console.log(customElements.get('x-foo'))
// undefined
customElements.define('x-foo', class {})
// defined!
console.log(customElements.get('x-foo'))
// class FooElement {}
</code></pre>
<p>连接到 DOM 的元素在自定义元素有定义时会自动升级。如果想在元素连接到 DOM 之前强制升级，可以使用 CustomElementRegistry.upgrade() 方法：</p>
<pre><code class="language-js">// 在自定义元素有定义之前会创建 HTMLUnknownElement 对象
const fooElement = document.createElement('x-foo')
// 创建自定义元素
class FooElement extends HTMLElement {}
customElements.define('x-foo', FooElement)
console.log(fooElement instanceof FooElement) // false
// 强制升级
customElements.upgrade(fooElement)
console.log(fooElement instanceof FooElement) // true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-1-jquery-的基础使用"><a class="header" href="#附录-1-jquery-的基础使用">附录 1-jQuery 的基础使用</a></h1>
<h2 id="一-jquery-简介"><a class="header" href="#一-jquery-简介">一 jQuery 简介</a></h2>
<p>原生 JavaScript 在操作 DOM 时，相对复杂且有兼容性问题，为了提升开发体验，诞生了大量相关的库，如：Dojo、ExtJS 等，其中热度最高的当属 jQuery。</p>
<p>jQuery 很好的解决了原生 JavaScript 的痛点，如</p>
<ul>
<li><code>window.onload</code> 事件只能出现一次，多次出现会覆盖之前的事件</li>
<li>兼容性复杂</li>
<li>简单功能原生实现复杂（比如各种循环，jQuery 隐式迭代帮我们做了）</li>
</ul>
<p>现在 jQuery 也有很多版本，需要依据业务场景进行选择：</p>
<ul>
<li>1.x 版本，兼容 IE6/7/8</li>
<li>2.x 版本，不兼容 IE6/7/8</li>
<li>3.x 版本，更精简，不再兼容低版 IE</li>
</ul>
<p>jQuery 诞生于 2006 年，是一个非常轻量级的库，拥有很强的选择器、极便利的 DOM 操作、优秀的浏览器兼容性等，此外链式编程、插件支持等也是其亮点。在 jQuery 基础上，也有针对不同场景的库，如：jQueryUI、jQuery Mobile 等。</p>
<h2 id="二-jquery-hello-world"><a class="header" href="#二-jquery-hello-world">二 jQuery Hello World</a></h2>
<p>示例：</p>
<pre><code class="language-html">&lt;div class=&quot;div&quot;&gt;点击&lt;/div&gt;
&lt;script src=&quot;https://libs.baidu.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  $(function () {
    $('.div').click(function () {
      alert('hello world!')
    })
  })
&lt;/script&gt;
</code></pre>
<p><code>$</code> 是 jQuery 提供的函数，业务代码写在该函数中即可，不过要注意的是 jQuery 的事件不带 on。</p>
<h2 id="三-原生-javascript-与-jquery-的区别"><a class="header" href="#三-原生-javascript-与-jquery-的区别">三 原生 JavaScript 与 jQuery 的区别</a></h2>
<h3 id="31-入口函数"><a class="header" href="#31-入口函数">3.1 入口函数</a></h3>
<p>原生 JavaScript 的入口函数是：<code>window.onload = function() { }</code>。</p>
<p>jQuery 的入口函数是：<code>$(function(){ })</code>，该方式其实是下列代码的简写：</p>
<pre><code class="language-js">// 入口函数
$(document).ready(function () {
  // 业务代码
})
</code></pre>
<p>原生 JavaScrip 与 jQuery 的入口函数是有区别的：</p>
<ul>
<li>执行时机不同：原生 JS 入口函数需要等待网页所有资源（包括图片）加载完成后才执行，而 jQuery 的入口函数是在 DOM 绘制完毕后即执行，此时 DOM 关联的东西可能没有加载完</li>
<li>编写个数不同：原生 JS 入口函数只能出现一次，出现多次会存在事件覆盖的问题，而 jQuery 入口函数可以书写多次，没有覆盖问题。</li>
</ul>
<p>在大量图片的网页中，jQuery 这样的做法速度更快，但是也可能会出现图片相关的盒子宽高无法设置的问题，如果要让 jQuery 也等待全部资源加载完毕后操作 DOM，和原生 JS 入口函数一致，则可以使用：</p>
<pre><code class="language-js">$(window).load(function () {})
</code></pre>
<h3 id="32-jquery-对象和-dom-对象"><a class="header" href="#32-jquery-对象和-dom-对象">3.2 jQuery 对象和 DOM 对象</a></h3>
<p>使用 jQuery 选择器获取到的对象与原生的 DOM 对象是有区别的，<strong>jQuery 获取的元素是对 DOM 对象包装后的伪数组</strong>。</p>
<p>jQuery 这样做的目的是：封装后不需要大量重复的遍历，能够更加简便的实现兼容问题。</p>
<p>不过这样做也让 jQuery 对象完全无法使用原生 DOM 对象，需要转换之后才行：</p>
<pre><code class="language-js">// DOM 对象转换为 jQuery 对象：
$(DOM对象)

// jQuery 对象转换为 DOM 对象：
let btn1 = jQuery对象[0] // 方式一：推荐
let btn2 = jQuery对象.get(0) // 方式二
</code></pre>
<h2 id="四-jquery-的基本选择器"><a class="header" href="#四-jquery-的基本选择器">四 jQuery 的基本选择器</a></h2>
<h3 id="41-基本选择器"><a class="header" href="#41-基本选择器">4.1 基本选择器</a></h3>
<pre><code class="language-js">// id 选择器
$('#btn')

// 类选择器
$('.btn')

// 标签选择器
$('div')

// 交集选择器
$('.red.green') // 选择 class 为 red 且 green 的元素

// 并集选择器
$('.red,.green') // 选择 class 为 red 或 green 的元素
</code></pre>
<h3 id="42-层级选择器"><a class="header" href="#42-层级选择器">4.2 层级选择器</a></h3>
<pre><code class="language-js">// 后代选择器（空格）
$('#ul li') // 选择 id 为 ul 的元素的所有后代 li

// 子代选择器（&gt;）
$('#ul &gt; li') // 选择 id 为 ul 的元素的直系后代 li
</code></pre>
<h3 id="43-筛选选择器"><a class="header" href="#43-筛选选择器">4.3 筛选选择器</a></h3>
<p>常见的筛选选择器：</p>
<pre><code class="language-js">// 选择第一个元素
$('ul li:first') // 获取第一个 li 元素

// 选择最后一个元素
$('ul li:last') // 获取最后一个 li 元素

// 选择匹配索引的元素，索引从 0 开始
$('ul li:eq(2)') // 选择索引号为 2 的 li

// 选择匹配奇数索引元素
$('ul li:odd') // 选择奇数索引的的 li

// 选择匹配偶数索引元素
$('ul li:even') // 选择偶数索引的的 li
</code></pre>
<h2 id="五-筛选方法"><a class="header" href="#五-筛选方法">五 筛选方法</a></h2>
<pre><code class="language-js">// find() 查找所有后代元素
$('#j_wrap').find('li').css('color', 'red')

// children() 查找直接子代元素
$('#j_wrap').children('ul').css('color', 'red')

// parent() 查找父元素
$('#j_liItem').parent('ul').css('color', 'red') //选择 id 为 j_liItem 的父元素

// parents() 查找所有祖先节点：传入参数具备筛选功能（只有复合参数的祖先节点）
$('#j_liItem').parents('ul').css('color', 'red') //选择 id 为 j_liItem 的所有祖先元素

// siblings() 查找所有兄弟元素，不包括自己
$('#j_liItem').siblings().css('color', 'red')

// 查找所有兄弟节点：
nextAll() // 查找当前元素之后的所有兄弟元素
nextUntil() // 作用同上，可以传入参数，查找到指定位置
prevAll() // 查找当前元素之前的所有兄弟元素
prevUntil() // 作用同上，可以传入参数，查找到指定位置

// offsetParent() 获取有定位的父级
offsetParent()

// eq(index) 查找指定元素的第 index 个元素
$('li').eq(2).css('color', 'red') //选择所有 li 元素中的第二个

// 返回选择元素集合从第 start-end 位置的元素
slice(start, end)
</code></pre>
<h2 id="六-常见操作"><a class="header" href="#六-常见操作">六 常见操作</a></h2>
<h3 id="61-操作样式"><a class="header" href="#61-操作样式">6.1 操作样式</a></h3>
<p>注意：jQuery 操作类样式的时候，所有的类名都不带点</p>
<pre><code class="language-js">// 获取样式
$(selector).css('font-size')

// 设置样式：可以设置单个、多个
$(selector).css({ color: 'red', 'font-size': '30px' }) // 引号、单位不写也可以

// 添加 class 名
$(selector).addClass('liItem')

// 移除样式：无参表示移除被选中元素的所有类名
$(selector).removeClass('liItem')

// 判断有没有类样式：返回 true 或 false
$(selector).hasClass('liItem')

// 切换类样式：该元素有类则移除，没有指定类则添加
$(selector).toggleClass('liItem')
</code></pre>
<h3 id="62-操作属性"><a class="header" href="#62-操作属性">6.2 操作属性</a></h3>
<pre><code class="language-js">// 操作元素固有属性
$(selector).prop('属性名') // 获取
$(selector).prop('属性名', '属性值') // 设置

// 操作元素自定义属性
$(selector).attr('属性名') // 获取
$(selector).attr('属性名', '属性值') // 设置
$(selector).attr('data-属性名') // 获取 H5 的自定 UI 属性，设置同理
$(selector).removeAttr('title') // 移除属性

// 将元素视为一个载体存储数据
$(selector).data('属性名', '属性值') // 存储一个数据在这个元素上
$(selector).data('属性名') // 获取
$(selector).data('自定义属性名') // 无需 data 开头，获取 H5 的自定 UI 属性，设置同理
</code></pre>
<h3 id="63-操作节点"><a class="header" href="#63-操作节点">6.3 操作节点</a></h3>
<pre><code class="language-js">//创建元素 $() 或者 节点.html()
let $spanNode = $(&quot;&lt;span&gt;我是一个 span 元素&lt;/span&gt;&quot;);
let node = $(&quot;#box&quot;).html（&quot;&lt;li&gt;我是 li&lt;/li&gt;&quot;）；

//添加子元素 append()
$(selector).append($node);              //追加传入 jQuery 对象
$(selector).append('&lt;div&gt;&lt;/div&gt;');      //直接传入 html 片段
appendTo(s)          //添加到 s 元素最后面，原生没有
prepend()           //添加到子元素最前面，类似原生的 appendChild()

//添加兄弟元素
after()             //添加到自己后面（作为兄弟）
before()            //添加到自己前面（作为兄弟）

//获取到的元素剪切到某个位置
nsertBefore()       //原生 JS 这里是选中后复制到某个位置
insertAfter()       //原生 JS 没有 insertAfter()

//html() val() text
html(): 没有参数是获取包含标签的内容，有参数是插入内容,
        设置内容时，如果是html标记，与原生 innerHTML相同
text(): 没有参数获取不包含标签的内容(字符串)，有参数是插入内容，
        设置内容时，类似原生innerText（火狐使用textContent获取），无视HTML标记插入纯文本，但是text()不存在兼容问题
val():  获取匹配元素的值，只匹配第一个元素，
        有参数时设置所有匹配到的元素的值

//删除与清空元素
$(selector).empty();        // 清空参数所有子元素，会清除事件，推荐使用
$(selector).html(&quot;&quot;);       // 同上，但元素事件不会被清空，会出现内存泄露
$(selector).remove();       // 删除元素与事件，包括自己，返回被删除的元素
$(selector).detach();       // 同上，但是会保留事件

//复制元素 clone()
$(selector).clone();        //复制匹配的元素，返回值为复制的新元素
$(selector).clone(true);    //同时复制操作行为

</code></pre>
<h3 id="64-操作尺寸位置"><a class="header" href="#64-操作尺寸位置">6.4 操作尺寸位置</a></h3>
<pre><code class="language-js">// 操作本身宽高，以下 width 同理 height 方法
$(selector).width() //获取高度，结果是数字类型
$(selector).width(200) //设置高度

// 操作 宽高 + padding。
$(selector).innerWidth() //获取 width+左右 padding

// 操作 宽高 + padding + border。
$(selector).outerWidth() // 原生的 outerWidth 无法获取隐藏元素的值，而 jQquery 可以

// 操作 宽高 + padding + border + margin
$(selector).outerWidth(true)

//  操作 offset 注意：设置 offset 后，如果元素没有定位 (默认值：static)，则被修改为 relative
$(selector).offset()
$(selector).offset({ left: 100, top: 150 })

// position() 获取相对于其最近的具有定位的父元素的位置，只能获取不能设置
$(selector).position() // 返回值为对象：{left:num, top:num}

// scrollTop() 获取或者设置元素垂直方向滚动的位置
$(selector).scrollTop(100) //无参数表示获取偏移，有参数表示设置偏移

// scrollLeft() :获取或者设置元素水平方向滚动的位置
$(selector).scrollLeft(100)

//总结：
$('div').offset() // 获取或设置坐标值，设置值后变成相对定位
$('div').position() // 获取坐标值 子绝父相只能读取不能设置

$('div').scrollTop() // 被卷曲的高度，即相对于滚动条顶部的偏移
$('div').scrolllLeft() // 被卷曲的宽度，即相对于滚动条左部的偏移
/*
垂直滚动条位置 是可滚动区域 在 可视区域上方的 被隐藏区域的高度。
如果滚动条在最上方没有滚动 或者 当前元素没有出现滚动条，那么这个距离为 0
*/
</code></pre>
<h3 id="65-操作元素内容"><a class="header" href="#65-操作元素内容">6.5 操作元素内容</a></h3>
<pre><code class="language-js">// 以 html 方式操作元素内容
$(selector).html() // 不传值用于获取内容，传值用于修改元素内的 html 结构

// 操作文本
$(selector).text()

// 获取表单值
$('input').val()
</code></pre>
<h2 id="七-jquery-事件机制"><a class="header" href="#七-jquery-事件机制">七 jQuery 事件机制</a></h2>
<h3 id="71-jquery-的事件绑定发展历程"><a class="header" href="#71-jquery-的事件绑定发展历程">7.1 jQuery 的事件绑定发展历程</a></h3>
<p>jQuery 的事件绑定方式有三种，随着版本迭代逐渐被最终的 on 方式取代：</p>
<pre><code class="language-js">// 第一阶段：简单事件绑定，类似 click()
$('div').click(callback)

// 第二阶段：bind 绑定，在 jQuery1.7 后被 on 取代
$('p').bind('click mouseenter', function (e) {})

// 第三阶段：delegate 绑定
$('.parentBox').delegate('p', 'click', function () {
  //为 .parentBox 下面的所有的 p 标签绑定事件
})

// 推荐方式：on
$(selector).on(events, [selector], callback)
</code></pre>
<h3 id="72-on-支持绑定多个事件"><a class="header" href="#72-on-支持绑定多个事件">7.2 on 支持绑定多个事件</a></h3>
<p>on 方式比起简单绑定方式，支持一次性绑定多个事件：</p>
<pre><code class="language-js">//on 绑定事件书写方式一
$('div').on('click mouseover', function () {
  alert(123)
})

//on 绑定事件书写方式二
$('div').on({
  click: function () {
    alert(123)
  },
  mouseover: function () {
    alert(456)
  },
})

//绑定一次性事件
$('p').one('click', function () {
  alert($(this).text())
})
</code></pre>
<p>如果一个元素被父级绑定了委托事件，自己也绑定了普通事件，优先执行委托事件。
注意：on 还有一个可选参数 data，在事件函数内，data 的访问方式是：e.data</p>
<h3 id="73-on-支持事件委托"><a class="header" href="#73-on-支持事件委托">7.3 on 支持事件委托</a></h3>
<pre><code class="language-js">//注册委托事件：让子元素 li 执行事件
$('ul').on('click', 'li', function () {
  alert(123)
})
</code></pre>
<h3 id="74-on-支持给动态创建的元素绑定事件"><a class="header" href="#74-on-支持给动态创建的元素绑定事件">7.4 on 支持给动态创建的元素绑定事件</a></h3>
<pre><code class="language-js">let li = $('&lt;li&gt;动态创建的 li&lt;/li&gt;')
$('ul')
  .append(li)
  .on('click', function () {})
</code></pre>
<h3 id="75-jquery-移除事件绑定"><a class="header" href="#75-jquery-移除事件绑定">7.5 jQuery 移除事件绑定</a></h3>
<p>on 事件解绑：</p>
<pre><code class="language-js">$(selector).off() // 解绑匹配元素的所有事件
$(selector).off('click') // 解绑匹配元素的所有 click 事件
$(selector).off('click', 'li') // 解绑事件委托
</code></pre>
<p>bind 与 delegate 事件的解绑：</p>
<pre><code class="language-js">$(selector).unbind();           //解绑 bind 所有的事件
$(selector).unbind(“click”);    //解绑 bing 绑定的指定事件

$( selector ).undelegate();     //解绑所有的 delegate 事件
$( selector).undelegate( “click” ); //解绑所有的 click 事件
</code></pre>
<h3 id="76-常见-jquery-事件"><a class="header" href="#76-常见-jquery-事件">7.6 常见 jQuery 事件</a></h3>
<p>常见 jQuery 事件：</p>
<pre><code class="language-js">click(handler) // 单击事件
blur(handler) // 失去焦点事件
mouseenter(handler) // 鼠标进入事件
mouseleave(handler) // 鼠标离开事件
dbclick(handler) // 双击事件
change(handler) // 改变事件，如：文本框值改变，下来列表值改变等
focus(handler) // 获得焦点事件
keydown(handler) // 键盘按下事件
</code></pre>
<h3 id="77-query-事件对象"><a class="header" href="#77-query-事件对象">7.7 Query 事件对象</a></h3>
<p>jQuery 的事件对象 ev 已经是兼容的，常见属性：</p>
<pre><code class="language-js">// 事件类型：click，dbclick…
event.type

event.pageX // 鼠标相对于文档左部边缘的位置，同理 Y 轴
event.clientX //相对于可视区，同理 Y 轴

// 按键相关
event.which // 鼠标的按键类型：左 1 中 2 右 3
event.keyCode // 键盘按键代码

// 传递给事件处理程序的额外数据
event.data

// 等同于 this，当前 DOM 对象
event.currentTarget
// 触发事件源，不一定===this
event.target

// 阻止行为
event.stopPropagation() // 阻止事件冒泡
event.preventDefault() // 阻止默认行为
</code></pre>
<h3 id="78-事件触发"><a class="header" href="#78-事件触发">7.8 事件触发</a></h3>
<p>事件触发是指在某些场景下，让某个元素去执行事件。</p>
<pre><code class="language-javascript">$(selector).click() //简单事件触发：触发 click 事件
$(selector).trigger('click') //让元素触发 click 事件，和上述相同
$(selector).triggerHandler('click') //此方式不触发浏览器默认行为
</code></pre>
<h3 id="79-阻止冒泡与默认行为"><a class="header" href="#79-阻止冒泡与默认行为">7.9 阻止冒泡与默认行为</a></h3>
<pre><code class="language-javascript">event.stopPropagation() //阻止事件冒泡
event.preventDefault() //阻止默认行为
// 如果：return false 则直接阻止全部
</code></pre>
<h2 id="八-节流阀"><a class="header" href="#八-节流阀">八 节流阀</a></h2>
<p>当类似 onkeydown 事件触发时，用户不停的按按按键，会反复触发，为了保证只触发一次，需要添加节流阀：</p>
<pre><code class="language-js">//按下 1-9 这几个数字键，能触发对应的 mouseenter 事件
$(document).on('keydown', function (e) {
  if (flag) {
    flag = false
    //获取到按下的键
    let code = e.keyCode
    if (code &gt;= 49 &amp;&amp; code &lt;= 57) {
      //触发对应的li的mouseenter事件
      $('.nav li')
        .eq(code - 49)
        .mouseenter()
    }
  }
})

$(document).on('keyup', function (e) {
  flag = true

  //获取到按下的键
  let code = e.keyCode
  if (code &gt;= 49 &amp;&amp; code &lt;= 57) {
    //触发对应的 li 的 mouseenter 事件
    $('.nav li')
      .eq(code - 49)
      .mouseleave()
  }
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="07-jquery-5-jquery-开发思想"><a class="header" href="#07-jquery-5-jquery-开发思想">07-jQuery-5-jQuery 开发思想</a></h1>
<h2 id="一-编程思想"><a class="header" href="#一-编程思想">一 编程思想</a></h2>
<h3 id="11-隐式迭代"><a class="header" href="#11-隐式迭代">1.1 隐式迭代</a></h3>
<blockquote>
<p>jQuery 的隐式迭代：jQuery 会在内部对每个匹配到的元素执行相应操作</p>
</blockquote>
<p>jQuery 的选择器具备隐式迭代的特性，如下案例所示：</p>
<pre><code class="language-html">&lt;div&gt;div1&lt;/div&gt;
&lt;div&gt;div2&lt;/div&gt;
&lt;div&gt;div3&lt;/div&gt;

&lt;script&gt;
  let div = $('div')
  console.log($('div')) // 3 个全拿到了
  div.css('background', 'red') // 3 个 div 全部被修改为了 red
&lt;/script&gt;
</code></pre>
<p><strong>获取索引号方式：<code>jQuery 对象.index()</code></strong></p>
<p>由于隐式迭代在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。
如果获取的是多元素的值，大部分情况下返回的是第一个元素的值。
但是有时候我们需要对获取的元素集合中每个元素做不同的处理，可以使用 each() 方法：</p>
<pre><code class="language-js">$('li').each(function (i, elem) {
  //i：下标 elem : 每个元素
  $(elem).html(i)
})
</code></pre>
<h3 id="12-排他思想"><a class="header" href="#12-排他思想">1.2 排他思想</a></h3>
<p>示例：</p>
<pre><code class="language-html">&lt;div style=&quot;background-color: aqua;&quot;&gt;div1&lt;/div&gt;
&lt;div style=&quot;background-color: aqua;&quot;&gt;div2&lt;/div&gt;
&lt;div style=&quot;background-color: aqua;&quot;&gt;div3&lt;/div&gt;
&lt;script src=&quot;https://libs.baidu.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // 当前元素变化背景，其余去掉颜色
  $('div').click(function () {
    //  this 必须转换为 jQuery 对象
    $(this).css('background', 'green')
    $(this).siblings('div').css('background', '')
  })
&lt;/script&gt;
</code></pre>
<h3 id="13-链式编程"><a class="header" href="#13-链式编程">1.3 链式编程</a></h3>
<p>链式编程原理是 <code>return this;</code>。</p>
<p>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 this。</p>
<h2 id="二-命名冲突问题"><a class="header" href="#二-命名冲突问题">二 命名冲突问题</a></h2>
<p>jQuery 的大量对象名都被限制在了自己的命名空间里，所以 jQuery 在与其他库一起使用时，一般不会引起命名冲突。</p>
<p>当然变量 <code>$</code> 的控制权也可以移交给其他库，有很多方案。</p>
<p>方案一：使用 jQuery 代替。</p>
<pre><code class="language-js">// 将 $ 移交给其他库

jQuery.noConflict()

// 此时只能使用 jQuery 变量
jQuery(function () {
  // 函数内部仍然可以继续使用 $
  $('p').click(function () {
    console.log(1)
  })
})
</code></pre>
<p>方案二：另启一个变量代替 <code>$</code>。</p>
<pre><code class="language-js">// $j  代替了 $
var $j = jQuery.noConflict()
</code></pre>
<p>方案三：传参</p>
<pre><code class="language-js">jQuery.noConflict()
function ($) {
  $(function () {
    $('p').click(function () {
      console.log(1)
    })
  })
}
</code></pre>
<h2 id="三-插件机制"><a class="header" href="#三-插件机制">三 插件机制</a></h2>
<p>jQuery 只提供了 DOM 等操作，复杂的操作依赖于大量的第三方插件，我们可以称之为 jQuery 的生态。</p>
<p>通过插件的方式，可以扩展 jQuery 的功能，常用的插件网址有：</p>
<ul>
<li><a href="http://www.htmleaf.com">http://www.htmleaf.com</a></li>
<li><a href="http://www.jq22.com">http://www.jq22.com</a></li>
</ul>
<p>案例：</p>
<pre><code class="language-html">&lt;script&gt;
  $.extend({
    leftTrim: function (str) {
      return str.replace(/^\s+/, '')
    },
    rightTrim: function () {
      //方法体
    },
  })
&lt;/script&gt;

&lt;script&gt;
  let str = ' hello '
  console.log($.leftTrim(str))
&lt;/script&gt;
</code></pre>
<p>比较实用的 jQuery 插件是：表单验证插件 Validation、懒加载插件 EasyLazyLoad、全屏滚动插件 fullpage。</p>
<h2 id="四--方法"><a class="header" href="#四--方法">四 <code>$</code> 方法</a></h2>
<p><code>$</code>下的方法大多数为工具类方法，不仅可以给 jQuery 使用，也可以给原生 JS 使用，调用方式统一为：<code>$.方法 ()</code></p>
<pre><code class="language-js">// 拷贝
$.extend(target, result) // 浅拷贝：源对象的中的复杂数据类型只拷贝地址。同一层的数据如果有冲突会被合并
$.extend(true, target, result) // 深拷贝：完全把数据重新赋值一份给 target

type() //判断类型，比如时间对象返回 Date，而 typeof 返回的都是 Object。

trim() // 去除空白

inArray() //类似 indexOf();

proxy() //改变 this 指向

parseJSON() //将字符串数据转换成 json 对象

makeArray() //将类数组转换成真正的数组

map()

each()
</code></pre>
<h2 id="五-性能优化"><a class="header" href="#五-性能优化">五 性能优化</a></h2>
<h3 id="51-选择器使用"><a class="header" href="#51-选择器使用">5.1 选择器使用</a></h3>
<p>不同的选择器，jQuery 底层使用的实现方式也是不同的，<code>$(#id)</code>使用的是原生的 <code>document.getElementById()</code>方法，而<code>$(.class)</code>在 IE8 中使用的 DOM 搜索到的数组查询结果。</p>
<h3 id="52-缓存-dom-对象"><a class="header" href="#52-缓存-dom-对象">5.2 缓存 DOM 对象</a></h3>
<p>获取到的 DOM 如果要反复使用最好使用变量保存，而不是一直重新获取：</p>
<pre><code class="language-js">// 效率低的写法
$('#box').bind('click', function () {})
$('#box').css('border', '1px solid red')

// 效率高写法
var box = $('#box')
box.bind('click', function () {})
box.css('border', '1px solid red')

// 或者直接采用链式写法
$('#box')
  .bind('click', function () {})
  .css('border', '1px solid red')
</code></pre>
<h3 id="53-循环操作-dom"><a class="header" href="#53-循环操作-dom">5.3 循环操作 DOM</a></h3>
<p>循环操作 DOM 是对性能影响极大的操作，在 jQuery 中也不例外，比如需要创建 100 个列表，可以先生成列表，最后 append：</p>
<pre><code class="language-js">var list;
for (var i = 0; i &lt; 100; i++&gt;){
  list += '&lt;li&gt;' + i + '&lt;/li&gt;'
}

$(#div).html(list)
</code></pre>
<h3 id="54-使用-join-拼接字符串"><a class="header" href="#54-使用-join-拼接字符串">5.4 使用 join 拼接字符串</a></h3>
<p>处理长字符串时，join 的性能往往比直接使用 + 号更高：</p>
<pre><code class="language-js">var list = [];
for (var i = 0; i &lt; 100; i++&gt;){
  list[i] = '&lt;li&gt;' + i + '&lt;/li&gt;'
}

$(#div).html(list.join(''))
</code></pre>
<h2 id="六-常用技巧"><a class="header" href="#六-常用技巧">六 常用技巧</a></h2>
<h3 id="61-输入框文字获取和失去焦点"><a class="header" href="#61-输入框文字获取和失去焦点">6.1 输入框文字获取和失去焦点</a></h3>
<pre><code class="language-js">$(document).ready(function () {
  $('input.text1').val('Enter your search text here')
  textFill($('input.text1'))
})
function textFill(input) {
  //input focus text function
  var originalvalue = input.val()
  input
    .focus(function () {
      if ($.trim(input.val()) == originalvalue) {
        input.val('')
      }
    })
    .blur(function () {
      if ($.trim(input.val()) == '') {
        input.val(originalvalue)
      }
    })
}
</code></pre>
<h3 id="62-判断浏览器类型"><a class="header" href="#62-判断浏览器类型">6.2 判断浏览器类型</a></h3>
<pre><code class="language-js">$(document).ready(function () {
  // Firefox 2 and above
  if ($.browser.mozilla &amp;&amp; $.browser.version &gt;= '1.8') {
    // do something
  }
  // Safari
  if ($.browser.safari) {
    // do something
  }
  // Chrome
  if ($.browser.chrome) {
    // do something
  }
  // Opera
  if ($.browser.opera) {
    // do something
  }
  // IE6 and below
  if ($.browser.msie &amp;&amp; $.browser.version &lt;= 6) {
    // do something
  }
  // anything above IE6
  if ($.browser.msie &amp;&amp; $.browser.version &gt; 6) {
    // do something
  }
})
</code></pre>
<h3 id="63-返回头部的滑动动画"><a class="header" href="#63-返回头部的滑动动画">6.3 返回头部的滑动动画</a></h3>
<pre><code class="language-js">jQuery.fn.scrollTo = function (speed) {
  var targetOffset = $(this).offset().top
  $('html,body').stop().animate({ scrollTop: targetOffset }, speed)
  return this
}
// use
$('#goheader').click(function () {
  $('body').scrollTo(500)
  return false
})
</code></pre>
<h3 id="64-设置-div-在屏幕中央"><a class="header" href="#64-设置-div-在屏幕中央">6.4 设置 div 在屏幕中央</a></h3>
<pre><code class="language-js">$(document).ready(function () {
  jQuery.fn.center = function () {
    this.css('position', 'absolute')
    this.css(
      'top',
      ($(window).height() - this.height()) / 2 + $(window).scrollTop() + 'px'
    )
    this.css(
      'left',
      ($(window).width() - this.width()) / 2 + $(window).scrollLeft() + 'px'
    )
    return this
  }
  //use
  $('#XY').center()
})
</code></pre>
<h3 id="65-获取选中下拉框"><a class="header" href="#65-获取选中下拉框">6.5 获取选中下拉框</a></h3>
<pre><code class="language-js">$('#someElement').find('option:selected')
$('#someElement option:selected')
</code></pre>
<h3 id="66-切换复选框"><a class="header" href="#66-切换复选框">6.6 切换复选框</a></h3>
<pre><code class="language-js">var tog = false
$('button').click(function () {
  $('input[type=checkbox]').attr('checked', !tog)
  tog = !tog
})
</code></pre>
<h3 id="67-选择同辈元素"><a class="header" href="#67-选择同辈元素">6.7 选择同辈元素</a></h3>
<pre><code class="language-js">$('#nav li').click(function () {
  $(this).addClass('active').siblings().removeClass('active')
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-3-dom-事件汇总"><a class="header" href="#附录-3-dom-事件汇总">附录 3-DOM 事件汇总</a></h1>
<h2 id="一-用户界面事件"><a class="header" href="#一-用户界面事件">一 用户界面事件</a></h2>
<p>UI 事件主要有以下几种：</p>
<ul>
<li>DOMActivate：元素被用户通过鼠标或键盘操作激活时触发（比 click 或 keydown 更通用）。这个事件在 DOM3 Events 中已经废弃。因为浏览器实现之间存在差异，所以不要使用它。</li>
<li>load：在 window 上当页面加载完成后触发，在窗套（ <code>&lt;frameset&gt;</code>）上当所有窗格（<code> &lt;frame&gt;</code>）都加载完成后触发，在 <code>&lt;img&gt;</code> 元素上当图片加载完成后触发，在 <code>&lt;object&gt;</code> 元素上当相应对象加载完成后触发。</li>
<li>unload：在 window 上当页面完全卸载后触发，在窗套上当所有窗格都卸载完成后触发，在<code>&lt;object&gt;</code>元素上当相应对象卸载完成后触发。</li>
<li>abort：在<code>&lt;object&gt;</code>元素上当相应对象加载完成前被用户提前终止下载时触发。</li>
<li>error：在 window 上当 JavaScript 报错时触发，在<code>&lt;img&gt;</code>元素上当无法加载指定图片时触发，在<code>&lt;object&gt;</code>元素上当无法加载相应对象时触发，在窗套上当一个或多个窗格无法完成加载时触发。</li>
<li>select：在文本框（ <code>&lt;input&gt;</code>或 textarea）上当用户选择了一个或多个字符时触发。</li>
<li>resize：在 window 或窗格上当窗口或窗格被缩放时触发。</li>
<li>scroll：当用户滚动包含滚动条的元素时在元素上触发。 <code>&lt;body&gt;</code>元素包含已加载页面的滚动条。</li>
</ul>
<h2 id="二-焦点事件"><a class="header" href="#二-焦点事件">二 焦点事件</a></h2>
<p>焦点事件有以下 6 种：</p>
<ul>
<li>blur：当元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持。</li>
<li>DOMFocusIn：当元素获得焦点时触发。这个事件是 focus 的冒泡版。 Opera 是唯一支持这个事件的主流浏览器。 DOM3 Events 废弃了 DOMFocusIn，推荐 focusin。</li>
<li>DOMFocusOut：当元素失去焦点时触发。这个事件是 blur 的通用版。 Opera 是唯一支持这个事件的主流浏览器。 DOM3 Events 废弃了 DOMFocusOut，推荐 focusout。</li>
<li>focus：当元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持。</li>
<li>focusin：当元素获得焦点时触发。这个事件是 focus 的冒泡版。</li>
<li>focusout：当元素失去焦点时触发。这个事件是 blur 的通用版</li>
</ul>
<p>焦点事件中的两个主要事件是 focus 和 blur， 这两个事件在 JavaScript 早期就得到了浏览器支持。它们最大的问题是不冒泡。这导致 IE 后来又增加了 focusin 和 focusout， Opera 又增加了 DOMFocusIn、DOMFocusOut。</p>
<p>IE 新增的这两个事件已经被 DOM3 Events 标准化。当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件：</p>
<ul>
<li>(1) focuscout 在失去焦点的元素上触发。</li>
<li>(2) focusin 在获得焦点的元素上触发。</li>
<li>(3) blur 在失去焦点的元素上触发。</li>
<li>(4) DOMFocusOut 在失去焦点的元素上触发。</li>
<li>(5) focus 在获得焦点的元素上触发。</li>
<li>(6) DOMFocusIn 在获得焦点的元素上触发。</li>
</ul>
<p>其中， blur、 DOMFocusOut 和 focusout 的事件目标是失去焦点的元素，而 focus、 DOMFocusIn 和 focusin 的事件目标是获得焦点的元素。</p>
<h2 id="三-鼠标和滚轮事件"><a class="header" href="#三-鼠标和滚轮事件">三 鼠标和滚轮事件</a></h2>
<p>DOM3 Events 定义了 9 种鼠标事件：</p>
<ul>
<li>click：在用户单击鼠标主键（通常是左键）或按键盘回车键时触发。这主要是基于无障碍的考虑，让键盘和鼠标都可以触发 onclick 事件处理程序。</li>
<li>dblclick：在用户双击鼠标主键（通常是左键）时触发。这个事件不是在 DOM2 Events 中定义的，但得到了很好的支持， DOM3 Events 将其进行了标准化。</li>
<li>mousedown：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发。</li>
<li>mouseenter：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。 mouseenter 事件不是在 DOM2 Events 中定义的，而是 DOM3 Events 中新增的事件。</li>
<li>mouseleave：在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。 mouseleave 事件不是在 DOM2 Events 中定义的，而是 DOM3 Events 中新增的事件。</li>
<li>mousemove：在鼠标光标在元素上移动时反复触发。这个事件不能通过键盘触发。</li>
<li>mouseout：在用户把鼠标光标从一个元素移到另一个元素上时触发。移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。这个事件不能通过键盘触发。</li>
<li>mouseover：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不能通过键盘触发。</li>
<li>mouseup：在用户释放鼠标键时触发。这个事件不能通过键盘触发。</li>
</ul>
<p>比如， click 事件触发的前提是 mousedown 事件触发后，紧接着又在同一个元素上触发了 mouseup 事件。如果 mousedown 和 mouseup 中的任意一个事件被取消，那么 click 事件就不会触发。类似地，两次连续的 click 事件会导致 dblclick 事件触发。只要有任何逻辑阻止了这两个 click 事件发生（比如取消其中一个 click 事件或者取消 mousedown 或 mouseup 事件中的任一个）， dblclick 事件就不会发生。这 4 个事件永远会按照如下顺序触发：</p>
<ul>
<li>(1) mousedown</li>
<li>(2) mouseup</li>
<li>(3) click</li>
<li>(4) mousedown</li>
<li>(5) mouseup</li>
<li>(6) click</li>
<li>(7) dblclick</li>
</ul>
<p>click 和 dblclick 在触发前都依赖其他事件触发， mousedown 和 mouseup 则不会受其他事件影响。IE8 及更早版本的实现中有个问题，这会导致双击事件跳过第二次 mousedown 和 click 事件。相应的顺序变成了：</p>
<ul>
<li>(1) mousedown</li>
<li>(2) mouseup</li>
<li>(3) click</li>
<li>(4) mouseup</li>
<li>(5) dblclick</li>
</ul>
<p>鼠标事件在 DOM3 Events 中对应的类型是&quot;MouseEvent&quot;，而不是&quot;MouseEvents&quot;。</p>
<p>鼠标事件还有一个名为滚轮事件的子类别。滚轮事件只有一个事件 mousewheel，反映的是鼠标滚轮或带滚轮的类似设备上滚轮的交互。</p>
<h2 id="四-键盘和输入事件"><a class="header" href="#四-键盘和输入事件">四 键盘和输入事件</a></h2>
<p>键盘事件包含 3 个事件：</p>
<ul>
<li>keydown，用户按下键盘上某个键时触发，而且持续按住会重复触发。</li>
<li>keypress，用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。 Esc 键也会触发这个事件。 DOM3 Events 废弃了 keypress 事件，而推荐 textInput 事件。</li>
<li>keyup，用户释放键盘上某个键时触发。</li>
</ul>
<p>输入事件只有一个，即 textInput。这个事件是对 keypress 事件的扩展，用于在文本显示给用户之前更方便地截获文本输入。 textInput 会在文本被插入到文本框之前触发。</p>
<p>对于 keydown 和 keyup 事件， event 对象的 keyCode 属性中会保存一个键码，对应键盘上特定的一个键。对于字母和数字键， keyCode 的值与小写字母和数字的 ASCII 编码一致。比如数字 7 键的 keyCode 为 55，而字母 A 键的 keyCode 为 65，而且跟是否按了 Shift 键无关。</p>
<pre><code class="language-js">let textbox = document.getElementById('myText')
textbox.addEventListener('keyup', (event) =&gt; {
  console.log(event.keyCode)
})
</code></pre>
<p>浏览器在 event 对象上支持 charCode 属性，只有发生 keypress 事件时这个属性才会被设置值，包含的是按键字符对应的 ASCII 编码。通常， charCode 属性的值是 0，在 keypress 事件发生时则是对应按键的键码。 IE8 及更早版本和 Opera 使用 keyCode 传达字符的 ASCII 编码。要以跨浏览器方式获取字符编码，首先要检查 charCode 属性是否有值，如果没有再使用 keyCode，如下所示：</p>
<pre><code class="language-js">var EventUtil = {
  // 其他代码
  getCharCode: function (event) {
    if (typeof event.charCode == 'number') {
      return event.charCode
    } else {
      return event.keyCode
    }
  },
  // 其他代码
}
</code></pre>
<p>这个方法检测 charCode 属性是否为数值（在不支持的浏览器中是 undefined）。如果是数值，则返回。否则，返回 keyCode 值。可以像下面这样使用：</p>
<pre><code class="language-js">let textbox = document.getElementById('myText')
textbox.addEventListener('keypress', (event) =&gt; {
  console.log(EventUtil.getCharCode(event))
})
</code></pre>
<p>一旦有了字母编码，就可以使用 String.fromCharCode()方法将其转换为实际的字符了。</p>
<p>DOM3Events 规范并未规定 charCode 属性，而是定义了 key 和 char 两个新属性。其中， key 属性用于替代 keyCode，且包含字符串。在按下字符键时， key 的值等于文本字符（如“k”或“M”）；在按下非字符键时， key 的值是键名（如“Shift”或“ArrowDown”）。 char 属性在按下字符键时与 key 类似，在按下非字符键时为 null。</p>
<p>IE 支持 key 属性但不支持 char 属性。 Safari 和 Chrome 支持 keyIdentifier 属性，在按下非字符键时返回与 key 一样的值（如“Shift”）。对于字符键， keyIdentifier 返回以“U+0000”形式表示 Unicode 值的字符串形式的字符编码。</p>
<pre><code class="language-js">let textbox = document.getElementById('myText')
textbox.addEventListener('keypress', (event) =&gt; {
  let identifier = event.key || event.keyIdentifier
  if (identifier) {
    console.log(identifier)
  }
})
</code></pre>
<p>由于缺乏跨浏览器支持，因此不建议使用 key、 keyIdentifier、char。</p>
<p>DOM3 Events 规范增加了一个名为 textInput 的事件，其在字符被输入到可编辑区域时触发。作为对 keypress 的替代， textInput 事件的行为有些不一样。一个区别是 keypress 会在任何可以获得焦点的元素上触发，而 textInput 只在可编辑区域上触发。另一个区别是 textInput 只在有新字符被插入时才会触发，而 keypress 对任何可能影响文本的键都会触发（包括退格键）。</p>
<p>因为 textInput 事件主要关注字符，所以在 event 对象上提供了一个 data 属性，包含要插入的字符（不是字符编码）。 data 的值始终是要被插入的字符，因此如果在按 S 键时没有按 Shift 键， data 的值就是&quot;s&quot;，但在按 S 键时同时按 Shift 键， data 的值则是&quot;S&quot;。</p>
<p>event 对象上还有一个名为 inputMethod 的属性，该属性表示向控件中输入文本的手段。可能的值如下：</p>
<ul>
<li>0，表示浏览器不能确定是什么输入手段；</li>
<li>1，表示键盘；</li>
<li>2，表示粘贴；</li>
<li>3，表示拖放操作；</li>
<li>4，表示 IME；</li>
<li>5，表示表单选项；</li>
<li>6，表示手写（如使用手写笔）；</li>
<li>7，表示语音</li>
<li>8，表示组合方式；</li>
<li>9，表示脚本。</li>
</ul>
<h2 id="五-合成事件"><a class="header" href="#五-合成事件">五 合成事件</a></h2>
<p>合成事件是 DOM3 Events 中新增的，用于处理通常使用 IME 输入时的复杂输入序列。 IME 可以让用户输入物理键盘上没有的字符。例如，使用拉丁字母键盘的用户还可以使用 IME 输入日文。 IME 通常需要同时按下多个键才能输入一个字符。合成事件用于检测和控制这种输入。合成事件有以下 3 种：</p>
<ul>
<li>compositionstart，在 IME 的文本合成系统打开时触发，表示输入即将开始；</li>
<li>compositionupdate，在新字符插入输入字段时触发；</li>
<li>compositionend，在 IME 的文本合成系统关闭时触发，表示恢复正常键盘输入。</li>
</ul>
<p>合成事件在很多方面与输入事件很类似。在合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是 data，其中包含的值视情况而异：</p>
<ul>
<li>在 compositionstart 事件中，包含正在编辑的文本（例如，已经选择了文本但还没替换）；</li>
<li>在 compositionupdate 事件中，包含要插入的新字符；</li>
<li>在 compositionend 事件中，包含本次合成过程中输入的全部内容。</li>
</ul>
<p>与文本事件类似，合成事件可以用来在必要时过滤输入内容。可以像下面这样使用合成事件：</p>
<pre><code class="language-js">let textbox = document.getElementById('myText')
textbox.addEventListener('compositionstart', (event) =&gt; {
  console.log(event.data)
})
textbox.addEventListener('compositionupdate', (event) =&gt; {
  console.log(event.data)
})
textbox.addEventListener('compositionend', (event) =&gt; {
  console.log(event.data)
})
</code></pre>
<h2 id="六-变化事件"><a class="header" href="#六-变化事件">六 变化事件</a></h2>
<p>DOM2 的变化事件（ Mutation Events）是为了在 DOM 发生变化时提供通知。这些事件已经被废弃，并被 Mutation Observers 所取代。</p>
<h2 id="七-html5-事件"><a class="header" href="#七-html5-事件">七 HTML5 事件</a></h2>
<p>HTML5 中还有一些已经得到浏览器较好支持的事件。</p>
<h3 id="71-contextmenu-事件"><a class="header" href="#71-contextmenu-事件">7.1 contextmenu 事件</a></h3>
<p>Windows 95 通过单击鼠标右键为 PC 用户增加了上下文菜单的概念。不久，这个概念也在 Web 上得以实现。开发者面临的问题是如何确定何时该显示上下文菜单（在 Windows 上是右击鼠标，在 Mac 上是 Ctrl+单击），以及如何避免默认的上下文菜单起作用。结果就出现了 contextmenu 事件，以专门用于表示何时该显示上下文菜单，从而允许开发者取消默认的上下文菜单并提供自定义菜单。</p>
<p>contextmenu 事件冒泡，因此只要给 document 指定一个事件处理程序就可以处理页面上的所有同类事件。事件目标是触发操作的元素。这个事件在所有浏览器中都可以取消，在 DOM 合规的浏览器中使用 event.preventDefault()，在 IE8 及更早版本中将 event.returnValue 设置为 false。</p>
<p>contextmenu 事件应该算一种鼠标事件，因此 event 对象上的很多属性都与光标位置有关。通常，自定义的上下文菜单都是通过 oncontextmenu 事件处理程序触发显示，并通过 onclick 事件处理程序触发隐藏的。来看下面的例子：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ContextMenu Event Example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;myDiv&quot;&gt;
      Right click or Ctrl+click me to get a custom context menu. Click anywhere
      else to get the default context menu.
    &lt;/div&gt;
    &lt;ul
      id=&quot;myMenu&quot;
      style=&quot;position:absolute;visibility:hidden;background-color:
silver&quot;
    &gt;
      &lt;li&gt;&lt;a href=&quot;http://www.somewhere.com&quot;&gt; somewhere&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.wrox.com&quot;&gt;Wrox site&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.somewhere-else.com&quot;&gt;somewhere-else&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
      // 作为上下文菜单， &lt;ul&gt;元素初始时是隐藏的
      window.addEventListener('load', (event) =&gt; {
        let div = document.getElementById('myDiv')
        div.addEventListener('contextmenu', (event) =&gt; {
          event.preventDefault()
          let menu = document.getElementById('myMenu')
          menu.style.left = event.clientX + 'px'
          menu.style.top = event.clientY + 'px'
          menu.style.visibility = 'visible'
        })
        document.addEventListener('click', (event) =&gt; {
          document.getElementById('myMenu').style.visibility = 'hidden'
        })
      })
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这里在<code>&lt;div&gt;</code>元素上指定了一个 oncontextmenu 事件处理程序。这个事件处理程序首先取消默认行，确保不会显示浏览器默认的上下文菜单。接着基于 event 对象的 clientX 和 clientY 属性把<code>&lt;ul&gt;</code>元素放到适当位置。最后一步通过将 visibility 属性设置为&quot;visible&quot;让自定义上下文菜单显示出来。另外，又给 document 添加了一个 onclick 事件处理程序，以便在单击事件发生时隐藏上下文菜单（系统上下文菜单就是这样隐藏的）</p>
<h3 id="72-beforeunload-事件"><a class="header" href="#72-beforeunload-事件">7.2 beforeunload 事件</a></h3>
<p>beforeunload 事件会在 window 上触发，用意是给开发者提供阻止页面被卸载的机会。这个事件会在页面即将从浏览器中卸载时触发，如果页面需要继续使用，则可以不被卸载。这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。相反，这个事件会向用户显示一个确认框，其中的消息表明浏览器即将卸载页面，并请用户确认是希望关闭页面，还是继续留在页面上。</p>
<p>为了显示类似图 17-8 的确认框，需要将 event.returnValue 设置为要在确认框中显示的字符串（对于 IE 和 Firefox 来说），并将其作为函数值返回（对于 Safari 和 Chrome 来说），如下所示：</p>
<pre><code class="language-js">window.addEventListener('beforeunload', (event) =&gt; {
  let message = &quot;I'm really going to miss you if you go.&quot;
  event.returnValue = message
  return message
})
</code></pre>
<h3 id="73-domcontentloaded-事件"><a class="header" href="#73-domcontentloaded-事件">7.3 DOMContentLoaded 事件</a></h3>
<p>window 的 load 事件会在页面完全加载后触发，因为要等待很多外部资源加载完成，所以会花费较长时间。而 DOMContentLoaded 事件会在 DOM 树构建完成后立即触发，而不用等待图片、 JavaScript 文件、 CSS 文件或其他资源加载完成。相对于 load 事件， DOMContentLoaded 可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。</p>
<p>要处理 DOMContentLoaded 事件，需要给 document 或 window 添加事件处理程序（实际的事件目标是 document，但会冒泡到 window）。下面是一个在 document 上监听 DOMContentLoaded 事件的例子：</p>
<pre><code class="language-js">document.addEventListener('DOMContentLoaded', (event) =&gt; {
  console.log('Content loaded')
})
</code></pre>
<p>DOMContentLoaded 事件的 event 对象中不包含任何额外信息（除了 target 等于 document）。DOMContentLoaded 事件通常用于添加事件处理程序或执行其他 DOM 操作。这个事件始终在 load 事件之前触发。</p>
<p>对于不支持 DOMContentLoaded 事件的浏览器，可以使用超时为 0 的 setTimeout()函数，通过其回调来设置事件处理程序，比如：</p>
<pre><code class="language-js">setTimeout(() =&gt; {
  // 在这里添加事件处理程序
}, 0)
</code></pre>
<p>以上代码本质上意味着在当前 JavaScript 进程执行完毕后立即执行这个回调。页面加载和构建期间，只有一个 JavaScript 进程运行。所以可以在这个进程空闲后立即执行回调，至于是否与同一个浏览器或同一页面上不同脚本的 DOMContentLoaded 触发时机一致并无绝对把握。为了尽可能早一些执行，以上代码最好是页面上的第一个超时代码。即使如此，考虑到各种影响因素，也不一定保证能在 load 事件之前执行超时回调。</p>
<h3 id="74-readystatechange-事件"><a class="header" href="#74-readystatechange-事件">7.4 readystatechange 事件</a></h3>
<p>IE 首先在 DOM 文档的一些地方定义了一个名为 readystatechange 事件。这个有点神秘的事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定。支持 readystatechange 事件的每个对象都有一个 readyState 属性，该属性具有一个以下列出的可能的字符串值。</p>
<ul>
<li>uninitialized：对象存在并尚未初始化。</li>
<li>loading：对象正在加载数据。</li>
<li>loaded：对象已经加载完数据。</li>
<li>interactive：对象可以交互，但尚未加载完成。</li>
<li>complete：对象加载完成。</li>
</ul>
<p>看起来很简单，其实并非所有对象都会经历所有 readystate 阶段。文档中说有些对象会完全跳过某个阶段，但并未说明哪些阶段适用于哪些对象。这意味着 readystatechange 事件经常会触发不到 4 次，而 readyState 未必会依次呈现上述值。</p>
<p>在 document 上使用时，值为&quot;interactive&quot;的 readyState 首先会触发 readystatechange 事件，时机类似于 DOMContentLoaded。进入交互阶段，意味着 DOM 树已加载完成，因而可以安全地交互了。此时图片和其他外部资源不一定都加载完了。可以像下面这样使用 readystatechange 事件：</p>
<pre><code class="language-js">document.addEventListener('readystatechange', (event) =&gt; {
  if (document.readyState == 'interactive') {
    console.log('Content loaded')
  }
})
</code></pre>
<p>这个事件的 event 对象中没有任何额外的信息，连事件目标都不会设置。在与 load 事件共同使用时，这个事件的触发顺序不能保证。在包含特别多或较大外部资源的页面中，交互阶 段会在 load 事件触发 前先触发。 而在包含较 少且较小外 部资源的页 面中，这个 readystatechange 事件有可能在 load 事件触发后才触发。</p>
<p>让问题变得更加复杂的是，交互阶段与完成阶段的顺序也不是固定的。在外部资源较多的页面中，很可能交互阶段会早于完成阶段，而在外部资源较少的页面中，很可能完成阶段会早于交互阶段。因此，实践中为了抢到较早的时机，需要同时检测交互阶段和完成阶段。比如：</p>
<pre><code class="language-js">document.addEventListener('readystatechange', (event) =&gt; {
  if (
    document.readyState == 'interactive' ||
    document.readyState == 'complete'
  ) {
    document.removeEventListener('readystatechange', arguments.callee)
    console.log('Content loaded')
  }
})
</code></pre>
<p>当 readystatechange 事件触发时，这段代码会检测 document.readyState 属性，以确定当前是不是交互或完成状态。如果是，则移除事件处理程序，以保证其他阶段不再执行。注意，因为这里的事件处理程序是匿名函数，所以使用了 arguments.callee 作为函数指针。然后，又打印出一条表示内容已加载的消息。这样的逻辑可以保证尽可能接近使用 DOMContentLoaded 事件的效果。</p>
<p>使用 readystatechange 只能尽量模拟 DOMContentLoaded，但做不到分毫不差。load 事件和 readystatechange 事件发生的顺序在不同页面中是不一样的。</p>
<h3 id="75-pageshow-与-pagehide-事件"><a class="header" href="#75-pageshow-与-pagehide-事件">7.5 pageshow 与 pagehide 事件</a></h3>
<p>Firefox 和 Opera 开发了一个名为往返缓存（ bfcache， back-forward cache）的功能，此功能旨在使用浏览器“前进”和“后退”按钮时加快页面之间的切换。这个缓存不仅存储页面数据，也存储 DOM 和 JavaScript 状态，实际上是把整个页面都保存在内存里。如果页面在缓存中，那么导航到这个页面时就不会触发 load 事件。通常，这不会导致什么问题，因为整个页面状态都被保存起来了。不过， Firefx 决定提供一些事件，把往返缓存的行为暴露出来。</p>
<p>第一个事件是 pageshow，其会在页面显示时触发，无论是否来自往返缓存。在新加载的页面上，pageshow 会在 load 事件之后触发；在来自往返缓存的页面上， pageshow 会在页面状态完全恢复后触发。注意，虽然这个事件的目标是 document，但事件处理程序必须添加到 window 上。</p>
<pre><code class="language-js">;(function () {
  let showCount = 0
  window.addEventListener('load', () =&gt; {
    console.log('Load fired')
  })
  window.addEventListener('pageshow', () =&gt; {
    showCount++
    console.log(`Show has been fired ${showCount} times.`)
  })
})()
</code></pre>
<p>这个例子使用了私有作用域来保证 showCount 变量不进入全局作用域。在页面首次加载时，showCount 的值为 0。之后每次触发 pageshow 事件， showCount 都会加 1 并输出消息。如果从包含</p>
<p>以上代码的页面跳走，然后又点击“后退”按钮返回以恢复它，就能够每次都看到 showCount 递增的值。这是因为变量的状态连同整个页面状态都保存在了内存中，导航回来后可以恢复。如果是点击了浏览器的“刷新”按钮，则 showCount 的值会重置为 0，因为页面会重新加载。</p>
<p>除了常用的属性， pageshow 的 event 对象中还包含一个名为 persisted 的属性。这个属性是一个布尔值，如果页面存储在了往返缓存中就是 true，否则就是 false。可以像下面这样在事件处理程序中检测这个属性：</p>
<pre><code class="language-js">;(function () {
  let showCount = 0
  window.addEventListener('load', () =&gt; {
    console.log('Load fired')
  })
  window.addEventListener('pageshow', () =&gt; {
    showCount++
    console.log(
      `Show has been fired ${showCount} times.`,
      `Persisted? ${event.persisted}`
    )
  })
})()
</code></pre>
<p>通过检测 persisted 属性可以根据页面是否取自往返缓存而决定是否采取不同的操作。与 pageshow 对应的事件是 pagehide，这个事件会在页面从浏览器中卸载后，在 unload 事件之前触发。与 pageshow 事件一样， pagehide 事件同样是在 document 上触发，但事件处理程序必须被添加到 window。</p>
<p>event 对象中同样包含 persisted 属性，但用法稍有不同。比如，以下代码检测了 event.persisted 属性：</p>
<pre><code class="language-js">window.addEventListener('pagehide', (event) =&gt; {
  console.log('Hiding. Persisted? ' + event.persisted)
})
</code></pre>
<p>这样，当 pagehide 事件触发时，也许可以根据 persisted 属性的值来采取一些不同的操作。对 pageshow 事件来说， persisted 为 true 表示页面是从往返缓存中加载的；而对 pagehide 事件来说，persisted 为 true 表示页面在卸载之后会被保存在往返缓存中。因此，第一次触发 pageshow 事件时 persisted 始终是 false，而第一次触发 pagehide 事件时 persisted 始终是 true（除非页面不符合使用往返缓存的条件）。</p>
<p>注册了 onunload 事件处理程序（即使是空函数）的页面会自动排除在往返缓存之外。这是因为 onunload 事件典型的使用场景是撤销 onload 事件发生时所做的事情，如果使用往返缓存，则下一次页面显示时就不会触发 onload 事件，而这可能导致页面无法使用。</p>
<h3 id="76-hashchange-事件"><a class="header" href="#76-hashchange-事件">7.6 hashchange 事件</a></h3>
<p>HTML5 增加了 hashchange 事件，用于在 URL 散列值（ URL 最后#后面的部分）发生变化时通知开发者。这是因为开发者经常在 Ajax 应用程序中使用 URL 散列值存储状态信息或路由导航信息。</p>
<p>onhashchange 事件处理程序必须添加给 window，每次 URL 散列值发生变化时会调用它。 event 对象有两个新属性： oldURL 和 newURL。这两个属性分别保存变化前后的 URL，而且是包含散列值的完整 URL。下面的例子展示了如何获取变化前后的 URL：</p>
<pre><code class="language-js">window.addEventListener(&quot;hashchange&quot;, (event) =&gt; {
console.log(`Old URL: ${event.oldURL}, New URL: ${event.newURL}`);
});
如果想确定当前的散列值，最好使用 location 对象：
window.addEventListener(&quot;hashchange&quot;, (event) =&gt; {
console.log(`Current hash: ${location.hash}`);
});
</code></pre>
<h2 id="八-设备事件"><a class="header" href="#八-设备事件">八 设备事件</a></h2>
<h3 id="81-orientationchange-事件"><a class="header" href="#81-orientationchange-事件">8.1 orientationchange 事件</a></h3>
<p>苹果公司在移动 Safari 浏览器上创造了 orientationchange 事件，以方便开发者判断用户的设备是处于垂直模式还是水平模式。移动 Safari 在 window 上暴露了 window.orientation 属性，它有以下 3 种值之一： 0 表示垂直模式， 90 表示左转水平模式（主屏幕键在右侧）， –90 表示右转水平模式（主屏幕键在左）。虽然相关文档也提及设备倒置后的值为 180，但设备本身至今还不支持。</p>
<p>每当用户旋转设备改变了模式，就会触发 orientationchange 事件。但 event 对象上没有暴露任何有用的信息，这是因为相关信息都可以从 window.orientation 属性中获取。以下是这个事件典型的用法：</p>
<pre><code class="language-js">window.addEventListener('load', (event) =&gt; {
  let div = document.getElementById('myDiv')
  div.innerHTML = 'Current orientation is ' + window.orientation
  window.addEventListener('orientationchange', (event) =&gt; {
    div.innerHTML = 'Current orientation is ' + window.orientation
  })
})
</code></pre>
<p>这个例子会在 load 事件触发时显示设备初始的朝向。然后，又指定了 orientationchange 事件处理程序。此后，只要这个事件触发，页面就会更新以显示新的朝向信息。</p>
<p>所有 iOS 设备都支持 orientationchange 事件和 window.orientation 属性。</p>
<p>注意：因为 orientationchange 事件被认为是 window 事件，所以也可以通过给<code>&lt;body&gt;</code>元素添加 onorientationchange 属性来指定事件处理程序</p>
<h3 id="82-deviceorientation-事件"><a class="header" href="#82-deviceorientation-事件">8.2 deviceorientation 事件</a></h3>
<p>deviceorientation 是 DeviceOrientationEvent 规范定义的事件。如果可以获取设备的加速计信息，而且数据发生了变化，这个事件就会在 window 上触发。要注意的是， deviceorientation 事件只反映设备在空间中的朝向，而不涉及移动相关的信息。</p>
<p>当 deviceorientation 触发时， event 对象中会包含各个轴相对于设备静置时坐标值的变化，主要是以下 5 个属性。</p>
<ul>
<li>alpha： 0~360 范围内的浮点值，表示围绕 z 轴旋转时 y 轴的度数（左右转）。</li>
<li>beta： –180~180 范围内的浮点值，表示围绕 x 轴旋转时 z 轴的度数（前后转）。</li>
<li>gamma： –90~90 范围内的浮点值，表示围绕 y 轴旋转时 z 轴的度数（扭转）。</li>
<li>absolute：布尔值，表示设备是否返回绝对值。</li>
<li>compassCalibrated：布尔值，表示设备的指南针是否正确校准</li>
</ul>
<p>基于这些信息，可以随着设备朝向的变化重新组织或修改屏幕上显示的元素。例如，以下代码会随着朝向变化旋转一个元素：</p>
<pre><code class="language-js">window.addEventListener('deviceorientation', (event) =&gt; {
  let arrow = document.getElementById('arrow')
  arrow.style.webkitTransform = `rotate(${Math.round(event.alpha)}deg)`
})
</code></pre>
<p>这个例子只适用于移动 WebKit 浏览器，因为使用的是专有的 webkitTransform 属性（ CSS 标准的 transform 属性的临时版本）。“箭头”（ arrow）元素会随着 event.alpha 值的变化而变化，呈现出指南针的样子。这里给 CSS3 旋转变形函数传入了四舍五入后的值，以确保平顺。</p>
<h3 id="83-devicemotion-事件"><a class="header" href="#83-devicemotion-事件">8.3 devicemotion 事件</a></h3>
<p>DeviceOrientationEvent 规范也定义了 devicemotion 事件。这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。例如， devicemotion 事件可以用来确定设备正在掉落或者正拿在一个行走的人手里。</p>
<p>当 devicemotion 事件触发时， event 对象中包含如下额外的属性：</p>
<ul>
<li>acceleration：对象，包含 x、 y 和 z 属性，反映不考虑重力情况下各个维度的加速信息。</li>
<li>accelerationIncludingGravity：对象，包含 x、 y 和 z 属性，反映各个维度的加速信息，包含 z 轴自然重力加速度。</li>
<li>interval：毫秒，距离下次触发 devicemotion 事件的时间。此值在事件之间应为常量。</li>
<li>rotationRate：对象，包含 alpha、 beta 和 gamma 属性，表示设备朝向。</li>
</ul>
<p>如果无法提供 acceleration、 accelerationIncludingGravity 和 rotationRate 信息，则属性值为 null。为此，在使用这些属性前必须先检测它们的值是否为 null。比如：</p>
<pre><code class="language-js">window.addEventListener('devicemotion', (event) =&gt; {
  let output = document.getElementById('output')
  if (event.rotationRate !== null) {
    output.innerHTML +=
      `Alpha=${event.rotationRate.alpha}` +
      `Beta=${event.rotationRate.beta}` +
      `Gamma=${event.rotationRate.gamma}`
  }
})
</code></pre>
<h2 id="九-触摸及手势事件"><a class="header" href="#九-触摸及手势事件">九 触摸及手势事件</a></h2>
<h3 id="90-触屏设备"><a class="header" href="#90-触屏设备">9.0 触屏设备</a></h3>
<p>Safari 为 iOS 定制了一些专有事件，以方便开发者。因为 iOS 设备没有鼠标和键盘，所以常规的鼠标和键盘事件不足以创建具有完整交互能力的网页。同时， WebKit 也为 Android 定制了很多专有事件，成为了事实标准，并被纳入 W3C 的 Touch Events 规范。本节介绍的事件只适用于触屏设备</p>
<h3 id="91-触摸事件"><a class="header" href="#91-触摸事件">9.1 触摸事件</a></h3>
<p>当手指放在屏幕上、在屏幕上滑动或从屏幕移开时， 触摸事件即会触发。触摸事件有如下几种：</p>
<ul>
<li>touchstart：手指放到屏幕上时触发（即使有一个手指已经放在了屏幕上）。</li>
<li>touchmove：手指在屏幕上滑动时连续触发。在这个事件中调用 preventDefault()可以阻止滚动。</li>
<li>touchend：手指从屏幕上移开时触发。</li>
<li>touchcancel：系统停止跟踪触摸时触发。文档中并未明确什么情况下停止跟踪。</li>
</ul>
<p>这些事件都会冒泡，也都可以被取消。尽管触摸事件不属于 DOM 规范，但浏览器仍然以兼容 DOM 的方式实现了它们。因此，每个触摸事件的 event 对象都提供了鼠标事件的公共属性： bubbles、cancelable、 view、 clientX、 clientY、 screenX、 screenY、 detail、 altKey、 shiftKey、ctrlKey 和 metaKey。</p>
<p>除了这些公共的 DOM 属性，触摸事件还提供了以下 3 个属性用于跟踪触点：</p>
<ul>
<li>touches： Touch 对象的数组，表示当前屏幕上的每个触点。</li>
<li>targetTouches： Touch 对象的数组，表示特定于事件目标的触点。</li>
<li>changedTouches： Touch 对象的数组，表示自上次用户动作之后变化的触点</li>
</ul>
<p>每个 Touch 对象都包含下列属性：</p>
<ul>
<li>clientX：触点在视口中的 x 坐标。</li>
<li>clientY：触点在视口中的 y 坐标。</li>
<li>identifier：触点 ID。</li>
<li>pageX：触点在页面上的 x 坐标。</li>
<li>pageY：触点在页面上的 y 坐标。</li>
<li>screenX：触点在屏幕上的 x 坐标。</li>
<li>screenY：触点在屏幕上的 y 坐标。</li>
<li>target：触摸事件的事件目标。</li>
</ul>
<p>这些属性可用于追踪屏幕上的触摸轨迹：</p>
<pre><code class="language-js">function handleTouchEvent(event) {
  // 只针对一个触点
  if (event.touches.length == 1) {
    let output = document.getElementById('output')
    switch (event.type) {
      case 'touchstart':
        output.innerHTML +=
          `&lt;br&gt;Touch started:` +
          `(${event.touches[0].clientX}` +
          ` ${event.touches[0].clientY})`
        break
      case 'touchend':
        output.innerHTML +=
          `&lt;br&gt;Touch ended:` +
          `(${event.changedTouches[0].clientX}` +
          ` ${event.changedTouches[0].clientY})`
        break
      case 'touchmove':
        event.preventDefault() // 阻止滚动
        output.innerHTML +=
          `&lt;br&gt;Touch moved:` +
          `(${event.changedTouches[0].clientX}` +
          ` ${event.changedTouches[0].clientY})`
        break
    }
  }
}
document.addEventListener('touchstart', handleTouchEvent)
document.addEventListener('touchend', handleTouchEvent)
document.addEventListener('touchmove', handleTouchEvent)
</code></pre>
<p>以上代码会追踪屏幕上的一个触点。为简单起见，代码只会在屏幕有一个触点时输出信息。在 touchstart 事件触发时，触点的位置信息会输出到 output 元素中。在 touchmove 事件触发时，会取消默认行为以阻止滚动（移动触点通常会滚动页面），并输出变化的触点信息。在 touchend 事件触发时，会输出触点最后的信息。注意， touchend 事件触发时 touches 集合中什么也没有，这是因为没有滚动的触点了。此时必须使用 changedTouches 集合。</p>
<p>这些事件会在文档的所有元素上触发，因此可以分别控制页面的不同部分。当手指点触屏幕上的元素时，依次会发生如下事件（包括鼠标事件）：</p>
<ul>
<li>(1) touchstart</li>
<li>(2) mouseover</li>
<li>(3) mousemove（ 1 次）</li>
<li>(4) mousedown</li>
<li>(5) mouseup</li>
<li>(6) click</li>
<li>(7) touchend</li>
</ul>
<h3 id="92-手势事件"><a class="header" href="#92-手势事件">9.2 手势事件</a></h3>
<p>手势事件会在两个手指触碰屏幕且相对距离或旋转角度变化时触发。手势事件有以下 3 种。</p>
<ul>
<li>gesturestart：一个手指已经放在屏幕上，再把另一个手指放到屏幕上时触发。</li>
<li>gesturechange：任何一个手指在屏幕上的位置发生变化时触发。</li>
<li>gestureend：其中一个手指离开屏幕时触发</li>
</ul>
<p>只有在两个手指同时接触事件接收者时，这些事件才会触发。在一个元素上设置事件处理程序，意味着两个手指必须都在元素边界以内才能触发手势事件（这个元素就是事件目标）。因为这些事件会冒泡，所以也可以把事件处理程序放到文档级别，从而可以处理所有手势事件。使用这种方式时，事件的目标就是两个手指均位于其边界内的元素。</p>
<p>触摸事件和手势事件存在一定的关系。当一个手指放在屏幕上时，会触发 touchstart 事件。当另一个手指放到屏幕上时， gesturestart 事件会首先触发，然后紧接着触发这个手指的 touchstart 事件。如果两个手指或其中一个手指移动，则会触发 gesturechange 事件。只要其中一个手指离开屏幕，就会触发 gestureend 事件，紧接着触发该手指的 touchend 事件。</p>
<p>与触摸事件类似，每个手势事件的 event 对象都包含所有标准的鼠标事件属性： bubbles、cancelable、 view、 clientX、 clientY、 screenX、 screenY、 detail、 altKey、 shiftKey、ctrlKey 和 metaKey。新增的两个 event 对象属性是 rotation 和 scale。 rotation 属性表示手指
变化旋转的度数，负值表示逆时针旋转，正值表示顺时针旋转（从 0 开始）。 scale 属性表示两指之间距离变化（对捏）的程度。开始时为 1，然后随着距离增大或缩小相应地增大或缩小。</p>
<p>可以像下面这样使用手势事件的属性：</p>
<pre><code class="language-js">function handleGestureEvent(event) {
  let output = document.getElementById('output')
  switch (event.type) {
    case 'gesturestart':
      output.innerHTML +=
        `Gesture started: ` +
        `rotation=${event.rotation},` +
        `scale=${event.scale}`
      break
    case 'gestureend':
      output.innerHTML +=
        `Gesture ended: ` +
        `rotation=${event.rotation},` +
        `scale=${event.scale}`
      break
    case 'gesturechange':
      output.innerHTML +=
        `Gesture changed: ` +
        `rotation=${event.rotation},` +
        `scale=${event.scale}`
      break
  }
}
document.addEventListener('gesturestart', handleGestureEvent, false)
document.addEventListener('gestureend', handleGestureEvent, false)
document.addEventListener('gesturechange', handleGestureEvent, false)
</code></pre>
<p>触摸事件也会返回 rotation 和 scale 属性，但只在两个手指触碰屏幕时才会变化。一般来说，使用两个手指的手势事件比考虑所有交互的触摸事件使用起来更容易一些。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-计算机网络简介"><a class="header" href="#011-计算机网络简介">01.1-计算机网络简介</a></h1>
<h2 id="一-计算机网络发展史"><a class="header" href="#一-计算机网络发展史">一 计算机网络发展史</a></h2>
<h3 id="11-电路交换"><a class="header" href="#11-电路交换">1.1 电路交换</a></h3>
<p>在早起的广域网中，通信双方之间，是通过电路交换建立电路连接的网路，如图所示：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-00-1.png" alt="电路交换" /></p>
<p>当左侧的任意一台电话与右侧的电话建立连接后，线路就被占用了，即电路交换有以下特点：</p>
<ul>
<li>连接过程是：建立连接-&gt;使用连接-&gt;释放连接</li>
<li>物理链路会被通信双方独占</li>
</ul>
<p>电路交换的传输效率极低，所以不适合传输计算机数据。</p>
<h3 id="12-分组交换"><a class="header" href="#12-分组交换">1.2 分组交换</a></h3>
<p>分组交换的意思是：使用标有地址的分组进行路由选择传输数据，通信双方仅在传输期间占用通信通道。</p>
<p>每个分组都由首部和数据段组成，因为用户一般会一直在接收多段数据，那么就需要首部等存储的信息来确认。</p>
<p>如图所示：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-00-2.png" alt="分组交换" /></p>
<p>分组是分组交换的传输单位，节点在收到分组后，会先暂时存储下来，检查其首部，按照首部中的目的地址，找到合适的下一个节点转发出去。</p>
<h2 id="二-网络协议"><a class="header" href="#二-网络协议">二 网络协议</a></h2>
<h3 id="21-网络分层"><a class="header" href="#21-网络分层">2.1 网络分层</a></h3>
<p>为了能够更好的屏蔽不同计算机之间软硬件不同，实现不同类型计算机、操作系统之间进行通信，出现了网络分层体系。</p>
<p>网络在理论上划分为了 OSI 七层结构，但是这只是理论模型，现代计算机网络都采用的是 TCP/IP 四层模型：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-00-3.png" alt="网络分层" /></p>
<p>TCP/IP 协议簇是一系列网络相关协议的总称，其典型特征是分为四层结构：</p>
<ul>
<li>
<p>应用层：面向开发者使用，提供应用程序之间沟通协议。</p>
</li>
<li>
<p>HTTP：超文本传输协议，用于 web 服务中从服务器传输超文本到本地浏览器</p>
</li>
<li>
<p>FTP：文件传输协议</p>
</li>
<li>
<p>传输层：传输层通过系统调用向应用层提供两台计算机之间输出传输能力</p>
</li>
<li>
<p>TCP 协议：传输层面向连接的协议，传输数据前需要建立连接，会对包进行排序、查错，损坏的包也可以重传。常用于 web 应用。</p>
</li>
<li>
<p>UDP 协议：传输层无连接的报文协议，传输数据前无需建立连接，不会对包进行排序、查错，损坏的包不可以重传。常用于 DNS 解析、音视频通话等。</p>
</li>
<li>
<p>网络层：提供数据封包传输功能，以尽力让每个数据包都能到达目的主机。</p>
</li>
<li>
<p>IP 协议：为数据从源地址到目的地址传输提供帮助的协议。是不可靠的，不保证传输结果是否成功，也是无连接，即不维护后续数据包的状态。ip 地址是主机的唯一标识。</p>
</li>
<li>
<p>链路层：也称为网络接口层，负责最终打包好的数据帧在硬件上的发送与接收。</p>
</li>
<li>
<p>ARP 协议：根据 IP 地址获取 Mac 地址</p>
</li>
<li>
<p>RARP 协议：根据 Mac 地址获取 IP 地址</p>
</li>
</ul>
<p>通信的职责：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-00-4.png" alt="通信的职责" /></p>
<h3 id="22-数据封包解包"><a class="header" href="#22-数据封包解包">2.2 数据封包、解包</a></h3>
<p>数据的传输过程：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-00-5.svg" alt="通信的传输过程" /></p>
<p>数据在网络传输时，是需要经过封包、解包的过程的。数据在经过应用程序发送时，封包的过程如下所示：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-00-6.png" alt="封包解包" /></p>
<p>在封包时候，数据沿着协议栈，不断的在各个层加上头部信息，链路层还会额外加入尾部信息。最终数据到达互联网后，就具备了所有需识别的信息。</p>
<p>解包即是数据从下层传输到上层时，会逐层把下层的头部信息删除：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-00-7.png" alt="解包" /></p>
<h3 id="23-各层封装格式"><a class="header" href="#23-各层封装格式">2.3 各层封装格式</a></h3>
<p>链路层封装：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-00-8.png" alt="解包" /></p>
<p>贴士：图中的 IEEE802.2/802.3 常用于无线网络，以太网用于有线网络。封装时，目的 Mac 地址、源 Mac 地址、协议类型已经占据了 14 个字节，CRC 占据了 4 个字节，也就是说即使发送了一个空的数据，也有 18 个字节。</p>
<p>网络层、传输层封装：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-00-9.png" alt="解包" /></p>
<p>贴士：以上每行为 4 个字节，所以 IP 协议占据了 20 个字节，</p>
<h2 id="三-tcp-协议"><a class="header" href="#三-tcp-协议">三 TCP 协议</a></h2>
<h3 id="31-tcp-概念"><a class="header" href="#31-tcp-概念">3.1 TCP 概念</a></h3>
<p>TCP 协议是面向连接的，可靠的传输层协议，用于实现不同主机之间的进程间通信。TCP 协议会对包进行排序、查错，损坏的包也可以重传。</p>
<h3 id="32-三次握手"><a class="header" href="#32-三次握手">3.2 三次握手</a></h3>
<p>TCP 所谓的可靠性是指在数据传输前，发送端、接收端先互相进行验证对方的收发功能是否正常！TCP 中的验证方式是三次握手、四次挥手。</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-01.svg" alt="三次握手简图" /></p>
<p>三次握手过程：</p>
<ul>
<li>第一次握手：客户端发送请求报文段，内部包含 SYN 标志，发送后进入 SYN_SEND 状态，等待服务端确认</li>
<li>第二次握手：服务端接收到客户端 SYN 报文后，发送 ACK 信息对这个 SYN 报文段进行确认，同时额外发送自己的 SYN 请求信息，发送后进入 SYN_RECV 状态</li>
<li>第三次握手：客户端接收到服务端的 SYN+ACK 报文后，会向服务端发送 ACK 确认报文段，发送完毕后，客户端和服务端都会进入 ESTABLISHED 状态，三次握手完成，开始进行真实数据传输！</li>
</ul>
<p>三次握手详图如下：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-02.png" alt="三次握手详图" /></p>
<h3 id="33-四次挥手"><a class="header" href="#33-四次挥手">3.3 四次挥手</a></h3>
<p>四次挥手过程是连接断开时做的操作，客户端在主动关闭时，发送的请求报文段包括 FIN 标志（假设值为 M），服务端接收到该报文后，同样返回 ACK 信息（值为 M+1）。此时服务端也执行 close 操作，并发送一个新的 FIN（假设值为 N）给客户端，客户端接收到该数据，将返回值为 ACK 信息（值为 N+1）。</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-03.svg" alt="四次挥手简图" /></p>
<p>如上所示，四次挥手其实是将三次握手中的第二步分 2 部处理。</p>
<p>注意：以上客户端和服务端只是是可以互换身份进行关闭的，即服务端也可以主动关闭，其关闭过程与客户端主动关闭一致。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-http-协议"><a class="header" href="#021-http-协议">02.1-Http 协议</a></h1>
<h2 id="一-http-协议"><a class="header" href="#一-http-协议">一 HTTP 协议</a></h2>
<h3 id="11-http-协议简介"><a class="header" href="#11-http-协议简介">1.1 HTTP 协议简介</a></h3>
<p>HTTP 协议是 TCP/IP 协议的一个子集，是超文本传输协议，在该协议规范下，允许将超文本标记语言 HTML 文档从 web 服务器传送到客户端（浏览器）。</p>
<p>客户端与服务端之间需要在 HTTP 协议基础上进行通信，双方通过网络传递的数据称为<code>报文</code>。</p>
<h3 id="12-报文"><a class="header" href="#12-报文">1.2 报文</a></h3>
<p>HTTP 协议中有两类报文，请求报文、响应报文。HTTP 是面向文本的，所以报文中的每一个字段都是一些 ASCII 码串，因而各个字段的长度都是不确定的。HTTP 请求报文和响应报文都是由三个部分组成。这两种报文格式的区别就是开始行不同。</p>
<pre><code class="language-txt">开始行：用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行，而在响应报文中的开始行叫做状态行。
首部行：用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。
实体主体：在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段
</code></pre>
<p>报文示例：</p>
<pre><code class="language-txt">GET/sample.jspHTTP/1.1
Accept:image/gif.image/jpeg,/
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate
</code></pre>
<h3 id="13-请求方法"><a class="header" href="#13-请求方法">1.3 请求方法</a></h3>
<p>请求方法：客户端和服务器之间交互会使用不同的方法。常见的请求方法有：</p>
<pre><code class="language-txt">GET：默认的方法，用来请求已经被 URI 识别的资源
POST：用于提交数据
PUT：与 POST 类似，但 PUT 是幂等的（多次重复造作结果一致），所以一般用于更新数据
HEAD：只用于获取报头，所以可以用来测试链接的有效性
DELETE：用于删除资源，与 PUT 相反或者说对应
OPTIOON：用来查询针对请求 URI 的资源的方法是否支持，比如常见的跨域问题
TRAC：回显服务器收到的请求，用于测试、诊断
CONNECT：用于代理服务器，开启客户端与服务端资源之间的通道
</code></pre>
<p>具有幂等性的方法：</p>
<pre><code class="language-txt">GET
HEAD
PUT
DELETE
OPTIONS
TRACE
</code></pre>
<h3 id="14-响应状态码"><a class="header" href="#14-响应状态码">1.4 响应状态码</a></h3>
<p>HTTP 请求的结果用状态码来表示请求的结果：</p>
<ul>
<li>1xx：表示消息，代表请求被接受，需要继续处理，是一种临时响应</li>
<li>2xx：表示成功。</li>
<li>200：OK，请求成功，处理成功</li>
<li>202：Accepted，请求已接受，但是处理未完成</li>
<li>206：Partial Content，部分请求被处理完成。断点续传中会用到。</li>
<li>3xx：表示重定向，代表客户端采取进一步操作才能完成请求，后续的请求地址（重定向目标）在本次响应的 Location 域中指明</li>
<li>301：Moved Permanently，永久重定向，请求的资源被永久移动到了新 URI</li>
<li>302：Found，临时移动，客户端后续请求应该继续使用原有 URI</li>
<li>4xx：表示请求错误。</li>
<li>400：Bad Request，客户端请求语法错误，服务器无法理解</li>
<li>401：Unauthorized，请求要求用户的身份认证</li>
<li>403：Forbidden，服务器理解了客户端的请求，但是拒绝执行，</li>
<li>404：Not Found，服务器未找到对应资源</li>
<li>5xx：表示服务器错误。</li>
<li>500：Internal Server Error，服务器内部错误，请求无法完成</li>
<li>502：Bad Gateway，网关或者代理服务器收到了无效请求</li>
</ul>
<h2 id="二-内容协商机制"><a class="header" href="#二-内容协商机制">二 内容协商机制</a></h2>
<p>内容协商机制：客户端和服务端就响应的资源内容进行交涉，以提供最适合当前客户端需求的资源。比如给英语地区的客户端显示英语界面，给汉语地区的客户端显示汉语界面。</p>
<p>内容协商一般以响应资源的语言、字符集、编码等方式作为判断基准。</p>
<p>协商方式有：</p>
<ul>
<li>客户端驱动：客户端发送请求，服务端返回可选列表，客户端做出选择后发送二次请求</li>
<li>服务端驱动：客户端发送请求，服务端 根据请求头部集，直接判断选择哪个版本的页面。该方式使用较为广泛。</li>
<li>常用判断头部：Accept，Accept-Language、Accpet-Charset、Accept-Encoding</li>
<li>常用判断头部：Content-Type，Content-Language</li>
<li>透明协商：某个中间设备（通常是缓存代理）代表客户端进行协商</li>
</ul>
<h2 id="三-https"><a class="header" href="#三-https">三 HTTPS</a></h2>
<p>Http 在网络中是以明文形式传输的，其安全性极差，HTTPS 就是为了解决 HTTP 安全性问题而诞生的。</p>
<p>HTTPS 其本质仍然是基于 http 协议，在此基础上增加了 TLS 传输层加密协议（前身是 SSL 协议），所以 HTTPS 可以简单理解为：</p>
<pre><code class="language-txt">HTTPS = HTTP + TLS
</code></pre>
<h2 id="四-http2"><a class="header" href="#四-http2">四 http2</a></h2>
<h3 id="41-http11-逐渐被取代"><a class="header" href="#41-http11-逐渐被取代">4.1 http1.1 逐渐被取代</a></h3>
<p>HTTP 协议已经很古老，目前广泛使用的 HTTP 协议版本为 http1.1，该版本支持缓存处理、长连接、请求流水线处理等，但是仍然不符合当前 4G、5G 的发展。</p>
<p>http2.0 在性能上有了大幅提升，特点如下：</p>
<ul>
<li>二进制传输</li>
<li>支持多路复用</li>
<li>header 压缩</li>
<li>支持服务端推送</li>
</ul>
<h3 id="42-二进制传输"><a class="header" href="#42-二进制传输">4.2 二进制传输</a></h3>
<p>http1.1 是基于文本传输的，http2 则基于二进制格式传输，能有效压缩传输数据大小。</p>
<p>在 http2 中，基本的协议单位是帧。帧的内容包括：</p>
<pre><code class="language-txt">Length              长度
Type                类型
Flags               标记
R                   保留字段
Steam Identifier    流标识符
Frame Payload       帧主题
</code></pre>
<p>帧的布局：
<img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/http2-01.png" alt="帧的布局" /></p>
<p>http2 发送的数据是由一个或者多个帧组合成的消息。</p>
<h3 id="43-多路复用"><a class="header" href="#43-多路复用">4.3 多路复用</a></h3>
<p>在 http1.0 中，如果需要并发多个请求，则必须创建多个 TCP 连接，一般最高只有 6 个，这些连接无法被复用。</p>
<p>为了解决连接无法复用问题，HTTP/1.1 引入了 Pipeling 解决方案，但是在该方案中：若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会（FIFO），一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</p>
<p>HTTP/2 则允许多个请求同时在一个连接上并行执行，某个请求任务耗时严重，也不会影响到其它连接的正常执行；</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-07.jpeg" alt="http1 与 http2 对比" /></p>
<p>至此，在 HTTP/2 中，连接是共享的，每一个 request 都是用作连接共享机制的，一个 req 对应一个 id，接收方根据 id 归属到不同的服务端请求里。</p>
<p>同时 HTTP/2 中还可以设置每个流的优先级，高优先级的流会被服务端优先处理并返回给客户端。</p>
<h3 id="44-首部压缩"><a class="header" href="#44-首部压缩">4.4 首部压缩</a></h3>
<p>http1.1 则每次请求都附带大量的 header 信息，在 HTTP/2 中，通讯双方各自缓存一份 header fields 表，避免 header 的重复传输，减小传输文件大小。</p>
<h3 id="45-服务端推送"><a class="header" href="#45-服务端推送">4.5 服务端推送</a></h3>
<p>服务端推送即支持从服务端主动推送信息给客户端。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-web-开发介绍"><a class="header" href="#031-web-开发介绍">03.1-Web 开发介绍</a></h1>
<h2 id="一-web-开发的本质"><a class="header" href="#一-web-开发的本质">一 Web 开发的本质</a></h2>
<h3 id="11-请求响应模型"><a class="header" href="#11-请求响应模型">1.1 请求响应模型</a></h3>
<p>客户端与服务端之间的链接是基于一种请求应答的模式。即：客户端和服务端建立一个链接，客户端提交一个请求，服务端收到该请求后返回一个响应，然后二者就会断开连接。</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-04.svg" alt="请求响应模型" /></p>
<p>Web 开发，其本质其实是：</p>
<ul>
<li>
<ol>
<li>请求：客户端发起请求</li>
</ol>
</li>
<li>
<ol start="2">
<li>处理：服务端处理请求</li>
</ol>
</li>
<li>
<ol start="3">
<li>响应：服务端返回处理结果给客户端</li>
</ol>
</li>
</ul>
<p>常见服务器有：Nginx、Tomcat、Apache 等。</p>
<h3 id="12-cs-与-bs-架构"><a class="header" href="#12-cs-与-bs-架构">1.2 C/S 与 B/S 架构</a></h3>
<p>基于请求 - 响应模型，目前的开发方式主要有两种，他们各有优劣：</p>
<ul>
<li>C/S 架构（Client/Server）：客户端与服务端完全分离，如：QQ、迅雷、精灵宝可梦等软件。能够合理利用操作系统 API，具有较高的性能与操作体验，但新版发布会带来更新的不便</li>
<li>B/S 架构（Browser/Server）：基于浏览器作为客户端的开发方式，如：招商银行官网、页游。能够快速发布新版不影响用户使用，但会受限于浏览器本身的能力</li>
</ul>
<h2 id="二-网页的访问"><a class="header" href="#二-网页的访问">二 网页的访问</a></h2>
<h3 id="21-dns"><a class="header" href="#21-dns">2.1 DNS</a></h3>
<p>服务器地址都是以 IP 的形式进行标识的，那么在浏览器中却无需直接输入 IP 地址，而是输入网址就可以访问对方服务器，这是因为有 DNS 的帮助。</p>
<p>DNS 服务就是用来提供域名到 IP 地址之间的转换解析服务的！</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-05.png" alt="网页访问" /></p>
<p>为了提升效率，DNS 服务是有缓存的，依照就近原则，来进行网址与 IP 的解析，当访问一个网址时：</p>
<ul>
<li>优先从本地 host 文件中查找 ip 地址</li>
<li>然后查找本地的 DNS 缓存服务</li>
<li>去 DNS 服务商中查找</li>
</ul>
<p>所以一个请求的真实访问过程如下所示：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/net-06.png" alt="请求过程" /></p>
<h3 id="21-输入-url-到网页展示的过程"><a class="header" href="#21-输入-url-到网页展示的过程">2.1 输入 url 到网页展示的过程</a></h3>
<p>假设我们点击了某网页上的一个链接，指向一个新浪体育上一个詹姆斯扣球新闻，一般网页地址为：<code>http://www.sina.com/sport/nba/20200203-zms.html</code>。</p>
<p>这个访问过程大致如下：</p>
<ul>
<li>第一步：查找 DNS 服务</li>
<li>第二步：根据 DNS 服务查找该网页所在服务器 IP</li>
<li>第三步：浏览器与网页所在服务器建立连接</li>
<li>第四步：浏览器发出获取文件请求，服务端响应请求返回文件内容</li>
<li>第五步：浏览器与服务端双方断开连接</li>
<li>第六步：浏览器将获取到的数据通过解析引擎展示给用户</li>
</ul>
<h3 id="22-关于网址"><a class="header" href="#22-关于网址">2.2 关于网址</a></h3>
<p>URI：是一个紧凑的字符串，用来表示抽象、物理资源，可以分为 URL、URN，类似 URN 作用类似一个人的名字（身份），URL 类似一个人的地址（位置）。</p>
<p>URL 是 URI 的一种，但不是所有的 URI 都是 URL，访问机制决定了他们的不同，有访问机制的 URI 才是 URL，示例如下：</p>
<ul>
<li>URL：<code>ftp://ftp.down/1.txt</code></li>
<li>URI：<code>tel:+1-010-11-1311</code></li>
</ul>
<h2 id="三-通信实现"><a class="header" href="#三-通信实现">三 通信实现</a></h2>
<h3 id="20-常见通信方式"><a class="header" href="#20-常见通信方式">2.0 常见通信方式</a></h3>
<p>实现网页客户端与服务端通信的方式有两种：</p>
<ul>
<li>表单：利用表单提交给服务端</li>
<li>Ajax：Asynchronous JavaScript+XML，利用浏览器提供的原生 Ajax 对象提交数据给服务端，有两种实现：</li>
<li>XHR 对象：即 XMLHttpRequest 对象，比较难用，适合较老的浏览器</li>
<li>fetch()：新的标准，支持 promise、服务线程等，很强大</li>
</ul>
<p>Ajax 优点：在 Ajax 诞生之前，如果网速很慢，页面加载时间很长，就会导致用户一直在等待，而无法进行别的操作。在带表单的网页中，表单提交后，如果出现内容不合法，则会重新渲染页面，之前填写的内容就会消失。这些都是用户体验极差的现象，虽然可以通过一些手段避免，但是实现起来较为复杂。<strong>Ajax 可以实现页面无刷新更新数据，极大提高了用户体验！</strong></p>
<h3 id="21-表单提交示例"><a class="header" href="#21-表单提交示例">2.1 表单提交示例</a></h3>
<p>表单提交数据方式演示：</p>
<pre><code class="language-html">&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
  Username:
  &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
  Password:
  &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;
  File:
  &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;
  &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;
</code></pre>
<h3 id="22-服务端环境准备"><a class="header" href="#22-服务端环境准备">2.2 服务端环境准备</a></h3>
<p>Ajax 是客户端（浏览器）与服务端通信的方式，自然少不了服务端的参与。这里我们可以按照如下方式启动一个 Node 服务器。</p>
<p>首先需要下载并安装 NodeJS，进入网址<a href="https://nodejs.org">https://nodejs.org</a>，点击 LTS（长久支持）标识的安装包，下载后，一直下一步即可。</p>
<p>创建一个 NodeJS 项目，如下所示：</p>
<p><img src="04-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/../images/net/ajax-01.png" alt="node 项目" /></p>
<p>package.json 内容如下：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;demo-ajax&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;app.js&quot;,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;node app.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;body-parser&quot;: &quot;^1.19.0&quot;,
    &quot;express&quot;: &quot;^4.17.1&quot;,
    &quot;formidable&quot;: &quot;^1.2.2&quot;
  }
}
</code></pre>
<p>app.js 是 NodeJS 项目的核心文件（入口文件），代码如下：</p>
<pre><code class="language-js">const express = require('express') // 引入 web 框架 express
const path = require('path') // 引入 路径处理模块 path
const bodyParser = require('body-parser') // post 请求解析模块
const formidable = require('formidable') // 解析 FormData 的模块

const app = express() // 创建 web 服务器

// 静态资源目录
app.use(express.static(path.join(__dirname, 'public')))

// post 请求参数设置
let urlencodedParser = bodyParser.urlencoded({ extended: false })
let jsonParser = bodyParser.json()

app.get('/hi', (req, res) =&gt; {
  res.send({ hi: 'hello get' })
})

app.post('/hi', (req, res) =&gt; {
  res.send({ hi: 'hello post' })
})

app.get('/getDemo', (req, res) =&gt; {
  console.log('GET 请求参数：', req.query)
  res.send({ cid: 1001, title: '新闻一', content: '内容一一一...' })
})

app.post('/postDemo', jsonParser, (req, res) =&gt; {
  console.log('POST 请求参数：', req.body)
  res.send([{ cid: 1001, title: '新闻二', content: '内容二一一...' }])
})

app.post('/formDataDemo', (req, res) =&gt; {
  const form = new formidable.IncomingForm()
  form.parse(req, (err, fileds, files) =&gt; {
    if (err) {
      res.send({ error: err })
      return
    }
    // fileds 保存了普通键值对，files 保存了上传的文件
    console.log('FormData 参数：', fileds)
    res.send([{ cid: 1001, title: '新闻三', content: '内容三一一...' }])
  })
})

app.post('/uploadDemo', () =&gt; {
  const form = new formidable.IncomingForm()
  form.uploadDir = path.joind(__dirname, 'uploads')
  form.parse(req, (err, fileds, files) =&gt; {
    if (err) {
      res.send({ error: err })
      return
    }
    res.send([{ cid: 1001, title: '新闻三', content: '内容三一一...' }])
  })
})

app.get('/crosDemo', (req, res) =&gt; {
  res.send(&quot;let user = {'uid':'1001'}&quot;)
})

app.get('/crosDemo2', (req, res) =&gt; {
  // 获取回调函数名称
  let callback = req.query.callback

  // 定义要返回的数据
  let data = JSON.stringify({ uid: '1001' })

  // 返回数据
  res.send(`${callback}(${data});`)
})

app.listen(3000, () =&gt; {
  console.log('服务器启动成功')
})
</code></pre>
<p>在学习 Ajax 时，只需要在 public 文件夹下的 <code>index.html</code> 内书写示例即可。</p>
<p>运行：</p>
<pre><code class="language-txt"># 进入项目根目录

# 安装依赖
npm i

# 运行项目
npm run dev
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-数据交互协议-xml"><a class="header" href="#041-数据交互协议-xml">04.1-数据交互协议-XML</a></h1>
<h2 id="一-数据交互协议"><a class="header" href="#一-数据交互协议">一 数据交互协议</a></h2>
<p>最常见的前后端数据交互方式有两种：</p>
<ul>
<li>JSON：轻量的通用数据格式，是目前互联网领域的主流数据交互格式</li>
<li>XML：曾经的互联网数据传输事实标准</li>
</ul>
<p>XML 因为过于冗余、啰嗦，JSON 逐渐成为 XML 的替代方案。</p>
<h2 id="二-json"><a class="header" href="#二-json">二 JSON</a></h2>
<h3 id="21-json-简介"><a class="header" href="#21-json-简介">2.1 JSON 简介</a></h3>
<p>JSON（JavaScript Object Notation）是 JS 的严格子集，可以用来替代以前的标准数据方案 XML，因为 <strong>JSON 可以直接传给 eval() 而不需要创建 DOM</strong>。</p>
<p>贴士：JSON 不属于 JavaScript，它们只是拥有相同的语法而已。JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式。很多语言都有解析和序列化 JSON 的内置能力。</p>
<h3 id="22-json-语法"><a class="header" href="#22-json-语法">2.2 JSON 语法</a></h3>
<p>JSON 语法支持表示 3 种类型的值。</p>
<pre><code class="language-txt">简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，特殊值 undefined 不可以。如：&quot;Hello world!&quot;
对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型。
数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。
</code></pre>
<p>ES5 新增了 JSON 解析全局对象 <code>JSON</code>，该对象提供了 2 个方法：</p>
<ul>
<li>stringify()：将 JS 序列化为 JSON 字符串</li>
<li>parse()：将 JSON 字符串解析为原生 JS，若字符串无效，则会解析错误。</li>
</ul>
<h3 id="23-序列化方法-stringify"><a class="header" href="#23-序列化方法-stringify">2.3 序列化方法 stringify()</a></h3>
<pre><code class="language-js">let obj = {
  id: 1001,
  name: 'Li',
  brothers: ['WW', 'ZS'],
}
// 参数二可选，表示只序列化哪些：JSON.stringify(book, [&quot;name&quot;, &quot;brothers&quot;])
let objStr = JSON.stringify(obj)
console.log(objStr)
</code></pre>
<p>参数二可以是一个函数，具备过滤功能：</p>
<pre><code class="language-js">let jsonText = JSON.stringify(obj, (key, value) =&gt; {
  switch (key) {
    case 'name':
      return value.join('-')
    case 'id':
      return 100
    default:
      return value
  }
})
</code></pre>
<p>toJSON() 方法可以自定义序列化：</p>
<pre><code class="language-js">let obj = {
  id: 1001,
  name: 'Li',
  brothers: ['WW', 'ZS'],
  toJSON: function () {
    return this.name
  },
}
</code></pre>
<p>toJSON() 方法可以与过滤函数一起使用，因此理解不同序列化流程的顺序非常重要。在把对象传给 JSON.stringify() 时会执行如下步骤。</p>
<pre><code class="language-txt">(1) 如果可以获取实际的值，则调用 toJSON() 方法获取实际的值，否则使用默认的序列化。
(2) 如果提供了第二个参数，则应用过滤。传入过滤函数的值就是第 (1) 步返回的值。
(3) 第 (2) 步返回的每个值都会相应地进行序列化。
(4) 如果提供了第三个参数，则相应地进行缩进
</code></pre>
<h3 id="24-解析方法-parse"><a class="header" href="#24-解析方法-parse">2.4 解析方法 parse()</a></h3>
<p>JSON.parse() 方法也可以接收一个额外的参数，这个函数会针对每个键/值对都调用一次。为区别于传给 JSON.stringify() 的起过滤作用的替代函数（replacer），这个函数被称为还原函数（reviver）。实际上它们的格式完全一样，即还原函数也接收两个参数，属性名（key）和属性值（value），另外也
需要返回值。</p>
<p>如果还原函数返回 undefined，则结果中就会删除相应的键。如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。还原函数经常被用于把日期字符串转换为 Date 对象。例如：</p>
<pre><code class="language-js">let book = {
  id: 1001,
  name: 'Li',
  brothers: ['WW', 'ZS'],
  date: new Date(2020, 12, 11),
}

let objText = JSON.stringify(obj)

let objCopy = JSON.parse(objText, (key, value) =&gt;
  key == 'date' ? new Date(value) : value
)
console.log(objCopy.date.getFullYear())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="042-数据交互协议-json"><a class="header" href="#042-数据交互协议-json">04.2-数据交互协议-JSON</a></h1>
<h2 id="一-xml-概念"><a class="header" href="#一-xml-概念">一 XML 概念</a></h2>
<p>XML 曾经是互联网上存储、传输结构化数据的标准。</p>
<h2 id="二-xml-基础使用"><a class="header" href="#二-xml-基础使用">二 XML 基础使用</a></h2>
<h3 id="21-创建-xml-文档"><a class="header" href="#21-创建-xml-文档">2.1 创建 XML 文档</a></h3>
<p>DOM Level 2 中可以直接创建 XML 文档，要创建一个 document 对象标签名为<code>&lt;root&gt;</code>的新 XML 文档，示例如下：</p>
<pre><code class="language-js">/**
 * 参数一：namespaceUri 参数用得很少，因为在 JavaScript 中很难管理命名空间
 * 参数二：root 参数通常只会使用一次，因为这个参数定义的是 XML DOM中 document 元素的标签名。
 * 参数三：doctype 参数
 */
let xmldom = document.implementation.createDocument('', 'root', null)
console.log(xmldom.documentElement.tagName) // &quot;root&quot;

let child = xmldom.createElement('child')
xmldom.documentElement.appendChild(child)
</code></pre>
<p>贴士： <code>document.implementation.hasFeature(&quot;XML&quot;, &quot;2.0&quot;)</code> 可以检查浏览器是否支持 DOM Level 2 XML。</p>
<h3 id="22-xml-解析为-dom"><a class="header" href="#22-xml-解析为-dom">2.2 XML 解析为 DOM</a></h3>
<p>DOMParser 是将 XML 解析为 DOM 文档的类：：</p>
<pre><code class="language-js">let parser = new DOMParser()
// 参数为：XML字符串、内容类型
let xmldom = parser.parseFromString('&lt;root&gt;&lt;child/&gt;&lt;/root&gt;', 'text/xml')

console.log(xmldom.documentElement.tagName) // &quot;root&quot;
console.log(xmldom.documentElement.firstChild.tagName) // &quot;child&quot;

let anotherChild = xmldom.createElement('child')
xmldom.documentElement.appendChild(anotherChild)
let children = xmldom.getElementsByTagName('child')
console.log(children.length) // 2
</code></pre>
<p>在发生解析错误时，parseFromString() 方法仍会返回一个 Document 对象，只不过其 document 元素是<code>&lt;parsererror&gt;</code>，该元素的内容为解
析错误的描述，为了兼容不同的返回结果，最好采用 try/catch：</p>
<pre><code class="language-js">let parser = new DOMParser(),
  xmldom,
  errors
try {
  xmldom = parser.parseFromString('&lt;root&gt;', 'text/xml')
  errors = xmldom.getElementsByTagName('parsererror')
  if (errors.length &gt; 0) {
    throw new Error('Parsing error!')
  }
} catch (ex) {
  console.log('Parsing error!')
}
</code></pre>
<h3 id="23-dom-解析为-xml"><a class="header" href="#23-dom-解析为-xml">2.3 DOM 解析为 XML</a></h3>
<p>XMLSerializer 类负责将 DOM 文档徐磊话为 XML 字符串：</p>
<pre><code class="language-js">let serializer = new XMLSerializer()
let xml = serializer.serializeToString(xmldom)
console.log(xml)
</code></pre>
<p>贴士：如果给 serializeToString()传入非 DOM 对象，就会导致抛出错误。</p>
<h2 id="三-xpath"><a class="header" href="#三-xpath">三 XPath</a></h2>
<h3 id="31-xpath-基本使用"><a class="header" href="#31-xpath-基本使用">3.1 XPath 基本使用</a></h3>
<p>XPath 是为了在 DOM 文档中定位特定节点而创建的，要确定浏览器是否支持 DOM Level 3 XPath，可以使用以下代码：</p>
<pre><code class="language-js">let supportsXPath = document.implementation.hasFeature('XPath', '3.0')
</code></pre>
<p>该一番总最重要的两个是：XPathEvaluator 和 XPathResult。</p>
<p>XPathEvaluator 用于在特定上下文中求值 XPath 表达式，包含三个方法。</p>
<ul>
<li>createExpression(expression, nsresolver)，用于根据 XPath 表达式及相应的命名空间计算得到一个 XPathExpression， XPathExpression 是查询的编译版本。这适合于同样的查询要运行多次的情况。</li>
<li>createNSResolver(node)，基于 node 的命名空间创建新的 XPathNSResolver 对象。当对使用名称空间的 XML 文档求值时，需要 XPathNSResolver 对象。</li>
<li>evaluate(expression, context, nsresolver, type, result)，根据给定的上下文和命名空间对 XPath 进行求值。其他参数表示如何返回结果。</li>
</ul>
<p>evaluate()方法接收五个参数： XPath 表达式、上下文节点、命名空间解析器、返回的结果类型和 XPathResult 对象（用于填充结果，通常是 null，因为结果也可能是函数值）。第三个参数，命名空间解析器，只在 XML 代码使用 XML 命名空间的情况下有必要。如果没有使用命名空间，这个参数也应该是 null。第四个参数要返回值的类型是如下 10 个常量值：</p>
<ul>
<li>XPathResult.ANY_TYPE：返回适合 XPath 表达式的数据类型。</li>
<li>XPathResult.NUMBER_TYPE：返回数值。</li>
<li>XPathResult.STRING_TYPE：返回字符串值。</li>
<li>XPathResult.BOOLEAN_TYPE：返回布尔值。</li>
<li>XPathResult.UNORDERED_NODE_ITERATOR_TYPE：返回匹配节点的集合，但集合中节点的顺序可能与它们在文档中的顺序不一致。</li>
<li>XPathResult.ORDERED_NODE_ITERATOR_TYPE：返回匹配节点的集合，集合中节点的顺序与它们在文档中的顺序一致。这是非常常用的结果类型。</li>
<li>XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，在文档外部捕获节点，因此对文档的进一步修改不会影响该节点集合。集合中节点的顺序可能与它们在文档中的顺序不一致。</li>
<li>XPathResult.ORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，在文档外部捕获节点，因此对文档的进一步修改不会影响这个节点集合。集合中节点的顺序与它们在文档中的顺序一致。</li>
<li>XPathResult.ANY_UNORDERED_NODE_TYPE：返回匹配节点的集合，但集合中节点的顺序可能与它们在文档中的顺序不一致。</li>
<li>XPathResult.FIRST_ORDERED_NODE_TYPE：返回只有一个节点的节点集合，包含文档中第一个匹配的节点</li>
</ul>
<p>指定的结果类型决定了如何获取结果的值：</p>
<pre><code class="language-js">let result = xmldom.evaluate(
  'employee/name',
  xmldom.documentElement,
  null,
  XPathResult.ORDERED_NODE_ITERATOR_TYPE,
  null
)
if (result !== null) {
  let element = result.iterateNext()
  while (element) {
    console.log(element.tagName)
    node = result.iterateNext()
  }
}
</code></pre>
<p>这个例子使用了 XPathResult.ORDERED_NODE_ITERATOR_TYPE 结果类型，也是最常用的类型。如果没有节点匹配 XPath 表达式， evaluate()方法返回 null；否则，返回 XPathResult 对象。返回的 XPathResult 对象上有相应的属性和方法用于获取特定类型的结果。如果结果是节点迭代器，无论有序还是无序，都必须使用 iterateNext()方法获取结果中每个匹配的节点。在没有更多匹配节点时，iterateNext()返回 null。</p>
<p>如果指定了快照结果类型（无论有序还是无序），都必须使用 snapshotItem()方法和 snapshotLength 属性获取结果，如以下代码所示：</p>
<pre><code class="language-js">let result = xmldom.evaluate(
  'employee/name',
  xmldom.documentElement,
  null,
  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
  null
)
if (result !== null) {
  for (let i = 0, len = result.snapshotLength; i &lt; len; i++) {
    console.log(result.snapshotItem(i).tagName)
  }
}
</code></pre>
<p>这个例子中， snapshotLength 返回快照中节点的数量，而 snapshotItem()返回快照中给定位置的节点（类似于 NodeList 中的 length 和 item()）。</p>
<h3 id="32-单个节点结果"><a class="header" href="#32-单个节点结果">3.2 单个节点结果</a></h3>
<p>XPathResult.FIRST_ORDERED_NODE_TYPE 结果类型返回匹配的第一个节点，可以通过结果的 singleNodeValue 属性获取。比如：</p>
<pre><code class="language-js">let result = xmldom.evaluate(
  'employee/name',
  xmldom.documentElement,
  null,
  XPathResult.FIRST_ORDERED_NODE_TYPE,
  null
)
if (result !== null) {
  console.log(result.singleNodeValue.tagName)
}
</code></pre>
<p>与其他查询一样，如果没有匹配的节点， evaluate()返回 null。如果有一个匹配的节点，则要使用 singleNodeValue 属性取得该节点。这对 XPathResult.FIRST_ORDERED_NODE_TYPE 也一样。</p>
<h3 id="33-简单类型结果"><a class="header" href="#33-简单类型结果">3.3 简单类型结果</a></h3>
<p>使用布尔值、数值和字符串 XPathResult 类型，可以根据 XPath 获取简单、非节点数据类型。这些结果类型返回的值需要分别使用 booleanValue、 numberValue 和 stringValue 属性获取。对于布尔值类型，如果至少有一个节点匹配 XPath 表达式， booleanValue 就是 true；否则， booleanValue 为 false。比如：</p>
<pre><code class="language-js">let result = xmldom.evaluate(
  'employee/name',
  xmldom.documentElement,
  null,
  XPathResult.BOOLEAN_TYPE,
  null
)
console.log(result.booleanValue)
</code></pre>
<p>在这个例子中，如果有任何节点匹配&quot;employee/name&quot;， booleanValue 属性就等于 true。对于数值类型， XPath 表达式必须使用返回数值的 XPath 函数，如 count()可以计算匹配给定模式的节点数。比如：</p>
<pre><code class="language-js">let result = xmldom.evaluate(
  'count(employee/name)',
  xmldom.documentElement,
  null,
  XPathResult.NUMBER_TYPE,
  null
)
console.log(result.numberValue)
</code></pre>
<p>以上代码会输出匹配&quot;employee/name&quot;的节点数量（比如 2）。如果在这里没有指定 XPath 函数，numberValue 就等于 NaN。</p>
<p>对于字符串类型， evaluate()方法查找匹配 XPath 表达式的第一个节点，然后返回其第一个子节点的值，前提是第一个子节点是文本节点。如果不是，就返回空字符串。比如：</p>
<pre><code class="language-js">let result = xmldom.evaluate(
  'employee/name',
  xmldom.documentElement,
  null,
  XPathResult.STRING_TYPE,
  null
)
console.log(result.stringValue)
</code></pre>
<p>这个例子输出了与&quot;employee/name&quot;匹配的第一个元素中第一个文本节点包含的文本字符串。</p>
<h3 id="34-默认类型结果"><a class="header" href="#34-默认类型结果">3.4 默认类型结果</a></h3>
<p>所有 XPath 表达式都会自动映射到特定类型的结果。设置特定结果类型会限制表达式的输出。 不过，可以使用 XPathResult.ANY_TYPE 类型让求值自动返回默认类型结果。通常，默认类型结果是布尔值、数值、字符串或无序节点迭代器。要确定返回的结果类型，可以访问求值结果的 resultType 属性，如下例所示：</p>
<pre><code class="language-js">let result = xmldom.evaluate(
  'employee/name',
  xmldom.documentElement,
  null,
  XPathResult.ANY_TYPE,
  null
)
if (result !== null) {
  switch (result.resultType) {
    case XPathResult.STRING_TYPE:
      // 处理字符串类型
      break
    case XPathResult.NUMBER_TYPE:
      // 处理数值类型
      break
    case XPathResult.BOOLEAN_TYPE:
      // 处理布尔值类型
      break
    case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
      // 处理无序节点迭代器类型
      break
    default:
    // 处理其他可能的结果类型
  }
}
</code></pre>
<p>使用 XPathResult.ANY_TYPE 可以让使用 XPath 变得更自然，但在返回结果后则需要增加额外的判断和处理。</p>
<h3 id="35-命名空间支持"><a class="header" href="#35-命名空间支持">3.5 命名空间支持</a></h3>
<p>对于使用命名空间的 XML 文档，必须告诉 XPathEvaluator 命名空间信息，才能进行正确求值：</p>
<pre><code class="language-html">&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;wrox:books xmlns:wrox=&quot;http://www.wrox.com/&quot;&gt;
  &lt;wrox:book&gt;
    &lt;wrox:title&gt;Professional JavaScript for Web Developers&lt;/wrox:title&gt;
    &lt;wrox:author&gt;Nicholas C. Zakas&lt;/wrox:author&gt;
  &lt;/wrox:book&gt;
  &lt;wrox:book&gt;
    &lt;wrox:title&gt;Professional Ajax&lt;/wrox:title&gt;
    &lt;wrox:author&gt;Nicholas C. Zakas&lt;/wrox:author&gt;
    &lt;wrox:author&gt;Jeremy McPeak&lt;/wrox:author&gt;
    &lt;wrox:author&gt;Joe Fawcett&lt;/wrox:author&gt;
  &lt;/wrox:book&gt;
&lt;/wrox:books&gt;
</code></pre>
<p>在这个 XML 文档中，所有元素的命名空间都属于 http://www.wrox.com/，都以 wrox 前缀标识。如果想使用 XPath 查询该文档，就需要指定使用的命名空间，否则求值会失败。</p>
<p>第一种处理命名空间的方式是通过 createNSResolver()方法创建 XPathNSResolver 对象。这个方法只接收一个参数，即包含命名空间定义的文档节点。对上面的例子而言，这个节点就是 document 元素<code>&lt;wrox:books&gt;</code>，其 xmlns 属性定义了命名空间。为此，可以将该节点传给 createNSResolver()，然后得到的结果就可以在 evaluate()方法中使用：</p>
<pre><code class="language-js">let nsresolver = xmldom.createNSResolver(xmldom.documentElement)
let result = xmldom.evaluate(
  'wrox:book/wrox:author',
  xmldom.documentElement,
  nsresolver,
  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
  null
)
console.log(result.snapshotLength)
</code></pre>
<p>把 nsresolver 传给 evaluate()之后，可以确保 XPath 表达式中使用的 wrox 前缀能够被正确理解。假如不使用 XPathNSResolver，同样的表达式就会导致错误。</p>
<p>第二种处理命名空间的方式是定义一个接收命名空间前缀并返回相应 URI 的函数：</p>
<pre><code class="language-js">let nsresolver = function (prefix) {
  switch (prefix) {
    case 'wrox':
      return 'http://www.wrox.com/'
    // 其他前缀及返回值
  }
}
let result = xmldom.evaluate(
  'count(wrox:book/wrox:author)',
  xmldom.documentElement,
  nsresolver,
  XPathResult.NUMBER_TYPE,
  null
)
console.log(result.numberValue)
</code></pre>
<p>在并不知晓文档的哪个节点包含命名空间定义时，可以采用这种定义命名空间解析函数的方式。只要知道前缀和 URI，就可以定义这样一个函数，然后把它作为第三个参数传给 evaluate()。</p>
<h2 id="四-xslt"><a class="header" href="#四-xslt">四 XSLT</a></h2>
<h3 id="41-xslt-概念"><a class="header" href="#41-xslt-概念">4.1 XSLT 概念</a></h3>
<p>可扩展样式表语言转换（ XSLT， Extensible Stylesheet Language Transformations）是与 XML 相伴的一种技术，可以利用 XPath 将一种文档表示转换为另一种文档表示。与 XML 和 XPath 不同， XSLT 没有与之相关的正式 API，正式的 DOM 中也没有涵盖它。因此浏览器都以自己的方式实现 XSLT。</p>
<h3 id="42-xsltprocessor-类型"><a class="header" href="#42-xsltprocessor-类型">4.2 XSLTProcessor 类型</a></h3>
<p>通过使用 XSLTProcessor 类型，开发者可以使用 XSLT 转换 XML 文档，其方式类似于在 IE 中使用 XSL 处理器。自从 XSLTProcessor 首次实现以来，所有浏览器都照抄了其实现，从而使 XSLTProcessor 成了通过 JavaScript 完成 XSLT 转换的事实标准。</p>
<p>与 IE 的实现一样，第一步是加载两个 DOM 文档： XML 文档和 XSLT 文档。然后，使用 importStyleSheet()方法创建一个新的 XSLTProcessor，将 XSLT 指定给它，如下所示：</p>
<pre><code class="language-js">let processor = new XSLTProcessor()
processor.importStylesheet(xsltdom)
</code></pre>
<p>最后一步是执行转换，有两种方式。如果想返回完整的 DOM 文档，就调用 transformToDocument()；如果想得到文档片段，则可以调用 transformToFragment()。一般来说，使用 transformToFragment()的唯一原因是想把结果添加到另一个 DOM 文档。</p>
<p>如果使用 transformToDocument()，只要传给它 XML DOM，就可以将结果当作另一个完全不同的 DOM 来使用。比如：</p>
<pre><code class="language-js">let result = processor.transformToDocument(xmldom)
console.log(serializeXml(result))
</code></pre>
<p>transformToFragment()方法接收两个参数：要转换的 XML DOM 和最终会拥有结果片段的文档。这可以确保新文本片段可以在目标文档中使用。比如，可以把 document 作为第二个参数，然后将创建的片段添加到其页面元素中。比如：</p>
<pre><code class="language-js">let fragment = processor.transformToFragment(xmldom, document)
let div = document.getElementById('divResult')
div.appendChild(fragment)
</code></pre>
<p>这里，处理器创建了由 document 对象所有的片段。这样就可以将片段添加到当前页面的<code>&lt;div&gt;</code>元素中了。</p>
<p>如果 XSLT 样式表的输出格式是&quot;xml&quot;或&quot;html&quot;，则创建文档或文档片段理所当然。不过，如果输出格式是&quot;text&quot;，则通常意味着只想得到转换后的文本结果。然而，没有方法直接返回文本。在输出格式为&quot;text&quot;时调用 transformToDocument()会返回完整的 XML 文档，但这个文档的内容会因浏览器而异。比如， Safari 返回整个 HTML 文档，而 Opera 和 Firefox 则返回只包含一个元素的文档，其中输出就是该元素的文本。</p>
<p>解决方案是调用 transformToFragment()，返回只有一个子节点、其中包含结果文本的文档片段。之后，可以再使用以下代码取得文本：</p>
<pre><code class="language-js">let fragment = processor.transformToFragment(xmldom, document)
let text = fragment.firstChild.nodeValue
console.log(text)
</code></pre>
<h3 id="43-使用参数"><a class="header" href="#43-使用参数">4.3 使用参数</a></h3>
<p>XSLTProcessor 还允许使用 setParameter()方法设置 XSLT 参数。该方法接收三个参数：命名空间 URI、参数本地名称和要设置的值。通常，命名空间 URI 是 null，本地名称就是参数名称。setParameter()方法必须在调用 transformToDocument()或 transformToFragment()之前调用。例子如下：</p>
<pre><code class="language-js">let processor = new XSLTProcessor()
processor.importStylesheet(xsltdom)
processor.setParameter(null, 'message', 'Hello World!')
let result = processor.transformToDocument(xmldom)
</code></pre>
<p>与参数相关的还有两个方法： getParameter()和 removeParameter()。它们分别用于取得参数的当前值和移除参数的值。它们都以一个命名空间 URI（同样，一般是 null）和参数的本地名称为参数。比如：</p>
<pre><code class="language-js">let processor = new XSLTProcessor()
processor.importStylesheet(xsltdom)
processor.setParameter(null, 'message', 'Hello World!')
console.log(processor.getParameter(null, 'message')) // 输出&quot;Hello World!&quot;
processor.removeParameter(null, 'message')
let result = processor.transformToDocument(xmldom)
</code></pre>
<h3 id="44-重置处理器"><a class="header" href="#44-重置处理器">4.4 重置处理器</a></h3>
<p>每个 XSLTProcessor 实例都可以重用于多个转换，只是要使用不同的 XSLT 样式表。处理器的 reset()方法可以删除所有参数和样式表。然后，可以使用 importStylesheet()方法加载不同的 XSLT 样表，如下所示：</p>
<pre><code class="language-js">let processor = new XSLTProcessor()
processor.importStylesheet(xsltdom)
// 执行某些转换
processor.reset()
processor.importStylesheet(xsltdom2)
// 再执行一些转换
</code></pre>
<p>在使用多个样式表执行转换时，重用一个 XSLTProcessor 可以节省内存。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-ajax-的-xhr-api-xhr-对象"><a class="header" href="#051-ajax-的-xhr-api-xhr-对象">05.1-Ajax 的 XHR API-XHR 对象</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="052-ajax-的-xhr-api-xhr-level-2"><a class="header" href="#052-ajax-的-xhr-api-xhr-level-2">05.2-Ajax 的 XHR API-XHR Level 2</a></h1>
<h2 id="一-xmlhttprequest-level-2-概念"><a class="header" href="#一-xmlhttprequest-level-2-概念">一 XMLHttpRequest Level 2 概念</a></h2>
<p>XMLHttpRequest Level 1 只是把已经存在的 XHR 对象的实现细节明确了一下。XMLHttpRequest Level 2 又进一步发展了 XHR 对象。</p>
<h2 id="二-xmlhttprequest-level-2-新特性"><a class="header" href="#二-xmlhttprequest-level-2-新特性">二 XMLHttpRequest Level 2 新特性</a></h2>
<h3 id="21-formdata-类型"><a class="header" href="#21-formdata-类型">2.1 FormData 类型</a></h3>
<p>FormData 类型可以进行表单的序列化，并能快速填充数据</p>
<pre><code class="language-js">let data = new FormData()
data.append('is', '10001')
</code></pre>
<p>通过直接给 FormData 构造函数传入一个表单元素，也可以将表单中的数据作为键/值对填充进去：</p>
<pre><code class="language-js">let data = new FormData(document.forms[0])
</code></pre>
<p>有了 FormData 实例，可以像下面这样直接传给 XHR 对象的 send()方法：</p>
<pre><code class="language-js">let xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {
      console.log(xhr.responseText)
    } else {
      console.log('error: ' + xhr.status)
    }
  }
}
xhr.open('post', 'localhost:3000/postDemo', true)

let params = new FormData(document.getElementById('loginForm'))
xhr.send(new FormData(form))
</code></pre>
<p>使用 FormData 的另一个方便之处是不再需要给 XHR 对象显式设置任何请求头部了。XHR 对象能够识别作为 FormData 实例传入的数据类型并自动配置相应的头部。</p>
<h3 id="22-超时"><a class="header" href="#22-超时">2.2 超时</a></h3>
<p>IE8 中 XHR 的 timeout 事件用于表示发送请求后等待多少毫秒，如果响应不成功就中断请求。 timeout 事件现在也成为了 XMLHttpRequest Level 2 规范。在给 timeout 属性设置了一个时间且在该时间过后没有收到响应时， XHR 对象就会触发 timeout 事件，调用 ontimeout 事件处理程序。</p>
<pre><code class="language-js">let xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    try {
      if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {
        alert(xhr.responseText)
      } else {
        alert('Request was unsuccessful: ' + xhr.status)
      }
    } catch (ex) {
      // 假设由 ontimeout 处理
    }
  }
}
xhr.open('get', 'localhost:3000', true)
xhr.timeout = 1000 // 1000 毫秒超时
xhr.ontimeout = function () {
  alert('Request did not return in a second.')
}
xhr.send(null)
</code></pre>
<p>如果在超时之后访问 status 属性则会发生错误。为做好防护，可以把检查 status 属性的代码封装在 try/catch 语句中。</p>
<h3 id="23-overridemimetype-方法"><a class="header" href="#23-overridemimetype-方法">2.3 overrideMimeType() 方法</a></h3>
<p>假设服务器实际发送了 XML 数据，但响应头设置的 MIME 类型是 text/plain。结果就会导致虽然数据是 XML，但 responseXML 属性值是 null。此时调用 overrideMimeType() 可以保证将响应当成 XML 而不是纯文本来处理：</p>
<pre><code class="language-js">let xhr = new XMLHttpRequest()
xhr.open('get', 'localhost:3000', true)
xhr.overrideMimeType('text/xml') // 强行让 XHR 把响应当做 XML 处理
xhr.send(null)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-ajax-的-fetch-api-fetch-用法"><a class="header" href="#061-ajax-的-fetch-api-fetch-用法">06.1-Ajax 的 fetch API-fetch 用法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="062-ajax-的-fetch-api-三大对象"><a class="header" href="#062-ajax-的-fetch-api-三大对象">06.2-Ajax 的 fetch API-三大对象</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="063-ajax-的-fetch-api-fetch-的-body-混入"><a class="header" href="#063-ajax-的-fetch-api-fetch-的-body-混入">06.3-Ajax 的 fetch API-fetch 的 Body 混入</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="071-跨域问题-跨域资源共享"><a class="header" href="#071-跨域问题-跨域资源共享">07.1-跨域问题-跨域资源共享</a></h1>
<h2 id="一-同源策略"><a class="header" href="#一-同源策略">一 同源策略</a></h2>
<h3 id="11-错误示例"><a class="header" href="#11-错误示例">1.1 错误示例</a></h3>
<p>之前我们强调了网页必须放置在 <code>public</code> 文件夹下，该文件夹也是服务端代码的一部分，即所有的静态文件都运行在我们自己的服务端上，所以这里在通过 <code>http://localhost:3000</code>中使用 Ajax 并未产生问题，因为是服务自己在与自己通信（浏览器只是展示给用户看而已）。如果我们在本地直接创建一个 HTML 文档，直接使用浏览器打开，即打开方式为：<code>file:///Users/mac/index.html</code>类似的格式。这时候，这个文档即存放于本地电脑，去请求服务端，就会产生错误了！</p>
<p>这是因为浏览器具有同源策略，本地的 Ajax 与服务端不是同源。</p>
<h3 id="12-同源策略概念"><a class="header" href="#12-同源策略概念">1.2 同源策略概念</a></h3>
<blockquote>
<p>同源策略：Ajax 的请求方与服务端双方必须使用同样的协议、网址、端口、header 等。</p>
</blockquote>
<p>如下所示，非同源的网址：</p>
<pre><code class="language-txt">http://www.demo.com/page.html 与 ftp://www.demo.com/page.html

http://news.demo.com/page.html 与 http://www.demo.com/page.html
</code></pre>
<p>同源策略的产生是为了提升安全策略。</p>
<h3 id="13-跨域的产生"><a class="header" href="#13-跨域的产生">1.3 跨域的产生</a></h3>
<p>对于简单的请求，比如 GET 或 POST 请求，没有自定义头部，而且请求体是 text/plain 类型，这样的请求在发送时会有一个额外的头部叫 Origin。Origin 头部包含发送请求的页面的源（协议、域名和端口），以便服务器确定是否为其提供响应。下面是 Origin 头部的一个示例：</p>
<pre><code class="language-txt">Origin: http://www.demo.com
</code></pre>
<p>如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源；或者如果资源是公开的，那么就包含 <code>*</code>。比如：</p>
<pre><code class="language-txt">Access-Control-Allow-Origin: http://www.demo.com
</code></pre>
<p>如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个请求。违反了同源策略的 Ajax 请求会报错，这就是产生了跨域。当一个请求发生跨域时，浏览器会报错：</p>
<pre><code class="language-txt">No 'Access'-Control-Allow-Origin'
</code></pre>
<p>注意：<strong>跨域时，请求是已经发出去的，只不过浏览自己拒绝了接收响应数据</strong>。</p>
<p>常见解决方案：</p>
<ul>
<li>iframe：包含跨域的文件，但无法对其内部进行 dom 操作、处理数据</li>
<li>代理请求：比如让本地 php 请求跨域资源，然后 ajax 访问本地的 php；</li>
<li>Flash</li>
<li>-JSONP：json with padding</li>
<li>CROS</li>
</ul>
<h2 id="二-跨域资源共享"><a class="header" href="#二-跨域资源共享">二 跨域资源共享</a></h2>
<h3 id="31-cors-机制"><a class="header" href="#31-cors-机制">3.1 CORS 机制</a></h3>
<p>跨源资源共享（CORS，Cross-Origin Resource Sharing）定义了浏览器与服务器如何实现跨源通信。CORS 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。</p>
<p>对于简单的请求，比如 GET 或 POST 请求，没有自定义头部，而且请求体是 text/plain 类型，这样的请求在发送时会有一个额外的头部叫 Origin。Origin 头部包含发送请求的页面的源（协议、域名和端口），以便服务器确定是否为其提供响应。下面是 Origin 头部的一个示例：</p>
<pre><code class="language-txt">Origin: http://www.nczonline.net
</code></pre>
<p>如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源；或者如果资源是公开的，那么就包含<code>&quot;\*&quot;</code>。比如：
Access-Control-Allow-Origin: http://www.nczonline.net如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个请求。注意，无论请求还是响应都不会包含 cookie 信息。</p>
<p>现代浏览器通过 XMLHttpRequest 对象原生支持 CORS。在尝试访问不同源的资源时，这个行为会被自动触发。要向不同域的源发送请求，可以使用标准 XHR 对象并给 open()方法传入一个绝对 URL，比如：</p>
<pre><code class="language-js">let xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) {
      alert(xhr.responseText)
    } else {
      alert('Request was unsuccessful: ' + xhr.status)
    }
  }
}
xhr.open('get', 'http://www.somewhere-else.com/page/', true)
xhr.send(null)
</code></pre>
<p>跨域 XHR 对象允许访问 status 和 statusText 属性，也允许同步请求。出于安全考虑，跨域 XHR 对象也施加了一些额外限制：</p>
<ul>
<li>不能使用 setRequestHeader()设置自定义头部。</li>
<li>不能发送和接收 cookie。</li>
<li>getAllResponseHeaders()方法始终返回空字符串。</li>
</ul>
<p>因为无论同域还是跨域请求都使用同一个接口，所以最好在访问本地资源时使用相对 URL，在访问远程资源时使用绝对 URL。这样可以更明确地区分使用场景，同时避免出现访问本地资源时出现头部或 cookie 信息访问受限的问题。</p>
<h3 id="32-预检请求"><a class="header" href="#32-预检请求">3.2 预检请求</a></h3>
<p>CORS 通过一种叫预检请求（ preflighted request）的服务器验证机制，允许使用自定义头部、除 GET 和 POST 之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个“预检”请求。这个请求使用 OPTIONS 方法发送并包含以下头部。</p>
<ul>
<li>Origin：与简单请求相同。</li>
<li>Access-Control-Request-Method：请求希望使用的方法。</li>
<li>Access-Control-Request-Headers：（可选）要使用的逗号分隔的自定义头部列表。</li>
</ul>
<p>下面是一个假设的 POST 请求，包含自定义的 NCZ 头部：</p>
<pre><code class="language-txt">Origin: http://www.nczonline.net
Access-Control-Request-Method: POST
Access-Control-Request-Headers: NCZ
</code></pre>
<p>服务端的响应：</p>
<pre><code class="language-txt">Access-Control-Allow-Origin：与简单请求相同。
Access-Control-Allow-Methods：允许的方法（逗号分隔的列表）。
Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）。
Access-Control-Max-Age：缓存预检请求的秒数。
</code></pre>
<p>在这个请求发送后，服务器可以确定是否允许这种类型的请求。服务器会通过在响应中发送如下头部与浏览器沟通这些信息。</p>
<ul>
<li>Access-Control-Allow-Origin：与简单请求相同。</li>
<li>Access-Control-Allow-Methods：允许的方法（逗号分隔的列表）。</li>
<li>Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）。</li>
<li>Access-Control-Max-Age：缓存预检请求的秒数。</li>
</ul>
<p>例如：</p>
<pre><code class="language-txt">Access-Control-Allow-Origin: http://www.nczonline.net
Access-Control-Allow-Methods: POST, GET
Access-Control-Allow-Headers: NCZ
Access-Control-Max-Age: 1728000
</code></pre>
<p>预检请求返回后，结果会按响应指定的时间缓存一段时间。换句话说，只有第一次发送这种类型的请求时才会多发送一次额外的 HTTP 请求。</p>
<h3 id="33-凭据请求"><a class="header" href="#33-凭据请求">3.3 凭据请求</a></h3>
<p>默认情况下，跨源请求不提供凭据（ cookie、 HTTP 认证和客户端 SSL 证书）。可以通过将 withCredentials 属性设置为 true 来表明请求会发送凭据。如果服务器允许带凭据的请求，那么可以在响应中包含如下 HTTP 头部：</p>
<pre><code class="language-js">// Access-Control-Allow-Credentials: true

// 客户端
xhr.open('...')
xhr.withCredentials = true

// 服务端
app.use((req, res, next) =&gt; {
  res.header('Access-Control-Allo-Origin', 'http://localhost:3000')
  res.header('Access-Control-Allo-Methods', 'get,post')
  res.header('Access-Control-Allo-Credentials', true) // 允许服务端携带跨域 cookie
  next()
})
</code></pre>
<p>如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给 JavaScript（ responseText 是空字符串， status 是 0， onerror()被调用）。注意，服务器也可以在预检请求的响应中发送这个 HTTP 头部，以表明这个源允许发送凭据请求。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="072-跨域问题-替代性跨源技术"><a class="header" href="#072-跨域问题-替代性跨源技术">07.2-跨域问题-替代性跨源技术</a></h1>
<h2 id="一-常见替代性跨源技术"><a class="header" href="#一-常见替代性跨源技术">一 常见替代性跨源技术</a></h2>
<p>CORS 出现之前，实现跨源 Ajax 通信是有点麻烦的。开发者需要依赖能够执行跨源请求的 DOM 特性，在不使用 XHR 对象情况下发送某种类型的请求。虽然 CORS 目前已经得到广泛支持，但这些技术仍然没有过时，因为它们不需要修改服务器。</p>
<p>以前使用的替代性跨源技术有：</p>
<ul>
<li>图片探测</li>
<li>JSONP</li>
</ul>
<h2 id="二-替代性跨源技术图片探测"><a class="header" href="#二-替代性跨源技术图片探测">二 替代性跨源技术：图片探测</a></h2>
<p>图片探测是利用<code>&lt;img&gt;</code>标签实现跨域通信的最早的一种技术。任何页面都可以跨域加载图片而不必担心限制，因此这也是在线广告跟踪的主要方式。可以动态创建图片，然后通过它们的 onload 和 onerror 事件处理程序得知何时收到响应。</p>
<p>这种动态创建图片的技术经常用于图片探测（ image pings）。图片探测是与服务器之间简单、跨域、单向的通信。数据通过查询字符串发送，响应可以随意设置，不过一般是位图图片或值为 204 的状态码。</p>
<p>浏览器通过图片探测拿不到任何数据，但可以通过监听 onload 和 onerror 事件知道什么时候能接收到响应。下面看一个例子：</p>
<pre><code class="language-js">let img = new Image()
img.onload = img.onerror = function () {
  alert('Done!')
}
img.src = 'http://www.example.com/test?name=Nicholas'
</code></pre>
<p>图片探测频繁用于跟踪用户在页面上的点击操作或动态显示广告。当然，图片探测的缺点是只能发送 GET 请求和无法获取服务器响应的内容。这也是只能利用图片探测实现浏览器与服务器单向通信的原因。</p>
<h2 id="三-替代性跨源技术jsonp"><a class="header" href="#三-替代性跨源技术jsonp">三 替代性跨源技术：JSONP</a></h2>
<h3 id="31-jsonp-概念"><a class="header" href="#31-jsonp-概念">3.1 JSONP 概念</a></h3>
<p>script 标签可以获取不同域下的文件，比如使用 script 标签引入 cdn 上的 jquery 文件就是利用了 script 标签的跨域功能：</p>
<p><code>&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;</code>。</p>
<p>JSONP 是“JSON with padding”的简写，是在 Web 服务上流行的一种 JSON 变体。 JSONP 看起来跟 JSON 一样，只是会被包在一个函数调用里，比如：</p>
<pre><code class="language-js">callback({ name: 'Nicholas' })
</code></pre>
<p>JSONP 调用是通过动态创建<code>&lt;script&gt;</code>元素并为 src 属性指定跨域 URL 实现的，并不是真正的跨域资源共享，该方案也逐渐被 CORS 淘汰。</p>
<p>JSONP 由于其简单易用，在开发者中非常流行。相比于图片探测，使用 JSONP 可以直接访问响应，实现浏览器与服务器的双向通信。不过 JSONP 也有一些缺点。</p>
<p>首先， JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。此时除了完全删除 JSONP 没有其他办法。在使用不受控的 Web 服务时，一定要保证是可以信任的。</p>
<p>第二个缺点是不好确定 JSONP 请求是否失败。虽然 HTML5 规定了<code>&lt;script&gt;</code>元素的 onerror 事件处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应。这种方式并不准确，毕竟不同用户的网络连接速度和带宽是不一样的</p>
<h3 id="22-jsonp-获取数据的使用问题"><a class="header" href="#22-jsonp-获取数据的使用问题">2.2 JSONP 获取数据的使用问题</a></h3>
<p>如果直接使用 script 标签会遇到问题：拿到的数据无法使用。假设返回的数据是：</p>
<pre><code class="language-js">&quot;{&quot;uid&quot;:&quot;1001&quot;}&quot;
</code></pre>
<p>通过 script 标签引入了该数据，但是这个数据没有变量接收，在脚本中也就无法使用了！为了解决该问题，必须让服务端进行配合，如果服务端返回的数据是：``</p>
<pre><code class="language-txt">&quot;let user = {'uid':'1001'}&quot;
</code></pre>
<p>这样的结果在脚本中就可以直接使用了！</p>
<pre><code class="language-html">&lt;script src=&quot;http://localhost:3000/crosDemo&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  console.log('跨域示例：', user)
&lt;/script&gt;
</code></pre>
<p>但是这时候我们需要防止 script 标签的异步加载问题，而且要注意顺序问题。而且每次页面都自动加载了这个跨域请求是不可控的，显然不符合真实开发要求。</p>
<p>我们一般动态的创建 script 标签然后来获取数据，但是新的问题产生了：请求是异步的，无法在创建标签后直接就能获得数据，所以必须让服务端返回一个回调函数：</p>
<pre><code class="language-js">// 服务端代码
let data = JSON.stringify({ uid: '1001' })
res.send(`cb(${data});`)

// 客户端代码：定义返回数据后的回调函数，名称必须写上一致，这里是 cb
function cb(data) {
  console.log('jsonp 数据：', data)
}

let btn = document.querySelector('#btn')
btn.onclick = function () {
  // 创建 script 跨域请求的标签
  let script = document.createElement('script')
  script.src = 'http://localhost:3000/crosDemo2'
  document.querySelector('head').appendChild(script)

  // 跨域得到的结果是：cb(&quot;数据&quot;)，自动定义好的 cb 函数
}
</code></pre>
<p>为了方便双方互相通信，回调函数名可以通过请求参数进行传递：</p>
<pre><code class="language-js">// 服务端代码
app.get('/crosDemo2', (req, res) =&gt; {
  // 获取回调函数名称
  let callback = req.query.callback

  // 定义要返回的数据
  let data = JSON.stringify({ uid: '1001' })

  // 返回数据
  res.send(`${callback}(${data});`)
})

// 客户端代码
// 定义返回数据后的回调函数，名称必须写上一致，这里是 cb
function cb(data) {
  console.log('jsonp 数据：', data)
}

let btn = document.querySelector('#btn')
btn.onclick = function () {
  // 创建 script 跨域请求的标签
  let script = document.createElement('script')
  script.src = 'http://localhost:3000/crosDemo2?callback=cb'
  document.querySelector('head').appendChild(script)

  // 跨域得到的结果是：cb(&quot;数据&quot;)，自动定义好的 cb 函数
}
</code></pre>
<p>贴士：服务端框架 Express 是直接自持 json 请求的：</p>
<pre><code class="language-js">app.get('/crosDemo2', (req, res) =&gt; {
  res.jsonp({ uid: 1 })
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="081-websocket"><a class="header" href="#081-websocket">08.1-WebSocket</a></h1>
<h2 id="一-websocket-概念"><a class="header" href="#一-websocket-概念">一 WebSocket 概念</a></h2>
<p>Web Socket（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。在 JavaScript 中创建 Web Socket 时，一个 HTTP 请求会发送到服务器以初始化连接。服务器响应后，连接使用 HTTP 的 Upgrade 头部从 HTTP 协议切换到 Web Socket 协议。这意味着 Web Socket 不能通过标准 HTTP 服务器实现，而必须使用支持该协议的专有服务器。</p>
<p>因为 Web Socket 使用了自定义协议，所以 URL 方案（scheme）稍有变化：不能再使用 http://或 https://，而要使用 ws://和 wss://。前者是不安全的连接，后者是安全连接。在指定 Web Socket URL 时，必须包含 URL 方案，因为将来有可能再支持其他方案。</p>
<p>使用自定义协议而非 HTTP 协议的好处是，客户端与服务器之间可以发送非常少的数据，不会对 HTTP 造成任何负担。使用更小的数据包让 Web Socket 非常适合带宽和延迟问题比较明显的移动应用。使用自定义协议的缺点是，定义协议的时间比定义 JavaScript API 要长。Web Socket 得到了所有主流浏览器支持。</p>
<h2 id="二-基本使用"><a class="header" href="#二-基本使用">二 基本使用</a></h2>
<h3 id="21-api"><a class="header" href="#21-api">2.1 API</a></h3>
<p>要创建一个新的 Web Socket，就要实例化一个 WebSocket 对象并传入提供连接的 URL：</p>
<pre><code class="language-js">let socket = new WebSocket('ws://www.example.com/demo')
</code></pre>
<p>注意，必须给 WebSocket 构造函数传入一个绝对 URL。同源策略不适用于 Web Socket，因此可以打开到任意站点的连接。至于是否与来自特定源的页面通信，则完全取决于服务器。（在握手阶段就可以确定请求来自哪里。）</p>
<p>浏览器会在初始化 WebSocket 对象之后立即创建连接。与 XHR 类似，WebSocket 也有一个 readyState 属性表示当前状态。不过，这个值与 XHR 中相应的值不一样：</p>
<pre><code class="language-txt">WebSocket.OPENING（0）：连接正在建立。
WebSocket.OPEN（1）：连接已经建立。
WebSocket.CLOSING（2）：连接正在关闭。
WebSocket.CLOSE（3）：连接已经关闭。
</code></pre>
<p>WebSocket 对象没有 readystatechange 事件，而是有与上述不同状态对应的其他事件。readyState 值从 0 开始。
任何时候都可以调用 close() 方法关闭 Web Socket 连接：</p>
<pre><code class="language-js">socket.close()
</code></pre>
<p>调用 close() 之后，readyState 立即变为 2（连接正在关闭），</p>
<h3 id="22-发送和接收数据"><a class="header" href="#22-发送和接收数据">2.2 发送和接收数据</a></h3>
<p>打开 Web Socket 之后，可以通过连接发送和接收数据。要向服务器发送数据，使用 send() 方法并传入一个字符串、ArrayBuffer 或 Blob，如下所示：</p>
<pre><code class="language-js">let socket = new WebSocket('ws://www.example.com/server.php')
let stringData = 'Hello world!'
let arrayBufferData = Uint8Array.from(['f', 'o', 'o'])
let blobData = new Blob(['f', 'o', 'o'])
socket.send(stringData)
socket.send(arrayBufferData.buffer)
socket.send(blobData)
</code></pre>
<p>服务器向客户端发送消息时，WebSocket 对象上会触发 message 事件。这个 message 事件与其他消息协议类似，可以通过 event.data 属性访问到有效载荷：</p>
<pre><code class="language-js">socket.onmessage = function (event) {
  let data = event.data
  // 对数据执行某些操作
}
</code></pre>
<p>与通过 send() 方法发送的数据类似，event.data 返回的数据也可能是 ArrayBuffer 或 Blob。这由 WebSocket 对象的 binaryType 属性决定，该属性可能是&quot;blob&quot;或&quot;arraybuffer&quot;。</p>
<h3 id="23-其他事件"><a class="header" href="#23-其他事件">2.3 其他事件</a></h3>
<p>WebSocket 对象在连接生命周期中有可能触发 3 个其他事件：</p>
<pre><code class="language-txt">open：在连接成功建立时触发。
error：在发生错误时触发。连接无法存续。
close：在连接关闭时触发。
</code></pre>
<p>WebSocket 对象不支持 DOM Level 2 事件监听器，因此需要使用 DOM Level 0 风格的事件处理程序来监听这些事件：</p>
<pre><code class="language-js">let socket = new WebSocket('ws://www.example.com/server.php')
socket.onopen = function () {
  alert('Connection established.')
}
socket.onerror = function () {
  alert('Connection error.')
}
socket.onclose = function () {
  alert('Connection closed.')
}
</code></pre>
<p>在这些事件中，只有 close 事件的 event 对象上有额外信息。这个对象上有 3 个额外属性：wasClean、code 和 reason。其中，wasClean 是一个布尔值，表示连接是否干净地关闭；code 是一个来自服务器的数值状态码；reason 是一个字符串，包含服务器发来的消息。可以将这些信息显示给用户或记录到日志：</p>
<pre><code class="language-js">socket.onclose = function (event) {
  console.log(
    `as clean? ${event.wasClean} Code=${event.code} Reason=${event.reason}`
  )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="091-客户端存储-cookie"><a class="header" href="#091-客户端存储-cookie">09.1-客户端存储-cookie</a></h1>
<h2 id="关于客户端存储"><a class="header" href="#关于客户端存储">关于客户端存储</a></h2>
<p>客户端存储在本文档指浏览器端用于在本地存储数据、读取数据的机制。目前常见的客户端存储技术有：Cookie、SessionStorage、LocalStorage、indexDB 等。</p>
<h2 id="一-cookie"><a class="header" href="#一-cookie">一 cookie</a></h2>
<h3 id="11-cookie-概念"><a class="header" href="#11-cookie-概念">1.1 cookie 概念</a></h3>
<p>cookie 最初用于在客户端存储会话信息，服务器在响应 HTTP 请求时，通过发送 Set-Cookie HTTP 头部包含会话信息，这个 HTTP 响应会设置一个名为&quot;name&quot;，值为&quot;value&quot;的 cookie。名和值在发送时都会经过 URL 编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 HTTP 头部 cookie 再将它们发回服
务器，比如：</p>
<pre><code class="language-txt">GET /index.jsl HTTP/1.1
Cookie: name=value
Other-header: other-header-value
</code></pre>
<h3 id="12-cookie-的限制"><a class="header" href="#12-cookie-的限制">1.2 cookie 的限制</a></h3>
<p>cookie 是与特定域绑定的。设置 cookie 后，它会与请求一起发送到创建它的域。这个限制能保证 cookie 中存储的信息只对被认可的接收者开放，不被其他域访问。</p>
<p>因为 cookie 存储在客户端机器上，所以为保证它不会被恶意利用，浏览器会施加限制。同时，cookie 也不会占用太多磁盘空间。</p>
<p>常见限制：</p>
<ul>
<li>不超过 300 个 cookie；</li>
<li>每个 cookie 不超过 4096 字节；</li>
<li>每个域不超过 20 个 cookie；</li>
<li>每个域不超过 81 920 字节。</li>
</ul>
<h3 id="13-cookie-的构成"><a class="header" href="#13-cookie-的构成">1.3 cookie 的构成</a></h3>
<p>cookie 在浏览器中是由以下参数构成的：</p>
<pre><code class="language-txt">名称：唯一标识 cookie 的名称。
    cookie 名不区分大小写，因此 myCookie 和 MyCookie 是同一个名称。
    不过，实践中最好将 cookie 名当成区分大小写来对待，因为一些服务器软件可能这样对待它们。
    cookie 名必须经过 URL 编码。

值：存储在 cookie 里的字符串值。这个值必须经过 URL 编码。

域：cookie 有效的域。发送到这个域的所有请求都会包含对应的 cookie。
    这个值可能包含子域（如 www.wrox.com），也可以不包含（如.wrox.com 表示对 wrox.com 的所有子域都有效）。
    如果不明确设置，则默认为设置 cookie 的域。

路径：请求 URL 中包含这个路径才会把 cookie 发送到服务器。
    例如，可以指定 cookie 只能由 http://www.wrox.com/books/访问，
    因此访问 http://www.wrox.com/下的页面就不会发送 cookie，即使请求的是同一个域。

过期时间：表示何时删除 cookie 的时间戳（即什么时间之后就不发送到服务器了）。
    默认情况下，浏览器会话结束后会删除所有 cookie。不过，也可以设置删除 cookie 的时间。
    这个值是 GMT 格式（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定删除 cookie 的具体时间。
    这样即使关闭浏览器 cookie 也会保留在用户机器上。把过期时间设置为过去的时间会立即删除 cookie。

安全标志：设置之后，只在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器。
    例如，请求 https://www.wrox.com 会发送 cookie，而请求 http://www.wrox.com 则不会。
</code></pre>
<p>这些参数在 Set-Cookie 头部中使用分号加空格隔开：</p>
<pre><code class="language-txt">HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com
Other-header: other-header-value
</code></pre>
<h2 id="二-cookie-在前端的应用"><a class="header" href="#二-cookie-在前端的应用">二 cookie 在前端的应用</a></h2>
<h3 id="21-documentcookie"><a class="header" href="#21-documentcookie">2.1 document.cookie</a></h3>
<p>document.cookie 返回包含页面中所有有效 cookie 的字符串（根据域、路径、过期时间和安全设置），以分号分隔：</p>
<pre><code class="language-txt"># 所有名和值都是 URL 编码的，因此必须使用 decodeURIComponent() 解码
name1=value1;name2=value2;name3=value3
</code></pre>
<p>在设置值时，可以通过 document.cookie 属性设置新的 cookie 字符串。这个字符串在被解析后会添加到原有 cookie 中。设置 document.cookie 不会覆盖之前存在的任何 cookie，除非设置了已有的 cookie。设置 cookie 的格式如下，与 Set-Cookie 头部的格式一样：</p>
<pre><code class="language-txt">name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure
</code></pre>
<p>在所有这些参数中，只有 cookie 的名称和值是必需的。下面是个简单的例子：</p>
<pre><code class="language-js">document.cookie = 'name=Lisi'
</code></pre>
<p>这个 cookie 在每次客户端向服务器发送请求时都会被带上，在浏览器关闭时就会被删除。虽然这样直接设置也可以，因为不需要在名称或值中编码任何字符，但最好还是使用 encodeURIComponent() 对名称和值进行编码，比如：</p>
<pre><code class="language-js">document.cookie = encodeURIComponent('name') + '=' + encodeURIComponent('Lisi')
</code></pre>
<p>要为创建的 cookie 指定额外的信息，只要像 Set-Cookie 头部一样直接在后面追加相同格式的字符串即可：</p>
<pre><code class="language-js">document.cookie =
  encodeURIComponent('name') +
  '=' +
  encodeURIComponent('Lisi') +
  '; domain=.wrox.com; path=/'
</code></pre>
<h3 id="22-cookieutil"><a class="header" href="#22-cookieutil">2.2 CookieUtil</a></h3>
<p>因为在 JavaScript 中读写 cookie 不是很直观，所以可以通过辅助函数来简化相应的操作。与 cookie 相关的基本操作有读、写和删除。这些在 CookieUtil 对象中表示如下：</p>
<pre><code class="language-js">class CookieUtil {
  static get(name) {
    let cookieName = `${encodeURIComponent(name)}=`,
      cookieStart = document.cookie.indexOf(cookieName),
      cookieValue = null
    if (cookieStart &gt; -1) {
      let cookieEnd = document.cookie.indexOf(';', cookieStart)
      if (cookieEnd == -1) {
        cookieEnd = document.cookie.length
      }
      cookieValue = decodeURIComponent(
        document.cookie.substring(cookieStart + cookieName.length, cookieEnd)
      )
    }
    return cookieValue
  }
  static set(name, value, expires, path, domain, secure) {
    let cookieText = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`
    if (expires instanceof Date) {
      cookieText += `; expires=${expires.toGMTString()}`
    }
    if (path) {
      cookieText += `; path=${path}`
    }
    if (domain) {
      cookieText += `; domain=${domain}`
    }
    if (secure) {
      cookieText += '; secure'
    }
    document.cookie = cookieText
  }
  static unset(name, path, domain, secure) {
    CookieUtil.set(name, '', new Date(0), path, domain, secure)
  }
}
</code></pre>
<h3 id="23-删除-cookie"><a class="header" href="#23-删除-cookie">2.3 删除 cookie</a></h3>
<p>没有直接删除已有 cookie 的方法。为此，需要再次设置同名 cookie（包括相同路径、域和安全选项），但要将其过期时间设置为某个过去的时间。CookieUtil.unset() 方法实现了这些处理。这个方法接收 4 个参数：要删除 cookie 的名称、可选的路径、可选的域和可选的安全标志。</p>
<p>这些参数会传给 CookieUtil.set()，将 cookie 值设置为空字符串，将过期时间设置为 1970 年 1 月 1 日（以 0 毫秒初始化的 Date 对象的值）。这样可以保证删除 cookie。</p>
<pre><code class="language-js">// 设置 cookie
CookieUtil.set('name', 'Nicholas')
CookieUtil.set('book', 'Professional JavaScript')
// 读取 cookie
alert(CookieUtil.get('name')) // &quot;Nicholas&quot;
alert(CookieUtil.get('book')) // &quot;Professional JavaScript&quot;
// 删除 cookie
CookieUtil.unset('name')
CookieUtil.unset('book')
// 设置有路径、域和过期时间的 cookie
CookieUtil.set(
  'name',
  'Nicholas',
  '/books/projs/',
  'www.wrox.com',
  new Date('January 1, 2010')
)
// 删除刚刚设置的 cookie
CookieUtil.unset('name', '/books/projs/', 'www.wrox.com')
// 设置安全 cookie
CookieUtil.set('name', 'Nicholas', null, null, null, true)
</code></pre>
<h2 id="三-子-cookie"><a class="header" href="#三-子-cookie">三 子 cookie</a></h2>
<h3 id="31-子-cookie-概念"><a class="header" href="#31-子-cookie-概念">3.1 子 cookie 概念</a></h3>
<p>为绕过浏览器对每个域 cookie 数的限制，有些开发者提出了子 cookie 的概念。子 cookie 是在单个 cookie 存储的小块数据，本质上是使用 cookie 的值在单个 cookie 中存储多个名/值对。最常用的子 cookie 模式如下：</p>
<pre><code class="language-txt">name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5
</code></pre>
<p>子 cookie 的格式类似于查询字符串。这些值可以存储为单个 cookie，而不用单独存储为自己的名/值对。结果就是网站或 Web 应用程序能够在单域 cookie 数限制下存储更多的结构化数据。</p>
<h3 id="32-subcookieutil"><a class="header" href="#32-subcookieutil">3.2 SubCookieUtil</a></h3>
<p>要操作子 cookie，就需要再添加一些辅助方法。解析和序列化子 cookie 的方式不一样，且因为对子 cookie 的使用而变得更复杂。比如，要取得某个子 cookie，就需要先取得 cookie，然后在解码值之前需要先像下面这样找到子 cookie：</p>
<pre><code class="language-js">class SubCookieUtil {
  static get(name, subName) {
    let subCookies = SubCookieUtil.getAll(name)
    return subCookies ? subCookies[subName] : null
  }
  static getAll(name) {
    let cookieName = encodeURIComponent(name) + '=',
      cookieStart = document.cookie.indexOf(cookieName),
      cookieValue = null,
      cookieEnd,
      subCookies,
      parts,
      result = {}
    if (cookieStart &gt; -1) {
      cookieEnd = document.cookie.indexOf(';', cookieStart)
      if (cookieEnd == -1) {
        cookieEnd = document.cookie.length
      }
      cookieValue = document.cookie.substring(
        cookieStart + cookieName.length,
        cookieEnd
      )
      if (cookieValue.length &gt; 0) {
        subCookies = cookieValue.split('&amp;')
        for (let i = 0, len = subCookies.length; i &lt; len; i++) {
          parts = subCookies[i].split('=')
          result[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1])
        }
        return result
      }
    }
    return null
  }
  // 省略其他代码
}
</code></pre>
<p>取得子 cookie 有两个方法：get() 和 getAll()。get() 用于取得一个子 cookie 的值，getAll() 用于取得所有子 cookie，并以对象形式返回，对象的属性是子 cookie 的名称，值是子 cookie 的值。get() 方法接收两个参数：cookie 的名称和子 cookie 的名称。这个方法先调用 getAll() 取得所有子 cookie，然后返回要取得的子 cookie（如果不存在则返回 null）。</p>
<p>SubCookieUtil.getAll() 方法在解析 cookie 值方面与 CookieUtil.get() 方法非常相似。不同的是 SubCookieUtil.getAll() 方法不会立即解码 cookie 的值，而是先用和号（ &amp;）拆分，将所有子 cookie 保存到数组。然后，再基于等号（ =）拆分每个子 cookie，使 parts 数组的第一个元素是子 cookie 的名称，第二个元素是子 cookie 的值。两个元素都使用 decodeURIComponent() 解码，并添加到 result 对象，最后返回 result 对象。如果 cookie 不存在则返回 null。</p>
<pre><code class="language-js">// 假设 document.cookie=data=name=Lisi&amp;des=hello%20word
// 取得所有子 cookie
let data = SubCookieUtil.getAll('data')
alert(data.name) // &quot;Lisi&quot;
alert(data.des) // hello world
// 取得个别子 cookie
alert(SubCookieUtil.get('data', 'name')) // &quot;Nicholas&quot;
alert(SubCookieUtil.get('data', 'book')) // &quot;Professional JavaScript&quot;
</code></pre>
<p>要写入子 cookie，可以使用另外两个方法：set() 和 setAll()。这两个方法的实现如下：</p>
<pre><code class="language-js">class SubCookieUtil {
  // 省略之前的代码
  static set(name, subName, value, expires, path, domain, secure) {
    let subcookies = SubCookieUtil.getAll(name) || {}
    subcookies[subName] = value
    SubCookieUtil.setAll(name, subcookies, expires, path, domain, secure)
  }
  static setAll(name, subcookies, expires, path, domain, secure) {
    let cookieText = encodeURIComponent(name) + '=',
      subcookieParts = new Array(),
      subName
    for (subName in subcookies) {
      if (subName.length &gt; 0 &amp;&amp; subcookies.hasOwnProperty(subName)) {
        subcookieParts.push(
          '${encodeURIComponent(subName)}=${encodeURIComponent(subcookies[subName])}'
        )
      }
    }
    if (cookieParts.length &gt; 0) {
      cookieText += subcookieParts.join('&amp;')
      if (expires instanceof Date) {
        cookieText += `; expires=${expires.toGMTString()}`
      }
      if (path) {
        cookieText += `; path=${path}`
      }
      if (domain) {
        cookieText += `; domain=${domain}`
      }
      if (secure) {
        cookieText += '; secure'
      }
    } else {
      cookieText += `; expires=${new Date(0).toGMTString()}`
    }
    document.cookie = cookieText
  }
  // 省略其他代码
}
</code></pre>
<p>使用示例：</p>
<pre><code class="language-js">// 假设 document.cookie=data=name=Nicholas&amp;book=Professional%20JavaScript
// 设置两个子 cookie
SubCookieUtil.set('data', 'name', 'Nicholas')
SubCookieUtil.set('data', 'book', 'Professional JavaScript')
// 设置所有子 cookie 并传入过期时间
SubCookieUtil.setAll(
  'data',
  { name: 'Nicholas', book: 'Professional JavaScript' },
  new Date('January 1, 2010')
)
// 修改&quot;name&quot;的值并修改整个 cookie 的过期时间
SubCookieUtil.set('data', 'name', 'Michael', new Date('February 1, 2010'))
</code></pre>
<h3 id="33-删除子-coookie"><a class="header" href="#33-删除子-coookie">3.3 删除子 coookie</a></h3>
<p>常规 cookie 可以通过直接设置过期时间为某个过去的时间删除，但删除子 cookie 没有这么简单。为了删除子 cookie，需要先取得所有子 cookie，把要删除的那个删掉，然后再把剩下的子 cookie 设置回去。下面是相关方法的实现：</p>
<pre><code class="language-js">class SubCookieUtil {
  // 省略之前的代码
  static unset(name, subName, path, domain, secure) {
    let subcookies = SubCookieUtil.getAll(name)
    if (subcookies) {
      delete subcookies[subName] // 删除
      SubCookieUtil.setAll(name, subcookies, null, path, domain, secure)
    }
  }
  static unsetAll(name, path, domain, secure) {
    SubCookieUtil.setAll(name, null, new Date(0), path, domain, secure)
  }
}
</code></pre>
<h2 id="四-http-only"><a class="header" href="#四-http-only">四 http-only</a></h2>
<p>还有一种叫作 HTTP-only 的 cookie。HTTP-only 可以在浏览器设置，也可以在服务器设置，但只能在服务器上读取，这是因为 JavaScript 无法取得这种 cookie 的值。因为所有 cookie 都会作为请求头部由浏览器发送给服务器，所以在 cookie 中保存大量信息可能会影响特定域浏览器请求的性能。保存的 cookie 越大，请求完成的时间就越长。即使浏览器对 cookie 大小有限制，最好还是尽可能只通过 cookie 保存必要信息，以避免性能问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="092-客户端存储-webstorage"><a class="header" href="#092-客户端存储-webstorage">09.2-客户端存储-WebStorage</a></h1>
<h2 id="一-web-storage-概念"><a class="header" href="#一-web-storage-概念">一 Web Storage 概念</a></h2>
<p>Web Storage 目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用 cookie 的问题。</p>
<p>Web Storage 的第 2 版定义了两个对象：</p>
<ul>
<li>localStorage：永久存储机制</li>
<li>sessionStorage：跨会话的存储机制</li>
</ul>
<p>这两种浏览器存储 API 提供了在浏览器中不受页面刷新影响而存储数据的两种方式。2009 年之后，该 API 被大多浏览器接受。</p>
<h2 id="二-api"><a class="header" href="#二-api">二 API</a></h2>
<h3 id="20-storage-类型"><a class="header" href="#20-storage-类型">2.0 Storage 类型</a></h3>
<p>Storage 类型用于保存名/值对数据，直至存储空间上限（由浏览器决定）。Storage 的实例与其他对象一样，但增加了以下方法：</p>
<pre><code class="language-txt">clear()：删除所有值；不在 Firefox 中实现。
getItem(name)：取得给定 name 的值。
key(index)：取得给定数值位置的名称。
removeItem(name)：删除给定 name 的名/值对。
setItem(name, value)：设置给定 name 的值
</code></pre>
<p>getItem()、removeItem() 和 setItem() 方法可以直接或间接通过 Storage 对象调用。因为每个数据项都作为属性存储在该对象上，所以可以使用点或方括号操作符访问这些属性，通过同样的操作来设置值，也可以使用 delete 操作符删除属性。即便如此，通常还是建议使用方法而非属性来执行这些操作，以免意外重写某个已存在的对象成员。</p>
<p>通过 length 属性可以确定 Storage 对象中保存了多少名/值对。我们无法确定对象中所有数据占用的空间大小，尽管 IE8 提供了 remainingSpace 属性，用于确定还有多少存储空间（以字节计）可用。</p>
<h3 id="21-sessionstorage"><a class="header" href="#21-sessionstorage">2.1 sessionStorage</a></h3>
<p>sessionStorage 对象只存储会话数据，这意味着数据只会存储到浏览器关闭。这跟浏览器关闭时会消失的会话 cookie 类似。存储在 sessionStorage 中的数据不受页面刷新影响，可以在浏览器崩溃并重启后恢复。（取决于浏览器，Firefox 和 WebKit 支持，IE 不支持。）</p>
<p>因为 sessionStorage 对象与服务器会话紧密相关，所以在运行本地文件时不能使用。存储在 sessionStorage 对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限。</p>
<p>因为 sessionStorage 对象是 Storage 的实例，所以可以通过使用 setItem() 方法或直接给属性赋值给它添加数据。下面是使用这两种方式的例子：</p>
<pre><code class="language-js">// 使用方法存储数据
sessionStorage.setItem('name', 'Nicholas')
// 使用属性存储数据
sessionStorage.book = 'Professional JavaScript'
</code></pre>
<p>所有现代浏览器在实现存储写入时都使用了同步阻塞方式，因此数据会被立即提交到存储。具体 API 的实现可能不会立即把数据写入磁盘（而是使用某种不同的物理存储），但这个区别在 JavaScript 层面是不可见的。通过 Web Storage 写入的任何数据都可以立即被读取。</p>
<p>老版 IE 以异步方式实现了数据写入，因此给数据赋值的时间和数据写入磁盘的时间可能存在延迟。对于少量数据，这里的差别可以忽略不计，但对于大量数据，就可以注意到 IE 中 JavaScript 恢复执行的速度比其他浏览器更快。这是因为实际写入磁盘的进程被转移了。在 IE8 中可以在数据赋值前调用 begin()、之后调用 commit() 来强制将数据写入磁盘。比如：</p>
<pre><code class="language-js">// 仅适用于 IE8
sessionStorage.begin()
sessionStorage.id = '1001'
sessionStorage.name = 'Lisi'
sessionStorage.commit()
</code></pre>
<p>以上代码确保了&quot;name&quot;和&quot;book&quot;在 commit() 调用之后会立即写入磁盘。调用 begin() 是为了保证在代码执行期间不会有写入磁盘的操作。对于少量数据，这个过程不是必要的，但对于较大的数据量，如文档，则可以考虑使用这种事务性方法。</p>
<p>对存在于 sessionStorage 上的数据，可以使用 getItem() 或直接访问属性名来取得：</p>
<pre><code class="language-js">// 使用方法取得数据
let name = sessionStorage.getItem(&quot;name&quot;);
// 使用属性取得数据
let book = sessionStorage.book;
可以结合 sessionStorage 的 length 属性和 key()方法遍历所有的值：
for (let i = 0, len = sessionStorage.length; i &lt; len; i++){
let key = sessionStorage.key(i);
let value = sessionStorage.getItem(key);
alert(`${key}=`${value}`);
}
</code></pre>
<p>这里通过 key() 先取得给定位置中的数据名称，然后使用该名称通过 getItem() 取得值，可以依次访问 sessionStorage 中的名/值对。也可以使用 for-in 循环迭代 sessionStorage 的值：</p>
<pre><code class="language-js">for (let key in sessionStorage) {
  let value = sessionStorage.getItem(key)
  alert(`${key}=${value}`)
}
</code></pre>
<p>每次循环，key 都会被赋予 sessionStorage 中的一个名称；这里不会返回内置方法或 length 属性。</p>
<p>要从 sessionStorage 中删除数据，可以使用 delete 操作符直接删除对象属性，也可以使用 removeItem() 方法。下面是使用这两种方式的例子：</p>
<pre><code class="language-js">// 使用 delete 删除值
delete sessionStorage.name
// 使用方法删除值
sessionStorage.removeItem('book')
</code></pre>
<p>sessionStorage 对象应该主要用于存储只在会话期间有效的小块数据。如果需要跨会话持久存储
数据，可以使用 globalStorage 或 localStorage。</p>
<h3 id="22-localstorage"><a class="header" href="#22-localstorage">2.2 localStorage</a></h3>
<p>在修订的 HTML5 规范里，localStorage 对象取代了 globalStorage，作为在客户端持久存储数据的机制。要访问同一个 localStorage 对象，页面必须来自同一个域（子域不可以）、在相同的端口上使用相同的协议。</p>
<p>因为 localStorage 是 Storage 的实例，所以可以像使用 sessionStorage 一样使用 localStorage。比如下面这几个例子：</p>
<pre><code class="language-js">// 使用方法存储数据
localStorage.setItem('name', 'Nicholas')
// 使用属性存储数据
localStorage.book = 'Professional JavaScript'
// 使用方法取得数据
let name = localStorage.getItem('name')
// 使用属性取得数据
let book = localStorage.book
</code></pre>
<p>两种存储方法的区别在于，存储在 localStorage 中的数据会保留到通过 JavaScript 删除或者用户清除浏览器缓存。localStorage 数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览器而丢失。</p>
<h2 id="三-存储事件"><a class="header" href="#三-存储事件">三 存储事件</a></h2>
<p>每当 Storage 对象发生变化时，都会在文档上触发 storage 事件。使用属性或 setItem() 设置
值、使用 delete 或 removeItem() 删除值，以及每次调用 clear() 时都会触发这个事件。这个事件的
事件对象有如下 4 个属性：</p>
<pre><code class="language-txt">domain：存储变化对应的域。
key：被设置或删除的键。
newValue：键被设置的新值，若键被删除则为 null。
oldValue：键变化之前的值。
</code></pre>
<p>可以使用如下代码监听 storage 事件：</p>
<pre><code class="language-js">window.addEventListener('storage', (event) =&gt;
  alert('Storage changed for ${event.domain}')
)
</code></pre>
<p>对于 sessionStorage 和 localStorage 上的任何更改都会触发 storage 事件，但 storage 事件不会区分这两者。</p>
<h2 id="四-限制"><a class="header" href="#四-限制">四 限制</a></h2>
<p>与其他客户端数据存储方案一样，Web Storage 也有限制。具体的限制取决于特定的浏览器。一般来说，客户端数据的大小限制是按照每个源（协议、域和端口）来设置的，因此每个源有固定大小的数据存储空间。分析存储数据的页面的源可以加强这一限制。</p>
<p>不同浏览器给 localStorage 和 sessionStorage 设置了不同的空间限制，但大多数会限制为每个源 5MB。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="093-客户端存储-indexeddb"><a class="header" href="#093-客户端存储-indexeddb">09.3-客户端存储-IndexedDB</a></h1>
<h2 id="一-indexeddb-概念"><a class="header" href="#一-indexeddb-概念">一 IndexedDB 概念</a></h2>
<p>Indexed Database API 简称 IndexedDB，是浏览器中存储结构化数据的一个方案。IndexedDB 用于代替目前已废弃的 Web SQL Database API。</p>
<p>IndexedDB 背后的思想是创造一套 API，方便 JavaScript 对象的存储和获取，同时也支持查询和搜索。IndexedDB 的设计几乎完全是异步的。为此，大多数操作以请求的形式执行，这些请求会异步执行，产生成功的结果或错误。绝大多数 IndexedDB 操作要求添加 onerror 和 onsuccess 事件处理程序来确定输出。</p>
<p>2017 年，新发布的主流浏览器（Chrome、Firefox、Opera、Safari）完全支持 IndexedDB。IE10/11 和 Edge 浏览器部分支持 IndexedDB。</p>
<p>IndexedDB 是类似于 MySQL 或 Web SQL Database 的数据库。与传统数据库最大的区别在于，IndexedDB 使用对象存储而不是表格保存数据。IndexedDB 数据库就是在一个公共命名空间下的一组对象存储，类似于 NoSQL 风格的实现。</p>
<h2 id="二-indexeddb-的使用"><a class="header" href="#二-indexeddb-的使用">二 IndexedDB 的使用</a></h2>
<h3 id="20-基本使用"><a class="header" href="#20-基本使用">2.0 基本使用</a></h3>
<p>使用 IndexedDB 数据库的第一步是调用 indexedDB.open() 方法，并给它传入一个要打开的数据库名称。如果给定名称的数据库已存在，则会发送一个打开它的请求；如果不存在，则会发送创建并打开这个数据库的请求。这个方法会返回 IDBRequest 的实例，可以在这个实例上添加 onerror 和 onsuccess 事件处理程序。举例如下：</p>
<pre><code class="language-js">let db,
  request,
  version = 1
request = indexedDB.open('admin', version)
request.onerror = (event) =&gt; alert(`Failed to open: ${event.target.errorCode}`)
request.onsuccess = (event) =&gt; {
  db = event.target.result
}
</code></pre>
<p>以前，IndexedDB 使用 setVersion() 方法指定版本号。这个方法目前已废弃。如前面代码所示，要在打开数据库的时候指定版本。这个版本号会被转换为一个 unsigned long long 数值，因此不要使用小数，而要使用整数。</p>
<p>在两个事件处理程序中，event.target 都指向 request，因此使用哪个都可以。如果 onsuccess 事件处理程序被调用，说明可以通过 event.target.result 访问数据库（IDBDatabase）实例了，这个实例会保存到 db 变量中。之后，所有与数据库相关的操作都要通过 db 对象本身来进行。如果打开数据库期间发生错误，event.target.errorCode 中就会存储表示问题的错误码。</p>
<h3 id="21-对象存储"><a class="header" href="#21-对象存储">2.1 对象存储</a></h3>
<p>建立了数据库连接之后，下一步就是使用对象存储。如果数据库版本与期待的不一致，那可能需要创建对象存储。不过，在创建对象存储前，有必要想一想要存储什么类型的数据。</p>
<p>假设要存储包含用户名、密码等内容的用户记录。可以用如下对象来表示一条记录：</p>
<pre><code class="language-js">let user = {
  username: '007',
  firstName: 'James',
  lastName: 'Bond',
  password: 'foo',
}
</code></pre>
<p>观察这个对象，可以很容易看出最适合作为对象存储键的 username 属性。用户名必须全局唯一，它也是大多数情况下访问数据的凭据。这个键很重要，因为创建对象存储时必须指定一个键。</p>
<p>数据库的版本决定了数据库模式，包括数据库中的对象存储和这些对象存储的结构。如果数据库还不存在，open() 操作会创建一个新数据库，然后触发 upgradeneeded 事件。可以为这个事件设置处理程序，并在处理程序中创建数据库模式。如果数据库存在，而你指定了一个升级版的版本号，则会立即触发 upgradeneeded 事件，因而可以在事件处理程序中更新数据库模式。</p>
<p>下面的代码演示了为存储上述用户信息如何创建对象存储：</p>
<pre><code class="language-js">request.onupgradeneeded = (event) =&gt; {
  const db = event.target.result
  // 如果存在则删除当前 objectStore。测试的时候可以这样做
  // 但这样会在每次执行事件处理程序时删除已有数据
  if (db.objectStoreNames.contains('users')) {
    db.deleteObjectStore('users')
  }
  db.createObjectStore('users', { keyPath: 'username' })
}
</code></pre>
<p>这里第二个参数的 keyPath 属性表示应该用作键的存储对象的属性名。</p>
<h3 id="22-事务"><a class="header" href="#22-事务">2.2 事务</a></h3>
<p>创建了对象存储之后，剩下的所有操作都是通过事务完成的。事务要通过调用数据库对象的 transaction() 方法创建。任何时候，只要想要读取或修改数据，都要通过事务把所有修改操作组织起来。最简单的情况下，可以像下面这样创建事务：</p>
<pre><code class="language-js">let transaction = db.transaction()
</code></pre>
<p>如果不指定参数，则对数据库中所有的对象存储有只读权限。更具体的方式是指定一个或多个要访问的对象存储的名称：</p>
<pre><code class="language-js">let transaction = db.transaction('users')
</code></pre>
<p>这样可以确保在事务期间只加载 users 对象存储的信息。如果想要访问多个对象存储，可以给第一个参数传入一个字符串数组：</p>
<pre><code class="language-js">let transaction = db.transaction(['users', 'anotherStore'])
</code></pre>
<p>如前所述，每个事务都以只读方式访问数据。要修改访问模式，可以传入第二个参数。这个参数应该是下列三个字符串之一： &quot;readonly&quot;、 &quot;readwrite&quot;或&quot;versionchange&quot;。比如：</p>
<pre><code class="language-js">let transaction = db.transaction('users', 'readwrite')
</code></pre>
<p>这样事务就可以对 users 对象存储读写了。</p>
<p>有了事务的引用，就可以使用 objectStore() 方法并传入对象存储的名称以访问特定的对象存储。然后，可以使用 add() 和 put() 方法添加和更新对象，使用 get() 取得对象，使用 delete() 删除对象，使用 clear() 删除所有对象。其中，get() 和 delete() 方法都接收对象键作为参数，这 5 个方法都创建新的请求对象。来看下面的例子：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  request = store.get('007')
request.onerror = (event) =&gt; alert('Did not get the object!')
request.onsuccess = (event) =&gt; alert(event.target.result.firstName)
</code></pre>
<p>因为一个事务可以完成任意多个请求，所以事务对象本身也有事件处理程序：onerror 和 oncomplete。这两个事件可以用来获取事务级的状态信息：</p>
<pre><code class="language-js">transaction.onerror = (event) =&gt; {
  // 整个事务被取消
}
transaction.oncomplete = (event) =&gt; {
  // 整个事务成功完成
}
</code></pre>
<p>注意，不能通过 oncomplete 事件处理程序的 event 对象访问 get() 请求返回的任何数据。因此，仍然需要通过这些请求的 onsuccess 事件处理程序来获取数据。</p>
<h3 id="23-插入对象"><a class="header" href="#23-插入对象">2.3 插入对象</a></h3>
<p>拿到了对象存储的引用后，就可以使用 add() 或 put() 写入数据了。这两个方法都接收一个参数，即要存储的对象，并把对象保存到对象存储。这两个方法只在对象存储中已存在同名的键时有区别。这种情况下，add() 会导致错误，而 put() 会简单地重写该对象。更简单地说，可以把 add() 想象成插入新值，而把 put() 想象为更新值。因此第一次初始化对象存储时，可以这样做：</p>
<pre><code class="language-js">// users 是一个用户数据的数组
for (let user of users) {
  store.add(user)
}
</code></pre>
<p>每次调用 add() 或 put() 都会创建对象存储的新更新请求。如果想验证请求成功与否，可以把请求对象保存到一个变量，然后为它添加 onerror 和 onsuccess 事件处理程序：</p>
<pre><code class="language-js">// users 是一个用户数据的数组
let request,
  requests = []
for (let user of users) {
  request = store.add(user)
  request.onerror = () =&gt; {
    // 处理错误
  }
  request.onsuccess = () =&gt; {
    // 处理成功
  }
  requests.push(request)
}
</code></pre>
<p>创建并填充了数据后，就可以查询对象存储了。</p>
<h3 id="24-通过游标查询"><a class="header" href="#24-通过游标查询">2.4 通过游标查询</a></h3>
<p>使用事务可以通过一个已知键取得一条记录。如果想取得多条数据，则需要在事务中创建一个游标。游标是一个指向结果集的指针。与传统数据库查询不同，游标不会事先收集所有结果。相反，游标指向第一个结果，并在接到指令前不会主动查找下一条数据。</p>
<p>需要在对象存储上调用 openCursor() 方法创建游标。与其他 IndexedDB 操作一样，openCursor() 方法也返回一个请求，因此必须为它添加 onsuccess 和 onerror 事件处理程序。例如：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  request = store.openCursor()
request.onsuccess = (event) =&gt; {
  // 处理成功
}
request.onerror = (event) =&gt; {
  // 处理错误
}
</code></pre>
<p>在调用 onsuccess 事件处理程序时，可以通过 event.target.result 访问对象存储中的下一条记录，这个属性中保存着 IDBCursor 的实例（有下一条记录时）或 null（没有记录时）。这个 IDBCursor 实例有几个属性：</p>
<pre><code class="language-txt">direction：字符串常量，表示游标的前进方向以及是否应该遍历所有重复的值。可能的值包括：
    NEXT(&quot;next&quot;)、 NEXTUNIQUE(&quot;nextunique&quot;)、 PREV(&quot;prev&quot;)、 PREVUNIQUE(&quot;prevunique&quot;)。

key：对象的键。

value：实际的对象。

primaryKey：游标使用的键。可能是对象键或索引键
</code></pre>
<p>可以像下面这样取得一个结果：</p>
<pre><code class="language-js">request.onsuccess = (event) =&gt; {
  const cursor = event.target.result
  if (cursor) {
    // 永远要检查
    console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`)
  }
}
</code></pre>
<p>注意，这个例子中的 cursor.value 保存着实际的对象。正因为如此，在显示它之前才需要使用 JSON 来编码。</p>
<p>游标可用于更新个别记录。update() 方法使用指定的对象更新当前游标对应的值。与其他类似操作一样，调用 update() 会创建一个新请求，因此如果想知道结果，需要为 onsuccess 和 onerror 赋值：</p>
<pre><code class="language-js">request.onsuccess = (event) =&gt; {
  const cursor = event.target.result
  let value, updateRequest
  if (cursor) {
    // 永远要检查
    if (cursor.key == 'foo') {
      value = cursor.value // 取得当前对象
      value.password = 'magic!' // 更新密码
      updateRequest = cursor.update(value) // 请求保存更新后的对象
      updateRequest.onsuccess = () =&gt; {
        // 处理成功
      }
      updateRequest.onerror = () =&gt; {
        // 处理错误
      }
    }
  }
}
</code></pre>
<p>也可以调用 delelte() 来删除游标位置的记录，与 update() 一样，这也会创建一个请求：</p>
<pre><code class="language-js">request.onsuccess = (event) =&gt; {
  const cursor = event.target.result
  let value, deleteRequest
  if (cursor) {
    // 永远要检查
    if (cursor.key == 'foo') {
      deleteRequest = cursor.delete() // 请求删除对象
      deleteRequest.onsuccess = () =&gt; {
        // 处理成功
      }
      deleteRequest.onerror = () =&gt; {
        // 处理错误
      }
    }
  }
}
</code></pre>
<p>如果事务没有修改对象存储的权限，update() 和 delete() 都会抛出错误。默认情况下，每个游标只会创建一个请求。要创建另一个请求，必须调用下列中的一个方法：</p>
<pre><code class="language-txt">continue(key)：移动到结果集中的下一条记录。参数 key 是可选的。如果没有指定 key，游标就移动到下一条记录；如果指定了，则游标移动到指定的键。

advance(count)：游标向前移动指定的 count 条记录。
</code></pre>
<p>这两个方法都会让游标重用相同的请求，因此也会重用 onsuccess 和 onerror 处理程序，直至不再需要。例如，下面的代码迭代了一个对象存储中的所有记录：</p>
<pre><code class="language-js">request.onsuccess = (event) =&gt; {
  const cursor = event.target.result
  if (cursor) {
    // 永远要检查
    console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`)
    cursor.continue() // 移动到下一条记录
  } else {
    console.log('Done!')
  }
}
</code></pre>
<p>调用 cursor.continue() 会触发另一个请求并再次调用 onsuccess 事件处理程序。在没有更多记录时，onsuccess 事件处理程序最后一次被调用，此时 event.target.result 等于 null。</p>
<h3 id="25-键范围"><a class="header" href="#25-键范围">2.5 键范围</a></h3>
<p>使用游标会给人一种不太理想的感觉，因为获取数据的方式受到了限制。使用键范围（key range）可以让游标更容易管理。键范围对应 IDBKeyRange 的实例。有四种方式指定键范围，第一种是使用 only() 方法并传入想要获取的键：</p>
<pre><code class="language-js">const onlyRange = IDBKeyRange.only('007')
</code></pre>
<p>这个范围保证只获取键为&quot;007&quot;的值。使用这个范围创建的游标类似于直接访问对象存储并调用 get(&quot;007&quot;)。</p>
<p>第二种键范围可以定义结果集的下限。下限表示游标开始的位置。例如，下面的键范围保证游标从&quot;007&quot;这个键开始，直到最后：</p>
<pre><code class="language-js">// 从&quot;007&quot;记录开始，直到最后
const lowerRange = IDBKeyRange.lowerBound('007')
</code></pre>
<p>如果想从&quot;007&quot;后面的记录开始，可以再传入第二个参数 true：</p>
<pre><code class="language-js">// 从&quot;007&quot;的下一条记录开始，直到最后
const lowerRange = IDBKeyRange.lowerBound('007', true)
</code></pre>
<p>第三种键范围可以定义结果集的上限，通过调用 upperBound() 方法可以指定游标不会越过的记录。下面的键范围保证游标从头开始并在到达键为&quot;ace&quot;的记录停止：</p>
<pre><code class="language-js">// 从头开始，到&quot;ace&quot;记录为止
const upperRange = IDBKeyRange.upperBound('ace')
</code></pre>
<p>如果不想包含指定的键，可以在第二个参数传入 true：</p>
<pre><code class="language-js">// 从头开始，到&quot;ace&quot;的前一条记录为止
const upperRange = IDBKeyRange.upperBound('ace', true)
</code></pre>
<p>要同时指定下限和上限，可以使用 bound() 方法。这个方法接收四个参数：下限的键、上限的键、可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限。下面是几个例子：</p>
<pre><code class="language-js">// 从&quot;007&quot;记录开始，到&quot;ace&quot;记录停止
const boundRange = IDBKeyRange.bound('007', 'ace')
// 从&quot;007&quot;的下一条记录开始，到&quot;ace&quot;记录停止
const boundRange = IDBKeyRange.bound('007', 'ace', true)
// 从&quot;007&quot;的下一条记录开始，到&quot;ace&quot;的前一条记录停止
const boundRange = IDBKeyRange.bound('007', 'ace', true, true)
// 从&quot;007&quot;记录开始，到&quot;ace&quot;的前一条记录停止
const boundRange = IDBKeyRange.bound('007', 'ace', false, true)
</code></pre>
<p>定义了范围之后，把它传给 openCursor() 方法，就可以得到位于该范围内的游标：</p>
<pre><code class="language-js">const store = db.transaction('users').objectStore('users'),
  range = IDBKeyRange.bound('007', 'ace')
request = store.openCursor(range)
request.onsuccess = function (event) {
  const cursor = event.target.result
  if (cursor) {
    // 永远要检查
    console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`)
    cursor.continue() // 移动到下一条记录
  } else {
    console.log('Done!')
  }
}
</code></pre>
<p>这个例子只会输出从键为&quot;007&quot;的记录开始到键为&quot;ace&quot;的记录结束的对象，比上一节的例子要少。</p>
<h3 id="26-设置游标方向"><a class="header" href="#26-设置游标方向">2.6 设置游标方向</a></h3>
<p>openCursor() 方法实际上可以接收两个参数，第一个是 IDBKeyRange 的实例，第二个是表示方向的字符串。通常，游标都是从对象存储的第一条记录开始，每次调用 continue() 或 advance() 都会向最后一条记录前进。这样的游标其默认方向为&quot;next&quot;。如果对象存储中有重复的记录，可能需要游标跳过那些重复的项。为此，可以给 openCursor() 的第二个参数传入&quot;nextunique&quot;：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  request = store.openCursor(null, 'nextunique')
</code></pre>
<p>注意，openCursor() 的第一个参数是 null，表示默认的键范围是所有值。此游标会遍历对象存储中的记录，从第一条记录开始迭代，到最后一条记录，但会跳过重复的记录。</p>
<p>另外，也可以创建在对象存储中反向移动的游标，从最后一项开始向第一项移动。此时需要给 openCursor() 传入&quot;prev&quot;或&quot;prevunique&quot;作为第二个参数（后者的意思当然是避免重复）。例如：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  request = store.openCursor(null, 'prevunique')
</code></pre>
<p>在使用&quot;prev&quot;或&quot;prevunique&quot;打开游标时，每次调用 continue() 或 advance() 都会在对象存储中反向移动游标。</p>
<h3 id="27-索引"><a class="header" href="#27-索引">2.7 索引</a></h3>
<p>对某些数据集，可能需要为对象存储指定多个键。例如，如果同时记录了用户 ID 和用户名，那可能需要通过任何一种方式来获取用户数据。为此，可以考虑将用户 ID 作为主键，然后在用户名上创建索引。要创建新索引，首先要取得对象存储的引用，然后像下面的例子一样调用 createIndex()：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  index = store.createIndex('username', 'username', { unique: true })
</code></pre>
<p>createIndex() 的第一个参数是索引的名称，第二个参数是索引属性的名称，第三个参数是包含键 unique 的 options 对象。这个选项中的 unique 应该必须指定，表示这个键是否在所有记录中唯一。因为 username 可能不会重复，所以这个键是唯一的。</p>
<p>createIndex() 返回的是 IDBIndex 实例。在对象存储上调用 index() 方法也可以得到同一个实例。例如，要使用一个已存在的名为&quot;username&quot;的索引，可以像下面这样：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  index = store.index('username')
</code></pre>
<p>索引非常像对象存储。可以在索引上使用 openCursor() 方法创建新游标，这个游标与在对象存储上调用 openCursor() 创建的游标完全一样。只是其 result.key 属性中保存的是索引键，而不是主键。下面看一个例子：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  index = store.index('username'),
  request = index.openCursor()
request.onsuccess = (event) =&gt; {
  // 处理成功
}
</code></pre>
<p>使用 openKeyCursor() 方法也可以在索引上创建特殊游标，只返回每条记录的主键。这个方法接收的参数与 openCursor() 一样。最大的不同在于，event.result.key 是索引键，且 event.result.value 是主键而不是整个记录：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  index = store.index('username'),
  request = index.openKeyCursor()
request.onsuccess = (event) =&gt; {
  // 处理成功
  // event.result.key 是索引键，event.result.value 是主键
}
</code></pre>
<p>可以使用 get() 方法并传入索引键通过索引取得单条记录，这会创建一个新请求：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  index = store.index('username'),
  request = index.get('007')
request.onsuccess = (event) =&gt; {
  // 处理成功
}
request.onerror = (event) =&gt; {
  // 处理错误
}
</code></pre>
<p>如果想只取得给定索引键的主键，可以使用 getKey() 方法。这样也会创建一个新请求，但 result.value 等于主键而不是整个记录：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  index = store.index('username'),
  request = index.getKey('007')
request.onsuccess = (event) =&gt; {
  // 处理成功
  // event.target.result.key 是索引键，event.target.result.value 是主键
}
</code></pre>
<p>在这个 onsuccess 事件处理程序中，event.target.result.value 中应该是用户 ID。</p>
<p>任何时候，都可以使用 IDBIndex 对象的下列属性取得索引的相关信息：</p>
<pre><code class="language-txt">name：索引的名称。
keyPath：调用 createIndex() 时传入的属性路径。
objectStore：索引对应的对象存储。
unique：表示索引键是否唯一的布尔值。
</code></pre>
<p>对象存储自身也有一个 indexNames 属性，保存着与之相关索引的名称。使用如下代码可以方便地了解对象存储上已存在哪些索引：</p>
<pre><code class="language-js">const transaction = db.transaction('users'),
  store = transaction.objectStore('users'),
  indexNames = store.indexNames
for (let indexName in indexNames) {
  const index = store.index(indexName)
  console.log(
    `Index name: ${index.name} KeyPath: ${index.keyPath} Unique: ${index.unique}`
  )
}
</code></pre>
<p>以上代码迭代了每个索引并在控制台中输出了它们的信息。</p>
<p>在对象存储上调用 deleteIndex() 方法并传入索引的名称可以删除索引：</p>
<pre><code class="language-js">const transaction = db.transaction(&quot;users&quot;),
store = transaction.objectStore(&quot;users&quot;),
store.deleteIndex(&quot;username&quot;);
</code></pre>
<p>因为删除索引不会影响对象存储中的数据，所以这个操作没有回调。</p>
<h2 id="三-并发问题"><a class="header" href="#三-并发问题">三 并发问题</a></h2>
<p>IndexedDB 虽然是网页中的异步 API，但仍存在并发问题。如果两个不同的浏览器标签页同时打开了同一个网页，则有可能出现一个网页尝试升级数据库而另一个尚未就绪的情形。有问题的操作是设置数据库为新版本，而版本变化只能在浏览器只有一个标签页使用数据库时才能完成。</p>
<p>第一次打开数据库时，添加 onversionchange 事件处理程序非常重要。另一个同源标签页将数据库打开到新版本时，将执行此回调。对这个事件最好的回应是立即关闭数据库，以便完成版本升级。例如：</p>
<pre><code class="language-js">let request, database
request = indexedDB.open('admin', 1)
request.onsuccess = (event) =&gt; {
  database = event.target.result
  database.onversionchange = () =&gt; database.close()
}
</code></pre>
<p>应该在每次成功打开数据库后都指定 onversionchange 事件处理程序。记住，onversionchange 有可能会被其他标签页触发。</p>
<p>通过始终都指定这些事件处理程序，可以保证 Web 应用程序能够更好地处理与 IndexedDB 相关的并发问题。</p>
<h2 id="四-限制-1"><a class="header" href="#四-限制-1">四 限制</a></h2>
<p>IndexedDB 的很多限制实际上与 Web Storage 一样。首先，IndexedDB 数据库是与页面源（协议、域和端口）绑定的，因此信息不能跨域共享。这意味着 www.wrox.com 和 p2p.wrox.com 会对应不同的数据存储。</p>
<p>其次，每个源都有可以存储的空间限制。当前 Firefox 的限制是每个源 50MB，而 Chrome 是 5MB。移动版 Firefox 有 5MB 限制，如果用度超出配额则会请求用户许可。</p>
<p>Firefox 还有一个限制——本地文本不能访问 IndexedDB 数据库。Chrome 没有这个限制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="101-javascriptapi-encoding-编码解码"><a class="header" href="#101-javascriptapi-encoding-编码解码">10.1-JavaScriptAPI-Encoding 编码解码</a></h1>
<h2 id="一-encoding-api"><a class="header" href="#一-encoding-api">一 Encoding API</a></h2>
<p>字符串与定型数组（二进制）之间的转换依赖于 EncodingAPI，如：TextEncoder、TextEncoderStream、TextDecoder 和 TextDecoderStream。</p>
<h2 id="二-文本编码"><a class="header" href="#二-文本编码">二 文本编码</a></h2>
<h3 id="20-字符串转换为定型数组"><a class="header" href="#20-字符串转换为定型数组">2.0 字符串转换为定型数组</a></h3>
<p>Encoding API 提供了两种将字符串转换为定型数组二进制格式的方法：批量编码和流编码。把字符串转换为定型数组时，编码器始终使用 UTF-8。</p>
<h3 id="21-批量编码"><a class="header" href="#21-批量编码">2.1 批量编码</a></h3>
<p>所谓批量，指的是 JavaScript 引擎会同步编码整个字符串。对于非常长的字符串，可能会花较长时间。</p>
<p>批量编码是通过 TextEncoder 对象实现的：</p>
<pre><code class="language-js">const textEncoder = new TextEncoder()

const encoderText = textEncoder.encode('foo')
// f 的 UTF-8 编码是 0x66（102），o 的 UTF-8 编码是 0x6F(111)
console.log(encoderText) // Uint8Array(3) [102, 111, 111]
</code></pre>
<p>编码器是用于处理字符的，有些字符（如表情符号）在最终返回的数组中可能会占多个索引：</p>
<pre><code class="language-js">const textEncoder = new TextEncoder()
const decodedText = '☺'
const encodedText = textEncoder.encode(decodedText)

// ☺的 UTF-8 编码是 0xF0 0x9F 0x98 0x8A（即十进制 240、 159、 152、 138）
console.log(encodedText) // Uint8Array(4) [240, 159, 152, 138]
</code></pre>
<p>TextEncoder 编码器的实例方法 encodeInto() 接收一个字符串和目标 Unit8Array，返回一个字典，该字典包含 read 和 written 属性，分别表示成功从源字符串读取了多少字符和向目标数组写入了多少字符。如果定型数组的空间不够，编码就会提前终止：</p>
<pre><code class="language-js">const textEncoder = new TextEncoder()

const fooArr = new Uint8Array(3)
const fooRes = textEncoder.encodeInto('foo', fooArr)
console.log(fooRes) // { read: 3, written: 3 }

const barArr = new Uint8Array(2)
const barRes = textEncoder.encodeInto('bar', barArr)
console.log(barRes) // { read: 2, written: 2 }
</code></pre>
<p>注意：由于 encodeInto() 不需要像 encode() 那样需要分配一个新的 Unit8Array，会有性能上的提升。</p>
<p>文本编码会始终使用 UTF-8 格式，而且必须写入 Unit8Array 实例。使用其他类型数组会导致 encodeInto()抛出错误。</p>
<h3 id="22-流编码"><a class="header" href="#22-流编码">2.2 流编码</a></h3>
<p>TextEncoderStream 其实就是 TransformStream 形式的 TextEncoder。将解码后的文本流通过管道输入流编码器会得到编码后文本块的流：</p>
<pre><code class="language-js">async function* chars() {
  const decodedText = 'foo'
  for (let char of decodedText) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, char))
  }
}

const decodedTextStream = new ReadableStream({
  async start(controller) {
    for await (let chunk of chars()) {
      controller.enqueue(chunk)
    }
    controller.close()
  },
})

const encodedTextStream = decodedTextStream.pipeThrough(new TextEncoderStream())
const readableStreamDefaultReader = encodedTextStream.getReader()

;(async function () {
  while (true) {
    const { done, value } = await readableStreamDefaultReader.read()
    if (done) {
      break
    } else {
      console.log(value)
    }
  }
})()
// Uint8Array[102]
// Uint8Array[111]
// Uint8Array[111]
</code></pre>
<h2 id="三-文本解码"><a class="header" href="#三-文本解码">三 文本解码</a></h2>
<h3 id="30-定型数组转换为字符串方式归纳"><a class="header" href="#30-定型数组转换为字符串方式归纳">3.0 定型数组转换为字符串方式归纳</a></h3>
<p>Encoding API 提供了两种将定型数组转换为字符串的方式：批量解码和流解码。解码器默认字符编码格式是 UTF-8，但是也支持其他字符串编码。</p>
<h3 id="31-批量解码"><a class="header" href="#31-批量解码">3.1 批量解码</a></h3>
<p>所谓批量，指的是 JavaScript 引擎会同步解码整个字符串。对于非常长的字符串，可能会花较长时间。批量解码是通过 TextDecoder 的实例完成的：</p>
<pre><code class="language-js">const textDecoder = new TextDecoder() // 可传入参数 'utf-16' 改变默认编码

const source = Uint32Array.of(102, 111, 111)
const decodeText = textDecoder.decode(source)
console.log(decodeText) // foo
</code></pre>
<p>解码器是用于处理定型数组中分散在多个索引上的字符的，包括表情符号：</p>
<pre><code class="language-js">const textDecoder = new TextDecoder()
// ☺ 的 UTF-8 编码是 0xF0 0x9F 0x98 0x8A（即十进制 240、 159、 152、 138）
const encodedText = Uint8Array.of(240, 159, 152, 138)
const decodedText = textDecoder.decode(encodedText)
console.log(decodedText) // ☺
</code></pre>
<p>与 TextEncoder 不同， TextDecoder 可以兼容很多字符编码。比如下面的例子就使用了 UTF-16 而非默认的 UTF-8：</p>
<pre><code class="language-js">const textDecoder = new TextDecoder('utf-16')
// f 的 UTF-8 编码是 0x0066（即十进制 102）
// o 的 UTF-8 编码是 0x006F（即二进制 111）
const encodedText = Uint16Array.of(102, 111, 111)
const decodedText = textDecoder.decode(encodedText)
console.log(decodedText) // foo
</code></pre>
<h3 id="32-流解码"><a class="header" href="#32-流解码">3.2 流解码</a></h3>
<p>TextDecoderStream 其实就是 TransformStream 形式的 TextDecoder。将编码后的文本流通过管道输入流解码器会得到解码后文本块的流：</p>
<pre><code class="language-js">async function* chars() {
  // 每个块必须是一个定型数组
  const encodedText = [102, 111, 111].map((x) =&gt; Uint8Array.of(x))
  for (let char of encodedText) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, char))
  }
}

const encodedTextStream = new ReadableStream({
  async start(controller) {
    for await (let chunk of chars()) {
      controller.enqueue(chunk)
    }
    controller.close()
  },
})

const decodedTextStream = encodedTextStream.pipeThrough(new TextDecoderStream())
const readableStreamDefaultReader = decodedTextStream.getReader()

;(async function () {
  while (true) {
    const { done, value } = await readableStreamDefaultReader.read()
    if (done) {
      break
    } else {
      console.log(value)
    }
  }
})()
// f
// o
// o
</code></pre>
<p>文本解码器流能够识别可能分散在不同块上的代理对。解码器流会保持块片段直到取得完整的字符。比如在下面的例子中，流解码器在解码流并输出字符之前会等待传入 4 个块：</p>
<pre><code class="language-js">async function* chars() {
  // ☺的 UTF-8 编码是 0xF0 0x9F 0x98 0x8A（即十进制 240、159、152、138）
  const encodedText = [240, 159, 152, 138].map((x) =&gt; Uint8Array.of(x))
  for (let char of encodedText) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, char))
  }
}

const encodedTextStream = new ReadableStream({
  async start(controller) {
    for await (let chunk of chars()) {
      controller.enqueue(chunk)
    }
    controller.close()
  },
})

const decodedTextStream = encodedTextStream.pipeThrough(new TextDecoderStream())
const readableStreamDefaultReader = decodedTextStream.getReader()

;(async function () {
  while (true) {
    const { done, value } = await readableStreamDefaultReader.read()
    if (done) {
      break
    } else {
      console.log(value)
    }
  }
})()
// ☺
</code></pre>
<p>文本解码器流经常与 fetch() 一起使用，因为响应体可以作为 ReadableStream 来处理：</p>
<pre><code class="language-js">const response = await fetch(url)
const stream = response.body.pipeThrough(new TextDecoderStream())
const decodedStream = stream.getReader()
for await (let decodedChunk of decodedStream) {
  console.log(decodedChunk)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="102-javascriptapi-文件对象"><a class="header" href="#102-javascriptapi-文件对象">10.2-JavaScriptAPI-文件对象</a></h1>
<h2 id="一-file-api"><a class="header" href="#一-file-api">一 File API</a></h2>
<h3 id="11-file-文件对象"><a class="header" href="#11-file-文件对象">1.1 File 文件对象</a></h3>
<p>Web 应用在早期只能通过<code>&lt;input type=&quot;file&quot;&gt;</code>获取文件，File API 与 Blob API 的出现可以让 Web 开发者以安全的方式访问客户端机器上的文件，从而更好地与这些文件进行交互。</p>
<p>DOM 上的文件输入元素现在拥有 files 集合，可以直接访问文件信息。用户在文件字段中选择一个或多个文件时，这个 files 集合中会包含一组 File 对象，表示被选中的文件。</p>
<p>每个 File 对象都有一些只读属性：</p>
<ul>
<li>name：本地系统中的文件名。</li>
<li>size：以字节计的文件大小。</li>
<li>type：包含文件 MIME 类型的字符串。</li>
<li>lastModifiedDate：表示文件最后修改时间的字符串。</li>
</ul>
<p>例如通过监听 change 事件遍历 files 集合获取每个选中文件的信息：</p>
<pre><code class="language-js">let filesList = document.getElementById('files-list')

filesList.addEventListener('change', (event) =&gt; {
  let files = event.target.files,
    i = 0,
    len = files.length
  while (i &lt; len) {
    const f = files[i]
    console.log(`${f.name} (${f.type}, ${f.size} bytes)`)
    i++
  }
})
</code></pre>
<h3 id="12-filereader-类型"><a class="header" href="#12-filereader-类型">1.2 FileReader 类型</a></h3>
<p>异步文件读取机制的实现类型是 FileReader，可以把 FileReader 想象成类似于 XMLHttpRequest，只不过是用于从文件系统读取文件，而不是从服务器读取数据，常见方法有：</p>
<ul>
<li>readAsText(file, encoding)：从文件中读取纯文本内容并保存在 result 属性中。第二个参数表示编码，是可选的。</li>
<li>readAsDataURL(file)：读取文件并将内容的数据 URI 保存在 result 属性中。</li>
<li>readAsBinaryString(file)：读取文件并将每个字符的二进制数据保存在 result 属性中。</li>
<li>readAsArrayBuffer(file)：读取文件并将文件内容以 ArrayBuffer 形式保存在 result 属性。</li>
</ul>
<p>由于 FileReader 的读取机制是异步的，所以需要事件支持，常用对应事件有：</p>
<ul>
<li>progress 事件：每 50 毫秒就会触发一次，包括信息有：lengthComputable、loaded 和 total。 progress 事件中还可以读取 FileReader 的 result 属性，即使其中尚未包含全部数据。</li>
<li>error 事件：会在无法读取文件时触发。触发 error 事件时，FileReader 的 error 属性会包含错误信息。error 属性内只有 错误码 code 一个属性，其值为：
<ul>
<li>1（未找到文件）</li>
<li>2（安全错误）</li>
<li>3（读取被中断）</li>
<li>4（文件不可读）</li>
<li>5（编码错误）</li>
</ul>
</li>
<li>load 事件：会在文件成功加载后触发。如果 error 事件被触发，则不会再触发 load 事件。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">let filesList = document.getElementById('files-list')

filesList.addEventListener('change', (event) =&gt; {
  let info = '',
    output = document.getElementById('output'),
    progress = document.getElementById('progress'),
    files = event.target.files,
    type = 'default',
    reader = new FileReader()
  if (/image/.test(files[0].type)) {
    reader.readAsDataURL(files[0])
    type = 'image'
  } else {
    reader.readAsText(files[0])
    type = 'text'
  }
  reader.onerror = function () {
    output.innerHTML = 'Could not read file, error code is ' + reader.error.code
  }
  reader.onprogress = function (event) {
    if (event.lengthComputable) {
      progress.innerHTML = `${event.loaded}/${event.total}`
    }
  }
  reader.onload = function () {
    let html = ''
    switch (type) {
      case 'image':
        html = `&lt;img src=&quot;${reader.result}&quot;&gt;`
        break
      case 'text':
        html = reader.result
        break
    }
    output.innerHTML = html
  }
})
</code></pre>
<p>如果想提前结束文件读取，则可以在过程中调用 abort() 方法，从而触发 abort 事件。在 load、error 和 abort 事件触发后，还会触发 loadend 事件。loadend 事件表示在上述 3 种情况下，所有读取操作都已经结束。</p>
<h3 id="13-filereadersync-类型"><a class="header" href="#13-filereadersync-类型">1.3 FileReaderSync 类型</a></h3>
<p>FileReaderSync 类型就是 FileReader 的同步版本。这个类型拥有与 FileReader 相同的方法，只有在整个文件都加载到内存之后才会继续执行。</p>
<p>FileReaderSync 只在工作者中可用，因为如果读取整个文件耗时太长则会影响全局。</p>
<p>假设通过 postMessage()向工作者发送了一个 File 对象。以下代码会让工作者同步将文件读取到内存中，然后将文件的数据 URL 发回来：</p>
<pre><code class="language-js">// worker.js
self.omessage = (messageEvent) =&gt; {
  const syncReader = new FileReaderSync()
  console.log(syncReader) // FileReaderSync {}
  // 读取文件时阻塞工作者
  const result = syncReader.readAsDataUrl(messageEvent.data)
  // PDF 文件的示例响应
  console.log(result) // data:application/pdf;base64,JVBERi0xLjQK...
  // 把 URL 发回去
  self.postMessage(result)
}
</code></pre>
<h2 id="二-blob-api"><a class="header" href="#二-blob-api">二 Blob API</a></h2>
<h3 id="21-二进制对象-blob"><a class="header" href="#21-二进制对象-blob">2.1 二进制对象 Blob</a></h3>
<p>某些情况下，可能需要读取部分文件而不是整个文件。为此，File 对象提供了一个名为 slice() 的方法。slice() 方法接收两个参数：起始字节和要读取的字节数。slice() 方法会返回一个 Blob 的实例，而 Blob 实际上是 File 的超类。</p>
<p>blob 表示二进制大对象（binary larget object），是 JavaScript 对不可修改二进制数据的封装类型。包含字符串的数组、ArrayBuffers、ArrayBufferViews，甚至其他 Blob 都可以用来创建 blob。</p>
<p>Blob 构造函数可以接收一个 options 参数，并在其中指定 MIME 类型：</p>
<pre><code class="language-js">console.log(new Blob(['foo']))
// Blob {size: 3, type: &quot;&quot;}
console.log(new Blob(['{&quot;a&quot;: &quot;b&quot;}'], { type: 'application/json' }))
// {size: 10, type: &quot;application/json&quot;}
console.log(new Blob(['&lt;p&gt;Foo&lt;/p&gt;', '&lt;p&gt;Bar&lt;/p&gt;'], { type: 'text/html' }))
// {size: 20, type: &quot;text/html&quot;}
</code></pre>
<p>Blob 对象有一个 size 属性和一个 type 属性，还有一个 slice() 方法用于进一步切分数据。另外也可以使用 FileReader 从 Blob 中读取数据。下面的例子只会读取文件的前 32 字节：</p>
<pre><code class="language-js">let filesList = document.getElementById('files-list')
filesList.addEventListener('change', (event) =&gt; {
  let info = '',
    output = document.getElementById('output'),
    progress = document.getElementById('progress'),
    files = event.target.files,
    reader = new FileReader(),
    blob = blobSlice(files[0], 0, 32)
  if (blob) {
    reader.readAsText(blob)
    reader.onerror = function () {
      output.innerHTML =
        'Could not read file, error code is ' + reader.error.code
    }
    reader.onload = function () {
      output.innerHTML = reader.result
    }
  } else {
    console.log(&quot;Your browser doesn't support slice().&quot;)
  }
})
</code></pre>
<p>只读取部分文件可以节省时间，特别是在只需要数据特定部分比如文件头的时候。</p>
<h3 id="22-对象-url-与-blob"><a class="header" href="#22-对象-url-与-blob">2.2 对象 URL 与 Blob</a></h3>
<p>对象 URL 有时候也称作 Blob URL，是指引用存储在 File 或 Blob 中数据的 URL。对象 URL 的优点是不用把文件内容读取到 JavaScript 也可以使用文件。只要在适当位置提供对象 URL 即可。要创建对象 URL，可以使用 window.URL.createObjectURL() 方法并传入 File 或 Blob 对象。这个函数返回的值是一个指向内存中地址的字符串。因为这个字符串是 URL，所以可以在 DOM 中直接使用。例如，以下代码使用对象 URL 在页面中显示了一张图片：</p>
<pre><code class="language-js">let filesList = document.getElementById('files-list')
filesList.addEventListener('change', (event) =&gt; {
  let info = '',
    output = document.getElementById('output'),
    progress = document.getElementById('progress'),
    files = event.target.files,
    reader = new FileReader(),
    url = window.URL.createObjectURL(files[0])
  if (url) {
    if (/image/.test(files[0].type)) {
      output.innerHTML = `&lt;img src=&quot;${url}&quot;&gt;`
    } else {
      output.innerHTML = 'Not an image.'
    }
  } else {
    output.innerHTML = &quot;Your browser doesn't support object URLs.&quot;
  }
})
</code></pre>
<p>如果把对象 URL 直接放到<code>&lt;img&gt;</code>标签，就不需要把数据先读到 JavaScript 中了。 <code>&lt;img&gt;</code>标签可以直接从相应的内存位置把数据读取到页面上。</p>
<p>使用完数据之后，最好能释放与之关联的内存。只要对象 URL 在使用中，就不能释放内存。如果想表明不再使用某个对象 URL，则可以把它传给 window.URL.revokeObjectURL()。页面卸载时，所有对象 URL 占用的内存都会被释放。不过，最好在不使用时就立即释放内存，以便尽可能保持页面占用最少资源。</p>
<h2 id="三-读取拖放文件"><a class="header" href="#三-读取拖放文件">三 读取拖放文件</a></h2>
<p>组合使用 HTML5 拖放 API 与 File API 可以创建读取文件信息的有趣功能。在页面上创建放置目标后，可以从桌面上把文件拖动并放到放置目标。这样会像拖放图片或链接一样触发 drop 事件。被放置的文件可以通过事件的 event.dataTransfer.files 属性读到，这个属性保存着一组 File 对象，就像文本输入字段一样。</p>
<p>下面的例子会把拖放到页面放置目标上的文件信息打印出来：</p>
<pre><code class="language-js">let droptarget = document.getElementById('droptarget')
function handleEvent(event) {
  let info = '',
    output = document.getElementById('output'),
    files,
    i,
    len
  event.preventDefault()
  if (event.type == 'drop') {
    files = event.dataTransfer.files
    i = 0
    len = files.length
    while (i &lt; len) {
      info += `${files[i].name} (${files[i].type}, ${files[i].size} bytes)&lt;br&gt;`
      i++
    }
    output.innerHTML = info
  }
}
droptarget.addEventListener('dragenter', handleEvent)
droptarget.addEventListener('dragover', handleEvent)
droptarget.addEventListener('drop', handleEvent)
</code></pre>
<p>贴士：必须取消 dragenter、dragover 和 drop 的默认行为。在 drop 事件处理程序中，可以通过 event.dataTransfer.files 读到文件，此时可以获取文件的相关信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="103-javascriptapi-stream-流对象"><a class="header" href="#103-javascriptapi-stream-流对象">10.3-JavaScriptAPI-Stream 流对象</a></h1>
<h2 id="一-理解流"><a class="header" href="#一-理解流">一 理解流</a></h2>
<p>Streams API 诞生原因：Web 应用如何消费有序的小信息块，而不是大块信息，比如：</p>
<ul>
<li>大块数据可能不会一次性都可用。比如网络请求中，网络负载是以连续信息包形式交付的，而流式处理可以让应用在数据一到达就能使用，而不必等到所有数据都加载完毕。</li>
<li>大块数据可能需要分小部分处理。视频处理、数据压缩、图像编码和 JSON 解析都是可以分成小部分进行处理，而不必等到所有数据都在内存中时再处理的例子。</li>
</ul>
<p>流类似于管道中液体的流动，所以 JS 也借用了管道这个概念，不过流是为映射低级 I/O 原语而设计的，主要解决的问题是：网络请求处理、磁盘读写处理。</p>
<p>流主要有三种：</p>
<ul>
<li>可读流：可以通过某个公共接口读取数据块的流。数据在内部从底层源进入流，然后由消费者（consumer）进行处理。</li>
<li>可写流：可以通过某个公共接口写入数据块的流。生产者（producer）将数据写入流，数据在内部传入底层数据槽（sink）。</li>
<li>转换流：由两种流组成，可写流用于接收数据（可写端），可读流用于输出数据（可读端）。这两个流之间是转换程序（transformer），可以根据需要检查和修改流内容。</li>
</ul>
<p>流的基本单位是块（chunk）。块可是任意数据类型，但通常是定型数组。每个块都是离散的流片段，可以作为一个整体来处理。更重要的是，块不是固定大小的，也不一定按固定间隔到达。在理想的流当中，块的大小通常近似相同，到达间隔也近似相等。不过好的流实现需要考虑边界情况。</p>
<p>由于各种类型的流都有入口和出口的概念，有时候，由于数据进出速率不同，可能会出现不匹配的情况。为此流平衡可能出现如下三种情形：</p>
<ul>
<li>流出口处理数据的速度比入口提供数据的速度快。流出口经常空闲（可能意味着流入口效率较低），但只会浪费一点内存或计算资源，因此这种流的不平衡是可以接受的。</li>
<li>流入和流出均衡。这是理想状态。</li>
<li>流入口提供数据的速度比出口处理数据的速度快。这种流不平衡是固有的问题。此时一定会在某个地方出现数据积压，流必须相应做出处理。</li>
</ul>
<p>流不平衡是常见问题，但流也提供了解决这个问题的工具。所有流都会为已进入流但尚未离开流的块提供一个内部队列。对于均衡流，这个内部队列中会有零个或少量排队的块，因为流出口块出列的速度与流入口块入列的速度近似相等。这种流的内部队列所占用的内存相对比较小。</p>
<p>如果块入列速度快于出列速度，则内部队列会不断增大。流不能允许其内部队列无限增大，因此它会使用反压（backpressure）通知流入口停止发送数据，直到队列大小降到某个既定的阈值之下。这个阈值由排列策略决定，这个策略定义了内部队列可以占用的最大内存，即高水位线（high water mark）。</p>
<h2 id="二-可读流"><a class="header" href="#二-可读流">二 可读流</a></h2>
<h3 id="20-可读流概念"><a class="header" href="#20-可读流概念">2.0 可读流概念</a></h3>
<p>可读流是对底层数据源的封装。底层数据源可以将数据填充到流中，允许消费者通过流的公共接口读取数据。</p>
<h3 id="21-readablestreamdefaultcontroller"><a class="header" href="#21-readablestreamdefaultcontroller">2.1 ReadableStreamDefaultController</a></h3>
<p>下面的生成器每 1000 毫秒就会生成一个递增的整数：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}
</code></pre>
<p>这个生成器的值可以通过可读流的控制器传入可读流。访问这个控制器最简单的方式就是创建 ReadableStream 的一个实例，并在这个构造函数的 underlyingSource 参数（第一个参数）中定义 start() 方法，然后在这个方法中使用作为参数传入的 controller。默认情况下，这个控制器参数是 ReadableStreamDefaultController 的一个实例：</p>
<pre><code class="language-js">const readableStream = new ReadableStream({
  start(controller) {
    console.log(controller) // ReadableStreamDefaultController {}
  },
})
</code></pre>
<p>调用控制器的 enqueue() 方法可以把值传入控制器。所有值都传完之后，调用 close() 关闭流：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}
const readableStream = new ReadableStream({
  async start(controller) {
    for await (let chunk of ints()) {
      controller.enqueue(chunk)
    }
    controller.close()
  },
})
</code></pre>
<h3 id="22-readablestreamdefaultreader"><a class="header" href="#22-readablestreamdefaultreader">2.2 ReadableStreamDefaultReader</a></h3>
<p>前面的例子把 5 个值加入了流的队列，但没有把它们从队列中读出来。为此，需要一个 ReadableStreamDefaultReader 的实例，该实例可以通过流的 getReader() 方法获取。调用这个方法会获得流的锁，保证只有这个读取器可以从流中读取值：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}
const readableStream = new ReadableStream({
  async start(controller) {
    for await (let chunk of ints()) {
      controller.enqueue(chunk)
    }
    controller.close()
  },
})

console.log(readableStream.locked) // false
const readableStreamDefaultReader = readableStream.getReader()
console.log(readableStream.locked) // true
</code></pre>
<p>消费者使用这个读取器实例的 read() 方法可以读出值：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}

const readableStream = new ReadableStream({
  async start(controller) {
    for await (let chunk of ints()) {
      controller.enqueue(chunk)
    }
    controller.close()
  },
})

console.log(readableStream.locked) // false
const readableStreamDefaultReader = readableStream.getReader()
console.log(readableStream.locked) // true

// 消费者
;(async function () {
  while (true) {
    const { done, value } = await readableStreamDefaultReader.read()
    if (done) {
      break
    } else {
      console.log(value)
    }
  }
})()
// 0
// 1
// 2
// 3
// 4
</code></pre>
<h2 id="三-可写流"><a class="header" href="#三-可写流">三 可写流</a></h2>
<h3 id="30-可写流概念"><a class="header" href="#30-可写流概念">3.0 可写流概念</a></h3>
<p>可写流是底层数据槽的封装。底层数据槽处理通过流的公共接口写入的数据。</p>
<h3 id="31-创建-writablestream"><a class="header" href="#31-创建-writablestream">3.1 创建 WritableStream</a></h3>
<p>下面的生成器每 1000 毫秒就会生成一个递增的整数：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}
</code></pre>
<p>这些值通过可写流的公共接口可以写入流。在传给 WritableStream 构造函数的 underlyingSink 参数中，通过实现 write() 方法可以获得写入的数据：</p>
<pre><code class="language-js">const readableStream = new ReadableStream({
  write(value) {
    console.log(value)
  },
})
</code></pre>
<h3 id="32-writablestreamdefaultwriter"><a class="header" href="#32-writablestreamdefaultwriter">3.2 WritableStreamDefaultWriter</a></h3>
<p>要把获得的数据写入流，可以通过流的 getWriter() 方法获取 WritableStreamDefaultWriter 的实例。这样会获得流的锁，确保只有一个写入器可以向流中写入数据：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}

const writableStream = new WritableStream({
  write(value) {
    console.log(value)
  },
})

console.log(writableStream.locked) // false
const writableStreamDefaultWriter = writableStream.getWriter()
console.log(writableStream.locked) // true
</code></pre>
<p>在向流中写入数据前，生产者必须确保写入器可以接收值。writableStreamDefaultWriter.ready 返回一个期约，此期约会在能够向流中写入数据时解决。然后，就可以把值传给 writableStreamDefaultWriter.write() 方法。写入数据之后，调用 writableStreamDefaultWriter.close() 将流关闭：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}

const writableStream = new WritableStream({
  write(value) {
    console.log(value)
  },
})

console.log(writableStream.locked) // false
const writableStreamDefaultWriter = writableStream.getWriter()
console.log(writableStream.locked) // true

// 生产者
;(async function () {
  for await (let chunk of ints()) {
    await writableStreamDefaultWriter.ready
    writableStreamDefaultWriter.write(chunk)
  }
  writableStreamDefaultWriter.close()
})()
</code></pre>
<h2 id="四-转换流"><a class="header" href="#四-转换流">四 转换流</a></h2>
<p>转换流用于组合可读流和可写流。数据块在两个流之间的转换是通过 transform() 方法完成的。</p>
<p>下面的生成器每 1000 毫秒就会生成一个递增的整数：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}
</code></pre>
<p>下面的代码创建了一个 TransformStream 的实例，通过 transform() 方法将每个值翻倍：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}
const { writable, readable } = new TransformStream({
  transform(chunk, controller) {
    controller.enqueue(chunk * 2)
  },
})
</code></pre>
<p>向转换流的组件流（可读流和可写流）传入数据和从中获取数据，与前面的方法相同：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}

const { writable, readable } = new TransformStream({
  transform(chunk, controller) {
    controller.enqueue(chunk * 2)
  },
})

const readableStreamDefaultReader = readable.getReader()
const writableStreamDefaultWriter = writable.getWriter()

// 消费者
;(async function () {
  while (true) {
    const { done, value } = await readableStreamDefaultReader.read()
    if (done) {
      break
    } else {
      console.log(value)
    }
  }
})()

// 生产者
;(async function () {
  for await (let chunk of ints()) {
    await writableStreamDefaultWriter.ready
    writableStreamDefaultWriter.write(chunk)
  }
  writableStreamDefaultWriter.close()
})()
</code></pre>
<h2 id="五-通过管道连接流"><a class="header" href="#五-通过管道连接流">五 通过管道连接流</a></h2>
<p>流可以通过管道连接成一串。最常见的用例是使用 pipeThrough() 方法把 ReadableStream 接入 TransformStream。从内部看，ReadableStream 先把自己的值传给 TransformStream 内部的 WritableStream，然后执行转换，接着转换后的值又在新的 ReadableStream 上出现。下面的例子将一个整数的 ReadableStream 传入 TransformStream，TransformStream 对每个值做加倍处理：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}
const integerStream = new ReadableStream({
  async start(controller) {
    for await (let chunk of ints()) {
      controller.enqueue(chunk)
    }
    controller.close()
  },
})
const doublingStream = new TransformStream({
  transform(chunk, controller) {
    controller.enqueue(chunk * 2)
  },
})
// 通过管道连接流
const pipedStream = integerStream.pipeThrough(doublingStream)
// 从连接流的输出获得读取器
const pipedStreamDefaultReader = pipedStream.getReader()
// 消费者
;(async function () {
  while (true) {
    const { done, value } = await pipedStreamDefaultReader.read()
    if (done) {
      break
    } else {
      console.log(value)
    }
  }
})()
// 0
// 2
// 4
// 6
// 8
</code></pre>
<p>使用 pipeTo() 方法也可以将 ReadableStream 连接到 WritableStream。整个过程与使用 pipeThrough() 类似：</p>
<pre><code class="language-js">async function* ints() {
  // 每 1000 毫秒生成一个递增的整数
  for (let i = 0; i &lt; 5; ++i) {
    yield await new Promise((resolve) =&gt; setTimeout(resolve, 1000, i))
  }
}
const integerStream = new ReadableStream({
  async start(controller) {
    for await (let chunk of ints()) {
      controller.enqueue(chunk)
    }
    controller.close()
  },
})
const writableStream = new WritableStream({
  write(value) {
    console.log(value)
  },
})
const pipedStream = integerStream.pipeTo(writableStream)
// 0
// 1
// 2
// 3
// 4
</code></pre>
<p>这里的管道连接操作隐式从 ReadableStream 获得了一个读取器，并把产生的值填充到 WritableStream。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="104-javascriptapi-web-加密对象"><a class="header" href="#104-javascriptapi-web-加密对象">10.4-JavaScriptAPI-Web 加密对象</a></h1>
<h2 id="一-web-cryptography-api"><a class="header" href="#一-web-cryptography-api">一 Web Cryptography API</a></h2>
<p>Web Cryptography API 描述了一套密码学工具，规范了 JavaScript 如何以安全和符合惯例的方式实现加密。这些工具包括生成、使用和应用加密密钥对，加密和解密消息，以及可靠地生成随机数。</p>
<h2 id="二-生成随机数"><a class="header" href="#二-生成随机数">二 生成随机数</a></h2>
<p>在需要生成随机值时，很多人会使用 Math.random()。这个方法在浏览器中是以伪随机数生成器（PRNG，PseudoRandom Number Generator）方式实现的。所谓“伪”指的是生成值的过程不是真的随机。</p>
<p>PRNG 生成的值只是模拟了随机的特性。浏览器的 PRNG 并未使用真正的随机源，只是对一个内部状态应用了固定的算法。每次调用 Math.random()，这个内部状态都会被一个算法修改，而结果会被转换为一个新的随机值。例如，V8 引擎使用了一个名为 xorshift128+的算法来执行这种修改。</p>
<p>由于算法本身是固定的，其输入只是之前的状态，因此随机数顺序也是确定的。xorshift128+使用 128 位内部状态，而算法的设计让任何初始状态在重复自身之前都会产生 2128–1 个伪随机值。这种循环被称为置换循环（permutation cycle），而这个循环的长度被称为一个周期（period）。很明显，如果攻击者知道 PRNG 的内部状态，就可以预测后续生成的伪随机值。如果开发者无意中使用 PRNG 生成了私有密钥用于加密，则攻击者就可以利用 PRNG 的这个特性算出私有密钥。</p>
<p>伪随机数生成器主要用于快速计算出看起来随机的值。不过并不适合用于加密计算。为解决这个问题，密码学安全伪随机数生成器（CSPRNG，Cryptographically Secure PseudoRandom Number Generator）额外增加了一个熵作为输入，例如测试硬件时间或其他无法预计行为的系统特性。这样一来，计算速度明显比常规 PRNG 慢很多，但 CSPRNG 生成的值就很难预测，可以用于加密了。</p>
<p>Web Cryptography API 的 CSPRNG 可以通过 crypto.getRandomValues() 在全局 Crypto 对象上访问。与 Math.random() 返回一个介于 0 和 1 之间的浮点数不同，getRandomValues() 会把随机值写入作为参数传给它的定型数组。定型数组的类不重要，因为底层缓冲区会被随机的二进制位填充。</p>
<p>生成 5 个 8 位随机值示例：</p>
<pre><code class="language-js">const array = new Uint8Array(1)
for (let i = 0; i &lt; 5; ++i) {
  console.log(crypto.getRandomValues(array))
}
// Uint8Array [41]
// Uint8Array [250]
// Uint8Array [51]
// Uint8Array [129]
// Uint8Array [35]
</code></pre>
<p>要使用 CSPRNG 重新实现 Math.random()，可以通过生成一个随机的 32 位数值，然后用它去除最大的可能值 0xFFFFFFFF。这样就会得到一个介于 0 和 1 之间的值：</p>
<pre><code class="language-js">function randomFloat() {
  // 生成 32 位随机值
  const fooArray = new Uint32Array(1)
  // 最大值是 2^32 –1
  const maxUint32 = 0xffffffff
  // 用最大可能的值来除
  return crypto.getRandomValues(fooArray)[0] / maxUint32
}
console.log(randomFloat()) // 0.5033651619458955
</code></pre>
<h2 id="三-密码学"><a class="header" href="#三-密码学">三 密码学</a></h2>
<h3 id="31-生成密码学摘要"><a class="header" href="#31-生成密码学摘要">3.1 生成密码学摘要</a></h3>
<p>Web Cryptography API 重头特性都暴露在了 SubtleCrypto 对象上，可以通过 window.crypto.subtle 访问。</p>
<p>这个对象包含一组方法，用于执行常见的密码学功能，如加密、散列、签名和生成密钥。因为所有密码学操作都在原始二进制数据上执行，所以 SubtleCrypto 的每个方法都要用到 ArrayBuffer 和 ArrayBufferView 类型 。由于字符串是密码学操作的重要应用场景，因此 TextEncoder 和 TextDecoder 是经常与 SubtleCrypto 一起使用的类，用于实现二进制数据与字符串之间的相互转换。</p>
<p>注意 SubtleCrypto 对象只能在安全上下文（ https）中使用。在不安全的上下文中，subtle 属性是 undefined。</p>
<p>计算数据的密码学摘要算法有四种：SHA-1、SHA-2（包括 3 种方式：SHA-256、SHA-384 和 SHA-512）。</p>
<p>SubtleCrypto.digest() 方法用于生成消息摘要：</p>
<pre><code class="language-js">;(async function () {
  const textEncoder = new TextEncoder()
  const message = textEncoder.encode('foo')
  const messageDigest = await crypto.subtle.digest('SHA-256', message)
  console.log(new Uint32Array(messageDigest))
})()
// Uint32Array(8) [1806968364, 2412183400, 1011194873, 876687389,
// 1882014227, 2696905572, 2287897337, 2934400610]
</code></pre>
<p>通常，在使用时，二进制的消息摘要会转换为十六进制字符串格式。通过将二进制数据按 8 位进行分割，然后再调用 toString(16) 就可以把任何数组缓冲区转换为十六进制字符串：</p>
<pre><code class="language-js">;(async function () {
  const textEncoder = new TextEncoder()
  const message = textEncoder.encode('foo')
  const messageDigest = await crypto.subtle.digest('SHA-256', message)
  const hexDigest = Array.from(new Uint8Array(messageDigest))
    .map((x) =&gt; x.toString(16).padStart(2, '0'))
    .join('')
  console.log(hexDigest)
})()
// 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae
</code></pre>
<p>软件公司通常会公开自己软件二进制安装包的摘要，以便用户验证自己下载到的确实是该公司发布的版本（而不是被恶意软件篡改过的版本）。下面的例子演示了下载 Firefox v67.0，通过 SHA-512 计算其散列，再下载其 SHA-512 二进制验证摘要，最后检查两个十六进制字符串匹配：</p>
<pre><code class="language-js">;(async function () {
  const mozillaCdnUrl =
    '// downloadorigin.cdn.mozilla.net/pub/firefox/releases/67.0 /'
  const firefoxBinaryFilename = 'linux-x86_64/en-US/firefox-67.0.tar.bz2'
  const firefoxShaFilename = 'SHA512SUMS'
  console.log('Fetching Firefox binary...')
  const fileArrayBuffer = await (
    await fetch(mozillaCdnUrl + firefoxBinaryFilename)
  ).arrayBuffer()
  console.log('Calculating Firefox digest...')
  const firefoxBinaryDigest = await crypto.subtle.digest(
    'SHA-512',
    fileArrayBuffer
  )
  const firefoxHexDigest = Array.from(new Uint8Array(firefoxBinaryDigest))
    .map((x) =&gt; x.toString(16).padStart(2, '0'))
    .join('')
  console.log('Fetching published binary digests...')
  // SHA 文件包含此次发布的所有 Firefox 二进制文件的摘要，
  // 因此要根据其格式进制拆分
  const shaPairs = (
    await (await fetch(mozillaCdnUrl + firefoxShaFilename)).text()
  )
    .split(/\n/)
    .map((x) =&gt; x.split(/\s+/))
  let verified = false
  console.log('Checking calculated digest against published digests...')
  for (const [sha, filename] of shaPairs) {
    if (filename === firefoxBinaryFilename) {
      if (sha === firefoxHexDigest) {
        verified = true
        break
      }
    }
  }
  console.log('Verified:', verified)
})()
// Fetching Firefox binary...
// Calculating Firefox digest...
// Fetching published binary digests...
// Checking calculated digest against published digests...
// Verified: true
</code></pre>
<h3 id="32-cryptokey-与算法"><a class="header" href="#32-cryptokey-与算法">3.2 CryptoKey 与算法</a></h3>
<p>如果没了密钥，那密码学也就没什么意义了。 SubtleCrypto 对象使用 CryptoKey 类的实例来生成密钥。 CryptoKey 类支持多种加密算法，允许控制密钥抽取和使用。CryptoKey 类支持很多算法，按各自的父密码系统归类，常用的有：</p>
<pre><code class="language-txt">RSA（ Rivest-Shamir-Adleman）：公钥密码系统，使用两个大素数获得一对公钥和私钥，可用于签名/验证或加密/解密消息。RSA 的陷门函数被称为分解难题（factoring problem）。

ECC（ Elliptic-Curve Cryptography）：公钥密码系统，使用一个素数和一个椭圆曲线获得一对公钥和私钥，可用于签名/验证消息。ECC 的陷门函数被称为椭圆曲线离散对数问题（elliptic curvediscrete logarithm problem）。ECC 被认为优于 RSA。虽然 RSA 和 ECC 在密码学意义上都很强，但 ECC 密钥比 RSA 密钥短，而且 ECC 密码学操作比 RSA 操作快。

AES（Advanced Encryption Standard）：对称密钥密码系统，使用派生自置换组合网络的分组密码加密和解密数据。AES 在不同模式下使用，不同模式算法的特性也不同。
</code></pre>
<h3 id="33-生成-cryptokey"><a class="header" href="#33-生成-cryptokey">3.3 生成 CryptoKey</a></h3>
<p>window.crypto.subtle 对象包含一组方法，用于执行常见的密码学功能，如加密、散列、签名和生成密钥。因为所有密码学操作都在原始二进制数据上执行，所以 SubtleCrypto 的每个方法都要用到 ArrayBuffer 和 ArrayBufferView 类型。</p>
<p>使用 SubtleCrypto.generateKey() 方法可以生成随机 CryptoKey，这个方法返回一个期约，解决为一个或多个 CryptoKey 实例。使用时需要给这个方法传入一个指定目标算法的参数对象、一个表示密钥是否可以从 CryptoKey 对象中提取出来的布尔值，以及一个表示这个密钥可以与哪个 SubtleCrypto 方法一起使用的字符串数组（keyUsages）。</p>
<p>由于不同的密码系统需要不同的输入来生成密钥，上述参数对象为每种密码系统都规定了必需的输入：</p>
<ul>
<li>RSA 密码系统使用 RsaHashedKeyGenParams 对象；</li>
<li>ECC 密码系统使用 EcKeyGenParams 对象；</li>
<li>HMAC 密码系统使用 HmacKeyGenParams 对象；</li>
<li>AES 密码系统使用 AesKeyGenParams 对象。</li>
</ul>
<p>keyUsages 对象用于说明密钥可以与哪个算法一起使用。至少要包含下列中的一个字符串：</p>
<ul>
<li>encrypt</li>
<li>decrypt</li>
<li>sign</li>
<li>verify</li>
<li>deriveKey</li>
<li>deriveBits</li>
<li>wrapKey</li>
<li>unwrapKey</li>
</ul>
<p>假设要生成一个满足如下条件的对称密钥：支持 AES-CTR 算法，密钥长度 128 位，不能从 CryptoKey 对象中提取，可以跟 encrypt()和 decrypt()方法一起使用。参考代码：</p>
<pre><code class="language-js">;(async function () {
  const params = {
    name: 'AES-CTR',
    length: 128,
  }
  const keyUsages = ['encrypt', 'decrypt']
  const key = await crypto.subtle.generateKey(params, false, keyUsages)
  console.log(key)
  // CryptoKey {type: &quot;secret&quot;, extractable: true, algorithm: {...}, usages: Array(2)}
})()
</code></pre>
<p>假设要生成一个满足如下条件的非对称密钥：支持 ECDSA 算法，使用 P-256 椭圆曲线，可以从 CryptoKey 中提取，可以跟 sign()和 verify()方法一起使用。参考代码：</p>
<pre><code class="language-js">;(async function () {
  const params = {
    name: 'ECDSA',
    namedCurve: 'P-256',
  }
  const keyUsages = ['sign', 'verify']
  const { publicKey, privateKey } = await crypto.subtle.generateKey(
    params,
    true,
    keyUsages
  )
  console.log(publicKey)
  // CryptoKey {type: &quot;public&quot;, extractable: true, algorithm: {...}, usages: Array(1)}
  console.log(privateKey)
  // CryptoKey {type: &quot;private&quot;, extractable: true, algorithm: {...}, usages: Array(1)}
})()
</code></pre>
<h3 id="34-导出和导入密钥"><a class="header" href="#34-导出和导入密钥">3.4 导出和导入密钥</a></h3>
<p>如果密钥是可提取的，那么就可以在 CryptoKey 对象内部暴露密钥原始的二进制内容。使用 exportKey() 方法并指定目标格式（ &quot;raw&quot;、 &quot;pkcs8&quot;、 &quot;spki&quot;或&quot;jwk&quot;）就可以取得密钥。这个方法返回一个期约，解决后的 ArrayBuffer 中包含密钥：</p>
<pre><code class="language-js">;(async function () {
  const params = {
    name: 'AES-CTR',
    length: 128,
  }
  const keyUsages = ['encrypt', 'decrypt']
  const key = await crypto.subtle.generateKey(params, true, keyUsages)
  const rawKey = await crypto.subtle.exportKey('raw', key)
  console.log(new Uint8Array(rawKey))
  // Uint8Array[93, 122, 66, 135, 144, 182, 119, 196, 234, 73, 84, 7, 139, 43, 238,
  // 110]
})()
</code></pre>
<p>与 exportKey() 相反的操作要使用 importKey() 方法实现。importKey() 方法的签名实际上是 generateKey() 和 exportKey() 的组合。下面的方法会生成密钥、导出密钥，然后再导入密钥：</p>
<pre><code class="language-js">;(async function () {
  const params = {
    name: 'AES-CTR',
    length: 128,
  }
  const keyUsages = ['encrypt', 'decrypt']
  const keyFormat = 'raw'
  const isExtractable = true
  const key = await crypto.subtle.generateKey(params, isExtractable, keyUsages)
  const rawKey = await crypto.subtle.exportKey(keyFormat, key)
  const importedKey = await crypto.subtle.importKey(
    keyFormat,
    rawKey,
    params.name,
    isExtractable,
    keyUsages
  )
  console.log(importedKey)
  // CryptoKey {type: &quot;secret&quot;, extractable: true, algorithm: {...}, usages: Array(2)}
})()
</code></pre>
<h3 id="35-从主密钥派生密钥"><a class="header" href="#35-从主密钥派生密钥">3.5 从主密钥派生密钥</a></h3>
<p>使用 SubtleCrypto 对象可以通过可配置的属性从已有密钥获得新密钥。SubtleCrypto 支持一个 deriveKey() 方法和一个 deriveBits() 方法，前者返回一个解决为 CryptoKey 的期约，后者返回一个解决为 ArrayBuffer 的期约。</p>
<p>deriveBits() 方法接收一个算法参数对象、主密钥和输出的位长作为参数。当两个人分别拥有自己的密钥对，但希望获得共享的加密密钥时可以使用这个方法。下面的例子使用 ECDH 算法基于两个密钥对生成了对等密钥，并确保它们派生相同的密钥位：</p>
<pre><code class="language-js">;(async function () {
  const ellipticCurve = 'P-256'
  const algoIdentifier = 'ECDH'
  const derivedKeySize = 128
  const params = {
    name: algoIdentifier,
    namedCurve: ellipticCurve,
  }
  const keyUsages = ['deriveBits']
  const keyPairA = await crypto.subtle.generateKey(params, true, keyUsages)
  const keyPairB = await crypto.subtle.generateKey(params, true, keyUsages)
  // 从 A 的公钥和 B 的私钥派生密钥位
  const derivedBitsAB = await crypto.subtle.deriveBits(
    Object.assign({ public: keyPairA.publicKey }, params),
    keyPairB.privateKey,
    derivedKeySize
  )
  // 从 B 的公钥和 A 的私钥派生密钥位
  const derivedBitsBA = await crypto.subtle.deriveBits(
    Object.assign({ public: keyPairB.publicKey }, params),
    keyPairA.privateKey,
    derivedKeySize
  )
  const arrayAB = new Uint32Array(derivedBitsAB)
  const arrayBA = new Uint32Array(derivedBitsBA)
  // 确保密钥数组相等
  console.log(
    arrayAB.length === arrayBA.length &amp;&amp;
      arrayAB.every((val, i) =&gt; val === arrayBA[i])
  ) // true
})()
</code></pre>
<p>deriveKey() 方法是类似的，只不过返回的是 CryptoKey 的实例而不是 ArrayBuffer。下面的例子基于一个原始字符串，应用 PBKDF2 算法将其导入一个原始主密钥，然后派生了一个 AES-GCM 格式的新密钥：</p>
<pre><code class="language-js">;(async function () {
  const password = 'foobar'
  const salt = crypto.getRandomValues(new Uint8Array(16))
  const algoIdentifier = 'PBKDF2'
  const keyFormat = 'raw'
  const isExtractable = false
  const params = { name: algoIdentifier }
  const masterKey = await window.crypto.subtle.importKey(
    keyFormat,
    new TextEncoder().encode(password),
    params,
    isExtractable,
    ['deriveKey']
  )
  const deriveParams = {
    name: 'AES-GCM',
    length: 128,
  }
  const derivedKey = await window.crypto.subtle.deriveKey(
    Object.assign({ salt, iterations: 1e5, hash: 'SHA-256' }, params),
    masterKey,
    deriveParams,
    isExtractable,
    ['encrypt']
  )
  console.log(derivedKey)
  // CryptoKey {type: &quot;secret&quot;, extractable: false, algorithm: {...}, usages: Array(1)}
})()
</code></pre>
<h3 id="36-使用非对称密钥签名和验证消息"><a class="header" href="#36-使用非对称密钥签名和验证消息">3.6 使用非对称密钥签名和验证消息</a></h3>
<p>通过 SubtleCrypto 对象可以使用公钥算法用私钥生成签名，或者用公钥验证签名。这两种操作分别通过 SubtleCrypto.sign() 和 SubtleCrypto.verify() 方法完成。</p>
<p>签名消息需要传入参数对象以指定算法和必要的值、CryptoKey 和要签名的 ArrayBuffer 或 ArrayBufferView。下面的例子会生成一个椭圆曲线密钥对，并使用私钥签名消息：</p>
<pre><code class="language-js">;(async function () {
  const keyParams = {
    name: 'ECDSA',
    namedCurve: 'P-256',
  }
  const keyUsages = ['sign', 'verify']
  const { publicKey, privateKey } = await crypto.subtle.generateKey(
    keyParams,
    true,
    keyUsages
  )
  const message = new TextEncoder().encode('I am Satoshi Nakamoto')
  const signParams = {
    name: 'ECDSA',
    hash: 'SHA-256',
  }
  const signature = await crypto.subtle.sign(signParams, privateKey, message)
  console.log(new Uint32Array(signature))
  // Uint32Array(16) [2202267297, 698413658, 1501924384, 691450316, 778757775, ... ]
})()
</code></pre>
<p>希望通过这个签名验证消息的人可以使用公钥和 SubtleCrypto.verify() 方法。这个方法的签名几乎与 sign() 相同，只是必须提供公钥以及签名。下面的例子通过验证生成的签名扩展了前面的例子：</p>
<pre><code class="language-js">;(async function () {
  const keyParams = {
    name: 'ECDSA',
    namedCurve: 'P-256',
  }
  const keyUsages = ['sign', 'verify']
  const { publicKey, privateKey } = await crypto.subtle.generateKey(
    keyParams,
    true,
    keyUsages
  )
  const message = new TextEncoder().encode('I am Satoshi Nakamoto')
  const signParams = {
    name: 'ECDSA',
    hash: 'SHA-256',
  }
  const signature = await crypto.subtle.sign(signParams, privateKey, message)
  const verified = await crypto.subtle.verify(
    signParams,
    publicKey,
    signature,
    message
  )
  console.log(verified) // true
})()
</code></pre>
<h3 id="37-使用对称密钥加密和解密"><a class="header" href="#37-使用对称密钥加密和解密">3.7 使用对称密钥加密和解密</a></h3>
<p>SubtleCrypto 对象支持使用公钥和对称算法加密和解密消息。这两种操作分别通过 SubtleCrypto.encrypt() 和 SubtleCrypto.decrypt() 方法完成。</p>
<p>密消息需要传入参数对象以指定算法和必要的值、加密密钥和要加密的数据。下面的例子会生成对称 AES-CBC 密钥，用它加密消息，最后解密消息：</p>
<pre><code class="language-js">;(async function () {
  const algoIdentifier = 'AES-CBC'
  const keyParams = {
    name: algoIdentifier,
    length: 256,
  }
  const keyUsages = ['encrypt', 'decrypt']
  const key = await crypto.subtle.generateKey(keyParams, true, keyUsages)
  const originalPlaintext = new TextEncoder().encode('I am Satoshi Nakamoto')
  const encryptDecryptParams = {
    name: algoIdentifier,
    iv: crypto.getRandomValues(new Uint8Array(16)),
  }
  const ciphertext = await crypto.subtle.encrypt(
    encryptDecryptParams,
    key,
    originalPlaintext
  )
  console.log(ciphertext)
  // ArrayBuffer(32) {}
  const decryptedPlaintext = await crypto.subtle.decrypt(
    encryptDecryptParams,
    key,
    ciphertext
  )
  console.log(new TextDecoder().decode(decryptedPlaintext))
  // I am Satoshi Nakamoto
})()
</code></pre>
<h3 id="38-包装和解包密钥"><a class="header" href="#38-包装和解包密钥">3.8 包装和解包密钥</a></h3>
<p>SubtleCrypto 对象支持包装和解包密钥，以便在非信任渠道传输。这两种操作分别通过 SubtleCrypto.wrapKey() 和 SubtleCrypto.unwrapKey() 方法完成。</p>
<p>包装密钥需要传入一个格式字符串、要包装的 CryptoKey 实例、要执行包装的 CryptoKey，以及一个参数对象用于指定算法和必要的值。下面的例子生成了一个对称 AES-GCM 密钥，用 AES-KW 来包装这个密钥，最后又将包装的密钥解包：</p>
<pre><code class="language-js">;(async function () {
  const keyFormat = 'raw'
  const extractable = true
  const wrappingKeyAlgoIdentifier = 'AES-KW'
  const wrappingKeyUsages = ['wrapKey', 'unwrapKey']
  const wrappingKeyParams = {
    name: wrappingKeyAlgoIdentifier,
    length: 256,
  }
  const keyAlgoIdentifier = 'AES-GCM'
  const keyUsages = ['encrypt']
  const keyParams = {
    name: keyAlgoIdentifier,
    length: 256,
  }
  const wrappingKey = await crypto.subtle.generateKey(
    wrappingKeyParams,
    extractable,
    wrappingKeyUsages
  )
  console.log(wrappingKey)
  // CryptoKey {type: &quot;secret&quot;, extractable: true, algorithm: {...}, usages: Array(2)}
  const key = await crypto.subtle.generateKey(keyParams, extractable, keyUsages)
  console.log(key)
  // CryptoKey {type: &quot;secret&quot;, extractable: true, algorithm: {...}, usages: Array(1)}
  const wrappedKey = await crypto.subtle.wrapKey(
    keyFormat,
    key,
    wrappingKey,
    wrappingKeyAlgoIdentifier
  )
  console.log(wrappedKey)
  // ArrayBuffer(40) {}
  const unwrappedKey = await crypto.subtle.unwrapKey(
    keyFormat,
    wrappedKey,
    wrappingKey,
    wrappingKeyParams,
    keyParams,
    extractable,
    keyUsages
  )
  console.log(unwrappedKey)
  // CryptoKey {type: &quot;secret&quot;, extractable: true, algorithm: {...}, usages: Array(1)}
})()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-网络开发常见问题"><a class="header" href="#附录-网络开发常见问题">附录-网络开发常见问题</a></h1>
<h2 id="一-ie-中的请求缓存问题"><a class="header" href="#一-ie-中的请求缓存问题">一 IE 中的请求缓存问题</a></h2>
<p>IE8 中，请求的信息会被缓存下来，所以后续的请求会先从浏览器中直接获取结果，如果在这之间服务端出现了数据变化，Ajax 的获取到的数据却不会做响应变更。</p>
<p>解决方案：</p>
<pre><code class="language-js">// 在请求地址的后面添加请求参数，每一次请求中的请求参数都不相同
xhr.open('get', 'http://www.demo.com?t=' + Math.random())
</code></pre>
<h2 id="二-beacon-api"><a class="header" href="#二-beacon-api">二 Beacon API</a></h2>
<p>为了把尽量多的页面信息传到服务器，很多分析工具需要在页面生命周期中尽量晚的时候向服务器发送遥测或分析数据。因此，理想的情况下是通过浏览器的 unload 事件发送网络请求。这个事件表示用户要离开当前页面，不会再生成别的有用信息了。</p>
<p>在 unload 事件触发时，分析工具要停止收集信息并把收集到的数据发给服务器。这时候有一个问题，因为 unload 事件对浏览器意味着没有理由再发送任何结果未知的网络请求（因为页面都要被销毁了）。例如，在 unload 事件处理程序中创建的任何异步请求都会被浏览器取消。为此，异步 XMLHttpRequest 或 fetch() 不适合这个任务。分析工具可以使用同步 XMLHttpRequest 强制发送请求，但这样做会导致用户体验问题。浏览器会因为要等待 unload 事件处理程序完成而延迟导航到下一个页面。</p>
<p>为解决这个问题，W3C 引入了补充性的 Beacon API。这个 API 给 navigator 对象增加了一个 sendBeacon() 方法。这个简单的方法接收一个 URL 和一个数据有效载荷参数，并会发送一个 POST 请求。可选的数据有效载荷参数有 ArrayBufferView、Blob、DOMString、FormData 实例。如果请求成功进入了最终要发送的任务队列，则这个方法返回 true，否则返回 false。</p>
<pre><code class="language-js">// 发送 POST 请求
// URL: 'https://example.com/analytics-reporting-url'
// 请求负载： '{foo: &quot;bar&quot;}'
navigator.sendBeacon(
  'https://example.com/analytics-reporting-url',
  '{foo: &quot;bar&quot;}'
)
</code></pre>
<p>这个方法虽然看起来只不过是 POST 请求的一个语法糖，但它有几个重要的特性：</p>
<pre><code class="language-txt">sendBeacon() 并不是只能在页面生命周期末尾使用，而是任何时候都可以使用。
调用 sendBeacon() 后，浏览器会把请求添加到一个内部的请求队列。浏览器会主动地发送队列中的请求。
浏览器保证在原始页面已经关闭的情况下也会发送请求。
状态码、超时和其他网络原因造成的失败完全是不透明的，不能通过编程方式处理。
信标（beacon）请求会携带调用 sendBeacon() 时所有相关的 cookie。
</code></pre>
<h2 id="三-ajax-安全"><a class="header" href="#三-ajax-安全">三 Ajax 安全</a></h2>
<p>大规模 Ajax 应用程序需要考虑的安全问题非常多，但在通用层面上一般需要考虑以下几个问题。</p>
<p>首先，任何 Ajax 可以访问的 URL，也可以通过浏览器或服务器访问，例如下面这个 URL：</p>
<pre><code class="language-txt">/getuserinfo?id=23
</code></pre>
<p>请求这个 URL，可以假定返回 ID 为 23 的用户信息。访问者可以将 23 改为 24 或 56，甚至其他任何值。 getuserinfo 接口必须知道访问者是否拥有访问相应数据的权限。否则，服务器就会大门敞开，泄露所有用户的信息。</p>
<p>在未授权系统可以访问某个资源时，可以将其视为跨站点请求伪造（ CSRF， cross-site request forgery）攻击。未授权系统会按照处理请求的服务器的要求伪装自己。 Ajax 应用程序，无论大小， 都会受到 CSRF 攻击的影响，包括无害的漏洞验证攻击和恶意的数据盗窃或数据破坏攻击。</p>
<p>关于安全防护 Ajax 相关 URL 的一般理论认为，需要验证请求发送者拥有对资源的访问权限。可以通过如下方式实现。</p>
<ul>
<li>要求通过 SSL 访问能够被 Ajax 访问的资源。</li>
<li>要求每个请求都发送一个按约定算法计算好的令牌（ token）。注意，以下手段对防护 CSRF 攻击是无效的。</li>
<li>要求 POST 而非 GET 请求（很容易修改请求方法）。</li>
<li>使用来源 URL 验证来源（来源 URL 很容易伪造）。</li>
<li>基于 cookie 验证（同样很容易伪造）。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-node-简介"><a class="header" href="#011-node-简介">01.1-Node 简介</a></h1>
<h2 id="一-node-初识"><a class="header" href="#一-node-初识">一 Node 初识</a></h2>
<h3 id="11-node-简介"><a class="header" href="#11-node-简介">1.1 Node 简介</a></h3>
<p>Node.js 由 Ryan Dahl 于 2009 年发布，其最初的目的是为了基于 V8 引擎开发一个高性能的异步 Web 服务器。由于 Node 补充了 JavaScript 在 Web 服务端的空白，其自带的网络、文件能力也让 Node 在前端工程化工具领域大放异彩，Node 收获了意想不到的繁荣。</p>
<p>现在可以先厘清一下 ECMAScript 与 V8 的关系：</p>
<ul>
<li>ECMAScript：JavaScript、JScript 等语言的语法标准</li>
<li>V8：解析 JavaScript 语言的引擎</li>
</ul>
<p>有了 ECMAScript 语法、V8 对语法的解析，一个语言就能书写、运行了。但是我们在学习时，经常使用 Chrome 浏览器来运行 JavaScript，因为 Chrome 浏览器内部也内置了 V8，而且在 ECMAScript 的基础上，浏览器给开发者额外提供了 DOM、BOM 的 API。
同理，Node 与 Chrome 浏览器道理一样，因为 Node 内部集成了 V8，其也能运行 JavaScript，但是 Node 没有浏览器额外提供的 DOM、BOM 等 API，而是拥有自己独立的文件、网络操作 API。</p>
<p>JavaScript 现在的运行平台可以总结如下：</p>
<ul>
<li>Chrome 浏览器：使用 V8 作为 JS 解析引擎，额外封装了 DOM、BOM 等页面渲染相关的 API。Chrome 浏览器还拥有 Webkit 排版引擎。</li>
<li>NodeJS：使用 V8 作为 JS 解析引擎，封装了文件、网络的 API。NodeJS 还拥有一个名为 libuv 事件处理库。</li>
</ul>
<p>下图是 Chrome 浏览器与 Node.js 的内核区别：</p>
<p><img src="05-Node.js/../images/node/node-00.svg" alt="Chrome 与 Node 内核区别" /></p>
<p>综上所述，Node 的官网对 Node 的概述非常准确：</p>
<blockquote>
<p>Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.
Node.js 是一个基于 Chrome 的 0i·1 V8 JavaScript 引擎 构建的 JavaScript 运行时。</p>
</blockquote>
<p>贴士：</p>
<ul>
<li>运行平台：为某个语言提供了该平台专属的 API，如浏览器平台，为 JS 提供了 DOM、BOM 操作 API；Node 平台为 JS 提供了文件、网络操作 API</li>
<li>运行时（runtime）：为某个语言提供解析引擎，如 Chrome 的 V8，Firefox 的 SpiderMonkey。运行时的作用是解析编程语言，所以其最核心的特点是要执行编程语言标准，如 ECMAScript，所以其于浏览器、Node，以及各自的事件循环都没有关系，这些平台可以选择任一款 JS 的运行时。</li>
</ul>
<p>当然，Node 的周边生态已经相当繁荣，类似 Java 平台，我们也可以将 Node 理解为一个开发平台：</p>
<pre><code class="language-txt">开发平台：Node            Java
编程语言：JavaScript      Java
runtime：    V8              JVM
包管理器：NPM             Maven
</code></pre>
<h3 id="12-node-核心"><a class="header" href="#12-node-核心">1.2 Node 核心</a></h3>
<p>Node 的核心部分有两部分：</p>
<ul>
<li>V8 引擎：由 C++ 语言开发的编译器，提供解析 JavaScript 语言的能力。该引擎由 Google 公司推出，是 Chrome 浏览器内置的 JavaScript 引擎</li>
<li>libuv：由 C++ 语言开发的异步 I/O 库，在该库基础上，Node 提供了网络、文件等操作系统 API。该库由 Ryan Dahl 自己为了让 Node 拥有异步 I/O 能力亲自开发。</li>
</ul>
<p><img src="05-Node.js/../images/node/node-01.png" alt="Node 架构图" /></p>
<p>Node 内部维护着一个核心线程专门用于处理各种网络请求，对请求对应的事件进行异步分发。binging 一层是 JS 与底层 C++沟通的关键，前者通过 bindings 调用后者，相互交换数据，libuv 为 Node 提供了跨平台、线程池、事件池、异步 IO 能力。</p>
<h3 id="13-node-特点---单线程非严格意义"><a class="header" href="#13-node-特点---单线程非严格意义">1.3 Node 特点 - 单线程（非严格意义）</a></h3>
<p>在传统编程语言中，大多使用多线程来应对并发请求，如 Java、Python。在多线程模型中，每有一个客户端接入服务器，服务端都会创建一个新的线程用来处理该连接，每个线程需要耗费大约 2MB 内存，理论上一台 8G 内存服务器同时只能有 4000 个客户端连接。</p>
<p>Node 本身也是多线程的，但是他与开发平台最大的不同是：在核心业务处理上，只有一个线程，且只用于监听事件的流动。即：负责客户端连接处理的线程只有一个，该线程并不会真正处理连接业务，而是利用事件循环机制，通过非阻塞 I/O 直接将连接处理交给操作系统处理，自己继续接收下一个连接请求。</p>
<p>这样做的意义是：</p>
<ul>
<li>在单线程上处理业务代码，避免了传统语言反复切换线程上下文带来的损耗</li>
<li>在事件循环机制支持下的，非阻塞 I/O 同样能够应对并发问题</li>
</ul>
<h3 id="14-node-特点---非阻塞-io"><a class="header" href="#14-node-特点---非阻塞-io">1.4 Node 特点 - 非阻塞 I/O</a></h3>
<p>Node 天生提供了大量的异步 API，为开发者提供了友好的 非阻塞 I/O 编程环境。</p>
<p>I/O 操作是 Web 领域最有代表性的性能瓶颈之地。在传统开发平台中，发起一个 I/O 操作后，线程会暂停下来，等待 I/O 结束后才能继续执行后续代码，即：I/O 阻塞了代码的执行，这会极大地降低程序的执行效率。</p>
<p>Node 本身就是以异步 API 为基础，如在运行到读取文件代码时，会立即转而执行后续代码，将读取文件的结果放入回调函数中，从而提高了程序的执行效率，如下所示：</p>
<pre><code class="language-js">const fs = require('fs')

fs.readFile('/path', function (err, file) {
  console.log('befroe...')
})

console.log('after....')
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-txt">after...
before...
</code></pre>
<h3 id="14-node-的问题与解决方案"><a class="header" href="#14-node-的问题与解决方案">1.4 Node 的问题与解决方案</a></h3>
<p>虽然单线程非阻塞 I/O 的设计给 Node 应用程序开发提供了极大的性能支持，但是也造成了 2 个极端情况：</p>
<ul>
<li>异步编程体验极度糟糕：由于异步操作的后续结果依赖回调函数，会造成<code>回调地狱</code></li>
<li>单线程带来的阻塞问题：Node 的核心线程一直在循环处理各种事件，该线程一旦要去处理一个耗时操作，就会造成整个 Node 服务暂停。如计算一个效率不高的位运算，那么整个事件循环会因为该运算而停止。</li>
</ul>
<p>但是上述问题在 EcmaScript 的发展下，都得到了很好的解决：</p>
<ul>
<li>回调地狱解决：Node7.6 之后引入了 async/await 编程语法糖，是回调地狱问题的终极解决方案。</li>
<li>单线程阻塞解决：Node10 之后引入 work thread（工作者），耗时操作可以交给新开启的工作者处理。</li>
</ul>
<h3 id="15-node-应用领域"><a class="header" href="#15-node-应用领域">1.5 Node 应用领域</a></h3>
<p>根据 Node 的特点，可以看出 Node 适合 I/O 密集型场景，不适合 CPU 密集型场景，当然 Node10 版本后（worker_threads）该问题也得到了缓解。</p>
<p>Node 目前的主要应用领域：</p>
<ul>
<li><strong>Web 开发</strong>：与 JavaWeb、PyhtonWeb 相同，可以应用于 Web 开发，因为 Web 是最常见的网络 I/O 场景</li>
<li><strong>命令行工具</strong>：目前市面上已经拥有大量的替代 shell 的 Node 开发的命令行工具，最出名的是前端开发领域的构建工具 Webpack</li>
<li><strong>客户端开发</strong>：使用基于 Node 的框架 Electron 可以快速开发跨平台客户端</li>
</ul>
<h2 id="二-node-的安装"><a class="header" href="#二-node-的安装">二 Node 的安装</a></h2>
<h3 id="20-安装简介"><a class="header" href="#20-安装简介">2.0 安装简介</a></h3>
<p>Node 只需要在官网下载对应安装包下一步下一步安装即可，<strong>默认会配置环境变量</strong>。下载界面有两个版本：长期支持版 (LTS)、Current(最新版)，建议使用 LTS 版本，当然 Node 的版本号中偶数位版本一般为稳定版，奇数位版本一般为非稳定版。</p>
<p>但是由于 Node 迭代速度很快，在企业开发中，经常要在多个 Node 版本中切换，使用 Node 的版本管理工具 nvm 来安装 Node，这样可以方便我们控制 Node 的版本。</p>
<blockquote>
<p>贴士：nvm 安装也可以有效避免直接安装可能会出现的权限问题，笔者极力推荐使用 nvm 安装 Node。</p>
</blockquote>
<h3 id="21-nvm-安装方式"><a class="header" href="#21-nvm-安装方式">2.1 NVM 安装方式</a></h3>
<p><strong>第一步：安装 nvm</strong>：</p>
<p><strong>Win 安装 nvm</strong>：Win 上是没有 nvm 的，但是有开发者提供了类似 nvm 的工具，下载地址为：<a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p>
<pre><code class="language-txt"># 安装方式：下载 nvm-setup.zip 直接下一步下一步安装即可

# 安装完毕后查看是否安装成功
nvm version
</code></pre>
<p>Linux 与 Mac 安装：下载地址为 <a href="https://github.com/creationix/nvm">https://github.com/creationix/nvm</a></p>
<pre><code class="language-txt"># 安装方式
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash

# 配置环境变量
vim ~/.bash_profile
export NVM_DIR=&quot;${XDG_CONFIG_HOME/:-$HOME/.}nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
source ~/.bash_profile

# 安装后查看：
nvm version
</code></pre>
<p>注意：新版 Mac 系统默认使用 zsh 作为命令行工具，需要进行调整：</p>
<pre><code class="language-txt">vim ~/.zshrc
setopt no_nomatch
export NVM_DIR=&quot;${XDG_CONFIG_HOME/:-$HOME/.}nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
source ~/.zshrc

# 安装后查看：
nvm version
</code></pre>
<p><strong>第二步：使用 nvm 安装 node</strong>：</p>
<pre><code class="language-txt"># 可以先配置镜像地址
nvm node_mirror https://npm.taobao.org/mirrors/node/    # node 镜像地址
nvm npm_mirror https://npm.taobao.org/mirrors/npm/      # node 包镜像地址

# 安装最新版
nvm install latest
# 安装指定版本
nvm install 8.11.3
# 切换版本
nvm use 8.11.3
# 指定默认版本
nvm alias default 8.5.0

# 查看是否安装成功
node -v
</code></pre>
<h3 id="22-开发工具配置"><a class="header" href="#22-开发工具配置">2.2 开发工具配置</a></h3>
<p>笔者推荐的 NodeJS 开发工具是 VScode/WebStorm。</p>
<p>如果是使用 VSCode 开发，推荐安装插件：</p>
<pre><code class="language-txt">Code Runner：用于快速右键运行 node 代码
Search node_modules：用于 node 包快速提示
</code></pre>
<p>如果使用 WebStorme（或者 IDEA+Node 插件），则可能需要配置下 node 环境：</p>
<p>打开 WebStorme，在设置中界面中选择：<code>File-setting-Languages&amp;Frameworks-Node</code>，对比下图进行勾选：</p>
<p><img src="05-Node.js/../images/node/idea.jpg" alt="WebStorme 配置 Node 环境" /></p>
<h2 id="三-node-的使用"><a class="header" href="#三-node-的使用">三 Node 的使用</a></h2>
<h3 id="31-repl-环境"><a class="header" href="#31-repl-环境">3.1 REPL 环境</a></h3>
<p>Node 默认提供了一个命令环境用来基础使用，类似 Chrome 浏览器中的 Console 模块：</p>
<pre><code class="language-txt"># 打开命令行窗口，输入 node 命令，即可进入 REPL 环境
node

# 输入
1+1

# 回车后界面将会显示
2
</code></pre>
<h3 id="32-node-执行-js-文件"><a class="header" href="#32-node-执行-js-文件">3.2 Node 执行 JS 文件</a></h3>
<p>REPL 环境过于简单，Node 是可以直接运行 JS 文件的，创建一个 <code>app.js</code> 文件，内容如下：</p>
<pre><code class="language-js">console.log(1 + 1)
</code></pre>
<p>在学习 Node 之前，该 JS 文件只能嵌入在 HTML 文档中，由浏览器来运行，现在 Node 命令可以直接运行：</p>
<pre><code class="language-txt">node app.js                 # 可以省略 .js 后缀

# 输出 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-常见核心模块"><a class="header" href="#021-常见核心模块">02.1-常见核心模块</a></h1>
<h2 id="零-node-基础知识"><a class="header" href="#零-node-基础知识">零-Node 基础知识</a></h2>
<h3 id="01-node-全局对象汇总"><a class="header" href="#01-node-全局对象汇总">0.1 Node 全局对象汇总</a></h3>
<p>为了方便操作，Node 默认提供了一些全局对象，这些对象的使用无需 <code>手动导入</code>，在任何地方都可以直接使用：</p>
<ul>
<li><code>console</code>：控制台输入输出对象</li>
<li>定时器：如 <code>setTimeout</code>,<code>setTimeInterval</code></li>
<li><code>global</code>：用于挂载全局变量</li>
<li><code>process</code>：用于获取系统运行信息</li>
<li><code>buffer</code>：缓存模块</li>
<li><code>stream</code>: 流模块</li>
<li><code>exports</code>：用于支持模块导出</li>
<li><code>module</code>：用于支持文件模块化</li>
<li><code>require</code>：该函数用于导入模块</li>
</ul>
<p>在原生 js 中定义全局变量，浏览器中可以通过 window 顶层对象访问（即全局变量是顶层对象的属性）：</p>
<pre><code class="language-js">let a = 100
console.log(window.a)
</code></pre>
<p>Node 没有 window 这个顶层对象，Node 自身的顶层对象是 global，定义全局变量方式：</p>
<pre><code class="language-js">a = 3 // 第一种定义全局变量方式，如果使用 var a = 3; global 是无法访问到的。
global.b = 3 // 第二种定义全局变量方式

console.log(a)
console.log(b)
</code></pre>
<p>console 与 浏览器中的 console 用法一致，但是二者却不是同一种实现，Node 中的 console 借助了操作系统来实现。</p>
<p>常见用法如下：</p>
<pre><code class="language-js">console.log() // 打印信息
console.info() // 返回信息性质的信息，控制台会显示蓝色惊叹号
console.error() // 打印错误信息，控制台会显示红色叉子
console.dir() // 对对象进行检查，并显示
console.time() // 计时开始
console.timeEnd() // 计时结束
console.trace() // 输出当前代码在堆栈中调用路径
</code></pre>
<p>Node 中的定时器与浏览器中的定时器用法一致，这里不做过多介绍。</p>
<h2 id="一-fs-模块"><a class="header" href="#一-fs-模块">一 fs 模块</a></h2>
<h3 id="10-fs-模块简介"><a class="header" href="#10-fs-模块简介">1.0 fs 模块简介</a></h3>
<p>fs 模块即：文件模块，是 Node 的核心模块，提供了操作文件的一些 API。</p>
<p>API 地址：<a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p>
<p>文件模块针对同一个业务提供了 异步、同步两种操作方式，比如读取文件：<code>readFile()、readFileSync()</code>。</p>
<h3 id="11-打开文件-open"><a class="header" href="#11-打开文件-open">1.1 打开文件 open()</a></h3>
<p>该 API 用于打开文件，可以获取文件描述符：</p>
<pre><code class="language-txt">调用格式：
    fs.open(path,flags,[mode],callback);
参数介绍：
    path：要打开的文件的路径（推荐相对路径用 ./开头，为了兼容）
    flags：打开文件的方式  读/写
    mode：设置文件的模式  读/写/执行 分别对应 4/2/2
    callback：回调
    err：打开失败后保存的错误对象，如果成功，err 为 null
    fd：被打开文件的标识
</code></pre>
<p>案例：</p>
<pre><code class="language-js">const fs = require('fs')

fs.open('./1.html', 'r', function (err, fd) {
  if (err) {
    console.log('open file err:', err)
  } else {
    console.log(&quot;file's fd:&quot;) //输出 3
  }
})
</code></pre>
<h3 id="12-读取文件-readfile"><a class="header" href="#12-读取文件-readfile">1.2 读取文件 readFile()</a></h3>
<p>该 API 用于读取文件，可以从一个特定文件描述符中读取数据：</p>
<pre><code class="language-txt">调用格式：
    fs.read(fd,buffer,offset,length,position,callback);
参数介绍：
    fd：通过 fs.open() 方法返回的文件描述符
    buffer：数据写入的缓冲区
    offset：缓冲区写入的写入偏移量
    length：要从文件中读取的字节数
    position：文件读取的起始位置，如果为 null，就会从当前文件指针的位置读取；
    callback：有 err，bytesRead，buffer 三个参数，bytesRead 表示读取的字节数，buffer 为缓冲区对象。
</code></pre>
<p>案例：</p>
<pre><code class="language-js">const fs = require('fs')

//可选参数 - 字符集：{'charset':'utf8'}
fs.readFile('./1.html', function (err, data) {
  if (err) {
    throw err
  }
  // data 是二进制 Buffer 格式，必须先转换
  console.log(data.toString())
})
</code></pre>
<p>注意：readFile 会将一个文件的内容全部读取到内存中，只适用于体积较小的文本文件。</p>
<h3 id="13-写入文件-writefile-appendfile"><a class="header" href="#13-写入文件-writefile-appendfile">1.3 写入文件 writeFile() appendFile()</a></h3>
<p>这 2 个 API 都可以实现异步地将数据写入一个文件，如果文件不存在则创建，如果文件存在，则替换。data 参数可以是一个 string，也可以是一个 buffer：</p>
<pre><code class="language-txt">替换文件内的内容：
    fs.writeFile(filename,data,[options],callback);

向文件追加内容：
    fs.appendFile(path, data[, options], callback);
</code></pre>
<h3 id="14-监听文件-watch"><a class="header" href="#14-监听文件-watch">1.4 监听文件 watch()</a></h3>
<p>监听文件的变化：</p>
<pre><code class="language-txt">调用格式：
    fs.wathc(filename,[options],[listener]);
使用说明：
    观察文件的改变，filename 可以是文件或者目录，返回的对象是：fs.FSWatcher。第二个参数为布尔值，默认为 true，代表只要文件被监听，就继续执行。
</code></pre>
<p>示例：</p>
<pre><code class="language-js">const fs = require('fs')

fs.watch('./1.html', function (ev, fn) {
  console.log(ev)
  if (fn) {
    console.log(fn + '发生了改变')
  } else {
    console.log('...')
  }
})
</code></pre>
<h2 id="二-path-模块"><a class="header" href="#二-path-模块">二 path 模块</a></h2>
<p>API 地址：<a href="http://nodejs.cn/api/path.html">http://nodejs.cn/api/path.html</a></p>
<p>该模块用于处理路径中常见的问题，如拼接路径时候，需要考虑兼容不同系统的分隔符（win 中的''，linux 中的'/'），又比如 2 个路径在拼接时，需要考虑前一个路径末尾是否带分隔符。有了 path 模块，默认会处理这些问题：</p>
<p>连接路径：</p>
<pre><code class="language-js">const path = require('path')

// 返回：'/foo/bar/baz/asdf'
path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')

let myurl = path.join(__dirname, 'username', '123')
console.log(myurl) //输出类似这样的绝对路径：/Test/username/123
</code></pre>
<p>__dirname 和 path.dirname 的区别：</p>
<pre><code class="language-js">console.log(__dirname) // 指向被执行 js 文件的绝对路径，包含的有文件名称
console.log(path.dirname('/abc/www/abc.txt')) // 只有路径，没有文件名称
</code></pre>
<p>获取路径的最后一部分：</p>
<pre><code class="language-js">path.basename('/foo/bar/aaa.html') // 得到的结果是：aaa.html

path.basename('/foo/bar/aaa.html', '.html') // 得到的结果是：aaa
</code></pre>
<p>获取扩展名：</p>
<pre><code class="language-js">// 如果后面只是个‘.’，那么得到的就是‘.’；如果没有扩展名，得到的就是空
path.extname('index.html') // 得到的结果： ‘.html’
</code></pre>
<p>路径的格式化处理：</p>
<pre><code class="language-js">let obj = {
  root: 'd:\\',
  base: 'abc.txt',
  ext: '.txt',
  name: 'abc',
}

console.log(path.format(obj)) //  输出的结果：d:\abc.txt
</code></pre>
<p>路径字符串转成对象</p>
<pre><code class="language-js">    console.log(path.parse(__filename));
   //  输出的结果：
    {
        root: '文件根路径',
        dir: '文件的全路径',
        base: '文件名称',
        ext: '扩展名',
        name: '文件名称'
    }
</code></pre>
<h2 id="三-url-模块"><a class="header" href="#三-url-模块">三 url 模块</a></h2>
<p>URL 的组成如下：</p>
<pre><code class="language-txt">┌────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                              href                                              │
├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │          host          │           path            │ hash  │
│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │    hostname     │ port │ pathname │     search     │       │
│          │  │                     │                 │      │          ├─┬──────────────┤       │
│          │  │                     │                 │      │          │ │    query     │       │
&quot;  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash &quot;
│          │  │          │          │    hostname     │ port │          │                │       │
│          │  │          │          ├─────────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │          host          │          │                │       │
├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │
│   origin    │                     │         origin         │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
│                                              href                                              │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>Node 中 ulr 模块用来处理 URL 总的各个字段：</p>
<pre><code class="language-js">const url = require('url')
const myURL = url.parse(
  'https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'
)
</code></pre>
<p>但是最新的 H5 标准组织已经提出了 URL 操作的标准，新版的 Node 也开始支持：</p>
<pre><code class="language-js">const myURL = new URL('https://%CF%80.example.com/foo')

console.log(myURL.href)
</code></pre>
<h2 id="四-querystring-模块"><a class="header" href="#四-querystring-模块">四 querystring 模块</a></h2>
<p>该模块有 2 个主要方法：</p>
<ul>
<li><code>querystring.parse()</code>：将查询字符串反序列化为一个对象，类似<code>JSON.parse()</code></li>
<li><code>querystring.stringify()</code>：将一个对象序列化为一个字符串对象，类似<code>JSON.stringify()</code></li>
</ul>
<pre><code class="language-js">const querstring = require('querystring')

let str1 = 'username=lisi&amp;password=123'
let obj1 = querstring.parse(str1) //  转换为了对象

let obj2 = { username: 'zs', password: '456' }
let str2 = querstring.stringify(obj2) //  重新转换为字符串
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-使用机制-模块机制"><a class="header" href="#031-使用机制-模块机制">03.1-使用机制-模块机制</a></h1>
<h2 id="一-模块简介"><a class="header" href="#一-模块简介">一 模块简介</a></h2>
<p>在项目开发中，对不同的项目功能需要做文件切割，以更好的产出可维护性代码，对分割后的不同功能代码的引入便需要编程需要编程语言的模块机制支持。</p>
<p>模块化的优势有：</p>
<ul>
<li>防止命名冲突</li>
<li>代码复用</li>
<li>提升可维护性</li>
</ul>
<p>JavaScript 由于诞生之初只是一个浏览器脚本语言，并未支持大型项目要求的模块化需求。</p>
<p>为了适应现在的发展，JavaScript 先后诞生了各种模块规范，如 AMD、CMD：</p>
<ul>
<li>CommonJS：主张文件即模块，通过 <code>module.exports</code> 导出接口，通过 <code>require()</code> 加载模块，被 Node.js 采用。</li>
<li>AMD：一种异步加载模块的实现规范，提倡依赖前置，提前加载（函数运行前加载好依赖），Require.js 是其代表，目前已经逐渐淘汰。</li>
<li>CMD：一种异步加载模块的实现规范，提倡依赖就近，按需加载（函数运行时才加载依赖），sea.js 是其代表，目前已经逐渐淘汰。</li>
<li>ES Module：目前 ECMAScript 官方的方案</li>
</ul>
<p>目前的主流模块化方案是：CommonJS、ES Module。但是 CommonJS 的文件加载是同步的，由于服务端的文件都位于服务器的本地磁盘中，所以 Node 采用该方式没有太大问题，但是该方式不适合前端中需要网络来加载远程模块！而 Node 现在也是 JavaScript 社区的一部分，也需要跟进 JavaScript 的更新，所以 ES Module 最后将会成为 JavaScript 最主要的模块化方案，没有之一。</p>
<h2 id="二-commonjs"><a class="header" href="#二-commonjs">二 CommonJS</a></h2>
<h3 id="21-commonjs-规范"><a class="header" href="#21-commonjs-规范">2.1 CommonJS 规范</a></h3>
<p>CommonJS 中定义一个模块：</p>
<pre><code class="language-js">// 创建 math.js 文件
function add(num1, num2) {
  return num1 + num2
}

module.exports = add
</code></pre>
<p>在其他文件引入该模块：</p>
<pre><code class="language-js">var add = require('./math')

console.log(add(5, 4)) // 输出 9
</code></pre>
<h3 id="22-exports-的导出导入"><a class="header" href="#22-exports-的导出导入">2.2 exports 的导出导入</a></h3>
<p>exports 导出变量：</p>
<pre><code class="language-js">// 新建 foo.js，导出 msg1 和 msg2 这两个变量
let msg1 = '你好'
let msg2 = 'hello world'
exports.zhText = msg1
exports.enText = msg2
</code></pre>
<p>变量导入并使用：</p>
<pre><code class="language-js">// 新建一个 main.js，输入以下代码
let foo = require('./foo.js') // 核心模块（node 本身的模块）在导入时无须路径，如 let http = require('http');
console.log(foo.zhText)
console.log(foo.enText)
</code></pre>
<p>一个 JavaScript 文件，可以向外 exports 无数个变量、函数。但是 require 的时候，仅仅需要 require 这个 JS 文件一次。使用的它的变量、函数的时候，用点语法即可。所以，CommonJS 的模块导出、导入机制可以让用户完全不必考虑变量污染问题。</p>
<h3 id="23-moduleexports-与-exports-变量-区别"><a class="header" href="#23-moduleexports-与-exports-变量-区别">2.3 module.exports 与 exports. 变量 区别</a></h3>
<p><strong>mdoule.exports</strong> 直接导出了变量本身，而 <strong>exports. 变量=</strong> 则是将该导出的变量重新挂载到 <code>=</code> 后的变量上。</p>
<p>在本质上，<code>exports</code> 只是 <code>module</code> 对象下的一个属性。所有 <code>exports</code> 都是通过 <code>module.exports</code> 传递的，类似于每个模块头部都有：<code>var exports = module.exports;</code>。如图所示：</p>
<p><img src="05-Node.js/../images/node/01-02.svg" alt="模块机制 01" /></p>
<p>贴士：</p>
<ul>
<li>多个 <code>module.exports</code>，只会导出最后一个，前面的都会被忽略</li>
<li><code>module.exports</code> 和 <code>exports</code> 不能共用</li>
<li>require 并不依赖于 exports，可以加载一个没有暴露任何方法的模块，这相当于执行一个模块内部的代码</li>
</ul>
<p>推荐在导出一个整体对象的时候使用 <code>module.exports</code>，因为 exports 是通过形参方式传入的，直接赋形参会改变形参的引用。</p>
<h2 id="三-模块加载机制"><a class="header" href="#三-模块加载机制">三 模块加载机制</a></h2>
<h3 id="31-文件类型查找机制"><a class="header" href="#31-文件类型查找机制">3.1 文件类型查找机制</a></h3>
<p>如果加载模块文件时，没有写后缀的话，找模块的时候会按照 <code>.js</code>，<code>.json</code>，<code>.node</code> 这三种后缀的优先级分别去找，查找过程如下：</p>
<ul>
<li>首先按照加载的模块的文件名进行查找；</li>
<li>没找到，在模块文件名后加上 .js 后缀进行查找；</li>
<li>没找到，在文件名后加上 .json 后缀查找；</li>
<li>没找到，在文件名后加上 .node 后缀查找；</li>
<li>抛出错误。</li>
</ul>
<p>贴士：在引入。node 和。json 文件时，带上标识名，会加快一点速度。</p>
<h3 id="32-文件加载机制"><a class="header" href="#32-文件加载机制">3.2 文件加载机制</a></h3>
<p>在 Node 中，模块分为两大类：</p>
<ul>
<li>核心模块：Node 官方默认提供的模块，如 fs、http，引入方式：<code>require('fs')</code>，无需指定路径。</li>
<li>文件模块：用户编写的模块，引入方式：<code>require('./mymodule/math')</code>，也可以使用绝对路径。</li>
<li>自定义模块：笔者认为可以称为第三方模块，也无需路径直接引入：<code>require('express')</code></li>
</ul>
<p>模块在被引入时大致要经过三个步骤：路径分析 --&gt; 文件定位 --&gt; 编译执行，但是在 Node 中，核心模块与文件模块加载时机制完全不同：</p>
<ul>
<li>核心模块：这些模块在 Node 源码编译时候，已经编译进了 Node 的二进制可执行文件中，Node 程序启动时，这些模块就会被直接加载进内存。所以核心模块在引入时只有编译执行一步，其加载速度也是最快的！</li>
<li>文件模块：该部分模块在运行时动态加载，需要完整执行上述三步，速度较慢</li>
</ul>
<p>当然还有一种情况，用户引入了第三方模块，这种模块位于 Node 默认提供的 <code>node_modules</code> 文件夹中，而这个文件夹在 Node 的项目目录、Node 安装目录中都存在着！！！由于 require 时没有指定路径，那么就需要 Node 进行逐级向上查找：</p>
<ul>
<li>首先从当前项目目录下的 node_modules 中查找</li>
<li>从父目录下的 node_modules 中查找，依次类推</li>
<li>直到找到 Node 本身跟目录下的 node_modules 文件夹</li>
</ul>
<p>该模块随着项目目录的深入，会造成大量耗时！！</p>
<h3 id="33-文件缓存机制"><a class="header" href="#33-文件缓存机制">3.3 文件缓存机制</a></h3>
<p>已经加载的模块会被缓存，所以，<strong>多次 require 同一个文件的时候不会重新加载</strong>，只会加载一次；<code>require</code> 根据文件的路径去判断是否是同一个文件，路径一样的话，加载多次，用的也是第一次加载的内容。</p>
<p>所在 Node 在加载文件时的消耗上整体是：从缓存中加载 --&gt; 加载核心模块 --&gt; 加载文件模块。</p>
<p>注意：require 从缓存中加载文件是基于文件路径的，这表示即使有两个完全相同的文件，但她们位于不同的路径下，也会在缓存中维持两份。</p>
<p>查看缓存代码：</p>
<pre><code class="language-js">console.log(require.cache)
</code></pre>
<p>当调用 require 加载一个模块时，模块内部的代码都会被调用！！！！，有时候这可能会带来隐藏的 bug。</p>
<p>module.js：</p>
<pre><code class="language-js">function test() {
  setInterval(function () {
    console.log('test')
  }, 1000)
}
test()

module.exports = test
</code></pre>
<p>main.js:</p>
<pre><code class="language-js">let test = require('./module')
</code></pre>
<p>main.js 只是加载了 module 文件，但是仍然每隔 1 秒输出了 test 字符串，且 main.js 的进程始终没有退出！！这在生产环境中极其造成内存泄漏。所以使用模块时要留意该情况。</p>
<h3 id="34-文件目录分析机制"><a class="header" href="#34-文件目录分析机制">3.4 文件目录分析机制</a></h3>
<p>在查找 require 的文件时，没有找到相应文件，却找到了对应 require 参数的目录，此时 Node 会将目录当做一个包来处理，此时 Node 会查找到包内的哪个文件呢？</p>
<ul>
<li>每个 Node 项目都带有 package.json 文件，该 json 文件内部有个 key 指定了包的入口文件 <code>&quot;main&quot;:&quot;app.js&quot;</code>，此时 Node 会加载该包内的 app.js</li>
<li>如果 package.json 文件不存在，或者内部的 main 指定的文件名错误，则 Node 会依次查找包中：index.js、index.json、index.node</li>
<li>如果没找到，则抛出查找失败异常</li>
</ul>
<h3 id="35-重复引用问题"><a class="header" href="#35-重复引用问题">3.5 重复引用问题</a></h3>
<p>Node 无须关心重复引用问题，因为 Node 先从缓存中加载模块，一个模块被第一次加载后，就会在缓存中维持一个副本，如果遇到重复加载的模块会直接提取缓存中的副本，也就是说在任何情况下每个模块都只在缓存中有一个实例。</p>
<h2 id="四-附源码查看方式"><a class="header" href="#四-附源码查看方式">四 附源码查看方式</a></h2>
<p>加入断点调试并不能进入源码，需要在 vscode 点击左侧的创建 launch.json 文件，然后注释掉：</p>
<pre><code class="language-js">{
  // 使用 IntelliSense 了解相关属性。
  // 悬停以查看现有属性的描述。
  // 欲了解更多信息，请访问：https://go.microsoft.com/fwlink/?linkid=830387
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      &quot;type&quot;: &quot;node&quot;,
      &quot;request&quot;: &quot;launch&quot;,
      &quot;name&quot;: &quot;启动程序&quot;,
      // &quot;skipFiles&quot;: [
      //   &quot;&lt;node_internals&gt;/**&quot;
      // ],
      &quot;program&quot;: &quot;${workspaceFolder}/index.js&quot;
    }
  ]
}

</code></pre>
<p>此时就可以进入源码查看了。</p>
<h2 id="五-模块属性-__filename-和-__dirname"><a class="header" href="#五-模块属性-__filename-和-__dirname">五 模块属性 <code>__filename</code> 和 <code>__dirname</code></a></h2>
<p><code>__filename</code> 和 <code>__dirname</code> 是常用的 2 个属性，但却并不是全局的，他们挂载到了每个模块上 (模块机制章节讲解)，所以每个模块都可以直接使用：</p>
<ul>
<li><code>__filename</code>：返回当前模块的文件的解析后的绝对路径（包含文件名）</li>
<li><code>__dirname</code>：返回当前模块文件所在目录解析后的绝对路径（不包含文件名），返回的是文件夹</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">console.log(__dirname)
</code></pre>
<p>Node 默认提供了许多模块，这些模块可以称呼为核心模块。模块在使用之前需要先导入，如：<code>require(&quot;fs&quot;)</code>。</p>
<p>模块的操作 API 可以在官网文档中查阅，也可以在 REPL 中查阅：</p>
<pre><code class="language-txt"># 进入 repl 环境
node

# 查询 fs 模块 API
fs
</code></pre>
<p>注意 1：<strong>对于大多模块中的异步操作，只能通过回调函数中的 err 来判断，而不同使用 try catch 来捕获！</strong></p>
<p>注意 2：Node 往往在提供异步 API 时，还会提供一个同步操作，如 <code>fs.readFile()</code> 对应的同步操作为：<code>fs.readFileSync()</code>。</p>
<h2 id="六-编译过程"><a class="header" href="#六-编译过程">六 编译过程</a></h2>
<h3 id="60-编译过程简述"><a class="header" href="#60-编译过程简述">6.0 编译过程简述</a></h3>
<p>在 Node 中，每个文件模块都是一个对象，其定义如下：</p>
<pre><code class="language-js">function Module(id, parent) {
  this.id = id
  this.exports = {}
  this.parents = parents
  if (parent &amp;&amp; parent.children) {
    parent.children.push(this)
  }

  this.filename = null
  this.loaded = false
  this.children = []
}
</code></pre>
<p>文件在引入后，将会进行编译与执行，Node 在定位到具体文件后，会新建一个模块对象，根据路径载入并编译，对不同扩展名的文件，载入方法不同：</p>
<ul>
<li>.js 文件：通过 fs 模块同步读取文件后编译执行</li>
<li>.node 文件：该模块是使用 C、C++编写的扩展文件，通过 <code>dlopen()</code>方法加载最后编译生成</li>
<li>.json 文件：通过 fs 模块同步读取文件被当做 js 文件载入</li>
<li>其他扩展名文件：都被当做 js 文件载入，Node 推荐将其其他文件都编译为 JS 文件后再引入，这样可以减少 Node 不必要的编译过程</li>
</ul>
<p>通过如下代码可以得到加载执行方式：</p>
<pre><code class="language-js">console.log(require.extensions)

// 输出： { '.js': [Function], '.json': [Function], '.node': [Function] }
</code></pre>
<p>每一个编译成功的模块都会将其文件路径作为索引缓存在<code>Module._chache</code>对象上，以提高再次引入的性能。</p>
<h3 id="61-js-模块"><a class="header" href="#61-js-模块">6.1 JS 模块</a></h3>
<p>在 Node 中，可以直接使用<code>__dirname</code>、<code>require</code>等默认 API，是因为在编译时，Node 会对 JS 文件内容进行头尾包装：</p>
<pre><code class="language-js">// 在头部添加
;(function (exports, require, module, __filename, __dirname) {
  \n

  // 在尾部添加
  \n
})
</code></pre>
<p>如下所示，一个普通的 JS 文件被包装为：</p>
<pre><code class="language-js">;(function (exports, require, module, __filename, __dirname) {
  var a = 3
  exports.add = function (num1, num2) {
    return num1 + num2
  }
})
</code></pre>
<p>通过上述包装，每个模块文件之间实现了作用域隔离，包装之后的代码通过 vm 原生模块的<code>runInThisContext()</code>方法执行，返回具体的函数对象。</p>
<h3 id="62-c模块编译"><a class="header" href="#62-c模块编译">6.2 C++模块编译</a></h3>
<p>C++模块是指.node 扩展名的文件，这些文件都是已经经过 C++模块编译后生成的，所以无需编译，直接会被 <code>process.dlopen()</code>方法进行加载和执行，该方法由 libuv 提供（在 win 和 linux 实现不同）。</p>
<h3 id="63-核心模块编译"><a class="header" href="#63-核心模块编译">6.3 核心模块编译</a></h3>
<p>Node 的核心模块都会被编译为二进制可执行文件，核心模块分为 C/C++编写、JavaScript 编写两种实现方式。C/C++实现的文件位于 Node 项目的 src 目录下，JavaScript 文件位于 lib 目录下。</p>
<p>Node 在进行编译 C/C++文件前，会先将所有 JavaScript 模块文件通过 v8 附带的 js2c.py 工具编译为 C/C++代码。此时所有内置的 JS 代码，如（src/node.js 和 lib/*.js）会被转换为 C++里的数组，生成 node_natives.h 文件，JS 代码以字符串形式存储在一个叫做 node 的命名空间中，此时代码自然也是不可执行的。</p>
<p>使用 C/C++编写的内建模块有：buffer、crypto、evals、fs、os 等模块。这些内建模块都会通过 NODE_MODULE 宏将模块定义到 node 命名空间中，位于<code>node_module_list</code>数组中。如果要使用这些模块，Node 提供了<code>get_builtin_module()</code>方法可以从这个数组中取出这些模块。</p>
<p>内建模块不推荐使用文件模块直接调用，Node 在启东时，会生成一个全局变量 process，并提供 Binding() 方法来协助加载内建模块。Binding() 的实现位于<code>src/node.cc</code>中。</p>
<p><img src="05-Node.js/../images/node/06-20.svg" alt="Binding()" /></p>
<p>原生模块的引入流程：</p>
<p><img src="05-Node.js/../images/node/06-21.svg" alt="原生模块的引入" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="032-使用机制-包管理机制"><a class="header" href="#032-使用机制-包管理机制">03.2-使用机制-包管理机制</a></h1>
<h2 id="一-包管理器-npm"><a class="header" href="#一-包管理器-npm">一 包管理器 npm</a></h2>
<h3 id="11-包管理器的历史与作用"><a class="header" href="#11-包管理器的历史与作用">1.1 包管理器的历史与作用</a></h3>
<p>由于核心模块在 Node 程序启动时就已经从 Node 的安装目录中加载到了内存中，其引入方式只需要 <code>require(&quot;fs&quot;)</code> 即可。但是市面上仍然有大量的第三方包供我们使用，该如何引入呢？</p>
<p>Node 在这个地方做的非常出色，官方在开发者的推动下，推出了 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 包管理平台，无论 Node 的第三方包使用的是 github 还是 gitlab 还是其他源码工具管理，其包的下载都能在 npmjs 官网找到，并且能够使用 <code>npm</code> 脚本命令下载这些第三方包，这样的做法使得 Node 的开源生态非常丰富强大，避免了混乱。</p>
<p>Node 的安装包已经自动集成 <code>npm</code> 脚本命令，我们无需手动安装，在安装完 Node 后，可以使用如下命令查看 npm 版本：</p>
<pre><code class="language-txt">npm -v
</code></pre>
<p>当然 npm 也存在极严重的缺陷，如 包安装地狱、版本锁定缺失等，这些问题困扰了 Node 开发者很多年，Facebook 推出了新的包管理工具 yarn，在一定程度上缓解了这些问题，后来 Node 官方也不甘示弱，新开发了 npm6 予以回击。</p>
<h3 id="12-使用-npm-初始化一个-node-项目"><a class="header" href="#12-使用-npm-初始化一个-node-项目">1.2 使用 npm 初始化一个 Node 项目</a></h3>
<p>步骤一：初始化项目配置</p>
<pre><code class="language-txt">mkdir demo      # 创建一个 demo 项目文件件
cd demo
npm init        # 初始化 Node 项目环境，会在当前项目目录下生成核心配置文件  package.json，添加 -y 参数可以自动生成
</code></pre>
<p>步骤二：安装开发包</p>
<pre><code class="language-txt">npm install express     # install 会执行安装 express 开发包的命令，默认安装最新版本。install 可以简写为 i

# 安装完毕后，我们会在 package.json 文件中发现该依赖，当前目录会生成文件夹 node_modules，express 包便被安装在此目录中
</code></pre>
<p>步骤三：使用开发包</p>
<pre><code class="language-js">// 安装了 express 包后，现在就可以使用 express 包了，新建一个文件 app.js，代码如下：
let express = require('express')

let app = express()

app.get('/', function (req, res) {
  return res.send('hello world')
})

app.listen(3000)
</code></pre>
<p>步骤三：测试。打开浏览器，访问 <code>http://localhost:3000/</code>，就会看到我们使用 express 包开发这个项目输出结果了。</p>
<h3 id="13-npm-的一些使用"><a class="header" href="#13-npm-的一些使用">1.3 npm 的一些使用</a></h3>
<p>npm 在安装包时候可以设定其安装为生产环境还是开发环境，如下所示：</p>
<pre><code class="language-txt">npm i express -g    # 全局安装
npm i express -S    # 以生产依赖形式本地安装，-S 是 --save 的缩写
npm i express -D    # 以开发依赖形式本地安装，-D 是 --save -dev 的缩写
</code></pre>
<h3 id="14-npm-镜像与-cnpm"><a class="header" href="#14-npm-镜像与-cnpm">1.4 npm 镜像与 cnpm</a></h3>
<p>由于一些国内原因，npm 安装包速度很慢，可以设置 npm 镜像：</p>
<pre><code class="language-txt">npm config rm proxy
npm config rm https-proxy
npm config set registry https://registry.npm.taobao.org
</code></pre>
<p>也可以直接使用淘宝开发的 cnpm 来代替 npm：</p>
<pre><code class="language-txt">npm install cnpm -g
cnpm install jQuery
</code></pre>
<p>恢复 npm 镜像办法：</p>
<pre><code class="language-txt">npm config set proxy=http://127.0.0.1:1080
npm config set registry=http://registry.npmjs.org
</code></pre>
<h3 id="15-描述文件"><a class="header" href="#15-描述文件">1.5 描述文件</a></h3>
<p>在使用 <code>npm init</code>时会生成一个包描述文件 <code>package.json</code>，该描述文件详细解释了整个包的情况。</p>
<p>该文件内的一些字段非常重要：</p>
<pre><code class="language-txt">main：说明项目的入口文件是谁
scritps：项目的脚本有哪些，如： &quot;start&quot;:&quot;node app.js&quot;，这个脚本可以利用 npm 运行：npm run start
</code></pre>
<h3 id="16-package-lockjson"><a class="header" href="#16-package-lockjson">1.6 package-lock.json</a></h3>
<p>npm5 之后为了锁定版本而设立的版本锁定文件，当项目存在该文件后，项目默认在 <code>npm i</code> 时，安装的版本为该文件内锁定的版本。</p>
<h3 id="17-node-项目正确的初始化方式"><a class="header" href="#17-node-项目正确的初始化方式">1.7 Node 项目正确的初始化方式</a></h3>
<pre><code class="language-txt">mkdir myproject
cd myproject
npm init          # 初始化项目，会生成 package.json，-y 参数可以直接按照默认项生成 package.json
</code></pre>
<h2 id="二-npx"><a class="header" href="#二-npx">二 npx</a></h2>
<p>Node 的包中，可执行程序位于 <code>./node_modules/.bin/</code> 目录中，如果我们安装完 npm 包，想使用该包的二进制执行程序，必须这样输入：</p>
<pre><code class="language-txt"># 假设二进制可执行程序为 cmd
./node_modules/.bin/cmd
</code></pre>
<p>运行方式极为不便，npx5.2 之后添加了 npx 命令，用于快速启动 Node 的二进制可执行程序：</p>
<pre><code class="language-txt"># 项目根目录中，无需输入路径
npx cmd
</code></pre>
<h2 id="三-nrm"><a class="header" href="#三-nrm">三 nrm</a></h2>
<p>如果我们为 npm 包添加了很多镜像源，那么管理起来就很不便，nrm 包可以用来管理 npm 的镜像源。</p>
<pre><code class="language-txt"># 安装 nrm
npm install -g nrm

# 列出当前镜像源
nrm ls
*npm ---- https://registry.npmjs.org/
cnpm --- http://r.cnpmjs.org/
taobao - http://registry.npm.taobao.org/

# 切换镜像源
nrm use taobao

# 增加镜像源
nrm add registry http://registry.npm.frp.trmap.cn/

# 删除镜像源
nrm del &lt;registry&gt;

# 测速
nrm test cnpm
</code></pre>
<h2 id="四-npm-私有仓库"><a class="header" href="#四-npm-私有仓库">四 npm 私有仓库</a></h2>
<p>在企业中，为了安全性，npm 包都是自己部署的私有仓库，目前较好的私有仓库解决方案是：<a href="https://github.com/verdaccio/verdaccio">https://github.com/verdaccio/verdaccio</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-新增对象-buffer"><a class="header" href="#041-新增对象-buffer">04.1-新增对象-Buffer</a></h1>
<h2 id="一-二进制文件操作"><a class="header" href="#一-二进制文件操作">一 二进制文件操作</a></h2>
<h3 id="11-前端操作二进制文件"><a class="header" href="#11-前端操作二进制文件">1.1 前端操作二进制文件</a></h3>
<p>前端的二进制对象 Blob 使用示例，演示数据与二进制的抓换：</p>
<pre><code class="language-html">&lt;a href=&quot;&quot; id=&quot;down&quot;&gt;下载&lt;/a&gt;
&lt;script&gt;
  let str = `&lt;div&gt;hello world!&lt;/div&gt;`
  const b = new Blob([str], { type: 'text/html' }) // 将字符串转换为二进制
  // 点击网页中的 a 链接实现下载这个二进制文件
  let down = document.querySelector('#down')
  down.setAttribute('download', 'index.html') // 设置下载文件名
  down.href = URL.createObjectURL(b)
&lt;/script&gt;
</code></pre>
<p>同样前端如果要读取二进制文件，可以使用 Blob 的子类 File 类：</p>
<pre><code class="language-html">&lt;input type=&quot;file&quot; id=&quot;fileList&quot; /&gt;
&lt;script&gt;
  let fileList = document.querySelector('#fileList')
  fileList.addEventListener('change', (e) =&gt; {
    let file = e.target.files[0]
    console.log(file) // 会打印该文件对象的基本信息

    let reader = new FileReader()
    reader.onload = function () {
      let img = document.createElement('img') // 假定操作的是一个图片
      img.src = reader.result
      document.body.appendChild(img)
    }
    reader.readAsDataURL(file) // 这里不推荐该做法，只是演示，推荐的做法是仍然使用 URL.createObjectURL(b)
  })
&lt;/script&gt;
</code></pre>
<h3 id="12-arraybuffer-缓冲区"><a class="header" href="#12-arraybuffer-缓冲区">1.2 ArrayBuffer 缓冲区</a></h3>
<p>ArrayBuffer 对象是 ECMAScript 提供的表示固定长度的原始二进制数据缓冲区，其本质是一个字节数组，通常在其他语言中称为“byte array”。</p>
<pre><code class="language-js">// 申请 4 个字节的缓冲区（一个字节由八位组成，最大能转换成十进制的 255）
const buf = new ArrayBuffer(4)
console.log(buf)

// 实际读取操作数据需要使用其子类
let x = new Uint8Array(buf)
console.log(x) // Uint8Array(4) [0, 0, 0, 0]
x[0] = 1
x[1] = 255
console.log(x) // Uint8Array(4) [1, 255, 0, 0]
</code></pre>
<h3 id="13-node-中的-buffer-概念"><a class="header" href="#13-node-中的-buffer-概念">1.3 Node 中的 Buffer 概念</a></h3>
<p>在 H5 之前，JavaScript 不具备文件的能力，所以其语言本身在以前也没有提供操作二进制数据的 API，但是这是后端开发的核心功能之一。Node 为了弥补这个不足，基于 C++ 模块提供了全新的对象 Buffer，用来操作字节。现在在 ES6 中，JavaScript 原生提供了 ArrayBuffer 类型，可以直接操作二进制数据，Node 也将自己的 Buffer 实现转换为了该类的子类：<code>Uint8Array</code>（8 表示 8 个位）。</p>
<p>可以将 Buffer 理解为 Node 扩充的数据类型，其作用类似 Array，用于操作二进制数据。</p>
<p>由于 Buffer 对象在 Node 中非常常用，所以在 Node 进程启动时就会被加载进内容，位于全局对象 global 中，可以直接使用。</p>
<p>Buffer 在文件 I/O，网络 I/O 中占据很大使用场合，网络传输中的字符串一般都会转换为 Buffer，以二进制方式进行传输，这样可以有效减轻服务端资源浪费。比如静态内容往往会先转换为 Buffer 格式，这样浏览器在访问网页内容时，服务器就无需转换再传输了！Node 在文件、网络操作中，如果没有显示声明编码格式，默认返回的数据类型都是 Buffer，比如 readFile 回调中的 data。</p>
<h3 id="14-buffer-的应用"><a class="header" href="#14-buffer-的应用">1.4 Buffer 的应用</a></h3>
<pre><code class="language-js">const fs = require('fs')

fs.readFile('./demo.html', (err, data) =&gt; {
  console.log(data) // 二进制 Buffer 类型数据
  console.log(data.toString()) // html 文档转换为了字符串
})
</code></pre>
<h2 id="二-buffer-的基本使用"><a class="header" href="#二-buffer-的基本使用">二 Buffer 的基本使用</a></h2>
<h3 id="21-buffer-的创建"><a class="header" href="#21-buffer-的创建">2.1 Buffer 的创建</a></h3>
<pre><code class="language-js">// new Buffer() 方式创建由于安全问题已被废弃

// 创建一个长度为 10 的 Buffer，填充了全部值为 `0` 的字节
const buf1 = Buffer.alloc(10)

// 创建一个长度为 10、且用 01 填充的 Buffer。
const buf2 = Buffer.alloc(10, 1)

// 创建一个长度为 10、且未初始化的 Buffer
// 这个方法比调用 Buffer.alloc() 更快，但返回的 Buffer 实例可能包含旧数据。可以理解为 这段字节内存被直接使用了，原来的数据还保留着
// 解决办法：使用 fill()、write() 或其他能填充 Buffer 的内容的函数进行重写。
const buf3 = Buffer.allocUnsafe(10)

// 创建一个包含字节 [1, 2, 3] 的 Buffer。
const buf4 = Buffer.from([1, 2, 3])

// 创建一个包含字节 [1, 1, 1, 1] 的 Buffer，其中所有条目均使用 `(value &amp; 255)` 进行截断以符合 0-255 的范围。
const buf5 = Buffer.from([257, 257.5, -255, '1'])

// 创建一个 Buffer，其中包含字符串 'tést' 的 UTF-8 编码字节：
// [0x74, 0xc3, 0xa9, 0x73, 0x74]（以十六进制表示）
// [116, 195, 169, 115, 116]（以十进制表示）
const buf6 = Buffer.from('test', 'utf-8')

for (let i = 0; i &lt; buf6.length; i++) {
  // 此 length 长度和字符串的长度有区别，指 buffer 的 bytes 大小
  console.log(buf6[i].toString(16)) // buffer[index]: 获取或设置在指定 index 索引未知的 8 位字节内容
  console.log(String.fromCharCode(bf[i])) // 依次输出 t e s t
}
</code></pre>
<h3 id="22-buffer-的实例方法"><a class="header" href="#22-buffer-的实例方法">2.2 Buffer 的实例方法</a></h3>
<pre><code class="language-js">// 根据参数 offset，将参数 string 数据写入 buffer
buf.write(string, [offset], [length], [encoding])

// 返回一个解码的 string 类型
buf.toString([encoding], [length])

// 返回一个 JSON 表示的 Buffer 实例，JSON.stringify 将会默认调用来字符串序列化这个 Buffer 实例
buf.toJSON()

// 返回一个新的 buffer，这个 buffer 和老的 buffer 引用相同的内存地址
buf.slice([start], [end])

// 进行 buffer 的拷贝，拷贝不会影响老的 buffer
buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])
</code></pre>
<h3 id="23-buffer-的静态方法"><a class="header" href="#23-buffer-的静态方法">2.3 Buffer 的静态方法</a></h3>
<pre><code class="language-js">Buffer.isBuffer(buf);              // 判断是不是 Buffer
Buffer.byteLength(str);                 // 获取字节长度，第二个参数为字符集，默认 utf8
Buffer.concat(list[, totalLength])     // Buffer 的拼接
</code></pre>
<h3 id="24-buffer-的转换"><a class="header" href="#24-buffer-的转换">2.4 Buffer 的转换</a></h3>
<p>Buffer 与 字符串之间的转换：</p>
<pre><code class="language-js">// 字符串转 Buffer
let buf = Buffer.from('test', 'utf-8')

// Buffer 转换为字符串
buf.toString([encoding], [start], [end])
</code></pre>
<p>Buffer 对象转换为 Buffer，一个 Buffer 对象可以存储不同编码类型的字符串转码的值，调用 write() 方法可以实现该目标：</p>
<pre><code class="language-js">buf.write(string, [offset], [length], [encoding])
</code></pre>
<p>由于可以不断写入内容到 Buffer 对象中，并且每次写入可以指定编码，所以 Buffer 对象中可以存在多种编码转换后的内容，需要小心的是，每种编码所用的字节长度不同，将 buffer 反转回字符串时需要谨慎处理。</p>
<h3 id="25-buffer-不支持的编码类型"><a class="header" href="#25-buffer-不支持的编码类型">2.5 Buffer 不支持的编码类型</a></h3>
<p>Node 的 Buffer 不支持中国的 GBK，GB2312，BUG-5 等编码格式。判断 Buffer 是否支持该编码格式：</p>
<pre><code class="language-js">Buffer.isEncoding(encodibg) // 返回 true、false
</code></pre>
<p>对于不支持的编码格式，Node 有第三方模块如 iconv 和 iconv-liten。</p>
<h2 id="三-buffer-乱码"><a class="header" href="#三-buffer-乱码">三 Buffer 乱码</a></h2>
<h3 id="31-乱码的产生"><a class="header" href="#31-乱码的产生">3.1 乱码的产生</a></h3>
<p>在 Buffer 使用场景中，通常是以一段一段的方式传输，常见从输入流中读取内容的示例如下：</p>
<pre><code class="language-js">let fs = require('fs')

let rs = fs.createReadStream('./demo.md')
let data = ''

rs.on('data', function (chunk) {
  data += chunk
})

rs.end('end', function () {
  console.log(data)
})
</code></pre>
<p>上述代码在读取全英文格式内容时，不会有任何问题，但是一旦输入流中存在宽字节编码，就会产生乱码问题。问题来自于 <code>data += chunk</code>，该句隐藏了 <code>toString()</code> 操作，其内部等价于：</p>
<pre><code class="language-js">data = data.toString() + chunk.toString()
</code></pre>
<p>下面模拟宽字节文字读取场景：</p>
<pre><code class="language-js">let fs = require('fs')

let buf = Buffer.from('白银之手骑士团')

// &lt;Buffer e7 99 bd e9 93 b6 e4 b9 8b e6 89 8b e9 aa 91 e5 a3 ab e5 9b a2 ef bc 81&gt;
console.log('buf:', buf)
console.log('buf.length:', buf.length) // 21
console.log('start:', buf.toString('UTF-8', 0, 3)) // 白  e7 99 bd
console.log('start:', buf.toString('UTF-8', 3, 6)) // 银  e9 93 b6
console.log('start:', buf.toString('UTF-8', 6, 9)) // 之  e4 b9 8b，e6 89 8b，e9 aa 91，e5 a3 ab，e5 9b a2，ef bc 81

let data = ''
let rs = fs.createReadStream('./demo.txt', { highWaterMark: 4 })
rs.on('data', function (chunk) {
  data += chunk
})
rs.on('end', function () {
  console.log('流式读取：', data) // 白�����手骑�����
})
</code></pre>
<p>在上述案例中，每 3 个长度能够读取到一个汉字，但是在使用流式读取时，每 4 个长度读取一次，在第一读取时，就会读取到多余的数据了，也即输出了 <code>白�</code>，在第 4 次读取时，正好又读取了原始数据的存储要求，输出了 <code>�手</code>，依次类推。</p>
<h3 id="32-乱码解决"><a class="header" href="#32-乱码解决">3.2 乱码解决</a></h3>
<p>流式读取可以设置编码：</p>
<pre><code class="language-js">let rs = fs.createReadStream('./demo.txt', { highWaterMark: 4 })
rs.setEncoding('utf8')
</code></pre>
<p>此时程序就能正常输出数据！但是这并不是直接说明了输出没有收到 Buffer 大小的影响。在实际运行过程中，无论如何设置编码，触发的 data 事件次数都仍然是相同的。但是在每次 data 事件都会额外通过一个 decoder 对象对 Buffer 进行转换到字符串的解码，然后传递给调用者。而这个 decoder 对象正是 <code>setEncoding()</code> 方法时在可读流对象内部设置的。此时 data 收到的不再是原始的 Buffer 对象。decoder 对象会被未转码的部分保留在 StringDecode 实例内部，再下一次 write 的时候，会将上次的剩余字节和后续的新读入的字节进行组合！</p>
<p>setEncding 只能解决 UTF-8，Base64 等带来的编码问题，没有从根本上解决问题。正确的 Buffer 拼接方式应该是用一个数组来存储接收到的所有 Buffer 片段并记录下所有的片段总长度，然后调用 Buffer.concat() 方法生成一个合并的 Buffer 对象。</p>
<pre><code class="language-js">fs.createReadStream('./test.txt', { highWaterMark: 10 })

let dataArr = []

rs.on('data', function (chunk) {
  dataArr.push(chunk)
})

rs.on('end', function () {
  let buf = Buffer.concat(dataArr)
  console.log(buf.toString())
})
</code></pre>
<p>Buffer.concat() 方法封装了从小 Buffer 对象向大 Buffer 对象复制过程：</p>
<pre><code class="language-js">Buffer.concat = function (list, length) {
  if (!Array.isArray(list)) {
    throw new Error('Usage: Buffer.concat(list, [length])')
  }
  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  if (typeof length !== 'number') {
    length = 0
    for (let i = 0; i &lt; list.length; i++) {
      let buf = list[i]
      length += buf.length
    }
  }

  let buffer = new Buffer(length)
  let pos = 0
  for (let i = 0; i &lt; list.length; i++) {
    let buf = list[i]
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="042-新增对象-stream"><a class="header" href="#042-新增对象-stream">04.2-新增对象-Stream</a></h1>
<h2 id="一-stream-流"><a class="header" href="#一-stream-流">一 Stream 流</a></h2>
<h3 id="11-stream-流简介"><a class="header" href="#11-stream-流简介">1.1 Stream 流简介</a></h3>
<p>假设我们要读取一个大文件发送给服务端，如果直接使用 readFile() 方法是极其浪费资源的，因为只有读取完毕后才能利用网络进行发送，这样磁盘、网络都没有得到有效的利用。如果能够读取一点，就发送一点，那么就能让磁盘、网络获得最大限度的利用，这便是流。</p>
<p>Node 提供了多种流（Stream）对象，如 <code>process.stdout</code>，这些对象都继承自 <code>EventEmitter</code>。</p>
<p>在 Node 有四种基础的 Stream 类型：</p>
<pre><code class="language-txt">Readable    可读流，如：fs.createWriteStream()
Writeable   可写流，如：fs.createReadStream()
Duplex      读写流，也称为双工流，如：net.Socket
Transform   转换流，在读写时，可以修改或者转换数据的 Duplex 流，如 zlib 流、crypto 流
</code></pre>
<h3 id="12-stream-流的使用"><a class="header" href="#12-stream-流的使用">1.2 Stream 流的使用</a></h3>
<p>示例：</p>
<pre><code class="language-js">const fs = require('fs')

let rs = fs.createReadStream('./demo-read.txt', 'utf-8')

rs.on('data', (data) =&gt; {
  console.log(data) // 输出第一次读取到的数据
})

rs.on('error', (error) =&gt; {
  console.log('error:', error) // 如果有错误，输出错误
})

rs.on('end', () =&gt; {
  console.log('end')
})

rs.on('close', () =&gt; {
  console.log('close') // 读取完毕后输出 close
})

// 将读取到的数据填入可写流
let ws = fs.createWriteStream('./demo-write.txt') // 创建可写流
rs.pipe(ws) // 将数据以流形式写入
</code></pre>
<p>上述案例将会依次输出：文件内的数据、end、close。同理，在服务端，如果要返回大文件给前端，则：</p>
<pre><code class="language-js">const http = require('http')
const fs = require('fs')

http
  .createServer((req, res) =&gt; {
    let rs = fs.createReadStream('./1.jpg')
    rs.pipe(res) // 将流写入返回结果 res
  })
  .listen(8000)
</code></pre>
<p>注意：只有流才有 on 监听事件，所以 req、res 也是流，而且流是有方向的！</p>
<h3 id="13-对象模式"><a class="header" href="#13-对象模式">1.3 对象模式</a></h3>
<p>Node 中的流都运作在字符串、Buffer、Unit8Array 上。但是流可以用其他的 JavaScript 数据类型来创建（null 除外），这些流将会以对象形式进行操作。</p>
<p>在创建流时使用 objectMode 选项将流实例转换为对象模式。</p>
<pre><code class="language-js">const { Transform } = require('stream')

const commaSplitter = new Transform({
  readableObjectMode: true,
  transform(chunk, encoding, callback) {
    this.push(chunk.toString().trim().split(','))
    callback()
  },
})

const arrayToObject = new Transform({
  readableObjectMode: true,
  writableObjectMode: true,
  transform(chunk, encoding, callback) {
    const obj = {}
    for (let i = 0; i &lt; chunk.length; i += 2) {
      obj[chunk[i]] = chunk[i + 1]
    }
    this.push(obj)
    callback()
  },
})

const objectToString = new Transform({
  writableObjectMode: true,
  transform(chunk, encoding, callback) {
    this.push(JSON.stringify(chunk) + '\n')
    callback()
  },
})

process.stdin
  .pipe(commaSplitter)
  .pipe(arrayToObject)
  .pipe(objectToString)
  .pipe(process.stdout)
</code></pre>
<p>注意：将已经存在的流切换到对象模式是不安全的。</p>
<h3 id="14-流的缓冲区"><a class="header" href="#14-流的缓冲区">1.4 流的缓冲区</a></h3>
<p>可写流与可读流都会在内部的缓冲区中存储数据，可缓冲的数据大小取决于构造实例时可选项 highWaterMark 大小，该选项用来指定字节的总数或者对象的总数。</p>
<p>当调用 <code>stream.push(chunk)</code> 时，数据会被缓冲到可读流中，如果流的消费者没有调用 <code>stream.read()</code> 则数据会保留在内部队列中直到被消费。缓存中的数据通过 <code>writable.writableBuffer</code>、<code>readable.readableBuffer</code> 获取。</p>
<p>当内部的可读缓冲的总大小达到 highWaterMark 时，流会暂时停止从底层资源读取数据，直到当前缓冲的数据被消费。使用 <code>writeable.write(chunk)</code> 用于写入数据到流中，其返回值为 true，则证明可写缓冲大小小于 highWaterMark，反之亦然。</p>
<p>注意：为了避免读写速度不一致，一些 Stream API，如 <code>stream.pipe()</code> 会限制缓冲区。</p>
<p>双工流与转换流内部各自维护了两个相对独立的内部缓冲区用于读取与写入，如 <code>net.Socket</code> 的可读端可以消费从 socket 接收打数据，可写端则可以将数据写入到 socket。</p>
<h2 id="三-自定义-stream"><a class="header" href="#三-自定义-stream">三 自定义 Stream</a></h2>
<h3 id="31-自定义一个-stream"><a class="header" href="#31-自定义一个-stream">3.1 自定义一个 Stream</a></h3>
<p>当原生的 stream 无法满足要求时，可以自定义 stream：</p>
<pre><code class="language-js">const { Readable } = require('stream')

//这里我们自定义了一个用来读取数组的流
class ArrRead extends Readable {
  constructor(arr, opt) {
    //注意这里，需调用父类的构造函数
    super(opt)
    this.arr = arr
    this.index = 0
  }

  //实现 _read() 方法
  _read(size) {
    //如果当前下标等于数组长度，说明数据已经读完
    if (this.index == this.arr.length) {
      this.push(null)
    } else {
      this.arr.slice(this.index, this.index + size).forEach((value) =&gt; {
        this.push(value.toString())
      })
      this.index += size
    }
  }
}

let arr = new ArrRead([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], {
  highWaterMark: 2,
})

//这样当我们监听 'data' 事件时，流会调用我们实现的 _read() 方法往缓冲区中读取数据
//然后提供给消费者
arr.on('data', function (data) {
  console.log(data.toString())
})
</code></pre>
<h3 id="32-自定义双工流"><a class="header" href="#32-自定义双工流">3.2 自定义双工流</a></h3>
<pre><code class="language-js">const { Duplex } = require('stream')

const kSource = Symbol('source')

class MyDuplex extends Duplex {
  constructor(source, options) {
    supre(options)
    this[kSource] = source
  }

  _write(chunk, endcoding, callback) {
    if (Buffer.isBuffer(chunk)) {
      chunk = chunk.toString()
    }
    this[kSource].writeSomeData(chunk)
    callback()
  }

  _read(size) {
    this[kSource].fetchSomeData(size, (data, encoding) =&gt; {
      this.push(Buffer.from(data, encoding))
    })
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-网络编程"><a class="header" href="#051-网络编程">05.1-网络编程</a></h1>
<h2 id="一-tcp-编程简介"><a class="header" href="#一-tcp-编程简介">一 TCP 编程简介</a></h2>
<h3 id="11-tcp-简介"><a class="header" href="#11-tcp-简介">1.1 TCP 简介</a></h3>
<p>TCP 即传输控制协议，在 OSI 七层模型中属于传输层协议，大多应用层协议都是基于 TCP 构建而来，如：HTTP/SMTP/IMAP 等，可以说 TCP 协议是现代网络编程最重要的基石之一。</p>
<p>TCP 是面向连接的协议，其显著的特征是在传输之前需要进行 3 次握手形成会话：</p>
<p><img src="05-Node.js/../images/node/tcp-01.svg" alt="三次握手" /></p>
<p>当会话形成后，服务器和客户端之间分别提供一个套接字，这 2 个套接字形成一个连接，服务端和客户端通过套接字实现了二者的连接操作。</p>
<h3 id="12-tcp-服务单示例"><a class="header" href="#12-tcp-服务单示例">1.2 TCP 服务单示例</a></h3>
<p>Node 使用 net 模块的 createServer 方法构建 TCP 服务器。</p>
<pre><code class="language-js">const net = require('net')

const server = net.createServer()

// 创建一个套接字 socket，作为参数传递给回调函数
server.on('connection', (socket) =&gt; {
  console.log('new connection comming')
})

server.listen(() =&gt; {
  console.log('Listen...')
})
</code></pre>
<h2 id="二-tcp-编程示例"><a class="header" href="#二-tcp-编程示例">二 TCP 编程示例</a></h2>
<h3 id="21-tcp-服务端"><a class="header" href="#21-tcp-服务端">2.1 TCP 服务端</a></h3>
<pre><code class="language-js">const net = require('net')

// 创建一个套接字 socket，作为参数传递给回调函数
const server = net.createServer((socket) =&gt; {
  // socket.end(&quot;world\n&quot;);
  socket.write('world\n')
})

server.on('error', (err) =&gt; {
  throw err
})

server.on('connection', (socket) =&gt; {
  console.log('new connection comming...')
})

server.on('listening', () =&gt; {
  console.log('listening...')
})

server.on('close', (socket) =&gt; {
  console.log('close...')
})

server.listen(3001, () =&gt; {
  console.log('Listen on ', server.address())
})
</code></pre>
<h3 id="22-tcp-客户端"><a class="header" href="#22-tcp-客户端">2.2 TCP 客户端</a></h3>
<p>Node 创建 TCP 客户端只需要创建一个连接 TCP 客户端的 socket 对象即可，示例如下：</p>
<pre><code class="language-js">const net = require('net')

//新建的 client 对象（就是 socket）用来支持数据交互
const client = new net.Socket()

client.connect(3000, 'localhost', () =&gt; {
  //运行后输出该句，证明回调已经执行
  console.log('connect...')
  client.write('msg of client') //发送数据
})

//接收数据
client.on('data', (data) =&gt; {
  console.log('the data come from server is ' + data.toString())
})
</code></pre>
<p>创建 client 时候可以传入一个 json 对象，这个 json 对象有以下属性：</p>
<pre><code class="language-txt">fd：置顶一个存在的文件描述，默认为 null
readable：是否允许在这个 socket 上读，默认为 false
writeable：是否允许在这个 socket 上写，默认为 false
allowHalfOpen：该属性为 false 时，TCP 服务器接收到客户端发送的一个 FIN 包后将会回发一个 FIN 包，
                该属性为 true 时，TCP 服务器接收客户端发送的一个 FIN 包后不会回发 FIN 包。
</code></pre>
<h2 id="三-了解-tcp-与-socket"><a class="header" href="#三-了解-tcp-与-socket">三 了解 TCP 与 Socket</a></h2>
<h3 id="31-tcp-协议"><a class="header" href="#31-tcp-协议">3.1 TCP 协议</a></h3>
<p>TCP 是面向连接的，提供端到端可靠的数据流（flow of data）的协议。与其他协议相比，TCP 提供了超时重发、检验数据、流量控制等功能，保证了数据能从一段传输到另一端。</p>
<p>面向连接：在正式收发数据前，必须和对方建立可靠的连接，类似打电话需要先拨号等待应答，再说明自己是谁。这个过程称为三次握手：</p>
<pre><code class="language-txt">主机 A 向主机 B 发出连接请求数据包：可以发送数据吗？

主机 B 收到信息发送统一连接和要求同步（一个发、一个收）的数据包：可以发送

主机 A 发出确认同步包：好的，同步吧。（三次握手结束，开发正式收发数据）
</code></pre>
<p>数据可靠性的保持：</p>
<pre><code class="language-txt">数据会被切割为 TCP 认为最适合发送的数据块，应用程序产生的数据报长度会保持不变。

TCP 发出一个段后，内部启动定时器，等待目的端确认收到这个报文段，如果不能及时收到确认，将重发该报文段（自适应超时、重传策略）。

接收端收到发送端数据后，将会在延迟很短时间后，发送一个确认。

TCP 将保持它首部和数据的检验和，这是一个端到端的检验和，目的是校验传输中的数据变化，如果出现差错，TCP 会丢弃该报文段，并不确认收到该报文段。

IP 层的数据到达可能会失序，在该情况下，TCP 会对接收到的数据进行重新排序。

IP 层的数据会发生重复，TCP 的接收端会丢弃重复的数据。
</code></pre>
<p>TCP 还会提供流量控制：</p>
<pre><code class="language-txt">TCP 连接的每一方都有固定大小的缓存空间，TCP 的接收端只允许另一端发送 接收端的缓存区能接纳的数据。这可以防止较快的主机让较慢的主机缓存区溢出。
</code></pre>
<h3 id="32-socket"><a class="header" href="#32-socket">3.2 Socket</a></h3>
<p>将 Socket 绑定到一个端口号上，TCP 层才可以标识数据最终要发送到哪个应用程序。Socket 即网络上 运行在两个程序之间双向通信链路的一个端点。</p>
<p>一般场景中，绑定在端口上的 Socket 会一直在等待，监听客户端的连接请求。Socket 是可读可写的双工流。</p>
<p>对于客户端来说，其知道服务端的主机地址与端口号，所以客户端可以与服务端建立连接，此时还要把自己的本地端口告知服务端以让服务端也能识别。</p>
<p>一旦客户端与服务端的 Socket 连接建立了，双方就可以开始数据传输。这时，服务端的 Socket 已经被使用了，必须要再开启一个 Socket，才能接收新的客户端的连接。</p>
<p>贴士：IP 地址与端口号组合为<code>端点</code>，端点是 TCP 识别连接的唯一标识。</p>
<h2 id="一-node-与-udp-编程简介"><a class="header" href="#一-node-与-udp-编程简介">一 Node 与 UDP 编程简介</a></h2>
<p>TCP 数据传输是一种可靠的数据传输方式，在数据传输之前必须建立客户端与服务端之间的连接，而 UDP 是一种面向非连接的协议，所以其传输速度比 TCP 更加快速，其名称为：用户数据报协议。</p>
<p>Node 使用 dgram 模块中的 createSocket() 方法创建一个 UDP 服务器，这个方法接收一个必须参数和一个可选参数，必须参数是一个标识 UDP 协议的类型，可指定为 udp4 或者 udp6，可选参数是一个回调函数，即 UDP 服务器接收数据时触发的回调函数，回调函数有 2 个参数，一个是接收的数据，一个是存放发送者信息的对象。</p>
<pre><code class="language-js">const dgram = require('dgram')

const socket = dgram.createSocket('udp4', (msg, rinfo) =&gt; {
  // code
})

socket.bind(3000, 'localhost', () =&gt; {
  console.log('bind 3000....')
})
</code></pre>
<h2 id="二-udp-编程示例"><a class="header" href="#二-udp-编程示例">二 UDP 编程示例</a></h2>
<h3 id="21-upd-服务端"><a class="header" href="#21-upd-服务端">2.1 UPD 服务端</a></h3>
<pre><code class="language-js">const dgram = require('dgram')
const server = dgram.createSocket('udp4')

server.on('error', (err) =&gt; {
  console.log(`server error:\n${err.stack}`)
  server.close()
})

server.on('message', (msg, rinfo) =&gt; {
  console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`)
})

server.on('listening', () =&gt; {
  const address = server.address()
  console.log(`server listening ${address.address}:${address.port}`)
})
</code></pre>
<p>这里与 TCP 的 createServer 一样，返回的都是 socket 对象，且回调函数就是监听 message 事件，因此使用 createServer 也可以不指定回调函数，直接显示的监听 message 事件就可以。</p>
<h3 id="22-udp-客户端"><a class="header" href="#22-udp-客户端">2.2 UDP 客户端</a></h3>
<pre><code class="language-js">var dgram = require('dgram')

var message = new Buffer('msg from client')

var socket = dgram.createSocket('udp4')

socket.send(
  message,
  0,
  message.length,
  3000,
  'localhost',
  function (err, bytes) {
    if (err) {
      console.log(err)
      return
    } else {
      console.log('client send ' + bytes + 'message')
    }
  }
)

socket.on('message', function (msg, rinfo) {
  console.log('msg from server')
})
</code></pre>
<h3 id="三-udp-协议"><a class="header" href="#三-udp-协议">三 UDP 协议</a></h3>
<p>UDP 的全程是用户数据报协议，与 TCP 协议在网络协议中都位于传输层，是无连接协议。</p>
<p>UDP 不提供数据包分组、组装，不能对数据包进行分排序，所以当 UDP 报文发送后，无法得知其是否已经完全安全到达。</p>
<p>UDP 的主要作用是将网络数据流量压缩成数据包形式，一个典型的数据包就是一个二进制数据的传输单位，每一个数据包的前 8 个字节用来包含报头信息，剩余字节用来包含具体的传输数据。</p>
<p>UDP 协议的主要应用场合是视频会议、聊天等场合。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-web-功能-http-服务"><a class="header" href="#061-web-功能-http-服务">06.1-Web 功能-http 服务</a></h1>
<h2 id="一-简单的-node-web-程序"><a class="header" href="#一-简单的-node-web-程序">一 简单的 Node Web 程序</a></h2>
<p>简单的 Web 服务器示例：</p>
<pre><code class="language-js">var http = require('http')

var server = http.createServer(function (req, res) {
  res.writeHead(200, { 'Content-Type': 'text/plain;charset=UTF8' })
  res.end('hello world')
})

server.listen(8000)
</code></pre>
<p>以上简单的几行代码就能开启一个 web 服务，访问 <a href="http://localhost:8000">http://localhost:8000</a> ，即可看到页面输出 8000 端口。</p>
<p>Node 与传统的 web 开发最大的不同是，Node 代码不需要 Web 容器来运行：</p>
<pre><code class="language-txt">Java：Java 开发的 Web 软件，需要先将源码打包为 war 包，然后将 war 包放置在其专用 web 服务器 Tomcat 中，由 Tomcat 来运行。
Php：Php 开发的 Web 软件，需要将源码放置在其专用的 web 服务器 Apache 中，由 Apache 来运行。
</code></pre>
<h2 id="二-http-模块"><a class="header" href="#二-http-模块">二 http 模块</a></h2>
<h3 id="21-createserver"><a class="header" href="#21-createserver">2.1 createServer</a></h3>
<p><code>http.createServer()</code> 方法返回的是 http 模块封装的一个基于事件的 http 服务器。</p>
<p><code>req</code>，<code>res</code> 分别是 http.IncomingMessage 和 http.ServerResponse 的实例。</p>
<p>http.Server 的主要事件有：</p>
<ul>
<li>request：客户端发起请求时，被处罚，提供 req，res 参数</li>
<li>connection：TCP 建立连接时候处罚，提供一个 scoket 参数，是 net.Socket 的实例。</li>
<li>close：服务器关闭时，触发。</li>
</ul>
<p>http.createServer() 方法其实就是添加了一个 Reuqest 事件监听，如下所示：</p>
<pre><code class="language-js">var http = require('http')

var server = http.createServer()

server.on('error', function (err) {
  console.log(err)
})

server.on('request', function (req, res) {
  console.log('有用户请求了')
  console.log(req)
})

server.listen(8081, function () {
  console.log('server run...')
})
</code></pre>
<h3 id="22-http-模块常见-api"><a class="header" href="#22-http-模块常见-api">2.2 http 模块常见 api</a></h3>
<p><code>http.IncomingMessage</code> 是 http 请求信息，提供了 3 个事件：</p>
<ul>
<li>data：当请求数据到来时触发；</li>
<li>end：当请求体数据传输完毕时候触发；</li>
<li>close：当用户请求结束时候触发。</li>
</ul>
<p><code>http.IncomingMessage</code> 提供的属性有：</p>
<ul>
<li>method：请求方式</li>
<li>headers：请求头</li>
<li>url：请求路径</li>
<li>httpVersion：http 版本</li>
</ul>
<p><code>http.ServerResponse</code> 是返回客户端的信息，主要方法有：</p>
<ul>
<li><code>res.writeHead(statusCode,[headers];</code>：向请求的客户端发送响应头</li>
<li><code>res.write(data,[encoding]);</code>：向请求发送内容</li>
<li><code>res.end([data],[encoding);</code>：结束请求</li>
</ul>
<h2 id="一-请求处理参数处理"><a class="header" href="#一-请求处理参数处理">一 请求处理参数处理</a></h2>
<h3 id="11-get-请求参数处理"><a class="header" href="#11-get-请求参数处理">1.1 GET 请求参数处理</a></h3>
<p>GET 请求的参数封装在 <code>req.url</code> 中，只要将该字段的值解析为 json 即可：</p>
<pre><code class="language-js">var http = require('http')
var url = require('url')

var server = http.createServer(function (req, res) {
  //true 代表直接将结果解析为 json
  var params = url.parse(req.url, true).query
  console.log(params) // GET 请求参数被解析为 json 对象，如：{name:'lisi'}

  res.end('hello')
})

server.listen(8000)
</code></pre>
<h3 id="12-post-请求参数处理"><a class="header" href="#12-post-请求参数处理">1.2 POST 请求参数处理</a></h3>
<p>POST 请求的参数封装在请求体中，Node 需要不断监听，每当接收到请求体数据，就累加到 post 参数的变量中：</p>
<pre><code class="language-js">var http = require('http');
var querystring = require('querystring');

http.createServer( function(req,res){

    var str = '';

    req.on('data',function(data){
         str += data;
    });

    req.on('end',function{

        // 将 post 请求体数据转换为 json 格式
        var params = querystring.parse(str);
        console.log(params);

    });

    res.end();

}).listen(8000);
</code></pre>
<h2 id="二-响应处理"><a class="header" href="#二-响应处理">二 响应处理</a></h2>
<h3 id="21-返回响应结果"><a class="header" href="#21-返回响应结果">2.1 返回响应结果</a></h3>
<p>示例：</p>
<pre><code class="language-js">var http = require('http')

var server = http.createServer(function (req, res) {
  res.write('&lt;h1&gt;hello world&lt;/h1&gt;')
  res.end()
})

server.listen(8000)
</code></pre>
<p><code>res.write()</code> 中的参数即返回给浏览器的字符串，浏览器可以识别字符串中的标签，然后进行渲染。当然 <code>res.end()</code> 也可以返回这些数据，会追加在 <code>write()</code> 渲染的界面之后。</p>
<h3 id="22-编码处理"><a class="header" href="#22-编码处理">2.2 编码处理</a></h3>
<p>Node 本身的编码与浏览器的编码一致，才能使返回结果正确的渲染在界面上，该场景尤其提现在返回结果包含中文时：</p>
<pre><code class="language-js">res.setHeader('Content-Type', 'text/html; charset=utf-8')
res.end('你好')
</code></pre>
<h3 id="23-响应头其他格式"><a class="header" href="#23-响应头其他格式">2.3 响应头其他格式</a></h3>
<p>上述示例中，响应头默认都是 <code>text/html</code> 格式，只能返回普通的 html 文档，一些特殊文件，如多媒体，则需要对响应头进行特殊处理。</p>
<p>响应 png 图片：</p>
<pre><code class="language-js">res.setHeader('Content-Type', 'image/png')
res.end()
</code></pre>
<p>响应 CSS：</p>
<pre><code class="language-js">res.setHeader('Content-Type', 'text/css')
res.end()
</code></pre>
<h3 id="24-writehead"><a class="header" href="#24-writehead">2.4 writeHead()</a></h3>
<p>无论是 <code>res.statusCode = 200</code>, 还是 <code>res.setHeader()</code> 等方法，其最终在内部都会调用 <code>res.writeHead()</code> 方法将之前的一些响应头设置写入响应数据中。</p>
<h2 id="三-node-请求报文解析"><a class="header" href="#三-node-请求报文解析">三 Node 请求报文解析</a></h2>
<h3 id="30-报文解析原理"><a class="header" href="#30-报文解析原理">3.0 报文解析原理</a></h3>
<p>Node 的 http 模块其实是对 HTTP 报文的头进行解析，然后触发了 request 事件。如果请求中还带有内容部分（如 POST 请求具有报头、内容），内容部分需要用户自行接收和解析，通过报头的 Transfer-Encoding 或者 Content-Length 即可判断请求中是否带有内容：</p>
<pre><code class="language-js">function hasBody(req) {
  return 'transter-encoding' in req.headers || 'content-length' in req.headers
}
</code></pre>
<p>在 HTTP_Parser 解析报头结束后，报文内容部分会通过 data 事件触发，用户以流的方式处理即可：</p>
<pre><code class="language-js">function (req, res){

    if (!hasBody(req)) {
        console.log(&quot;没有数据报文可解析&quot;);
        return
    }

    var bufs = [];

    req.on('data', function(chunk){
        bufs.push(chunk);
    });

    req.on('end', function(){
        // 将接受到的 Buffer 列表转换为 Buffer 对象，再转换为没有乱码的字符串，暂时存放于 rawBody 属性处
        req.rawBody = Buffer.concat(buffers).toString();
    })

}
</code></pre>
<h3 id="31-普通表单数据解析"><a class="header" href="#31-普通表单数据解析">3.1 普通表单数据解析</a></h3>
<p>有了上面的函数，就可以用来直接解析表单中的数据了：</p>
<pre><code class="language-js">function handle(req, res){
    if(req.headers['contengt-type]' === 'application/x-www-form-urlencoded'){
        req.body = querystring.parse(req.rawBody);
    }
    // 业务代码
}
</code></pre>
<h3 id="32-解析-json-数据"><a class="header" href="#32-解析-json-数据">3.2 解析 json 数据</a></h3>
<p>如果提交的数据是 JSON，在 Node 中直接就可以处理，但是需要注意的是，Content-Type 中可能还附带了如下的编码信息：</p>
<pre><code class="language-txt">Content-Type:application/json;charset=utf-8
</code></pre>
<p>在判断时就需要注意区分：</p>
<pre><code class="language-js">function(req, res){
    if(req.headers['contengt-type]' === 'application/json'){
        var str = req.headers['content-type'] || '';
        console.log(&quot;json 参数为：&quot;, str.split(';')[0]);
    }
}
</code></pre>
<p>Node 直接解析 JSON 文件：</p>
<pre><code class="language-js">function handle(req, res) {
  if (mime(req) === 'application/json') {
    try {
      req.body = JSON.parse(req.rawBody)
    } catch (e) {
      res.writeHead(400)
      res.end('Invalid JSON')
      return
    }
  }
  // 业务代码
}
</code></pre>
<h3 id="33-node-解析-xml-文件"><a class="header" href="#33-node-解析-xml-文件">3.3 Node 解析 XML 文件</a></h3>
<p>同样 XML 的请求类型是<code>application/xml</code>，但是 Node 不能直接解析 XML，需要借助第三方库，如<code>xml2js</code>：</p>
<pre><code class="language-js">var xml2js = require('xml2js')

function handle(req, res) {
  if (mime(req) === 'application/xml') {
    xm2js.parseString(req.rawBody, function (err, xml) {
      if (err) {
        console.log('解析 XML 异常：', err)
        res.writeHead(400)
        res.end('Invalid XML')
        return
      }

      req.body = xml
      // 业务代码
    })
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="062-web-功能-路由解析"><a class="header" href="#062-web-功能-路由解析">06.2-Web 功能-路由解析</a></h1>
<h2 id="一-简单的路由实现"><a class="header" href="#一-简单的路由实现">一 简单的路由实现</a></h2>
<p>根据请求接口地址的不同，返回不同的结果，简单示例如下：</p>
<pre><code class="language-js">var http = require('http')
var url = require('url')
var fs = require('fs')

var server = http.createServer()

server.on('request', function (req, res) {
  console.log('有用户请求了')

  var urlStr = url.parse(req.url)

  switch (urlStr.pathname) {
    case '/': //首页
      res.writeHead(200, { 'content-type': 'text/html;charset=utf-8' })
      res.end('&lt;h1&gt;这是首页&lt;/h1&gt;')
      break
    case '/user': //用户页面
      sendData(__dirname + '/html/' + '1.html', req, res)
      break
    default:
      res.writeHead(404, { 'content-type': 'text/html;charset=utf-8' })
      res.end('&lt;h1&gt;页面不存在&lt;/h1&gt;')
      break
  }
})

function sendData(filePath, req, res) {
  fs.readFile(filePath, function (err, data) {
    if (err) {
      res.writeHead(404, { 'content-type': 'text/html;charset=utf-8' })
      res.end('&lt;h1&gt;页面不存在&lt;/h1&gt;')
    } else {
      res.writeHead(200, { 'content-type': 'text/html;charset=utf-8' })
      console.log(String(data))
      res.end(data)
    }
  })
}

server.listen(8081, 'localhost')
</code></pre>
<h2 id="二-路由实现"><a class="header" href="#二-路由实现">二 路由实现</a></h2>
<h3 id="20-路由实现方式"><a class="header" href="#20-路由实现方式">2.0 路由实现方式</a></h3>
<p>路由可以是自然映射的，即在实际开发中，按照一定的约定，不需要手动维护路由与控制器（action）的关联，但是这种方式需要严格遵守开发规范，如：静态服务。</p>
<p>下面是手工映射路由的实现原理示例。</p>
<h3 id="21-手工映射---核心实现"><a class="header" href="#21-手工映射---核心实现">2.1 手工映射 - 核心实现</a></h3>
<p>路由的映射，其实就是在 Node 服务启动后，内部维护了一个数据结构，这个结构的实例存储了路由与控制器函数的对应关系，这里暂且使用数组作为存储结构，那么应该是这个样子：</p>
<pre><code class="language-js">const routes = [
  {path: &quot;/user/info&quot;, action: function info(){} },
  {path: &quot;/user/add&quot;, action: function add(){} },
  {path: &quot;/user/update&quot;, action: function update(){} },
  {path: &quot;/user/delete&quot;, action: function delete(){} },
]
</code></pre>
<p>定义一个路由数组：</p>
<pre><code class="language-js">var routes = []
function use(path, action) {
  routes.push({
    path: path,
    action: action,
  })
}
</code></pre>
<p>在程序的入口判断 URL，然后执行对应逻辑，以完成路由映射</p>
<pre><code class="language-js">function (req, res){

    var pathname = url.parse(req.url).pathname;

    for(var i = 0; i &lt; routes.length; i++){
        if(pathname === routes[i]){
            routes[i].action(req, res);
            return
        }
    }

    // 处理 404

}
</code></pre>
<p>在一些场景中，路由中直接携带了参数，如：<code>/user/lisi</code>，lisi 是一个参数，并不是真实的路由，用户期望的请求路由应该是：</p>
<pre><code class="language-js">use('/user/:username', function (req, res) {
  // TODO
})
</code></pre>
<p>这里可以改进路由匹配方式，在通过 use 注册时，将路径转换为一个正则表达式，然后进行匹配：</p>
<pre><code class="language-js">var pathRegexp = function (path) {
  path = path
    .concat(strict ? '' : '/?')
    .replace(/\/\(/g, '(?:/')
    .replace(
      /(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g,
      function (_, slash, format, key, capture, optional, star) {
        slash = slash || ''
        return (
          '' +
          (optional ? '' : slash) +
          '(?:' +
          (optional ? slash : '') +
          (format || '') +
          (capture || (format &amp;&amp; '([^/.]+?)') || '([^/]+?)') +
          ')' +
          (optional || '') +
          (star ? '(/*)?' : '')
        )
      }
    )
    .replace(/([\/.])/g, '\\$1')
    .replace(/\*/g, '(.*)')
  return new RegExp('^' + path + '$')
}
</code></pre>
<p>注册的代码对应修改为：</p>
<pre><code class="language-js">function use(path, action) {
  routes.push({
    path: pathRegexp(path),
    action: action,
  })
}
</code></pre>
<p>路由匹配的代码：</p>
<pre><code class="language-js">function (req, res){

    var pathname = url.parse(req.url).pathname;

    for(var i = 0; i &lt; routes.length; i++){
        if(routes[i].path.exec(pathname)){
            routes[i].action(req, res);
            return
        }
    }

    // 处理 404

}
</code></pre>
<p>上述步骤完成了 URL 匹配，但是没有解决:username 匹配到了什么，在实际业务中，用户期待如下使用方式：</p>
<pre><code class="language-js">use('/user/:username', function (req, res) {
  var username = req.params.username
  // TODO
})
</code></pre>
<p>这里的目标是将抽取的内容设置到 req.params 处，第一步应该将键值抽取出来：</p>
<pre><code class="language-js">var pathRegexp = function(path) {

    var keys = [];          // 设置保存的 key

    path = path
        .concat(strict ? '' : '/?')
        .replace(/\/\(/g, '(?:/')
        .replace(
            /(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g,
            function(_, slash, format, key, capture,optional, star){
                keys.push(key);             // 将匹配到的键值保存起来
                slash = slash || '';
                return ''
                        + (optional ? '' : slash)
                        + '(?:'
                        + (optional ? slash : '')
                        + (format || '') + (capture || (format &amp;&amp; '([^/.]+?)' || '([^/]+?)')) + ')'
                        + (optional || '')
                        + (star ? '(/*)?' : '');
                })
        .replace(/([\/.])/g, '\\$1')
        .replace(/\*/g, '(.*)');
        return {
            keys: keys.
            regexp: new RegExp('^' + path + '$');
        }
}
</code></pre>
<p>此时的匹配代码：</p>
<pre><code class="language-js">function (req, res){

    var pathname = url.parse(req.url).pathname;

    for(var i = 0; i &lt; routes.length; i++){

        var reg = routes[i].regexp;
        var keys = route[i].keys;
        var matched = req.exec(pathname);

        if(matched){
            var params = {};
            for (var i = 0; i &lt; routes.length; i++) {
                var value = mathced[i + 1];
                if (value){
                    params[keys[i]] = value;
                }
            }

            req.params = params;
            var action = route[i];
            action(req, res);
            return
        }

    }

    // 处理 404

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="063-web-功能-静态服务"><a class="header" href="#063-web-功能-静态服务">06.3-Web 功能-静态服务</a></h1>
<h2 id="一-node-没有-web-容器"><a class="header" href="#一-node-没有-web-容器">一 Node 没有 web 容器</a></h2>
<p>由于 Node 的网络服务不需要 Web 容器，这样也造成了静态文件无法直接访问，必须手动维护一个一个服务端上的静态文件提供给客户端。</p>
<p>如果这时候采用手工映射路由，那么工程量就实在太浩大了，可以采用自然映射，如：Node 提供一个静态服务，请求的网址就是文件所在的目录地址，类似地址<code>/public/products/apple.png</code>，该 url 地址直接和资源在一起，就无需手动一一映射了。</p>
<h2 id="二-静态资源服务简单实现"><a class="header" href="#二-静态资源服务简单实现">二 静态资源服务简单实现</a></h2>
<pre><code class="language-js">const http = require('http')
const fs = require('fs')
const path = require('path') //用来判断请求的文件的扩展名

http
  .createServer((req, res) =&gt; {
    let urlStr = req.url

    // 静态路由渲染列表
    res.render = function (urlStr) {
      // 拼接完整的服务端资源路径：假设静态资源文件都放置在项目根目录的 public 文件夹中
      let filename = path.join(__dirname, urlStr) // 服务端上资源文件全名

      fs.readFile(filename, function (err, data) {
        if (err) {
          res.writeHead(404, { 'Content-Type': 'text/html;charset=UTF8' })
          res.end('404')
          return
        }

        let mime = getMime(path.extname(urlStr))
        res.writeHead(200, { 'Content-Type': mime })
        res.end(data)
      })
    }

    // 静态服务路由
    if (urlStr.substring(0, 8) == '/public/') {
      res.render(urlStr)
      return
    }

    // 其他一系列路由列表，这里省略
    res.end('main page...')
    return
  })
  .listen(3000)

function getMime(extname) {
  switch (extname) {
    case '.html':
      return 'text/html'
      break
    case '.css':
      return 'text/css'
      break
    case '.jpg':
      return 'image/jpg'
      break
    case '.png':
      return 'image/png'
      break
  }
}
</code></pre>
<h2 id="三-静态资源缓存"><a class="header" href="#三-静态资源缓存">三 静态资源缓存</a></h2>
<p>每次请求服务器的静态资源，都会造成 IO 上的浪费，那么我们可以使用缓存来优化性能。当浏览器中有缓存副本时，不确定该副本是否有效，会生成一个 get 请求，在该请求的 header 中包含一个 if-modified-since 时间参数。如果服务器端文件在这个时间参数后修改过了，服务器发送全部文件给客户端，如果没有，则返回 304 状态码，并不发送整个文件。</p>
<p>如果确定该副本有效，客户端不会发送 GET 请求。判断有效的方法是：服务端响应头上带有 expires 头。</p>
<p>Expires：是一个毫秒值，如果该值小于当前时间，则不缓存。</p>
<pre><code class="language-JavaScript">const http = require('http');
const url = require('url');
const fs = require('fs');

http.createServer(function (req,res) {
    let pathname = url.parse(req.url).pathname;
    if(pathname == '/favicon.ico'){
        return;
    } else {
        dealStatic(req,res,pathname);
    }
}).listen(80);


function dealStatic(req,res,pathname) {
    console.log('pathname=' + pathname);
    let realPath = __dirname + '\\public\\' + pathname.toString().substr(1);
    console.log('realPath=' + realPath);
    if(pathname == '/' || pathname == '/index'){
        res.writeHead(200);
        res.end('hi');
    } else {
        fs.exists(realPath,function (exists) {
            if(!exists){                //文件不存在
                res.writeHead(404,{'Content-Type':'text/plain'});
                res.end('404');
            }else {

                let mimeString = pathname.substring(pathname.lastIndexOf('.') + 1);
                console.log('mimeString=' + mimeString);
                let mimeType = null;
                switch (mimeString){
                    case 'css': mimeType = 'text/css';
                        break;
                    case 'png': mimeType = 'image/png';
                        break;
                    default: mimeType = 'text/plain';
                }

                let fileInfo = fs.statSync(realPath);
                //获取服务器文件最后修改时间
                let lastModified = fileInfo.mtime.toUTCString();
                //设置7天缓存存在时间
                let CACHETIME = 60*60*24*7;
                /*
                客户端请求时间 大于 Expires（date值）发送新请求
                客户端请求时间 小于 Expires（date值）读取本地缓存
                 */
                let date = new Date();
                //当前时间+缓存时间
                date.setTime(date.getTime() + CACHETIME*1000);

                if(req.headers['if-modified-since'] &amp;&amp; lastModified == req.headers['if-modified-since']){
                    console.log('执行了读取本地缓存');
                    res.writeHead(304,'Not Modified');
                    res.end('304');
                } else {
                    fs.readFile(realPath,function (err,file) {
                        if(err){
                            res.writeHead(500);
                            res.end(err);
                        } else {
                            //没有缓存，设置缓存
                            console.log('执行了发送服务器文件');
                            res.setHeader('Expires',date.toUTCString());
                            res.setHeader('Cache-Control','max-age=' + CACHETIME);
                            res.setHeader('Last-Modified',lastModified);
                            res.writeHead(200,{'Content-Type':mimeType});
                            res.end(file);
                        }
                    });
                }
            }
        });
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="064-web-功能-视图渲染"><a class="header" href="#064-web-功能-视图渲染">06.4-Web 功能-视图渲染</a></h1>
<h2 id="一-响应体"><a class="header" href="#一-响应体">一 响应体</a></h2>
<h3 id="11-mime"><a class="header" href="#11-mime">1.1 MIME</a></h3>
<p>在响应体中，有个字段很重要：<code>Content-*</code>，如下所示：</p>
<pre><code class="language-txt">Content-Encoding: gzip
Content-Length: 21170
Content-Type: text/javascript; charset=utf-8
</code></pre>
<p>上述字段告诉了客户端，需要用 gzip 来解码报文内容，可以用 21170 长度校验文本内容是否正确，然后再以 UTF-8 字符将解码后的脚本插入到文档节点中。</p>
<p>Content-Type 中的字段为：MIME，用来告知客户端浏览器使用哪种渲染方式，如下所示返回的字符串为：</p>
<pre><code class="language-txt">&lt;h1&gt;hello&lt;/h1&gt;
</code></pre>
<p>当 MIME 为：<code>text/plain</code>时，会将上述字符全部显示，当 MIME 为<code>text/html</code>时，会按照 html 语法解析显示。</p>
<p>Node 的第三方库，可以用来判断 mime 类型。</p>
<h3 id="12-附件下载"><a class="header" href="#12-附件下载">1.2 附件下载</a></h3>
<p>在下载场景中，无论什么样的 MIME 值，需求并不要求客户端打开，而是弹出下载即可。Content-Disposition 字段用于判断报文数据是浏览器内容还是可下载附件。</p>
<pre><code class="language-txt">Content-Disposition: attachment; filename=&quot;filename.ext&quot;
</code></pre>
<p>设计一个 API 响应附件下载：</p>
<pre><code class="language-js">res.sendfile = function (filepath) {
    fs.stat(filepath, function(err, stat) {

        var stream = fs.createReadStream(filepath);
        // 设置内容
        res.setHeader('Content-Type', mime.lookup(filepath));
        // 设置长度
        res.setHeader('Content-Length', stat.size);
        // 设置为附件
        res.setHeader('Content-Disposition' 'attachment; filename=&quot;' + path.basename(filepath) + '&quot;');
        res.writeHead(200);
        stream.pipe(res);
    });
};
</code></pre>
<h3 id="13-响应-json"><a class="header" href="#13-响应-json">1.3 响应 JSON</a></h3>
<p>可以为 JSON 响应封装一个 API：</p>
<pre><code class="language-js">res.json = function (json) {
  res.setHeader('Content-Type', 'application/json')
  res.writeHead(200)
  res.end(JSON.stringify(json))
}
</code></pre>
<h3 id="14-响应跳转"><a class="header" href="#14-响应跳转">1.4 响应跳转</a></h3>
<pre><code class="language-js">res.redirect = function (url) {
  res.setHeader('Location', url)
  res.writeHead(302)
  res.end('Redirect to ' + url)
}
</code></pre>
<h2 id="二-模板引擎"><a class="header" href="#二-模板引擎">二 模板引擎</a></h2>
<h3 id="20-模板引擎设计"><a class="header" href="#20-模板引擎设计">2.0 模板引擎设计</a></h3>
<p>最早的服务端动态页面开发，是在 CGI 程序或者 Servlet 中输出 HTML 片段，通过网络流输出到客户端，客户端将其渲染到用户界面。这种场景下，逻辑代码与 HTML 输出代码混杂在一起，会引起开发的极大不便，甚至每次更新需要重新编译。</p>
<p>ASP，PHP，JSP 等服务端动态网页技术可以将 HTML 于逻辑代码分离出来，通过特殊的标签，如（&lt;% %&gt;），通过 HTML 与模板标签混排，将开发者从输出 HTML 的工作中解脱出来。虽然该方案现在渐渐开始被单页面应用淘汰，但是仍然占据很大市场，如需要 SEO 的网站。</p>
<p>模板其本质其实就是拼接字符串！</p>
<p>Node 没有内置动态网页技术，必须依赖第三方库。一般可以将渲染页面的方法设计为 render()，参数是模板路径和数据：</p>
<pre><code class="language-js">res.render = function (view, data) {
  res.setHeader('Content-Type', 'text/html')
  res.writeHead(200)
  var html = render(view, data)
  res.end(html)
}
</code></pre>
<p>现在来实现 render 方法：</p>
<pre><code class="language-js">var render = function (str, data) {

    var tpl = str.replace(/&lt; =([ % \s\S]+?) &gt;/g, function(match, code) { %
        return &quot;' + obj.&quot; + code + &quot;+ '&quot;;
    });

    tpl = &quot;var tpl = '&quot; + tpl + &quot;'\nreturn tpl;&quot;;
    var complied = new Function('obj', tpl);

    return complied(data);
};
</code></pre>
<p>模板编译：</p>
<pre><code class="language-js">tpl = &quot;var tpl = '&quot; + tpl + &quot;'\nreturn tpl;&quot;
var complied = new Function('obj', tpl)
</code></pre>
<p>笔者这里一向不推荐模板技术，这里点到为止了！！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="065-web-功能-文件上传"><a class="header" href="#065-web-功能-文件上传">06.5-Web 功能-文件上传</a></h1>
<h2 id="一-文件上传"><a class="header" href="#一-文件上传">一 文件上传</a></h2>
<h3 id="10-文件上传的编码格式"><a class="header" href="#10-文件上传的编码格式">1.0 文件上传的编码格式</a></h3>
<p>文件上传的编码格式一般是：</p>
<pre><code class="language-js">&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
  &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;{' '}
  &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt;
  &lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt; &lt;input
    type=&quot;file&quot;
    name=&quot;file&quot;
    id=&quot;file&quot;
  /&gt; &lt;br /&gt;
  &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
&lt;/form&gt;
</code></pre>
<h3 id="11-原生文件上传"><a class="header" href="#11-原生文件上传">1.1 原生文件上传</a></h3>
<p>在 POST 请求说明中，使用了字符串变量 str 来接收，如果上传的是文本文件，则仍然是正确的，但是如果上传的是图片、音频等，这里就无法实现了，我们可以使用数组的形式保存：</p>
<pre><code class="language-js">var http = require('http')

var server = http.createServer(function (req, res) {
  var arr = []

  req.on('data', function (data) {
    arr.push(data)
  })

  req.on('end', function () {
    var buf = Buffer.concat(arr)
    console.log(buf.toString())
    res.end()
  })
})

server.listen(8000, function () {
  console.log('server is started...')
})
</code></pre>
<h3 id="12-第三方模块-formidable"><a class="header" href="#12-第三方模块-formidable">1.2 第三方模块 formidable</a></h3>
<p>原生文件上传过于复杂，一般使用第三方框架实现，常见的文件上传框架是 formidable：</p>
<pre><code class="language-js">var url = require('url');
var http = require('http');
var path = require('path');

var formidable = require('formidable');

http.createServer(function (req,res) {

    var pathname = url.parse(req.url).pathname;

    var (pathname == '/upload' &amp;&amp; req.method.toLowerCase() == &quot;post&quot;) {
        uploading(req,res);
    }
}).listen(3000);

//图片上传的方法
function uploading(req,res) {

    var form = new formidable.IncomingForm();

    form.uploadDir = path.join(__dirname, './upload');

    form.parse(req, function (err, fields, files) {
        if (err) throw err;
        res.writeHead(200, {'content-type': 'text/plain;charset=utf8'});
        res.end('上传成功');
    });
}
</code></pre>
<h2 id="二-文件上传解析原理"><a class="header" href="#二-文件上传解析原理">二 文件上传解析原理</a></h2>
<p>浏览器在遇到<code>enctype=&quot;multipart/form-data&quot;</code>表单提交时，构造的请求报文与普通表单完全不同。</p>
<p>报头如下所示：</p>
<pre><code class="language-txt">Content-Type: multipart/form-data; boundary=AaB03x
Content-Length: 18231
</code></pre>
<p>其中<code>boundary=AaB03x</code>指定的是每部分内容的分界符，AaB03x 是随机产生的一段字符串，报文体的内容将通过在它前面添加 -- 进行分割，报文结束时在它前后都加上 -- 表示结束。</p>
<p>Content-Length 的值也必须是报文体的长度。</p>
<p>普通数据报文如下：</p>
<pre><code class="language-txt">--AaB03x\r\n
Content-Disposition: form-data; name=&quot;username&quot;\r\n
\r\n
lisi\r\n
</code></pre>
<p>上传文件的报文如下：</p>
<pre><code class="language-txt">--AaB03x\r\n
Content-Disposition: form-data; name=&quot;username&quot;\r\n
\r\n
lisi\r\n
--AaB03x\r\n
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;demo.js&quot;\r\n
Content-Type: application/javascript\r\n
\r\n
... demo.js 的文本内容 ...
--AaB03x--
</code></pre>
<p>这时候就可以对该编码格式进行对应方法书写：</p>
<pre><code class="language-js">function(req, res){
    if(mime(req) === 'multipart/form-data'){
        parseMultipart(req, done);          // 该方法是具体的解析方法，done 是解析后的回调函数
    }
}
</code></pre>
<h2 id="三-文件上传的安全性"><a class="header" href="#三-文件上传的安全性">三 文件上传的安全性</a></h2>
<p>在解析普通表单、JSON、XML 时，一般会先保存用户提交的数据，然后再解析，最后传递给业务逻辑。该方式适合小数据提交，一旦数据量过大，则会产生内存不足现象，同时也会很容易被伪造的大量数据攻击。</p>
<p>一般解决方案有两种：</p>
<ul>
<li>限制上传内容大小，超过限制则停止接收数据，并相应 400 状态码</li>
<li>流式解析数据，将数据流持久化到磁盘中，Node 只保留文件路径名等小数据</li>
</ul>
<p><code>formidable</code>库即是通过流式处理的数据上传，在一些 web 框架中，也会对内容直接进行大小限制，如 Express 内部的 Connect 中间件：</p>
<pre><code class="language-js">var bytes = 1024;

function (req, res) {

    var received = 0;
    var len = req.headers['content-length'] ? parseInt(req.headers['content-length'], 10) : null;

    // 如果内容超过长度限制，则返回请求实体过长的状态码
    if (len &amp;&amp; len &gt; bytes) {
        res.writeHead(413);
        res.end();
        return;
    }

    // limit
    req.on('data', function (chunk) {
        received += chunk.length;
        if (received &gt; bytes) {
            // 停止接收数据，触发 end()
            req.destroy();
        }
    });

    handle(req, res);
};
</code></pre>
<p>在上面的代码中，数据是由包含 Content-Length 的请求报文判断是否长度超过限制的，若没有 Content-Length 报文，可以在每个 data 事件中判断。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="071-web-框架-express"><a class="header" href="#071-web-框架-express">07.1-Web 框架-Express</a></h1>
<h2 id="一-express-初识"><a class="header" href="#一-express-初识">一 Express 初识</a></h2>
<p>安装方式：</p>
<pre><code class="language-txt"># 初始化一个项目
mkdir myproject
cd myproject
npm init -y
npm install express -S
</code></pre>
<p>使用 express 启动一个 web 服务：</p>
<pre><code class="language-js">var express = require('express')

var app = express()

app.get('/', function (req, res) {
  res.send('hello world!')
})

app.listen(3000)
</code></pre>
<h2 id="二-express-常见技术使用"><a class="header" href="#二-express-常见技术使用">二 Express 常见技术使用</a></h2>
<h3 id="21-静态服务"><a class="header" href="#21-静态服务">2.1 静态服务</a></h3>
<pre><code class="language-JavaScript">app.use(express.static(&quot;./public&quot;));
//一句话，就将public文件夹变为了静态服务文件夹。当然也可以指定访问路由名称：
app.use('/test',express.static('public'));  //test是虚拟路径
</code></pre>
<h3 id="22-模板引擎"><a class="header" href="#22-模板引擎">2.2 模板引擎</a></h3>
<pre><code class="language-JavaScript">app.set(&quot;view engine&quot;,&quot;ejs&quot;);
app.get(&quot;/&quot;,function(req,res){
    res.render(&quot;haha&quot;,{
        &quot;news&quot; : [&quot;我是小新闻啊&quot;,&quot;我也是啊&quot;,&quot;哈哈哈哈&quot;]
    });
});
//但是上述模板引擎定义后，我们使用的模板依然需要修改后缀为设定的引擎后缀，进行下列设定，无需修改html后缀：
app.engine('html',ejs.renderFile);
app.set('view engine','html');
</code></pre>
<h3 id="23-错误处理"><a class="header" href="#23-错误处理">2.3 错误处理</a></h3>
<p>一般情况下，普通的错误，重定向或者展示一个错误页面即可，express 内部在执行路由时候，其实也是用到了 tyr catch。但是这些并不是真正的捕获了异常。如下无法捕获：</p>
<pre><code class="language-JavaScript">app.get('/test', function (req, res) {
    process.nextTick(function () {
        throw new Error('error');
    });
});
</code></pre>
<p>该错误被推迟到 Node 空闲时执行，但是当 Node 空闲时，上下文已经不存在了，所以只能关闭服务器！！！出现未捕获异常，唯一能做的是关闭服务器，但是我们要保证服务器的正常关闭，且有故障转移，最容易的故障转移机制是集群。</p>
<p>正常关闭服务器办法，node 有 2 个：uncaughtException 事件和域，严重推荐后者。域是一个执行上下文，会捕获在其中发生的错误。</p>
<p>每个请求都在域中处理，能达到很好的错误处理，封装一个放在最前的中间件：</p>
<pre><code class="language-JavaScript">const express = require('express');

let app = express();

app.use(function (req, res,next) {

    let domain = require('domain').create();    //为这个请求创建一个域
    domain.on('error',function (err) {
        console.log(&quot;domain err &quot; + err.stack);
    });

    try  {

        setTimeout(function () {         //5秒内故障保护关机
            console.log('server shutdown');
        },5000);

        let worker = require('cluster').worker;
        if (worker) worker.disconnect();    //从集群断开

        server.close();             //停止接收新请求

        try {
            next(err);  //尝试使用express错误路由
        } catch (e) {
            console.log(&quot;express error failed &quot; +e.stack);      //如果express错误路由失效
            res.statusCode = 500;
            res.setHeader('content-type','text/plain');
            res.end('Server error');
        }
    } catch (error) {
        console.log('Unable to send 500 ', error.stack);
    }

    domain.add(req);        //向域中添加请求、响应对象
    domain.add(res);
    domain.run(next);
});

app.get('/test', function (req, res) {
    process.nextTick(function () {
        throw new Error('error');
    });
});

app.listen(3000);
</code></pre>
<p>上面的代码中，一旦出现未捕获错误，就会调用该函数。</p>
<h2 id="三-express-路由"><a class="header" href="#三-express-路由">三 Express 路由</a></h2>
<h3 id="31-路由展示"><a class="header" href="#31-路由展示">3.1 路由展示</a></h3>
<pre><code class="language-JavaScript">const express = require('express');
let app = express();

app.get('/',function (req,res) {
    res.send('hi');
});

app.get('/showname',function () {
    res.send('name si lisi');
});

app.get(/^\/student\/([\d]{10})$/,function(req,res){
    res.send(&quot;学生信息，学号&quot; + req.params[0]);
});

app.get(&quot;/teacher/:gonghao&quot;,function(req,res){
    res.send(&quot;老师信息，工号&quot; + req.params.gonghao);
});

app.listen(3000);

</code></pre>
<p>注意：express 使用 res.set 和 res.status 取代了原生的 res.writeHead()</p>
<h3 id="32-常见路由-api"><a class="header" href="#32-常见路由-api">3.2 常见路由 API</a></h3>
<pre><code class="language-js">app.get('网址', function (req, res) {}) //get 请求
app.post('网址', function (req, res) {}) //post 请求
app.all('网址', function () {}) //处理这个网址的任何类型请求
</code></pre>
<p>注意：</p>
<ul>
<li>所有的 GET 参数，? 后面的都已经被忽略，锚点#也被忽略，路由到/a，实际/a?id=2&amp;sex=nan 也能被处理；</li>
<li>正则表达式中，未知部分用圆括号分组，然后可以用 req.params[0]、[1] 得到，req.params 是一个类数组对象。</li>
</ul>
<p>如果 get、post 回调函数中，没有 next 参数，那么就匹配上第一个路由，就不会往下匹配了。如果想往下匹配的话，那么需要写 next()：</p>
<pre><code class="language-JavaScript">app.get(&quot;/&quot;,function(req,res,next){
    console.log(&quot;1&quot;);
    next();
});

app.get(&quot;/&quot;,function(req,res){
    console.log(&quot;2&quot;);
});
</code></pre>
<h3 id="33-参数获取"><a class="header" href="#33-参数获取">3.3 参数获取</a></h3>
<p>GET 请求的参数在 URL 中，在原生 Node 中，需要使用 url 模块来识别参数字符串。在 Express 中，不需要使用 url 模块了。可以直接使用 req.query 对象。</p>
<p>POST 请求的参数在 express 中不能直接获得，必须使用 body-parser 模块。使用后，将可以用 req.body 得到参数。但是如果表单中含有文件上传，那么还是需要使用 formidable 模块。</p>
<p>冒号参数引起的路由问题：</p>
<pre><code class="language-JavaScript">app.get(&quot;/:username/:id&quot;,function(req,res){    //express推荐使用冒号获得参数
    console.log(&quot;1&quot;);
    res.send(&quot;用户信息&quot; + req.params.username);
});

app.get(&quot;/admin/login&quot;,function(req,res){
    console.log(&quot;2&quot;);
    res.send(&quot;管理员登录&quot;);
});

</code></pre>
<p>上面两个路由，感觉没有关系，但是实际上冲突了，因为 admin 可以当做用户名 login 可以当做 id。</p>
<pre><code class="language-JavaScript">//解决方法1 交换位置。 也就是说，express中所有的路由（中间件）的顺序至关重要，匹配上第一个，就不会往下匹配了。 具体的往上写，抽象的往下写。
app.get(&quot;/admin/login&quot;,function(req,res){
    console.log(&quot;2&quot;);
    res.send(&quot;管理员登录&quot;);
});

app.get(&quot;/:username/:id&quot;,function(req,res){
    console.log(&quot;1&quot;);
    res.send(&quot;用户信息&quot; + req.params.username);
});

//解决方法2：
app.get(&quot;/:username/:id&quot;,function(req,res,next){
    let username = req.params.username;
    //检索数据库，如果username不存在，那么next()
    if(检索数据库){
        console.log(&quot;1&quot;);
        res.send(&quot;用户信息&quot;);
    }else{
        next();
    }
});

app.get(&quot;/admin/login&quot;,function(req,res){
    console.log(&quot;2&quot;);
    res.send(&quot;管理员登录&quot;);
});
</code></pre>
<h3 id="34-路由匹配"><a class="header" href="#34-路由匹配">3.4 路由匹配</a></h3>
<p>app.use() 他的网址不是精确匹配的，使用 user(path,fn()) 时候，user 内的路由，将匹配/path /path/images/ /path/images/1.png 等路由情况。</p>
<p>如果写一个 / 实际上就相当于&quot;/&quot;，就是所有网址，也可以直接不写该地址。</p>
<h2 id="四-中间件"><a class="header" href="#四-中间件">四 中间件</a></h2>
<h3 id="41-中间件概念"><a class="header" href="#41-中间件概念">4.1 中间件概念</a></h3>
<p>在业务系统中，往往接口都必须经过一些特殊方法进行处理后，才会执行下一步动作。而当多个接口都要应用到这些处理时，每个接口都书写一遍显然是不合适的。我们可以利用类似 Java 的 filter 原理，在 Node 中也制作类似的方法，让路由在执行控制器方法之前先执行这些通用方法。这些通用方法即是中间件。</p>
<p>由于中间件往往需要对请求的上下文，即请求对象 req、响应对象 res，进行一定的封装处理，所以中间件函数必须具备这 2 个参数，而且中间件也必须提供一种机制，在当前中间处理完成后，通知下一个中间件执行，在 Node 框架 Connect 中，通过尾触发方式实现了中间件：</p>
<pre><code class="language-js">function middleware(req, res, next) {
  // 业务代码
  next()
}
</code></pre>
<h3 id="42-express-中的中间件"><a class="header" href="#42-express-中的中间件">4.2 Express 中的中间件</a></h3>
<p>中间件是在管道中执行的，在 Express 中，使用 app.use() 向管道中插入中间件。中间件讲究顺序，匹配上第一个之后，就不会往后匹配了，next 函数才能够继续往后匹配。</p>
<p>模糊意义上讲，app.get()、app.post()、app.post() 等方法也属于中间件。</p>
<p>大坑：express 的中间件函数，不需要传入 req，res，他是在中间件函数执行回调的时候自动传入。</p>
<p>创建中间件：</p>
<pre><code class="language-js">module.exports = function (req, res, next) {
  //中间件函数在这里调用
  next() //记得使用 next() 或者 next(route)
}
</code></pre>
<p>使用中间件：</p>
<pre><code class="language-JavaScript">const test2 = require('./test1');
app.use(test2);

app.get('/',function (req, res) {//每次访问/调用一次中间件
    res.send(&quot;hello world!&quot;);
});
</code></pre>
<p>创建可配置的模块化中间件：</p>
<pre><code class="language-JavaScript">module.exports = function (config) {
    if (!config) config= {}
    return function (req, res, next) {
        next();     //除非这个中间件是终点，否则需要next
    }
};
</code></pre>
<p>输出多个相互关联的中间件：</p>
<pre><code class="language-JavaScript">module.exports = function (config) {
    if (config)  config= {}
    return {
        m1: function (req, res, next) {
            next();     //除非这个中间件是终点，否则需要next
        },
        m2: function (req, res, next) {
            next();     //除非这个中间件是终点，否则需要next
        }
    }
};
</code></pre>
<p>使用互相关联的中间件：</p>
<pre><code class="language-JavaScript">const test2 = require('./test1')({option:'test'});
app.use(test2.m1);
app.use(test2.m2);

</code></pre>
<p>也可以将处理函数挂载在一个对象的原则上：</p>
<pre><code class="language-JavaScript">//创建中间件
function Stuff(config) {
    this.config = config || {};
}

Stuff.prototype.m1 = function (req, res, next) {
    //注意这里的this最好别用
};
module.exports = Stuff;
//使用中间件
const test2 = require('./test1');
let stuff = new test2({option:&quot;test&quot;});
app.use(stuff.m1);
</code></pre>
<h3 id="43-中间件的使用"><a class="header" href="#43-中间件的使用">4.3 中间件的使用</a></h3>
<p>常见的场景是鉴权，比如有的页面需要登录才能访问，有的页面无需登录，如果现在封装一个是否登录的中间函数 isLogin()，那么在实际开发中的使用方式是：</p>
<pre><code class="language-js">// 需要登录
app.get('/user/:username', isLogin, function (req, res) {})

// 不需要登录
app.get('/news/:date', isLogin, function (req, res) {})
</code></pre>
<p>isLogin 中间件的写法：</p>
<pre><code class="language-js">function isLogin(req, res, next) {
  var cookie = req.headers.cookie
  var cookies = {}

  if (!cookie) {
    console.log('cookie 不存在')
    return
  }

  if (!cookie.isLogin) {
    console.log('用户未登录')
    return
  }

  next()
}
</code></pre>
<h3 id="44-中间件的开发"><a class="header" href="#44-中间件的开发">4.4 中间件的开发</a></h3>
<p>中间件和具体业务应该都是不同的业务处理单元，现在改进上一节中 use 方法：</p>
<pre><code class="language-js">app.use = function(){
    var handle = {
        path: pathR egexp(path),            // 第一个参数作为路径
        stack: Array.prototype.slice.call(arguments, 1)     // 其他的都是处理单元
    };
    routes.all.push(handle);
}
</code></pre>
<p>改进后的 use() 方法都将中间件存进了 stack 数组中，等待匹配后触发执行，匹配部分修改如下：</p>
<pre><code class="language-js">function match(pathname, routes) {
  for (var i = 0; i &lt; routes.length; i++) {
    var route = routes[i]
    var reg = route.path.regexp
    var matched = reg.exec(pathname)

    if (matched) {
      handle(req, res, route.stack)
      return true
    }
  }

  return false
}
</code></pre>
<p>一旦匹配成功，中间件具体如何调用都交给了 handle() 方法处理，该方法封装后，递归性的执行数组中的中间件，每个中间件执行完成后，按照约定调用传入 next() 方法触发下一个中间执行：</p>
<pre><code class="language-js">function handle(req, res, stack) {
  function next() {
    // 从 stack 数组中取出中间件并执行
    var middleware = stack.shift()
    if (middleware) {
      // 传入 next() 函数自身，使中间件能够执行结束后递归
      middleware(req, res, next)
    }
  }
  // 启动执行
  next()
}
</code></pre>
<h3 id="45-通用中间件"><a class="header" href="#45-通用中间件">4.5 通用中间件</a></h3>
<p>有的中间件要在所有路由中触发，如果每个路由都要书写一遍该中间件，显然是不合理的，用户期望的使用方式是：</p>
<pre><code class="language-js">app.use(isLogin)
</code></pre>
<p>现在修改 use() 方法，以实现更灵活的适应参数变化：</p>
<pre><code class="language-js">app.use = function (path) {
  var handle

  if (typeof path === 'string') {
    handle = {
      // 第一个参数作为路径
      path: pathRegexp(path),
      // 其他的都是处理单元
      stack: Array.prototype.slice.call(arguments, 1),
    }
  } else {
    handle = {
      // 第一个参数作为路径
      path: pathRegexp('/'),
      // 其他的都是处理单元
      stack: Array.prototype.slice.call(arguments, 0),
    }
  }
  routes.all.push(handle)
}
</code></pre>
<p>改进匹配过程，之前的匹配是一旦一次匹配后就不再执行，现在需要将所有匹配到的中间都暂时保存起来：</p>
<pre><code class="language-js">function match(pathname, routes) {
  var stacks = []

  for (var i = 0; i &lt; routes.length; i++) {
    var route = routes[i]
    var reg = route.path.regexp
    var matched = reg.exec(pathname)
    if (matched) {
      // 抽取具体值.....将中间件保存
      stacks = stacks.concat(route.stack)
    }
  }

  return stacks
}
</code></pre>
<p>高进分发过程：</p>
<pre><code class="language-js">function (req, res) {

    var pathname = url.parse(req.url).pathname;
    var method = req.method.toLowerCase();

    // 获取 all() 方法里的中间件
    var stacks = match(pathname, routes.all);

    if (routes.hasOwnPerperty(method)) {
        // 根据请求方法分发，获取相关的中间件
        stacks.concat(match(pathname, routes[method]));
    }

    if (stacks.length) {
        handle(req, res, stacks);
    } else {
        // 处理 404 请求
        handle404(req, res);
    }
}
</code></pre>
<h3 id="46-异常处理"><a class="header" href="#46-异常处理">4.6 异常处理</a></h3>
<p>中间件自身也可能出现错误，所以必须为 next() 方法添加 err 参数，捕获异常：</p>
<pre><code class="language-js">function handle(req, res, stack) {
  function next(err) {
    if (err) {
      return handle500(err, req, res, stack)
    }

    // 从 stack 数组中取出中间件执行
    var middleware = stack.shift()
    if (middleware) {
      // 传入 next() 函数自身，使中间件能够执行结束后递归
      try {
        middleware(req, res, next)
      } catch (ex) {
        next(err)
      }
    }
  }

  // 启动执行
  next()
}
</code></pre>
<p>注意：异步方法的异常无法直接捕获，中间件异步产生的异常需要自己传递出来：</p>
<pre><code class="language-js">function isLogin() {
  var uid = req.cookie.session_id

  // 假设是个异步方法，产生了错误
  store.get(uid, function (err, session) {
    if (err) {
      next(err)
      return
    }

    req.session = session
    next()
  })
}
</code></pre>
<p>所以异步的中间件往往有四个参数：</p>
<pre><code class="language-js">function middleware(err, req, res, next) {
  // ...
  next()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="072-web-框架-koa"><a class="header" href="#072-web-框架-koa">07.2-Web 框架-Koa</a></h1>
<h2 id="一-koa-简介"><a class="header" href="#一-koa-简介">一 Koa 简介</a></h2>
<p>Koa 是 express 团队全新打造的更轻量级的 web 框架，内部没有任何功能模块封装，甚至没有路由模块，源码仅仅只有几千行。Koa 仅仅提供了简单的请求响应封装、中间件模型。</p>
<p>与 Express 不同的是：Koa 的请求、响应对象都被包装进了 context 对象中，且 Koa 的中间件模型是洋葱模型。</p>
<p>示例：</p>
<pre><code class="language-js">const koa = require('koa')

let app = new koa()

app.use((ctx) =&gt; {
  ctx.body = 'hello world'
})

app.listen(3000)
</code></pre>
<p>koa 将 node 的 Request 和 Response 对象封装进了 Context 对象中，所以也可以把 Context 对象称为一次对话的上下文。Context 对象内部封装的常见属性：</p>
<pre><code class="language-js">ctx // Context 对象，包含 req、res
ctx.request
ctx.response
ctx.status
ctx.throw(500) // 页面会抛出状态码为 500 的错误页面

this // Context 对象也可以直接写为 this
this.request
this.response
</code></pre>
<p>Koa 与 Express 的不同：</p>
<ul>
<li>Express 内部支持路由，Koa 没有路由管理</li>
<li>Express 的中间件模型是传统的顺序式，而 Koa 是洋葱模型</li>
</ul>
<h2 id="二-洋葱模型"><a class="header" href="#二-洋葱模型">二 洋葱模型</a></h2>
<h3 id="21-洋葱模型的执行"><a class="header" href="#21-洋葱模型的执行">2.1 洋葱模型的执行</a></h3>
<p>中间件函数是一个带有 ctx 和 next 两个参数的简单函数。next() 函数就是在其内部调用下一个中间件函数，返回的其实是一个 Promise 对象，该对象内部包裹了下一个中间件的返回结果。next 用于将中间件的执行权交给下游的中间件。</p>
<pre><code class="language-js">const koa = require('koa')

let app = new koa()

app.use((ctx, next) =&gt; {
  console.log('1')
  next()
  console.log('2')
  ctx.body = 'hello world1'
})

app.use((ctx, next) =&gt; {
  console.log('3')
  ctx.body = 'hello world2'
  next()
  console.log('4')
})

app.listen(3000)
</code></pre>
<p>执行结果：按照顺序执行了中间件代码，再按反方向执行一遍 next 之后的代码，web 界面也输出的是 hello world2：</p>
<pre><code class="language-txt">1
3
4
2
</code></pre>
<p>上述的执行方式，称之为洋葱模型：
<img src="05-Node.js/../images/node/yangchong.png" alt="洋葱模型" /></p>
<p><strong>Koa 中间件相比 Express 中间件：按照洋葱模型执行，中间件无论写在什么位置，都会先执行</strong>。</p>
<h3 id="22-生产实践"><a class="header" href="#22-生产实践">2.2 生产实践</a></h3>
<p>推荐所有的中间件的 next() 均使用 <code>async/await</code> 形式包裹，这是因为中间件中一般需要处理一些事情，包裹之后更方便编码，更关键的是：所有中间件如果都被包裹，则不会引发顺序错乱：</p>
<pre><code class="language-js">app.use(async (ctx, next) =&gt; {
  console.log('2')
  await next()
  console.log('2')
  ctx.body = 'hello world1'
})

app.use(async (ctx, next) =&gt; {
  console.log('3')
  ctx.body = 'hello world2'
  await next()
  console.log('4')
})

// 顺序不变：1 3 4 2
</code></pre>
<p>如果不使用 async/await 的中间件与使用包裹的中间件进行了混用，则顺序就会发生变化：</p>
<pre><code class="language-js">app.use((ctx, next) =&gt; {
  console.log('1')
  next()
  console.log('2')
  ctx.body = 'hello world1'
})

app.use(async (ctx, next) =&gt; {
  console.log('3')
  ctx.body = 'hello world2'
  await next()
  console.log('4')
})

// 顺序变了：1 3 2 4
</code></pre>
<h2 id="23-洋葱模型的意义"><a class="header" href="#23-洋葱模型的意义">2.3 洋葱模型的意义</a></h2>
<p>为什么 Koa 被称为下一代 web 框架？本质上是舍弃了路由之后更基础的设计理念，以及洋葱模型带来的便利。</p>
<p>比如现在需要知道所有中间件加载的时间，可以直接在第一个中间件的 next 之后获取时间：</p>
<pre><code class="language-js">// 第一个中间件
app.use(async (ctx, next) =&gt; {
  console.time()
  await next()
  // next 之后的代码表示 中间件已经全部执行完毕了
  console.timeEnd()
})
</code></pre>
<p>此时在 Express 中就没有这么多顺利了。</p>
<h2 id="三-中间件应用"><a class="header" href="#三-中间件应用">三 中间件应用</a></h2>
<h3 id="31-koa-compose-组合中间件"><a class="header" href="#31-koa-compose-组合中间件">3.1 koa-compose 组合中间件</a></h3>
<p>如果需要将中间件组合使用，可以使用 koa-compose</p>
<pre><code class="language-js">function middleware1(ctx, next) {
  console.log('midlle1...')
  next()
}

function middleware2(ctx, next) {
  console.log('midlle2...')
  next()
}

const all = compose([middleware1, middleware2])

app.use(all)
</code></pre>
<h3 id="32-koa-常用中间件"><a class="header" href="#32-koa-常用中间件">3.2 koa 常用中间件</a></h3>
<ul>
<li>koa-bodyparser:获取 POST 请求参数</li>
<li>koa-router:路由中间件</li>
<li>koa-static:静态文件目录</li>
<li>koa-views:加载模板文件</li>
</ul>
<p>综合案例：</p>
<pre><code class="language-js">const koa = require('koa')
const path = require('path')
const ejs = require('ejs')
const views = require('koa-views')
const bodyParser = require('koa-bodyparser')
const static = require('koa-static')
const Router = require('koa-router')
const favicon = require('koa-favicon')

const app = new koa()
const router = new Router()

//加载静态资源
app.use(static(path.join(__dirname, 'static')))

//favicon
app.use(favicon(__dirname + '/static/favicon.ico'))

// 加载 ejs 模板引擎:ejs 后缀方式
// app.use(views(path.join(__dirname, './views'), {
//     extension: 'ejs'
// }));

// 加载 ejs 模板引擎:html 后缀方式
app.use(
  views(path.join(__dirname, 'views'), {
    map: { html: 'ejs' },
  })
)

//post 解析中间件
app.use(bodyParser())

//路由-&gt;渲染模板
router.get('/', async (ctx, next) =&gt; {
  await ctx.render('test', {
    msg: 'hello',
  })
})
router.post('/', (ctx, next) =&gt; {
  let data = ctx.request.body
  console.log(JSON.stringify(data))
  ctx.body = data
})

app.use(router.routes()) //启动路由中间件
app.use(router.allowedMethods()) //根据 ctx.status 设置响应头

//支持链式写法
// app.use(router.routes()).use(router.allowedMethods());

app.listen(3000)
</code></pre>
<h2 id="三-路由管理"><a class="header" href="#三-路由管理">三 路由管理</a></h2>
<h3 id="31-koa-router-基本使用"><a class="header" href="#31-koa-router-基本使用">3.1 koa-router 基本使用</a></h3>
<pre><code class="language-js">const Koa = require('koa')
const Router = require('koa-router')

const app = new Koa()
const router = new Router({
  prefix: '/test', //路由前缀---全局的
})

router.get('/', function (ctx, next) {
  ctx.body = 'index....'
})
router.get('/todo', function (ctx, next) {
  ctx.body = 'todo....'
})

app.use(router.routes()) //启动路由中间件
app.use(router.allowedMethods()) //根据 ctx.status 设置响应头

app.listen(3000)
</code></pre>
<h3 id="32-路由前缀"><a class="header" href="#32-路由前缀">3.2 路由前缀</a></h3>
<pre><code class="language-js">let home = new Router() //子路由
let page = new Router() //子路由

home
  .get('/test', async (ctx) =&gt; {
    //http://localhost:8000/home/test
    ctx.body = 'home test...'
  })
  .get('/todo', async (ctx) =&gt; {
    //http://localhost:8000/home/todo
    ctx.body = 'home todo...'
  })

page.get('/test', async (ctx) =&gt; {
  ctx.body = 'page router...'
})

//父路由
let router = new Router()

//装载子路由
router.use('/home', home.routes())
router.use('/page', page.routes())
</code></pre>
<h3 id="33-restful-规范"><a class="header" href="#33-restful-规范">3.3 RESTful 规范</a></h3>
<p>关于 RESTful：koa-router 作者推荐使用该风格，即所有的事物都应该被抽象为资源，每个资源对应唯一的 URL</p>
<p>比如对 url 的增删改查：</p>
<pre><code class="language-txt">/users                  # post 方式：新增用户
/users/:id              # delete 方式：删除用户
/users/:id              # put 方式：修改用户
/users/:id              # get 方式：获取用户
</code></pre>
<p>上述以 <code>/:id</code> 参数接收方式的路由也可以称呼为<strong>动态路由</strong>。</p>
<h3 id="34-routerall"><a class="header" href="#34-routerall">3.4 router.all()</a></h3>
<p>router.all() 可以用来模糊匹配</p>
<pre><code class="language-js">router.get('/', async (ctx, next) =&gt; {
  console.log('111')
  ctx.response.body = '111'
  await next() // 如果 注释该段，则不执行 all
  console.log('222')
})

router.all('/', async (ctx, next) =&gt; {
  console.log('all...111')
  await next()
  console.log('all...222')
})
</code></pre>
<h3 id="35-路由中多中间件处理方式"><a class="header" href="#35-路由中多中间件处理方式">3.5 路由中多中间件处理方式</a></h3>
<pre><code class="language-js">router.get('/', middleware, midlleware, (ctx) =&gt; {})
</code></pre>
<h3 id="36-嵌套路由"><a class="header" href="#36-嵌套路由">3.6 嵌套路由</a></h3>
<p>嵌套路由也可以实现类似路由前缀的功能，但是能够额外添加动态参数</p>
<pre><code class="language-js">const userRouter = new Router()
const userAction = new Router()

userAction.get('/:pid', (ctx, next) =&gt; {
  console.log('/:pid')
})

// /user/123/login/123    /user/123/login
userRouter.use(
  '/user/:fid/login',
  userAction.routes(),
  userAction.allowedMethods()
)

app.use(userRouter.routes())
</code></pre>
<h3 id="37-多路由文件实践"><a class="header" href="#37-多路由文件实践">3.7 多路由文件实践</a></h3>
<p>当项目中有多个路由时，可以进行分文件开发，便于维护：</p>
<pre><code class="language-js">// userRouter.js  user 模块路由
const Router = require('koa-router')
const userRouter = new Router()
userRouter.get('/users', () =&gt; {})
userRouter.post('/users/:uid', () =&gt; {})
module.exports = userRouter

// orderRouter.js order 模块路由
const Router = require('koa-router')
const orderRouter = new Router()
orderRouter.get('/orders', () =&gt; {})
orderRouter.post('/ords/:oid', () =&gt; {})
module.exports = orderRouter
</code></pre>
<p>此时在 app.js，或者单独引设置一个 routes.js 内引入这些路由：</p>
<pre><code class="language-js">const Koa = require('koa')
const Router = require('koa-router')
const userRouter = require('./routers/userRouter')
const orderRouter = require('./routers/orderRouter')

const app = new Koa()
const router = new Router()

app.use(userRouter.routes())
app.use(orderRouter.routes())
app.use(router.allowedMethods()) //根据 ctx.status 设置响应头

app.listen(3000)
</code></pre>
<p>为了减少重复书写 <code>app.use(userRouter.routes())</code> 这样的路由加载，可以使用 <code>require-directory</code> 库进行整合：</p>
<pre><code class="language-js">requireDirectory(module, './routers', { visit: whenLoadModule })

function whenLoadModule(obj) {
  if (obj instanceof Router) {
    app.use(obj.routes())
  }
}
</code></pre>
<p>注意：<strong>笔者不推荐这种整合方式，该库长久不更新，且每个 router 文件 都要导出，路由排查困难。</strong></p>
<h2 id="四-参数处理"><a class="header" href="#四-参数处理">四 参数处理</a></h2>
<p>示例：</p>
<pre><code class="language-js">app.use(async function (ctx) {
  console.log(ctx.url) //login?name=lisi
  console.log(ctx.querystring) //name=lisi

  // 参数方式一： /login?name=lisi
  console.log(ctx.query) //{ name: 'lisi' }

  // 参数方式二：/login/:name   实际路由：/login/lisi
  console.log(ctx.params) // 获取动态路由参数

  // 参数方式三：body 传参
  console.log(ctx.body) // 获取动态路由参数

  // 参数方式四：headers 传参
  console.log(ctx.header)
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="081-鉴权-cookie"><a class="header" href="#081-鉴权-cookie">08.1-鉴权-Cookie</a></h1>
<h2 id="一-cookie-简介"><a class="header" href="#一-cookie-简介">一 Cookie 简介</a></h2>
<p>http 是无状态协议，即使在同一个网站，从一个页面跳转到另外一个页面时，服务器和浏览器都没有任何内在的方法认识到他们的关联，所有的 http 请求都要包含所有必要的信息，服务器才能满足这个请求。</p>
<p>cookie 是浏览器端的技术，用来实现类似 登录、记忆用户喜好 等功能。cookie 的处理步骤：</p>
<ul>
<li>服务端向客户端发送 Cookie</li>
<li>浏览器将收到的 Cookie 保存</li>
<li>之后的每次请求，浏览器都会将 Cookie 信息发送给服务端</li>
</ul>
<p>cookie 包括：名字、值、过期时间、路径、域，只有 4k 大小。路径与域一起构成 cookie 的作用范围。</p>
<p>cookie 过期时间如果不设置，关闭浏览器，cookie 就会消失，这种生命期为浏览器会话期间的 cookie 被称为会话 cookie。会话 cookie 一般保存在内存中，这种行为是不规范的。若设置了过期时间，则保存信息到硬盘上。</p>
<p>cookie 特点：</p>
<ul>
<li>cookie 是不加密的，用户可以自由看到；</li>
<li>用户可以删除 cookie，或者禁用它；</li>
<li>cookie 可以被篡改、攻击（XSS 攻击）；</li>
<li>cookie 存储量很小，滥用会被用户注意到，如果可以选择，会话要优于 cookie，未来要被 localStorage 替代。</li>
</ul>
<h2 id="二-node-中使用-cookie"><a class="header" href="#二-node-中使用-cookie">二 Node 中使用 Cookie</a></h2>
<p>构造一个携带 Cookie 的请求：</p>
<pre><code class="language-txt">curl -v -H &quot;Cookie: foo=bar;baz=val&quot; &quot;http://127.0.0.1:3000&quot;
</code></pre>
<p>Node 解析请求中的 Cookie：</p>
<pre><code class="language-js">function parseCookie(cookie) {
  var cookies = {}
  if (!cookie) {
    return cookies
  }

  var list = cookie.split(';')

  for (var i = 0; i &lt; list.length; i++) {
    var pair = list[i].split('=')
    cookies[pair[0].trim()] = pair[1]
  }

  return cookies
}
</code></pre>
<p>在业务逻辑代码执行之前，可以将 cookie 挂载在 req 对象上，让业务代码可以直接访问：</p>
<pre><code class="language-js">function (req, res) {
    req.cookies = parseCookie(req.headers.cookie);
    hande(req, res);
}

function hande(req, res) {

    res.writeHead(200);

    if (!req.cookies.isVisit) {
        res.end('࣌ᆓڼᅃْઠڟ动࿿ᇴ ');
    } else {
        // TODO
    }
};
</code></pre>
<p>响应的 Cookie 值在 Set-Cookie 字段中，其格式如下：</p>
<pre><code class="language-txt">Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;
</code></pre>
<p>其中 name=value 是必须包含的部分，其余部分皆是可选参数：</p>
<ul>
<li>path：表示这个 Cookie 影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个 Cookie</li>
<li>Expires 和 Max-Age 分别用来告知浏览器 Cookie 何时过期，多久后过期。如果不设置该选项，则浏览器一旦关闭，Cookie 直接就会消失。</li>
<li>HttpOnly：告知浏览器不允许通过脚本<code>document.cookie</code>去更改这个 Cookie 只，事实上，设置 HttpOnly 之后，这个值在<code>document.cookie</code>中不可见，但是在 Http 请求过程中，依然会发送这个 Cookie 到服务端</li>
<li>Secure：该值为 true 时，只有在 HTTPS 中才有效，表示创建的 Cookie 只有在 HTTPS 连接中才会被传输</li>
</ul>
<p>cookie 序列化的方法：</p>
<pre><code class="language-js">function serialize(name, val, opt) {
  var pairs = [name + '=' + encode(val)]

  opt = opt || {}

  if (opt.maxAge) pairs.push('Max-Age=' + opt.maxAge)
  if (opt.domain) pairs.push('Domain=' + opt.domain)
  if (opt.path) pairs.push('Path=' + opt.path)
  if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString())
  if (opt.httpOnly) pairs.push('HttpOnly')
  if (opt.secure) pairs.push('Secure')

  return pairs.join('; ')
}
</code></pre>
<p>用户状态的判断业务代码：</p>
<pre><code class="language-js">function handle(req, res) {
  if (!req.cookies.isLogin) {
    res.setHeader('Set-Cookie', serialize('isVisit', '1'))
    res.writeHead(200)
    res.end('欢迎登陆')
  } else {
    res.writeHead(200)
    res.end('请先登录')
  }
}
</code></pre>
<p>报头中也可能存在多个字段：</p>
<pre><code class="language-js">res.setHeader('Set-Cookie', [serialize('foo', 'bar'), serialize('baz', 'val')])
</code></pre>
<h2 id="三-cookie-的性能问题"><a class="header" href="#三-cookie-的性能问题">三 Cookie 的性能问题</a></h2>
<p>由于网络传输需要额外传输 Cookie 信息，一旦设置的 Cookie 过多，将会导致报头较大，而且大多数 Cookie 并不需要每次都用上，同样会造成带宽的浪费。</p>
<p>应该：</p>
<ul>
<li>减小 Cookie 大小</li>
<li>为静态组件使用不同的域名，避免不必要的 Cookie</li>
<li>减少 DNS 查询，现代浏览器都支持 DNS 缓存，可以削弱 DNS 查询带来的影响。</li>
</ul>
<h2 id="四-express-中使用-cookie"><a class="header" href="#四-express-中使用-cookie">四 Express 中使用 cookie</a></h2>
<h3 id="41-中间件-cookie-parser"><a class="header" href="#41-中间件-cookie-parser">4.1 中间件 cookie-parser</a></h3>
<pre><code class="language-JavaScript">const express = require('express');
const cookieParser = require('cookie-parser');

let app = express();
app.use(cookieParser());

app.get('/',function(req,res){
    res.cookie('name','lisi',{maxAge:900000,httpOnly:true});
    res.send(req.cookies);
});

app.get('/other',function (req,res) {
    //当用户访问首页缓存了cookie后，再访问other，在这个页面我们就可以获取cookie
   let cookieName = req.cookies.name;
   res.send(cookieName);

});
</code></pre>
<h3 id="42-cookie-加密"><a class="header" href="#42-cookie-加密">4.2 cookie 加密</a></h3>
<p>cookie 的加密方式有两种：</p>
<ul>
<li>方式一：保存的时候加密</li>
<li>方式二：cookie-parser 里面，signed 属性设置为 true，且需要在调用中间件时传递 任意加密字符串。</li>
</ul>
<pre><code class="language-JavaScript">const express = require('express');
const cookieParser = require('cookie-parser');

let app = express();

app.use(cookieParser('sss'));

app.get('/',function (req,res) {
    //获取加密的cookie
    console.log(req.signedCookies);
    res.send('hi');
});

app.get('/set',function (req,res) {
    res.cookie(
        'info',
        'lisi',
        {
            maxAge: 60000,
            signed: true
        }
    );
    res.send('set cookie');
});

app.listen(3000);

</code></pre>
<h3 id="43-删除-cookie"><a class="header" href="#43-删除-cookie">4.3 删除 cookie</a></h3>
<p>删除 cookie：<code>res.clearCookie(‘secret’);</code></p>
<h3 id="44-cookie-的其他设置"><a class="header" href="#44-cookie-的其他设置">4.4 cookie 的其他设置</a></h3>
<p>cookie 的其他配置：</p>
<pre><code class="language-txt">domain：将 cookie 分配给特定的子域名，但是不能分配给和服务器所用域名不同的域名
path：控制应用该 cookie 的路径，默认是 /  应用到所有页面上，如果参数是 /foo，则会应用到 /foo /foo/bar等路径上
maxAge：cookie 有效期，单位是毫秒
secure：cookie 只通过 https 发送
httpOnly：设置为 true，表明 cookie 只能由服务器修改，可以防范 XSS 攻击。
singend：设为 true 会对 cookie 签名，此时只能通过 res.signedCookies 获取，而不是 res.cookies。此时被串改的签名 cookie 会被服务器拒绝，并且 cookie 会被重置为原始值。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="082-鉴权-session"><a class="header" href="#082-鉴权-session">08.2-鉴权-Session</a></h1>
<h2 id="一-session-简介"><a class="header" href="#一-session-简介">一 Session 简介</a></h2>
<p>cookie 的数据有严重的安全问题，很容易被篡改、伪造，比如在上一节案例中，开发者直接发一个请求中带有 isLogin 的字段，服务端就判断其为登录状态了而且 Cookie 对敏感数据的保护是无效的。</p>
<p>Session 是专门为了解决 Cookie 数据安全性而提出来的技术，其实现基于 Cookie。</p>
<p>一般 Session 的实现步骤：</p>
<ul>
<li>用户第一次访问服务器，服务器创建 session 对象，生成一个类似 key，value 的对象，然后将 key 返回给浏览器，以 cookie 的形式保存该 key。</li>
<li>用户再次访问时，携带了该 key，会得到对应的值。</li>
</ul>
<h2 id="二-session-的实现"><a class="header" href="#二-session-的实现">二 Session 的实现</a></h2>
<h3 id="21-第一种-基于-cookue-实现用户和数据的映射"><a class="header" href="#21-第一种-基于-cookue-实现用户和数据的映射">2.1 第一种 基于 Cookue 实现用户和数据的映射</a></h3>
<p>可以将 Session 的口令存储在 Cookie 中，一旦口令被篡改，就会丢失映射关系，无法修改服务端数据了，而且 Session 有效期很短，通常为 20 分钟，也就是说，20 分钟内客户端与服务端之间没有交互产生，服务端就会将该 Cookie 中的口令数据删除。</p>
<pre><code class="language-js">var sessions = {}
var key = 'session_id'
var EXPIRES = 20 * 60 * 1000

function generate() {
  var session = {}

  session.id = new Date().getTime() + Math.random()
  session.cookie = {
    expire: new Date().getTime() + EXPIRES,
  }

  sessions[session.id] = session

  return session
}
</code></pre>
<p>每个请求到来时，检查 Cookie 中的口令与服务端的数据，如果过期，就重新生成：</p>
<pre><code class="language-js">function (req, res) {
    var id = req.cookies[key];
    if (!id) {
        req.session = generate();
    } else {
        var session = sessions[id];
        if (session) {
            if (session.cookie.expire &gt; (new Date()).getTime()) {
                // 更新超时时间
                session.cookie.expire = (new Date()).getTime() + EXPIRES;
                req.session = session;
            } else {
                // 超时了，删除旧的数据，并重新生成
                delete sessions[id];
                req.session = generate();
            }
        } else {
            // 如果 session 过期或口令不对，重新生成 session
            req.session = generate();
        }
    }
    handle(req, res);
}
</code></pre>
<p>此时还需要在响应给客户端时设置新的值，以便下次请求时能够对应服务端的数据，这里重新实现 writeHead() 方法，在内部注入设置 Cookie 的逻辑：</p>
<pre><code class="language-js">var writeHead = res.writeHead
res.writeHead = function () {
  var cookies = res.getHeader('Set-Cookie')
  var session = serialize('Set-Cookie', req.session.id)
  cookies = Array.isArray(cookies)
    ? cookies.concat(session)
    : [cookies, session]
  res.setHeader('Set-Cookie', cookies)
  return writeHead.apply(this, arguments)
}
</code></pre>
<p>业务逻辑使用 session：</p>
<pre><code class="language-js">function handle(req, res) {
  if (!req.session.isLogin) {
    res.session.isLogin = true
    res.writeHead(200)
    res.end('欢迎登陆')
  } else {
    res.writeHead(200)
    res.end('请先登录')
  }
}
</code></pre>
<p>该方案依赖了 Cookie 的实现，也是大多 Web 系统中 Session 的实现方案，如果客户端禁止 Cookie，则本方案将会失效。</p>
<h3 id="22-第二种-通过查询字符串来实现浏览器和服务端数据对应"><a class="header" href="#22-第二种-通过查询字符串来实现浏览器和服务端数据对应">2.2 第二种 通过查询字符串来实现浏览器和服务端数据对应</a></h3>
<p>该方案原理是检查请求的查询字符串，如果没有值，则会先生成新的带值的 URL，禁用 cookie 时可以采用该方案：</p>
<pre><code class="language-js">function getURL(_url, key, value) {
  var obj = url.parse(_url, true)
  obj.query[key] = value
  return url.format(obj)
}
</code></pre>
<p>然后形成跳转，让客户端重新发起请求：</p>
<pre><code class="language-js">function (req, res) {

    var redirect = function (url) {
        res.setHeader('Location', url);
        res.writeHead(302);
        res.end();
    };

    var id = req.query[key];

    if (!id) {
        var session = generate();
        redirect(getURL(req.url, key, session.id));
    } else {
        var session = sessions[id];
        if (session) {
            if (session.cookie.expire &gt; (new Date()).getTime()) {
                // 更新超时时间
                session.cookie.expire = (new Date()).getTime() + EXPIRES;
                req.session = session;
                handle(req, res);
            } else {
                // 超时了，删除旧的数据，并重新生成
                delete sessions[id];
                var session = generate();
                redirect(getURL(req.url, key, session.id));
            }
        } else {
            // 如果 session 过期或口令不对，重新生成 session
            var session = generate();
            redirect(getURL(req.url, key, session.id));
        }
    }
}
</code></pre>
<p>用户访问<code>http://localhost/pathname</code>时，如果服务端发现查询字符串中没有 session_id 参数，就会将用户调转到 <code>http://localhost/pathname?session_id=12344567</code> 类似这样的地址，如果浏览器收到 302 状态码和 Location 报头，就会重新发起新的请求：</p>
<pre><code class="language-txt">&lt; HTTP/1.1 302 Moved Temporarily
&lt; Location: /pathname?session_id=12344567
</code></pre>
<p>这样，新的请求到来时就能通过 Session 的检查。虽然该方案可以应对 Cookie 被禁用的情况，但是只要将地址栏中的地址发给另外一个人，他就会拥有和你相同的身份，风险更大！</p>
<h2 id="三-集中式-session-管理"><a class="header" href="#三-集中式-session-管理">三 集中式 Session 管理</a></h2>
<p>在上述案例中 Session 都是存储在一个 Node 进程的变量中的。这会引起两个问题：</p>
<ul>
<li>状态过多，如登录用户数目极大，会突破 Node 进程的内存限制，引起频繁 GC 扫描，造成性能问题</li>
<li>Node 多进程中不共享内存，Session 就会出现错乱</li>
<li>在负载均衡状态下，多个服务器共同协作，用户的请求可能被不同的服务器执行，这时候其中一个服务器保存了 session，那么用户下次的请求在别的服务器上，将如何获取？</li>
</ul>
<p>通常 Session 不会被考虑直接存储在业务进程中，一般将 session 保存在缓存服务器中，如 redis、memcache。</p>
<h2 id="四-session-安全"><a class="header" href="#四-session-安全">四 Session 安全</a></h2>
<p>Session 的口令仍然是存储在 Cookie 中的，同样存在口令盗用的情况。通常可以对口令进行私钥加密签名，提升伪造成本。在服务端，只需要在响应数据时将口令和签名进行对比，如果签名非法，则服务端的数据立即过期即可：</p>
<pre><code class="language-js">// 将值通过私钥签名，由 . 分割原值和签名
var sign = function (val, secret) {
  return (
    val +
    '.' +
    crypto
      .createHmac('sha256', secret)
      .update(val)
      .digest('base64')
      .replace(/\=+$/, '')
  )
}
</code></pre>
<p>在响应时，设置 session 值到 Cookie 中或者跳转 URL 中：</p>
<pre><code class="language-js">var val = sign(req.sessionID, secret)
res.setHeader('Set-Cookie', cookie.serialize(key, val))
</code></pre>
<p>接收请求时，检查签名，对比用户提交的值：</p>
<pre><code class="language-js">// 取出口令部分进行签名，对比用户提交的值
var unsign = function (val, secret) {
  var str = val.slice(0, val.lastIndexOf('.'))
  return sign(str, secret) == val ? str : false
}
</code></pre>
<p>这样一来，即使攻击者知道口令中 . 号的前的值是服务端 Session 的 ID 的值，只要不知道私钥的值，就无法伪造签名信息。</p>
<h2 id="五-session-在框架中的集成"><a class="header" href="#五-session-在框架中的集成">五 Session 在框架中的集成</a></h2>
<h3 id="51-express-中使用-session"><a class="header" href="#51-express-中使用-session">5.1 Express 中使用 Session</a></h3>
<pre><code class="language-JavaScript">const express = require('express');
const session = require('express-session');

let app = express();

app.use(session({
//任意一个字符串，作为session的签名
    secret: 'sss',
    name: 'session_id', //session在本地cookie的名字，可以不设置
    //强制保存session，即使它没有变化，默认为true，建议为false
resave: false,
//强制将为初始化的session存储，默认是true
saveUninitialized: true,
cookie: {
   //不设置，那么关闭浏览器就过期，
//设置了即使在浏览页面，50000内没有操作也会过期
        maxAge: 50000
    },
    // secure https下才能访问cookie
//每次请求时强行设置cookue，将重置cookuie过期时间，默认false
    rolling: true
}));

app.get('/',function (req,res) {
    console.log(req.session.info);
    res.send('index');
});
app.get('/set',function (req,res) {
    req.session.info = 'lisi';
    res.send('set..');
});

app.listen(3000);
</code></pre>
<p>没有设置 maxAge，那么 session 在浏览器关闭时候被销毁，但是有时候用户即使仍在访问，我们也需要主动销毁 session，比如用户不关闭浏览器切换账户登录。
销毁方法一：req.session.cookie.maxAge = 0;
销毁方法二：req.session.destroy(function(err){})</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="083-鉴权-jwt"><a class="header" href="#083-鉴权-jwt">08.3-鉴权-JWT</a></h1>
<h2 id="一-jwt-简介"><a class="header" href="#一-jwt-简介">一 JWT 简介</a></h2>
<p>JWT (Json Web Token) 是目前非常流行的鉴权方案。官网地址为：<a href="https://jwt.io/">https://jwt.io/</a></p>
<p>相对于 session 方案，JWT 会生成一个 token 而不是 session_id，token 中保存了一定的用户信息，一般是用户的 id、权限等，服务端接收到 token 后进行解密即可知道用户信息。</p>
<p>与 session 方案不同的是：由于 token 中已经存储了用户真实信息，所以后端无需存储 token，只需要每次请求解析 toke 那几科。JWT 的理念是直接将状态放在前端，至于说在前端用 cookie 保存还是 localStorage 保存还是其它的手段保存都不重要。</p>
<p>在官网中，可以看到 JWT 加密解密的结果如下所示：</p>
<p><img src="05-Node.js/../images/node/jwt-01.png" alt="jwt 加密解密对比" /></p>
<p>解析上图：</p>
<ul>
<li>Token：即左侧区域内容，是按照指定的算法（图中是 hash256）生成的字符串。字符串的颜色分别对应右侧解密后的部分。</li>
<li>Header：放置 JWT 的一些基本信息，如是哪个算法生成的</li>
<li>Payload：称为载荷，也即数据，是真实的状态信息，一般用来存储用户 id、权限等</li>
<li>Verify Signature：签名。根据 header、payload、加密算法、秘钥生成的签名。作用是让 token 无法被伪造，即使有心者可以修改 payload 中的 uid 为其自己的，但是 signature 无法修改，该部分生成的秘钥位于后端，前端是无法拿到的。</li>
</ul>
<h2 id="二-jwt-的使用"><a class="header" href="#二-jwt-的使用">二 JWT 的使用</a></h2>
<h3 id="20-jwt-鉴权的流程"><a class="header" href="#20-jwt-鉴权的流程">2.0 JWT 鉴权的流程</a></h3>
<pre><code class="language-txt">1、用户登录，发送用户信息给服务端，服务端据此制作 Token 并返回该 Token 给前端
2、前端接收到 Token 后，保存该 Token（存储于 Cookie、localStorage 均可）
3、后续每次请求，携带该 Token（请求头、Cookie 中均可携带）
4、服务端每次收到请求，解密 Token，验证 Token 是否合法，合法则通过请求发返回资源。
</code></pre>
<p>JWT 的鉴权方式，非常适用于 无状态请求、第三方登录等场景。</p>
<h3 id="21-token-使用示例代码"><a class="header" href="#21-token-使用示例代码">2.1 Token 使用示例代码</a></h3>
<p>第一次登陆时，根据前端发送的信息生成 token：</p>
<pre><code class="language-js">const jwt = require('jsonwebtoken')
const secret = '&amp;*&amp;*(&amp;(&amp;(*^HKJG1'

app.post('/user/login', async (ctx, body) =&gt; {
  // 假设使用手机 + 验证码登录
  let uid = '' // 校验手机与验证码后获取到用户 uid
  let username = 'Li' // 获取权限等级
  const token = jsonwebtoken.sign({ uid, username }, secret, {
    expiresIn: 60 * 60 * 24, // 授权时效 24 小时
  })
  ctx.body = { token }
})
</code></pre>
<p>后续前端发送的信息中携带 Token，这里 token 携带与 header 字段中：</p>
<pre><code class="language-js">fetch('api/user/1', {
  headers: {
    Authorization: token,
  },
})
</code></pre>
<p>后续服务端对接口进行 token 校验：</p>
<pre><code class="language-js">// 校验中间件
const checkToken = async (ctx, next) =&gt; {
  const { token = '' } = ctx.request.header
  try {
    const user = jsonwebtoken.verify(token, secret)
    ctx.state.user = user
  } catch (e) {
    ctx.throw(401, '没有权限')
  }
  await next()
}

// 路由使用
router.get('/news/list', checkToken, listNews)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="091-node-连接数据库"><a class="header" href="#091-node-连接数据库">09.1-Node 连接数据库</a></h1>
<h2 id="一-node-连接-mysql"><a class="header" href="#一-node-连接-mysql">一 Node 连接 mysql</a></h2>
<h3 id="11-原生连接"><a class="header" href="#11-原生连接">1.1 原生连接</a></h3>
<pre><code class="language-JavaScript">let db=mysql.createConnection({host, port, user, password, database});
db.query('select * from user', (err, data)=&gt;{});
</code></pre>
<p>连接池配置：</p>
<pre><code class="language-JavaScript">const express = require('express');
const mysql = require('mysql');

let mysqlDB = mysql.createPool({
    host:'localhost',
    post:3306,
    user:'root',
    password:'root',
    database:'suibian'
});

let app = express();

app.get('/api',function (req,res) {
    let query = 'select * from students';
    mysqlDB.query(query,function (err,data) {
        let name = data[0].name;
        res.send(name);
    });
});

app.listen(3000);

</code></pre>
<h3 id="12-orm-框架-sequlize"><a class="header" href="#12-orm-框架-sequlize">1.2 ORM 框架 sequlize</a></h3>
<pre><code class="language-txt">sequelize 框架需要额外安装 mysql2 包
npm install mysql2 --save
npm install sequelize --save
</code></pre>
<pre><code class="language-JavaScript">const Sequelize = require('sequelize');
const mysqlConfig = {
    database: 'lib1', // 使用哪个数据库
    username: 'root', // 用户名
    password: 'root', // 口令
    host: 'localhost', // 主机名
    port: 3306 // 端口号，MySQL默认3306
};
let sequelize = new Sequelize(
 mysqlConfig.database,
 mysqlConfig.username,
  mysqlConfig.password,
 {
      host: mysqlConfig.host,
      dialect: 'mysql',
      pool: {
          max: 5,
          min: 0,
          idle: 30000
    }
});

//sequelize与数据库直连
// (async ()=&gt;{
//     let table = await sequelize.query(&quot;SELECT * FROM users&quot;);
//     console.log(table);
// })();

//ORM
let User = sequelize.define('user', {
 //sequelize会给user自动添加s后缀
    id: {
        type: Sequelize.STRING(50),
        primaryKey: true
    },
    name: Sequelize.STRING(100),
    age: Sequelize.STRING(10),
}, {
    timestamps: false       //关闭sequelize默认的timestamp的功能
});

let name = 'ha';
let age = 22;
(async ()=&gt;{
    let dog = await User.create({
        id:0,
        name:name,
        age:age
    });
})();


</code></pre>
<h2 id="二-node-连接-redis"><a class="header" href="#二-node-连接-redis">二 Node 连接 Redis</a></h2>
<h3 id="21-连接示例"><a class="header" href="#21-连接示例">2.1 连接示例</a></h3>
<p>Redis 官方推荐的 Node.js 连接 Redis 驱动包有 node_redis 和 ioredis。本文以 ioredis 为例。</p>
<pre><code class="language-js">const Redis = require('ioredis')

// let redis = new Redis();
// 指定地址访问
// let redis = new Redis(6379, '127.0.0.1');
let redis = new Redis({
  port: 6379, // Redis port
  host: '1****', // Redis host
  family: 4, // 4 (IPv4) or 6 (IPv6)
  password: 'test',
  db: 0,
})

redis.set('name', 'lisi', function () {
  redis.get('name', function (error, result) {
    console.log(result)
  })
})
</code></pre>
<p>ioredis 支持在 HMSET 命令中使用对象作为参数，对象的属性值只能是字符串，相应的 HGETALL 会返回一个对象。
对事务的支持：</p>
<pre><code class="language-js">let multi = redis.multi()
multi.set('foo1', 'bar1')
multi.sadd('foo2', 'bar2')
multi.exec(function (err, replies) {
  console.log(replies) //[ [ null, 'OK' ], [ null, 1 ] ]
})

//或者链式调用：
redis
  .multi()
  .set('foo3', 'bar3')
  .sadd('set', 'b')
  .exec(function (err, replies) {
    console.log(replies) //[ [ null, 'OK' ], [ null, 1 ] ]
  })
</code></pre>
<p>发布订阅：创建两个连接，分别充当发布者和订阅者</p>
<pre><code class="language-js">let pub = new Redis({})

let sub = new Redis({})

sub.subscribe('chat', function () {
  pub.publish('chat', 'hi!')
})

sub.on('message', function (channel1, message) {
  console.log('收到 ' + channel1 + ' 频道的消息：' + message) //收到 chat 频道的消息 hi
})
</code></pre>
<p>注意：redis 建立连接也是异步的。连接建立完成前的 redi 操作都会被加入到离线任务队列中，连接成功后，按顺序依次执行。</p>
<h3 id="22-消息队列"><a class="header" href="#22-消息队列">2.2 消息队列</a></h3>
<p>一般来说，消息队列有两种场景：</p>
<ul>
<li>发布订阅模式：发布者向某个频道发布一条消息后，多个订阅者都会收到同一个消息</li>
<li>生产消费模式：生产者生产消息放到队列里，消费者同时监听队列，如果队列里有了新的消息就将其取走，对于单条消息，只能由一个消费者消费</li>
</ul>
<p>发布订阅模式：</p>
<pre><code class="language-js">// publisher
let redis = require('redis')
let client = redis.createClient(6379, '127.0.0.1')
client.on('error', function (err) {
  console.log(err)
})
client.on('ready', function () {
  client.publish('channel1', 'hello')
})

//subsciber
let redis = require('redis')
let client = redis.createClient(6379, '127.0.0.1')
client.on('error', function (err) {
  console.log(err)
})
client.subscribe('channel1')
client.on('message', function (channel, message) {
  console.log('channel: ', channel)
  console.log('message: ', message)
})
</code></pre>
<h2 id="三-node-连接-mongodb"><a class="header" href="#三-node-连接-mongodb">三 Node 连接 mongodb</a></h2>
<pre><code class="language-JavaScript">const MongoClient = require('mongodb').MongoClient;
const MongoURL = 'mongodb://localhost:27017/';
function _connectDB(callback) {
    MongoClient.connect(MongoURL,function (err,db) {
        if(err){
            console.log('Mongo未连接');
            callback(err,'Mongo未连接');
            return;
        }
        console.log('Mongo已连接');
        callback(null, db);
    });
}

//插入一个数据
exports.insertOne = function (dbname,collectionName,json,callback) {
    _connectDB(function (err,db) {
        if(err){
            throw err;
            return;
        }
        let dbObj = db.db(dbname);
        dbObj.collection(collectionName).insertOne(json, function (err, result) {
            if (err) {
                throw err;
                db.close();
                return;
            }
            callback(null, result);
            db.close();
        });
    });
};

</code></pre>
<p>使用：</p>
<pre><code class="language-JavaScript">const db = require('./db');
db.insertOne('testdb','teacher',{'name':'lisi'},function (err,result) {
    if(err){
        console.log(err);
        return;
    }
    console.log('sucess');
});

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="101-异常机制-错误处理"><a class="header" href="#101-异常机制-错误处理">10.1-异常机制-错误处理</a></h1>
<h2 id="一-koa-中的异常处理"><a class="header" href="#一-koa-中的异常处理">一 Koa 中的异常处理</a></h2>
<h3 id="10-说明"><a class="header" href="#10-说明">1.0 说明</a></h3>
<p>这里以 Koa 为例，因为 Koa 是下一代 Web 框架，非常适合作为大型框架的基础框架。</p>
<p>错误处理是开发中最常见的需求之一，在后端，错误处理的核心目标是让服务端不会因为一些未捕获错误而死去。</p>
<h3 id="11-koa-抛出错误"><a class="header" href="#11-koa-抛出错误">1.1 Koa 抛出错误</a></h3>
<p>Koa 默认提供了 throw() 方法抛出错误：</p>
<pre><code class="language-js">const Koa = require('koa')
const Router = require('koa-router')

const app = new Koa()
const router = new Router()

router.get('/error/serverErr', async (ctx, next) =&gt; {
  ctx.throw(500) // 错误：Internal Server Error
})

router.get('/error/serverErr2', async (ctx, next) =&gt; {
  ctx.throw(501) // 错误：Not Implemented
})

router.get('/error/sourceErr2', async (ctx, next) =&gt; {
  ctx.throw(400) // 错误：Bad Request
})

router.get('/error/sourceErr', async (ctx, next) =&gt; {
  ctx.throw(404) // 错误：NotFound
})

app.use(router.routes())
app.use(router.allowedMethods()) //根据 ctx.status 设置响应头

app.listen(3000)
</code></pre>
<p>值得注意的是，如果将 ctx.response.status 设置成对应的状态码，效果跟 ctx.throw() 是一样的：</p>
<pre><code class="language-js">router.get('/error/sourceErr', async (ctx, next) =&gt; {
  ctx.status = 404
  ctx.body = 'Page Not Found'
})
</code></pre>
<h3 id="12-错误处理事件"><a class="header" href="#12-错误处理事件">1.2 错误处理事件</a></h3>
<p>错误处理事件 error 可以捕获全局中的错误：</p>
<pre><code class="language-js">router.get('/error/onErr', async (ctx, next) =&gt; {
  throw '数据库连接失败'
})

app.on('error', async (err, ctx) =&gt; {
  console.log('捕获到错误：', err)
  // 都不会触发
  // ctx.status = 404
  // ctx.body = '发生了异常'
})
</code></pre>
<p>如果错误被 try...catch 捕获，就不会触发 error 事件。这时，必须调用 ctx.app.emit()，手动释放 error 事件，才能让监听函数生效，而且此时也可以在 error 事件函数中对 ctx 进行处理了：</p>
<pre><code class="language-js">router.get('/error/onErr', async (ctx, next) =&gt; {
  try {
    throw new Error('数据库连接失败')
  } catch (e) {
    ctx.app.emit('error', e, ctx)
  }
})

app.on('error', async (err, ctx) =&gt; {
  console.log('ctx:', ctx)
  console.log('捕获到错误：', err)

  // 现在会触发不会触发
  ctx.status = 500
  ctx.body = { msg: err.message }
})
</code></pre>
<h2 id="二-错误处理实践"><a class="header" href="#二-错误处理实践">二 错误处理实践</a></h2>
<h3 id="21-企业中的错误处理"><a class="header" href="#21-企业中的错误处理">2.1 企业中的错误处理</a></h3>
<p>在企业的 MVC 分层模型中，经常会在 Controller 层进行错误处理：如参数校验错误将错误返回给前端。</p>
<p>但是如果是 Service 发生的错误呢？这里有两种选择：</p>
<ul>
<li>Service 层通过自定义错误码，向 Controller 层传递自定义错误码，在 Controller 层进行正常处理</li>
<li>Service 层的错误向上抛出，在 Controller 层进行 catch 处理</li>
</ul>
<h3 id="22-错误处理中间件"><a class="header" href="#22-错误处理中间件">2.2 错误处理中间件</a></h3>
<p>可以利用 Koa 的中间件机制，将上述两种做法进行一定的结合，作为更好的错误处理方式。</p>
<p>首先假设错误的返回给客户端的方式是：</p>
<pre><code class="language-js">{
    errCode: 10000,
    errMsg: 'Server Err'
}
</code></pre>
<p>可以定义一个 http 异常，由中间件进行全局错误拦截：</p>
<pre><code class="language-js">const Koa = require('koa')
const Router = require('koa-router')

const app = new Koa()
const router = new Router()

class HttpException extends Error {
  constructor(code = 10000, msg) {
    super()
    this.errCode = code
    this.errMsg = msg || '服务器异常'
  }
}

async function httpErrorMiddleware(ctx, next) {
  try {
    await next()
  } catch (e) {
    if (e instanceof HttpException) {
      ctx.status = 200
      ctx.body = {
        errCode: e.errCode,
        errMsg: e.errMsg,
        requestUrl: `${ctx.method} ${ctx.path}`,
      }
    } else {
      ctx.status = 500
      ctx.body = {
        errCode: 11000,
        errMsg: e.message || '未知服务错误',
        requestUrl: `${ctx.method} ${ctx.path}`,
      }
    }
  }
}

router.get('/error/paramErr', httpErrorMiddleware, (ctx, next) =&gt; {
  throw new HttpException(10001, '参数不合法')
})

router.get('/error/notFoundErr', httpErrorMiddleware, (ctx, next) =&gt; {
  throw new HttpException(10004, '资源不存在')
})

router.get('/error/sourceErr', httpErrorMiddleware, (ctx, next) =&gt; {
  ctx.throw(400)
})

app.use(router.routes())
app.use(router.allowedMethods()) //根据 ctx.status 设置响应头

app.listen(3000)
</code></pre>
<h3 id="23-错误处理优化---最终版"><a class="header" href="#23-错误处理优化---最终版">2.3 错误处理优化 - 最终版</a></h3>
<p>显然上述的错误处理在自定义上无法满足我们的需要，写起来也较为繁琐。</p>
<p>首先我们会需要自定义更多的错误，这些错通通过继承关系实现即可，此外为了简化导出的不同类型异常数目过多，可以通过工厂函数形式导出：</p>
<pre><code class="language-js">class HttpException extends Error {
  constructor(code = 10000, msg) {
    super()
    this.errCode = code
    this.errMsg = msg || '服务器异常'
  }
}

class ParamException extends HttpException {
  constructor(msg) {
    super()
    this.errCode = 10001
    this.errMsg = msg || '参数不合法'
  }
}

class NotFountException extends HttpException {
  constructor(msg) {
    super()
    this.errCode = 10004
    this.errMsg = msg || '资源未找到'
    this.status = 404
  }
}

class ForbiddenException extends HttpException {
  constructor(msg) {
    super()
    this.errCode = 10005
    this.errMsg = msg || '没有资源权限'
    this.status = 403
  }
}

// 直接导出会导致导入错误时过于繁琐
// module.exports = {
//     HttpException,ParamException,NotFountException,ForbiddenException
// }

// 在传参时无需记住字符串
const HttpCode = {
  ParamException: 'ParamException',
  NotFountException: 'NotFountException',
  ForbiddenException: 'ForbiddenException',
}

// 根据传入的名字创建对象
function createHttpException(exceptionStr = 'HttpException', msg = '') {
  return eval(`new ${exceptionStr}('${msg}')`)
}

module.exports = { HttpCode, HttpException, createHttpException }
</code></pre>
<p>中间件不需要有太多变化，路由中使用：</p>
<pre><code class="language-js">const Koa = require('koa')
const Router = require('koa-router')
const httpErrorMiddleware = require('./middleware/httpErrorMiddleware')
const { HttpCode, createHttpException } = require('./common/HttpException')

const app = new Koa()
const router = new Router()

app.use(httpErrorMiddleware)

// 自定义错误数据
router.get('/error/paramErr', (ctx, next) =&gt; {
  throw createHttpException(HttpCode.ParamException, 'uid 不合法')
})

// 使用默认设置
router.get('/error/notFoundErr', (ctx, next) =&gt; {
  throw createHttpException(HttpCode.NotFountException)
})

// 未定义的错误捕获
router.get('/error/sourceErr', (ctx, next) =&gt; {
  ctx.throw(400) // 错误：Bad Request
})

app.use(router.routes())
app.use(router.allowedMethods()) //根据 ctx.status 设置响应头

app.listen(3000)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="102-异常机制-日志功能"><a class="header" href="#102-异常机制-日志功能">10.2-异常机制-日志功能</a></h1>
<h2 id="一-日志框架"><a class="header" href="#一-日志框架">一 日志框架</a></h2>
<p>常见的 Node 日志框架为 log4js，笔者这里的配置如下：</p>
<pre><code class="language-js">const log4js = require('log4js')

log4js.configure({
  appenders: {
    console: {
      type: 'console',
    },
    dateFile: {
      type: 'dateFile',
      filename: 'logs/log.log',
      pattern: '_yyyy-MM-dd',
      maxLogSize: 20480,
      alwaysIncludePattern: false,
      backups: 4,
    },
  },
  categories: {
    cheese: { appenders: ['dateFile'], level: 'error' },
    another: { appenders: ['console'], level: 'trace' },
    default: { appenders: ['console', 'dateFile'], level: 'trace' },
  },
  replaceConsole: true,
})

exports.INFOLogger = function (name) {
  var logger = log4js.getLogger(name)
  logger.level = 'info'
  return logger
}
</code></pre>
<p>项目中使用：</p>
<pre><code class="language-js">const logger = require('../utils/log4jsUtil').INFOLogger(
  'controller/userController'
)

logger.info('进入 userController')
</code></pre>
<h2 id="二-性能指标采集"><a class="header" href="#二-性能指标采集">二 性能指标采集</a></h2>
<h3 id="21-基础演示"><a class="header" href="#21-基础演示">2.1 基础演示</a></h3>
<p>一般使用 process 全局对象即可采集到 CPU、内存等信息：</p>
<pre><code class="language-js">let previousCpuUsage = process.cpuUsage() // 记录上一次的 usage
let previousHrTime = process.hrtime() //记录上一次的 hrtime

setInterval(() =&gt; {
  const currentCpuUsage = process.cpuUsage(previousCpuUsage) //根据上次信息采集本次
  const currentHrTime = process.hrtime(previousHrTime) //得到本次的 hrtime
  const duration = currentHrTime[O] * le6 + currentHrTime[1] / 1e3 //根据 hrtime 计算时间

  previousTime = currentHrTime // 保存本次 hrtime
  previousCpuUsage = currentCpuUsage // 保存本次 usage

  const cpuPercent = {
    user: currentCpuUsage.user / duration, // CPU用户资源占比
    system: currentCpuUsage.system / duration, // CPU系统资源占比
  }

  console.log(cpuPercent)
}, 1000)
</code></pre>
<p>贴士：hrtime 是 process 对象提供了更高精度的时间。</p>
<h3 id="22-日志分析系统-elk"><a class="header" href="#22-日志分析系统-elk">2.2 日志分析系统 ELK</a></h3>
<p>企业级的项目可以使用 ELK 日志分析系统：</p>
<ul>
<li>E：Elasticsearch，开源分布式搜索引擎，为日志提供存储、搜索引擎</li>
<li>L：Logstash，处理日志的搜索、分析、过滤等</li>
<li>K：Kibana，日志查询的 web 管理界面</li>
</ul>
<h3 id="23-keymetrics-监控"><a class="header" href="#23-keymetrics-监控">2.3 Keymetrics 监控</a></h3>
<p>采集到的 Node 性能数据，需要输入到特定系统进行展示、分析，PM2 官方提供了 Keymetrics 工具。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-websocket"><a class="header" href="#111-websocket">11.1-WebSocket</a></h1>
<h2 id="一-websocket-简介"><a class="header" href="#一-websocket-简介">一 websocket 简介</a></h2>
<p>与 HTTP 协议类似，WebSocket 也是基于 TCP 协议的应用层协议，弥补了 HTTP 协议无状态等缺陷，且提供了客户端和服务器之间双工通信机制。</p>
<p>目前支持状态、双工通信的协议有：</p>
<ul>
<li>http2：国际标准协议，但是该协议尚未被完全支持</li>
<li>websocket：非标准协议，但是该协议已经被大多浏览器支持，所以在实践中较为常用。</li>
</ul>
<h2 id="二-socketio"><a class="header" href="#二-socketio">二 socket.io</a></h2>
<h3 id="21-使用-socketio"><a class="header" href="#21-使用-socketio">2.1 使用 socket.io</a></h3>
<p>原生的 websocket 在服务端使用起来较为繁琐，需要做解析处理，socket.io 是目前较为常用的 Node 的 websocket 框架。</p>
<h3 id="22-客户端代码"><a class="header" href="#22-客户端代码">2.2 客户端代码</a></h3>
<p>安装 socket.io 的服务端模块：</p>
<pre><code class="language-txt">npm i -S socket.io-client
</code></pre>
<p>服务端默认支持的事件：</p>
<pre><code class="language-js">ws.on('connec') // 发起连接事件
ws.on('disconnect') // 断开连接事件
</code></pre>
<p>客户端代码示例：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
      #listText {
        list-style: none;
        border: solid 1px #2aabd2;
        width: 400px;
        height: 300px;
        position: relative;
      }
      #listText .myText {
        color: #5cb85c;
      }
      #listText #connectStat {
        position: absolute;
        left: auto;
        bottom: 20px;
        color: red;
        display: none;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;ul id=&quot;listText&quot;&gt;
      &lt;span id=&quot;connectStat&quot;&gt;服务器已断开，请检查网络....&lt;/span&gt;
    &lt;/ul&gt;
    &lt;textarea rows=&quot;4&quot; cols=&quot;60&quot; id=&quot;sendText&quot;&gt;&lt;/textarea&gt;
    &lt;button id=&quot;sendBtn&quot;&gt;发送&lt;/button&gt;
    &lt;script src=&quot;./node_modules/socket.io-client/dist/socket.io.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      const ws = io(`ws://localhost:8000`)

      let listText = document.querySelector('#listText')
      let sendText = document.querySelector('#sendText')
      let connectStat = document.querySelector('#connectStat')
      let sendBtn = document.querySelector('#sendBtn')

      sendBtn.onclick = function () {
        //发送一个名称为 msg 的消息
        ws.emit('msg', sendText.value)
        let myLi = document.createElement('li')
        myLi.innerHTML = sendText.value
        myLi.className = 'myText'
        listText.appendChild(myLi)
        sendText.value = ''
      }

      //已经连接
      ws.on('connect', function () {
        console.log('已连接')
        connectStat.style.display = 'none'
      })

      //接收消息
      ws.on('rec', function (str) {
        let oLi = document.createElement('li')
        oLi.innerHTML = str
        listText.appendChild(oLi)
      })

      //断开连接
      ws.on('disconnect', function () {
        console.log('已断开')
        connectStat.style.display = 'block'
      })
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="23-服务端代码"><a class="header" href="#23-服务端代码">2.3 服务端代码</a></h3>
<p>安装 socket.io 的服务端模块：</p>
<pre><code class="language-txt">npm i -S socket.io
</code></pre>
<p>服务端默认支持的事件：</p>
<pre><code class="language-js">ws.on('connection') // 连接成功事件
ws.on('disconnect') // 断开连接事件
</code></pre>
<p>服务端代码示例：</p>
<pre><code class="language-js">const http = require('http')
const io = require('socket.io')

let server = http.createServer((req, res) =&gt; {})
server.listen(8000)

const ws = io.listen(hs)

let sockArr = []
ws.on('connection', (socket) =&gt; {
  sockArr.push(sock)

  //接收消息
  socket.on('msg', function (str) {
    //分发消息给所有客户端，除了发消息的客户端
    sockArr.forEach(function (s) {
      if (s != socket) {
        s.emit('serverMsg', str)
      }
    })
  })

  //断开连接
  socket.on('disconnect', function () {
    //从数组中删除该链接
    let n = sockArr.indexOf(socket)
    if (n != -1) {
      sockArr.splice(n, 1)
    }
  })
})
</code></pre>
<h2 id="三-原生-websocket"><a class="header" href="#三-原生-websocket">三 原生 websocket</a></h2>
<h3 id="31-简介"><a class="header" href="#31-简介">3.1 简介</a></h3>
<p>websocket 其实是前端 H5 的内容，Node 等后台是自带 socket 服务的，而 Node 本身的 socket 很底层，在上述案例中使用了第三方包 io.socket 来处理。
使用源生 net 包来处理 socket，得到的数据经过打印是：</p>
<pre><code class="language-txt">GET / HTTP/1.1
Host: localhost:8000
Connection: Upgrade
Pragma: no-cache
Cache-Control: no-cache
Upgrade: websocket
Origin: http://localhost:63342
Sec-WebSocket-Version: 13
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.119 Safari/537.36
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cookie: _ga=GA1.1.574841553.1517937000; Webstorm-63f64cd9=acfa6107-17dd-497f-85f8-29856fe9a6b2; io=-hHwrF9Hh_HRNJ8LAAAB
Sec-WebSocket-Key: Z6eN3mB4Ip+FHChXL+jQ+g==
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits
</code></pre>
<p>我们需要对该数据进行解析：每行数据都是以 : + 空格形式 存在的键值对</p>
<h3 id="32-服务端代码"><a class="header" href="#32-服务端代码">3.2 服务端代码</a></h3>
<pre><code class="language-js">//http,socket.io 都是基于 net 模块制作的
const net = require('net');
const crypto = require('crypto');
//前台不使用 socket.io 时，使用源生 webscoket 连接服务，会被 http 服务拒绝，所以这里使用 net 创建服务
net.createServer(socket=&gt;{    //使用 http 接收会拒绝

    console.log('已经连接');

    //发现数据传输
    socket.once('data',data=&gt;{        //握手的过程只有一次
        //该过程即 握手 此时接收到了 http 头数据，但是我们没有 http 模块来解析
        console.log('开始握手...');
        // console.log(data.toString());//打印该数据
        let str = data.toString();
        let lines = str.split('\r\n');
        //舍弃第一行和最后两行
        lines = lines.slice(1,lines.length - 2);
        //用：+ 空格切割
        let headers = {};
        lines.forEach(line=&gt;{
            let [key,value] = line.split(': ');
            headers[key] = value;
        });

        if(headers['Upgrade'] != 'websocket'){
            console.log('其他协议',headers['Upgrade']);
            socket.end();
        } else if(headers['Sec-WebSocket-Version'] != 13){
            console.log('只支持 13 版本的 webscoket');
            socket.end();
        } else {

            // 此处为官方规定：sha1(key+mask)-&gt;base64=&gt;client
            let key=headers['Sec-Websocket-Key'];
            let mask='258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
            let hash=crypto.createHash('sha1');
            hash.update(key+mask);
            let key2=hash.digest('base64');

            //发送 key2 给客户端
            socket.write(`HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ${key2}\r\n\r\n`);

            console.log('握手结束');

            //真正的数据，以后每次来数据都只走这一步
            socket.on('data', data=&gt;{

                console.log('真正的数据' + data);

                let FIN=data[0]&amp;0x001;
                let opcode=data[0]&amp;0x0F0;
                let mask=data[1]&amp;0x001;
                let payload=data[1]&amp;0x0FE;

                console.log(FIN, opcode);
                console.log(mask, payload);
            }
        }
    });

    //断开连接
    socket.on('end',()=&gt;{

    });
}).listen(8000);
</code></pre>
<h3 id="33-客户端代码"><a class="header" href="#33-客户端代码">3.3 客户端代码</a></h3>
<pre><code class="language-html">&lt;script&gt;
  let ws = new WebSocket('ws://localhost:8000')

  //模仿 socket.io 手工封装一个 emit 方法
  ws.emit = function (name, ...args) {
    console.log('发送了：' + JSON.stringify({ name, data: [...args] }))
    ws.send(JSON.stringify({ name, data: [...args] }))
  }
  //已经连接
  ws.onopen = function () {
    console.log('连接上了')
    ws.emit('msg', 12, 5)
  }

  //发现数据传输
  ws.onmessage = function () {
    console.log('有数据传输')
  }

  //断开连接
  ws.onclose = function () {
    console.log('断开连接')
  }
&lt;/script&gt;
</code></pre>
<h3 id="34-数据帧解析数据"><a class="header" href="#34-数据帧解析数据">3.4 数据帧解析数据</a></h3>
<p>计算机的数据都是由位构成的，1 个位占据 8。</p>
<pre><code class="language-txt"> 0 位        1 位        2 位        3 位
 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+-------------------------------+
|     Extended payload length continued, if payload len == 127  |
+-------------------------------+-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------+-------------------------------+
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
|                     Payload Data continued ...                |
+---------------------------------------------------------------+


FIN               1bit 是否最后一帧
RSV               3bit 预留
Opcode            4bit 帧类型
Mask              1bit 掩码，是否加密数据，默认必须置为 1
Payload           7bit 长度
Masking-key       1 or 4 bit 掩码
Payload data      (x + y) bytes 数据
Extension data    x bytes  扩展数据
Application data  y bytes  程序数据
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="121-node-与加密-密码学"><a class="header" href="#121-node-与加密-密码学">12.1-Node 与加密-密码学</a></h1>
<h2 id="一-密码学概述"><a class="header" href="#一-密码学概述">一 密码学概述</a></h2>
<h3 id="11-加密算法分类"><a class="header" href="#11-加密算法分类">1.1 加密算法分类</a></h3>
<p>常用的加密算法有三类：</p>
<ul>
<li>哈希算法：不可逆</li>
<li>加密解密算法：通过秘钥实现加密解密，是可逆的</li>
<li>编码解码算法：无需秘钥，是可逆的，如 Base64，但是严格意义上来说该类算法只是一种数据编码格式，而非加密</li>
</ul>
<h3 id="12-哈希算法"><a class="header" href="#12-哈希算法">1.2 哈希算法</a></h3>
<blockquote>
<p>哈希算法：让任意长度的数据通过该算法映射为较短的固定长度的数据，并且不同数据基本上不会映射为相同的 Hash 值。</p>
</blockquote>
<p>哈希算法其实是一种消息摘要实现技术，hash 是剁碎的意思，所以也称呼 hash 为散列，其加密是不可逆的，常见的 hash 算法有：</p>
<pre><code class="language-txt">md4、md5、hash1、SHA256、SHA3
</code></pre>
<p>哈希算法加密不可逆，常见的算法有：等。</p>
<p>例如一段字符串<code>hello world</code>，经过 md5 加密后转换成了：<code>5eb63bbbe01eeed093cb22bb8f5acdc3</code>，该密文是无法返回到原始的明文的。但是现在一些网站能够根据结构给出原始值，是因为其数据库存暴力存储了一些常用数据经过哈希后得到的结果。</p>
<p>哈希算法必须解决冲突问题，即不同的数据通过哈希算法产生了相同的输出，MD5，SHA-1 算法都已经被证明不具备<code>强抗碰撞性</code>，不足以应对要求很高的商业场景。为了提升哈希算法的安全性，推荐使用 SHA-2，该算法是 SHA-256,SHA-512 等算法的并称。</p>
<p>不过 MD5 仍然被大量用于网站的登录中，如下所示：</p>
<p><img src="05-Node.js/../images/node/04-01.png" alt="登录设计" /></p>
<p>彩虹表攻击会让哈希算法变得很脆弱，通过加盐的方式能够提升安全性：</p>
<p><img src="05-Node.js/../images/node/04-02.png" alt="加盐" /></p>
<h3 id="13-加解密算法"><a class="header" href="#13-加解密算法">1.3 加解密算法</a></h3>
<p>加密解密算法包括三种：</p>
<ul>
<li>对称加密：包括 DES、3DES、AES 等</li>
<li>非对称加密：包括 RSA 算法、椭圆曲线加密算法</li>
<li>数字签名算法 DSA</li>
</ul>
<h3 id="14-编码解码算法"><a class="header" href="#14-编码解码算法">1.4 编码解码算法</a></h3>
<p>编码解码算法常见的有 Base64 编码解码，Base58 编码解码。</p>
<h2 id="二-对称加密"><a class="header" href="#二-对称加密">二 对称加密</a></h2>
<p>对称加密（datar encryption algorithm，DEA）也称为私钥加密算法、单秘钥算法。对称加密的特点：</p>
<ul>
<li>加密和解密的秘钥相同</li>
<li>运算效率加高</li>
</ul>
<p>使用图示：</p>
<p><img src="05-Node.js/../images/node/04-03.png" alt="对称加密" /></p>
<p>DES 目前是非常安全的加密方式，只有穷举法才可以破解。常见的对称加密算法有：DES,3DES,AES 等。</p>
<p>对称加密由于加密方和解密方双方使用同一个秘钥，所以必须保证该秘钥的绝对安全性！此外，每对用户每次使用加密算法时，都需要使用其他人不知道的唯一钥匙，这样收发双方拥有的钥匙数量会呈几何增长，故而不适合分布式系统（不过分布式系统本身就应该是无状态的）。</p>
<h2 id="三-非对称加密"><a class="header" href="#三-非对称加密">三 非对称加密</a></h2>
<h3 id="31-非对称加密概念"><a class="header" href="#31-非对称加密概念">3.1 非对称加密概念</a></h3>
<p>非对称加密也称呼为公钥加密，最著名的非对称加密算法是 RSA、椭圆曲线算法 ECC。</p>
<p>非对称加密的特点：加密和解密分别使用两个不同的秘钥。使用其中一个秘钥对明文加密得到的密文，只有另外一个秘钥才能解密得到明文！而且这 2 个秘钥只在数学上有关，即使知道了其中一个，也无法计算出另外一个，所以一个可以公开，任意发布，一个不公开，由用户保管，绝对不同通过任何途径传输。</p>
<p>这两个秘钥分别是：</p>
<ul>
<li>公钥：公开秘钥，公钥可以向外任意发布。</li>
<li>私钥：私有秘钥，私钥由用户存储，私钥不能通过任何渠道传输</li>
</ul>
<p>总结如下：</p>
<ul>
<li>公开密钥和私有密钥是一对</li>
<li>如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。</li>
<li>如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。</li>
<li>因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</li>
</ul>
<p>步骤如下：
<img src="05-Node.js/../images/node/04-04.png" alt="非对称加密" /></p>
<p>非对称加密中用于解密的私钥是不公开、不进行传输的，所以安全性较高，但是相对的，也增加了运算时间。</p>
<h3 id="32-数字签名与验证"><a class="header" href="#32-数字签名与验证">3.2 数字签名与验证</a></h3>
<p>非对称加密中双方进行通信的加密解密过程：</p>
<ul>
<li>1.A 要向 B 发送信息，A 和 B 都要产生一对用于加密和解密的公钥和私钥</li>
<li>2.A 的私钥保密，A 的公钥告诉 B；B 的私钥保密，B 的公钥告诉 A。</li>
<li>3.A 要给 B 发送信息时，A 用 B 的公钥加密信息，因为 A 知道 B 的公钥。</li>
<li>4.A 将这个消息发给 B（已经用 B 的公钥加密消息）。</li>
<li>5.B 收到这个消息后，B 用自己的私钥解密 A 的消息。其他所有收到这个报文的人都无法解密，因为只有 B 才有 B 的私钥。</li>
</ul>
<p>通过公钥加密、私钥解密的过程，称为数字签名、验证签名。数字签名有两部分组成：</p>
<ul>
<li>使用私钥从消息中创建签名</li>
<li>允许任何人验证签名</li>
</ul>
<p>数字签名主要用于验证双方的数据是否被串改，数字签名与加密解密不是一个概念！</p>
<p>非对称加密找那个双方进行通信时，不但要对消息进行加密解密，也要执行数字签名与验证：</p>
<p><img src="05-Node.js/../images/node/04-05.png" alt="数字签名" /></p>
<h2 id="四-网络的安全传输"><a class="header" href="#四-网络的安全传输">四 网络的安全传输</a></h2>
<h3 id="41-ssl-简介"><a class="header" href="#41-ssl-简介">4.1 SSL 简介</a></h3>
<p>传统的网络传输中，内容都是以明文形式传输，安全性很低。而对于 HTTP、FTP 协议而言，我们同样希望其本身只是负责数据的传输而不是加密解密。SSL 是当年的网景公司（火狐的前身）退出的安全协议，它会在传输层提供对网络连接的加密功能。对于应用程序而言，数据在传递到应用层之前就已经完成了加密、解密的过程。SSL 经过标准化后，称呼为 TLS。</p>
<p>HTTPS 即 SSL 和 HTTP 结合产物，WSS 即 SSL 和 WebSocket 结合的产物。</p>
<p>当然 HTTPS 由于引入了加密解密过程，而且这种加密机制使用的是非对称加密，其算法性能很低，所以 HTTPS 也因此牺牲了很大一部分性能。</p>
<h3 id="42-ssl-实现"><a class="header" href="#42-ssl-实现">4.2 SSL 实现</a></h3>
<p>不同的 SSL 握手过程存在差异，分为以下三种：</p>
<ul>
<li>只验证服务器</li>
<li>验证服务器和客户端</li>
<li>恢复原有会话</li>
</ul>
<p>这里只介绍第一种过程。</p>
<p><strong>第 1 步</strong>：客户端发送一个消息，假为 Client Hello，给服务端，该消息包括：</p>
<pre><code class="language-txt">一个随机数（假设它是 random1）
一个 session id(用来避免后续请求的握手)
浏览器支持的密码套件（cipher suite），即由加密算法名称组成的字符串，示例：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
</code></pre>
<p><strong>第 2 步</strong>：服务器对消息进行验证（如 SSL 版本）后，返回一个消息给客户端，假设为 Server Hello，该消息包括：</p>
<pre><code class="language-txt">服务器支持的 SSL 版本信息
一个伪随机数（假设它是 random2）
服务器的密码套件（cipher suite）
</code></pre>
<p><strong>第 3 步</strong>：服务器发送 CA 证书给客户端</p>
<p><strong>第 4 步</strong>：服务器发送 Server Hello done</p>
<p><strong>第 5 步</strong>：客户端验证服务器证书的合法性后 (Certificate Verify) 后，利用证书中的公钥加密 premaster secret(一个在堆成加密密钥生成中的 46 字节随机数字，以及消息认证代码) 作为 Client Key Exchange 的消息发送给服务器。</p>
<p><strong>第 6 步</strong>：SSL 客户端发送 Change Cipher Spec 消息，该消息属于 SSL 密码变化协议</p>
<p><strong>第 7 步</strong>：客户端计算历史消息的 hash 值，然后使用服务器公钥加密后发送给服务器，服务器进行同样的操作，然后两个值结果相同表示密钥交换成功</p>
<p><strong>第 8 步</strong>：服务器发送 Change Cipher Spec 消息</p>
<p><strong>第 9 步</strong>：服务器计算历史消息的 hash 值，通过交换后的密钥加密，将其作为 finished 消息发送给客户端，客户端利用交换后的密钥解密，如果和本地历史消息相同就黄泽宁服务器身份，握手结束</p>
<h3 id="43-密钥交换步骤"><a class="header" href="#43-密钥交换步骤">4.3 密钥交换步骤</a></h3>
<p>常见的密钥交换算法是 RSA 算法，是一种非对称加密算法，步骤如下：</p>
<ul>
<li>步骤 1：Client Verify。客户端接收到服务端传来的整数后，先验证该证书合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 random3，再用服务端公钥加密 random3 生成 PreMasterKey</li>
<li>步骤 2：Clent Key Exchange：将第一步最后生成的 key 传给服务端，服务端用自己的私钥解出这个 key，得到客户端生成的 random3，再加上 random1，random2，至此，客户端和服务端都拥有了 random1，random2，random3.</li>
</ul>
<p>两边再根据同样的算法就可以生成一份密钥，握手结束后应用层数据都是用该密钥进行对称加密，使用三个随机数的原因是提升暴力破解难度。</p>
<h3 id="44-ca-证书与中间人攻击"><a class="header" href="#44-ca-证书与中间人攻击">4.4 CA 证书与中间人攻击</a></h3>
<p>上述的步骤就像两个同学上课传纸条，二人为了不让其他人发现纸条的信息，互相约定了写法和破译，各自的加密内容只有自己的解密办法才能破译，那么在传输信息前需要双方交换自己的加方法（公钥）。</p>
<p>然而在第一次交换加密方法的纸条传递时，中间负责传递的同学把交换双方的公钥都换成了自己伪造的公钥，那么就可以轻松使用自己的私钥读取她们的通信内容，这就是中间人攻击。</p>
<p>CA 是第三方组织，用来验证证书合法性，即在上述案例中，纸条由互相信任的班主任传递。</p>
<h2 id="五-创建证书"><a class="header" href="#五-创建证书">五 创建证书</a></h2>
<p>制作公钥与私钥：</p>
<pre><code class="language-txt"># 生成服务端私钥
openssl genrsa -out server.key 1024

# 生成服务端公钥
openssl rsa -in server.key -pubout -out server.pem

# 生成客户端私钥
openssl genrsa -out client.key 1024

# 生成客户端公钥
openssl rsa -in client.key -pubout -out client.pem
</code></pre>
<p>公钥和私钥仍然不能完全预防破解、窃听的可能，典型的例子是中间人攻击。客户端和服务端在交换公钥的过程中，中间人对客户端扮演服务端角色，对服务端扮演客户端角色，客户端和服务端就不再感受到有中间人的存在。为了解决这个问题，数据传输还需要对得到的公钥进行认证，以确认得到的公钥是出自目标服务器！这便是数字认证，一般使用第三方数字证书颁发机构 CA 制作的证书，这个证书中具有 CA 通过自己的刚要和私钥实现的签名。</p>
<p>为了得到签名证书，服务端需要通过自己的私钥生成 CSR 证书签名请求文件，CA 机构通过该文件办法属于该服务端的签名证书，只要通过 CA 机构就能验证证书是否合法。</p>
<p>通过 CA 机构办法证书相当复杂耗时，中小企业一般采用自签名来构建安全网络，就是自己扮演 CA 机构，给自己的服务端办法签名证书，下面步骤即是制作扮演 CA 角色需要的文件：</p>
<pre><code class="language-txt">openssl genrsa -out ca.key 1024
openssl req -new -key ca.key -out ca.csr
openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt
</code></pre>
<p>服务端此时需要向 CA 机构申请签名证书，在申请前要创建自己的 CSR 文件（Common Name 要匹配服务器域名）：</p>
<pre><code class="language-txt">openssl req -new -key server.key -out server.csr
</code></pre>
<p>得到 CSR 文件后，向自己的 CA 机构申请签名：</p>
<pre><code class="language-txt">openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt
</code></pre>
<p>客户端在发起安全连接前先回去获取服务端的证书，通过 CA 的证书验证服务端证书、服务器名称、服务器 IP 的真伪。</p>
<p>CA 机构将证书颁发给服务端后，证书在请求过程中会被发送给客户端，客户端需要通过 CA 的证书验证真伪，如果是知名的 CA 机构，它们的证书一般会预装在浏览器中，如果是自己扮演的 CA 机构，颁发自有签名则没有该福利！！</p>
<p>注意：签名证书是一环一环的颁发的，但是在 CA 那里的证书是不需要上级证书参与签名的，这个证书通常称为根证书。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="122-node-与加密-加密通信"><a class="header" href="#122-node-与加密-加密通信">12.2-Node 与加密-加密通信</a></h1>
<h2 id="一-node-中的-tcp-使用-tls-服务"><a class="header" href="#一-node-中的-tcp-使用-tls-服务">一 Node 中的 TCP 使用 TLS 服务</a></h2>
<h3 id="11-服务端"><a class="header" href="#11-服务端">1.1 服务端</a></h3>
<p>Node 的 tls 模块可以创建一个安全的 TCP 服务：</p>
<pre><code class="language-js">const tls = require('tls')
const fs = require('fs')

let options = {
  key: fs.readFileSync('./keys/server.key'),
  cert: fs.readFileSync('./keys/server.crt'),
  requestCert: true,
  ca: [fs.readFileSync('./keys/ca.crt')],
}

const server = tls.createServer(options, function (stream) {
  console.log(
    'server connected',
    stream.authorized ? 'authorized' : 'unauthorized'
  )
  stream.write('welcome!\n')
  stream.setEncoding('utf8')
  stream.pipe(stream)
})

server.listen(8000, function () {
  console.log('server bound')
})
</code></pre>
<p>启动后测试证书：</p>
<pre><code class="language-txt">openssl s_client -connect 127.0.0.1:8000
</code></pre>
<h3 id="12-客户端"><a class="header" href="#12-客户端">1.2 客户端</a></h3>
<p>在构建客户端之前，需要为客户端生成属于自己的私钥和签名：</p>
<pre><code class="language-txt"># 创建私钥
openssl genrsa -out client.key 1024

# 生成 CSR
openssl req -new -key client.key -out client.csr

# 生成签名证书
openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt
</code></pre>
<p>构建客户端：</p>
<pre><code class="language-js">const tls = require('tls')
const fs = require('fs')

let options = {
  key: fs.readFileSync('./keys/client.key'),
  cert: fs.readFileSync('./keys/client.crt'),
  ca: [fs.readFileSync('./keys/ca.crt')],
}

let stream = tls.connect(8000, options, function () {
  console.log(
    'client connected',
    stream.authorized ? 'authorized' : 'unauthorized'
  )
  process.stdin.pipe(stream)
})

stream.setEncoding('utf8')

stream.on('data', function (data) {
  console.log(data)
})

stream.on('end', function () {
  server.close()
})
</code></pre>
<h2 id="二-node-中使用-https-服务"><a class="header" href="#二-node-中使用-https-服务">二 Node 中使用 HTTPS 服务</a></h2>
<h3 id="21-服务端"><a class="header" href="#21-服务端">2.1 服务端</a></h3>
<p>HTTPS 服务器代码：</p>
<pre><code class="language-js">const https = require('https')
const fs = require('fs')

let options = {
  key: fs.readFileSync('./keys/server.key'),
  cert: fs.readFileSync('./keys/server.crt'),
}

https
  .createServer(options, function (req, res) {
    res.writeHead(200)
    res.end('hello world\n')
  })
  .listen(8000)
</code></pre>
<p>启动后通过 curl 进行测试：</p>
<pre><code class="language-txt">curl https://localhost:8000/
</code></pre>
<p>此时会爆出错误警告，因为 curl 工具无法验证服务端证书是否正确，解决方案：</p>
<ul>
<li>加 -k 选项，忽略证书验证，这样仍然通过公钥加密传输，但是无法保证对方是否可靠，存在中间人攻击风险</li>
<li>使用：<code>curl --cacert keys/ca.crt https://localhost:8000/</code></li>
</ul>
<h3 id="22-客户端"><a class="header" href="#22-客户端">2.2 客户端</a></h3>
<pre><code class="language-js">const https = require('https')
const fs = require('fs')

let options = {
  hostname: 'localhost',
  port: 8000,
  path: '/',
  method: 'GET',
  key: fs.readFileSync('./keys/client.key'),
  cert: fs.readFileSync('./keys/client.crt'),
  ca: [fs.readFileSync('./keys/ca.crt')],
}

options.agent = new https.Agent(options)

let req = https.request(options, function (res) {
  res.setEncoding('utf-8')
  res.on('data', function (d) {
    console.log(d)
  })
})

req.end()

req.on('error', function (e) {
  console.log(e)
})
</code></pre>
<p>如果不设置 ca 选项，则会得到异常：<code>Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE</code>。解决方案是添加选项属性：rejectUnauthorized 为 false，其效果与 curl 工具添加 -k 一致。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-并发的概念"><a class="header" href="#011-并发的概念">01.1-并发的概念</a></h1>
<h2 id="一-并发编程历史"><a class="header" href="#一-并发编程历史">一 并发编程历史</a></h2>
<p>在早期的操作系统中，各个任务的执行完全是串行的，只有在一个任务运行完成之后，另一个任务才会被执行，我们称之为<code>单道程序</code>。</p>
<p>而现代操作系统引入了<code>多道程序</code>的并发概念：</p>
<blockquote>
<p>多道程序：当一个程序暂时不需要使用 CPU 的时候，系统会把该程序挂起或中断，此时其他程序可以使用 CPU，多个任务在操作系统的控制中实现了宏观上的并发。<br />
多道程序提升了计算机资源的利用率，但是也引起了多个任务对系统资源的抢夺，在开发上极为不便。</p>
</blockquote>
<h2 id="二-计算机术语"><a class="header" href="#二-计算机术语">二 计算机术语</a></h2>
<h3 id="21-串行与并发"><a class="header" href="#21-串行与并发">2.1 串行与并发</a></h3>
<p>串行与并发是同一个维度的概念，区别是：</p>
<ul>
<li>串行：指令按照顺序执行</li>
<li>并发：指令并未按照顺序执行，而是在宏观上同时执行，即 CPU 不停的在各个任务之间来回切换，给人感觉所有任务同时执行了！比如电脑同时运行了 QQ、浏览器，其实是 CPU 在这 2 个程序之间按照一定的调度算法在来回切换执行！</li>
</ul>
<p>并行与并发并不是同一个维度上的概念：</p>
<ul>
<li>并行（parallel）：在同一时刻（微秒级），多条指令在多个处理器上同时执行，并行一般要借助多核 CPU 实现！</li>
<li>并发（concurrency）：并未同时执行，只是由于 CPU 运行过快，给人产生同时运行的假象</li>
</ul>
<p>并发与并行概念的区别是是否同时执行，比如吃饭时，电话来了，需要停止吃饭去接电话，接完电话继续吃饭，这是并发执行，但是吃饭时电话来了，边吃边接是并行。</p>
<h3 id="22-进程"><a class="header" href="#22-进程">2.2 进程</a></h3>
<blockquote>
<p>进程：就是二进制可执行文件在计算机内存中的运行实例，可以简单理解为：一个.exe 文件是个类，进程就是该类 new 出来的实例。
进程是操作系统资源分配的最小单位（如虚拟内存资源），所有代码都是在进程中执行的。</p>
</blockquote>
<p>在 Unix 系统中，操作系统启动后将会运行进程号（PID）为 1 的一个进程 init 进程，该进程是所有其他进程的父进程。操作系统通过 fork() 函数能够创建多个子进程，从而能够提升计算机资源的利用率。</p>
<p>进程在创建后会拥有自己的独立地址空间，操作系统会提供一个数据结构 PCB 来描述该进程（Process Control Block，进程控制块），PCB 中保存了进程的管理、控制信息等数据。</p>
<p>由于进程拥有互相独立的地址空间，所以进程之间无法直接通信，必须利用进程间通信 (IPC,InterProcess Communication) 方式来实现通信。</p>
<h3 id="23-内核态与用户态"><a class="header" href="#23-内核态与用户态">2.3 内核态与用户态</a></h3>
<p>操作系统的内存会被划分为两大区域：</p>
<ul>
<li>内核区：提供了大量的系统调用函数，即最原生、最底层的操作函数，如 open()，write()</li>
<li>用户区：加载、运行应用程序的区域，比如使用 C 语言写的程序，同样的 C 语言也提供了本语言的对应操作函数 fopen()，fwrite()。这些由编程语言提供的函数称之为库函数。</li>
</ul>
<p>我们不难发现，库函数其实是在系统调用函数基础上再次进行了封装，方便开发者使用。当然开发者既可以使用库函数来操作文件，也可以直接使用底层的系统调用函数（但是这样需要做很多错误处理）。</p>
<p>程序在运行时，CPU 有两种状态：</p>
<ul>
<li>用户态：当一个进程在执行用户自己的代码时处于用户运行态（用户态）</li>
<li>内核态：当进程需要执行一些系统调用时，比如利用 C 的库函数 fopen() 时，fopen() 虽然是库函数，但是执行时底层调用了系统的 open() 函数，此时程序进入内核态，调用结束后，程序会重新回到用户态！</li>
</ul>
<p>操作系统之所以要这样设计是出于内存的安全考虑，内核地址只有内核自己的函数（系统调用函数）才能使用！</p>
<h3 id="24-线程"><a class="header" href="#24-线程">2.4 线程</a></h3>
<blockquote>
<p>线程：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位（即 cpu 分配时间轮片的对象）</p>
</blockquote>
<p>一个进程内部可以创建多个线程，他们与进程一样拥有独立的 PCB，但是没有独立的地址空间，即线程之间共享了地址空间。这样也让线程之间无需 IPC，直接就能通信！！（因为他们在同一个地址空间内）。</p>
<p>虽然线程带来了通信的便利，但是如果同一空间的中多个线程同时去修改同一个数据，就会造成资源竞争问题，这是计算机编程中最复杂的问题！</p>
<h3 id="25-协程"><a class="header" href="#25-协程">2.5 协程</a></h3>
<p>进程和线程都是操作系统级别的，协程与他们并不是一个维度的概念，所以类似《现代操作系统》的书籍并未提出协程的概念。</p>
<p>贴士：千万不要将协程理解为轻量级线程！</p>
<blockquote>
<p>协程：程序在执行时，函数内部可以中断，适当时候返回接着执行，即协程运行在用户态</p>
</blockquote>
<p>协程的优势在于其轻量级、执行效率高：</p>
<ul>
<li>轻量级：没有线程开销，可以轻松创建上百万个协程而不会造成系统资源衰竭</li>
<li>执行效率高：函数之间的切换不再是线程切换，由程序自身控制</li>
</ul>
<p>线程需要上下文不停切换，而协程不会主动交出使用权，除非代码中主动要求切换，或者发生 I/O，此时会切换到别的协程，这样能更好的解决并发问题。</p>
<h2 id="三-并发理论基础"><a class="header" href="#三-并发理论基础">三 并发理论基础</a></h2>
<h3 id="31-并发解决方案"><a class="header" href="#31-并发解决方案">3.1 并发解决方案</a></h3>
<ul>
<li>多进程：由系统内核管理并发，操作简单、进程互不影响。但是开销最大，占用资源较多，能开启的进程数极少，</li>
<li>多线程：多线程在大部分系统上仍然属于系统层面的并发，开销较大，且会存在死锁管理问题。</li>
<li>非阻塞 I/O:基于回调的异步非阻塞 I/O，尽可能少的运用线程</li>
<li>协程：本质上仍然是用户态线程，但不需要系统进行抢占式调度，且真正的实现寄存于线程中，开销极小。</li>
</ul>
<h3 id="32-并发程序数据交互方式一同步"><a class="header" href="#32-并发程序数据交互方式一同步">3.2 并发程序数据交互方式一：同步</a></h3>
<blockquote>
<p>线程同步：线程在发出某一个功能调用时，如果没有得到结果，则该调用不返回。此时其他线程不能调用该功能（因为要保证数据一致性）。</p>
</blockquote>
<p>线程同步是为了避免引起数据混乱。实际上，多个控制流共同操作一个共享资源，都需要同步，比如：进程、线程、信号之间都需要同步机制，常见的线程同步技术就是互斥锁。</p>
<p>同步的作用是避免在并发访问共享资源时可能发生的冲突。</p>
<p>同步的理念：</p>
<ul>
<li>程序如果想使用一个共享数据，就必须先获取对它的使用权，当程序不再使用该资源时，则应放弃对该资源的访问权 (即：释放资源)。</li>
<li>资源的使用权被拿走后，其他访问该资源的程序不应该被中断，而是应该等到拥有使用权的程序释放资源之后再进行访问。<br />
即：在同一时刻，某个资源应该只被一个程序占用。</li>
</ul>
<h3 id="33-并发程序数据交互方式二数据传递"><a class="header" href="#33-并发程序数据交互方式二数据传递">3.3 并发程序数据交互方式二：数据传递</a></h3>
<p>除了使用同步方式来实现并发程序数据的交互之外，还可以使用数据传递方式（也称为通信）。</p>
<p>该方式可以使数据不加延迟的发送给数据接收方。即使数据接收方还没有为接收数据做好准备，也不会造成数据发送方的等待。数据会被临时存储在一个称谓通信缓存的数据结构中。通信缓存是一种特殊的数据结构，可以同时被多个程序使用，数据接收方可以在准备就绪之后按照数据存入通信缓存的顺序接收它们。</p>
<h2 id="四-各个语言的并发理念"><a class="header" href="#四-各个语言的并发理念">四 各个语言的并发理念</a></h2>
<ul>
<li>Java：典型的多线程并发模式，利用同步机制（加锁）来实现并发访问控制</li>
<li>Node.js：典型的单线程非阻塞 I/O 实践者，不存在 Java 的资源竞争问题，I/O 操作处理完毕后才会利用事件机制通知业务线程返回结果，没有资源竞争的难题。</li>
<li>Go：典型的协程并发理念实践者，在语言本身层面实现了协程，协程之间通过<strong>管道</strong>进行<strong>数据传递</strong></li>
</ul>
<p>目前流行的并发理念是：异步非阻塞 I/O，协程。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-并发模型-多进程"><a class="header" href="#021-并发模型-多进程">02.1-并发模型-多进程</a></h1>
<h2 id="一-进程概念"><a class="header" href="#一-进程概念">一 进程概念</a></h2>
<blockquote>
<p>进程：就是二进制可执行文件在计算机内存中的运行实例，可以简单理解为：一个.exe 文件是个类，进程就是该类 new 出来的实例。
进程是操作系统最小的资源分配单位（如虚拟内存资源），所有代码都是在进程中执行的。</p>
</blockquote>
<p>为了方便管理进程，每个进程都有自己的描述符，是个复杂的数据结构，我们称之为<strong>进程控制块</strong>，即 PCB(Process Control Block)。</p>
<p>PCB 中保存了进程的管理、控制信息等数据，主要包含字段有：</p>
<pre><code class="language-txt">进程 ID（PID）：进程的唯一标识符，是一个非负整数的顺序编号
父进程 ID（PPID）：当前进程的父进程 ID
文件描述符表：即很多指向 file 接否提的指针
进程状态：就绪、运行、挂起、停止等状态
虚拟地址范围
访问权限
当前工作目录
用户 id 和组 id
会话和进程组
</code></pre>
<p>贴士：进程 ID 是可以重用的，当进程 ID 达到最大限额值时，内核会从头开始查找闲置的进程 ID 并使用最先找到的那一个作为新进程的 ID</p>
<h2 id="二-进程创建"><a class="header" href="#二-进程创建">二 进程创建</a></h2>
<p>Unix 系统在启动后，会首先运行一个名为 init 的进程，其 PID 为 1。该进程是所有其他进程的父进程。</p>
<p>Unix 操作系统通过 <code>fork()</code> 函数能够创建多个子进程，从而能够提升计算机资源的利用率。此时调用者称为父进程，被创造出来的进程称为子进程。</p>
<ul>
<li>每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆、栈的拷贝，并与父进程共享代码段。</li>
<li>子进程对自己副本的修改对其父进程和兄弟进程都是不可见的，反之亦然。</li>
</ul>
<p>创建的子进程可以直接开始运行，但是也可以通过 <code>exec()</code> 函数来加载一个全新的程序，此时子进程会丢弃现存的程序文本段，为加载的新程序重新创建栈、数据段、堆，我们对这一个过程称为执行一个新程序。</p>
<p>贴士：exec 并不是 1 个函数，是一系列 exec 开头的函数，作用都是执行新程序。</p>
<p>C 语言示例如下：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(){

    pid_t pid;
    int r;

    // 创建子进程
    pid = fork();
    if (pid == -1){                   // 发生错误
        perror(&quot;fork发生错误 &quot;);
        exit(1);
    }

    // 返回值大于0时是父进程
    if(pid &gt; 0){
        printf(&quot;父进程: pid = %d, ppid = %d \n&quot;, getpid(),getppid());        // 父进程执行动作
        sleep(3);                       // 父进程睡眠，防止子进程还没运行完毕，父进程却直接退出了
    }

    // 返回值为0的是子进程
    if(pid == 0){

        printf(&quot;子进程: pid = %d , ppid = %d \n&quot;, getpid(),getppid());     // 子进程执行动作

        // 子进程加载一个新程序：系统自带的 echo程序，输出 hello world!
        char * execv_str[] = {&quot;echo&quot;, &quot;hello world!&quot;,NULL};
        int r = execv(&quot;/bin/echo&quot;, execv_str);    // 笔者的是mac，linux上为： &quot;/usr/bin/echo&quot;
  if (r &lt;0 ){
   perror(&quot;error on exec&quot;);
   exit(0);
        }
    }
    return 0;
}
</code></pre>
<p>在 Go 语言中，没有直接提供 fork 系统调用的封装，而是将 fork 和 execve 合二为一，具体信息可以参见 Go 的 os 包。</p>
<pre><code class="language-go">package main

import (
 &quot;fmt&quot;
 &quot;os&quot;
 &quot;time&quot;
)

func main() {

 fmt.Println(&quot;当前进程 ID：&quot;, os.Getpid())

 procAttr := &amp;os.ProcAttr{
  Files: []*os.File{os.Stdin, os.Stdout, os.Stderr},
 }
 process, err := os.StartProcess(&quot;/bin/echo&quot;, []string{&quot;&quot;, &quot;hello,world!&quot;}, procAttr)
 if err != nil {
  fmt.Println(&quot;进程启动失败：&quot;, err)
  os.Exit(2)
 } else {
  fmt.Println(&quot;子进程 ID：&quot;, process.Pid)
 }

 time.Sleep(time.Second)

}
</code></pre>
<p>根据该方式，就可以很容运行计算机上的其他任何程序，包括自身的命令行、Java 程序等等。</p>
<h2 id="四-进程分类"><a class="header" href="#四-进程分类">四 进程分类</a></h2>
<p>进程分类：</p>
<ul>
<li>用户进程：位于用户空间中，是程序执行的实例</li>
<li>内核进程：位于内核空间中，可以访问硬件</li>
</ul>
<p>由于用户进程无法访问内核空间，所以无法直接操作硬件。内核会暴露一些接口提供给用户进程使用，让用户进程简介操作硬件，这便是系统调用。</p>
<p>内核为了保证系统的安全和稳定，为<strong>CPU</strong>特供了两个状态：</p>
<ul>
<li>用户态：大部分时间 CPU 处于该状态，此时只能访问用户空间</li>
<li>内核态：当用户进程发起系统调用时，内核会将 CPU 切换到内核态，然后执行相应接口函数。</li>
</ul>
<p>注意：这里的用户态和内核态是针对 CPU 的。</p>
<h2 id="五-进程调度"><a class="header" href="#五-进程调度">五 进程调度</a></h2>
<p>同一时刻只能运行一个进程，但是 CPU 可以在多个进程间进行来回切换，我们称之为上下文切换。</p>
<p>操作系统会按照调度算法为每个进程分配一定的 CPU 运行时间，称之为时间轮片，每个进程在运行时都会认为自己独占了 CPU，如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-01.svg" alt="进程调度" /></p>
<p>切换进程是有代价的，因为必须保存进程的运行时状态。</p>
<h2 id="六-进程状态转换"><a class="header" href="#六-进程状态转换">六 进程状态转换</a></h2>
<p>进程在创建后，在执行过程中，其状态一直在变化。不同时代的操作系统有不同的进程模型：</p>
<ul>
<li>三态模型：运行态、就绪态、等待态</li>
<li>五态模型：初始态、就绪态、运行态、挂起态（阻塞）、终止态</li>
</ul>
<p>本笔记介绍五态模型。初始态是进程的准备节点，常与就绪状态结合来看，进程的状态转换图：<br />
<img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-02.svg" alt="进程状态转换" /></p>
<h2 id="七-进程运行的问题"><a class="header" href="#七-进程运行的问题">七 进程运行的问题</a></h2>
<h3 id="71-写时复制"><a class="header" href="#71-写时复制">7.1 写时复制</a></h3>
<p>父进程无法预测子进程什么时候结束，只有进程完成工作后，父进程才会调用子进程的终止态。</p>
<p>贴士：全盘复制父进程的数据相当低效，Linux 使用写时复制（COW：Copy on Write）技术来提高进程的创建效率。</p>
<h3 id="72-进程回收"><a class="header" href="#72-进程回收">7.2 进程回收</a></h3>
<p>当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的 PCB 资源，必须由它的父进程调用 wait 或者 waitpid 函数完成对子进程的回收，避免造成系统资源的浪费。</p>
<blockquote>
<p>孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，此时该进程会被系统的 init 进程领养
僵尸进程：子进程终止，但父进程未回收，子进程残留资源（PCB）于内核中，变成僵尸进程。</p>
</blockquote>
<p>注意：由于僵尸进程是一个已经死亡的进程，所以不能使用 kill 命令将其杀死，通过杀死其父进程的方法可以消除僵尸进程，杀死其父进程后，这个僵尸进程会被 init 进程领养，由 init 进程完成对僵尸进程的回收。</p>
<h2 id="八-进程间通信"><a class="header" href="#八-进程间通信">八 进程间通信</a></h2>
<h3 id="80-进程间通信方式概述"><a class="header" href="#80-进程间通信方式概述">8.0 进程间通信方式概述</a></h3>
<p>Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-09.png" alt="进程通信" /></p>
<p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p>
<ul>
<li>管道 (使用最简单)</li>
<li>共享映射区 (无血缘关系进程通信)</li>
<li>信号 (开销最小)</li>
<li>本地套接字 (最稳定)</li>
</ul>
<p>Go 支持的 IPC 方法有：管道、信号、socket。</p>
<h3 id="81-管道"><a class="header" href="#81-管道">8.1 管道</a></h3>
<p>管道是一种最基本的 IPC 机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用 C 的 pipe 函数即可创建一个管道。</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-10.png" alt="管道" /></p>
<p>管道有如下特质：</p>
<ul>
<li>管道的本质是一块内核缓冲区</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端。</li>
<li>规定数据从管道的写端流入管道，从读端流出。</li>
<li>当两个进程都终结的时候，管道也自动消失。</li>
<li>管道的读端和写端默认都是阻塞的。</li>
</ul>
<p>管道的实质是内核缓冲区，内部使用唤醒队列实现。</p>
<p>管道的缺陷：</p>
<ul>
<li>管道中的数据一旦被读走，便不在管道中存在，不可反复读取。</li>
<li>数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道</li>
<li>只能在有血缘关系的进程间使用管道。</li>
</ul>
<p>Go 模拟管道的实现：</p>
<pre><code class="language-go"> cmd1 := exec.Command(&quot;ps&quot;, &quot;aux&quot;)
 cmd2 := exec.Command(&quot;grep&quot;, &quot;apipe&quot;)

 var outputBuf1 bytes.Buffer
 cmd1.Stdout = &amp;outputBuf1
 cmd1.Start()
 cmd1.Wait()    // 开始阻塞

 var outputBuf2 bytes.Buffer
 cmd2.Stdout = &amp;outputBuf2
 cmd2.Start()
 cmd2.Wait()    // 开始阻塞

 fmt.Println(outputBuf2.Bytes())
</code></pre>
<p>当然也有一种管道称为命名管道（FIFO），它支持无血缘关系的进程之间通信。FIFO 是 Linux 基础文件类型中的一种（文件类型为 p，可通过 ls -l 查看文件类型）。但 FIFO 文件在磁盘上没有数据块，文件大小为 0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行 read/write，实际上是在读写内核缓冲区，这样就实现了进程间通信，如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-11.png" alt="FIFO" /></p>
<h3 id="82-内存映射区"><a class="header" href="#82-内存映射区">8.2 内存映射区</a></h3>
<p>存储映射 I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用 read 和 write 函数的情况下，使用地址（指针）完成 I/O 操作。</p>
<p>使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过 mmap 函数来实现。</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-12.png" alt="内存映射区" /></p>
<h3 id="83-信号"><a class="header" href="#83-信号">8.3 信号</a></h3>
<p>信号是 IPC 中唯一一种异步的通信方法，本质是用软件模拟硬件的中断机制，例如：在命令行终端按下某些快捷键，就会挂起或停止正在运行的程序。Go 中的 ginal 包提供了相关操作。</p>
<pre><code class="language-go"> sigRecv := make(chan os.Signal, 1)                      // 创建接收通道
 sigs := []os.Signal{syscall.SIGINT, syscall.SIGQUIT}    // 创建信号类型
 signal.Notify(sigRecv, sigs...)
 for sig := range sigRecv {                              // 循环接收通道中的信号，通道关闭后，for 会立即停止
  fmt.Println(sig)
 }
</code></pre>
<h3 id="84-socket"><a class="header" href="#84-socket">8.4 socket</a></h3>
<p>socket 即套接字，也是一种 IPC 方法，与其他 IPC 方法不同之处在于：可以通过网络连接让多个进程建立通信并相互传递数据，这使得通信不再依赖于在同一台计算机上。</p>
<h2 id="九-进程同步"><a class="header" href="#九-进程同步">九 进程同步</a></h2>
<p>当多个子进程对同一资源进行访问时，就会产生竞态条件。比如：某一个数据，进程 A 对其进行执行<code>一系列</code>操作，但是在执行过程中，系统有可能会切换到另外一个进程 B 中，B 也对该数据进行<code>一系列</code>操作，那么在两个进程中操作同一份数据时，这个数据的结果值到底按照谁的来运算呢？</p>
<p>原子操作：如果执行过程中操作不能中断，那么就能解决上述问题，这样的操作称为原子操作（atomic operation）。这些只能被串行化访问或执行的资源或者某段代码被称为临界区（critical section）。Go 中 (sync/atomic 包提供了原子操作函数)。</p>
<p>注意：</p>
<ul>
<li>所有的系统调用都是原子操作，即不用担心它们的执行被中断！</li>
<li>原子操作不能被中断，临界区是否可以被中断没有强制规定，只是保证了只能同时被一个访问者访问。</li>
</ul>
<p>问题：如果一个原子操作无法结束，现在也无法中断，如何处理？</p>
<blockquote>
<p>答案：内核只提供了针对二进制位和整数的原子操作（即保证细粒度），不会有上述现象。</p>
</blockquote>
<p>互斥锁：<br />
在实际开发中，原子操作并不通用，我们可以保证只有一个进程/线程在临界区，该做法称为互斥锁（exclusion principle），比如信号量是实现互斥方法的方式之一，Golang 的 sync 包也有对互斥的支持。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="022-并发模型-多线程"><a class="header" href="#022-并发模型-多线程">02.2-并发模型-多线程</a></h1>
<h2 id="一-线程概述"><a class="header" href="#一-线程概述">一 线程概述</a></h2>
<h3 id="11-进程与线程创建"><a class="header" href="#11-进程与线程创建">1.1 进程与线程创建</a></h3>
<p>操作系统会为每个进程分配一定的内存地址空间，如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-03.svg" alt="内存地址空间" /></p>
<p>上图所示的是 32 位系统中虚拟内存的分配方式，不同系统分配的虚拟内存是不同的，但是其数据所占区域的比例是相同的：</p>
<ul>
<li>32 位：最大内存地址为 $2^3$$^2$，这么多的字节数换算为 G 单位，即为 4G。（换算为 1G=1024MB=1024<em>1024KB=1024</em>1024*1024B）</li>
<li>64 位：最大内存地址为 $2^6$$^4$，这么多的字节数换算为 G 单位，数值过大，不便图示</li>
</ul>
<p>在多进程编程的并发模型中，每次 fork 一个子进程，都代表新创建了一个完整的上述内存地址空间，如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-03-1.svg" alt="内存地址空间" /></p>
<p>线程就与进程不同了，一个进程内部可以创建多个线程，如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-03-2.svg" alt="创建多个线" /></p>
<h3 id="12-理解线程"><a class="header" href="#12-理解线程">1.2 理解线程</a></h3>
<p>从创建线程的图示可以看出：线程可以视为某个进程内部的控制流。</p>
<blockquote>
<p>线程：操作系统基于进程开启的轻量级进程，
线程是操作系统最小的调度执行单位（即 cpu 分配时间轮片的对象）</p>
</blockquote>
<p>线程不能独立于进程而存在，其生命周期不可能逾越其所属的进程生命周期，与进程不同，线程不存在父子级别关系，同一进程中的任意 2 个线程之间的关系是平等的。<br />
一个进程内部的线程包括：</p>
<ul>
<li>主线程：必定拥有，因为进程必须有一个控制流持续运行，该线程随着进程的启动而创建</li>
<li>其他线程：不一定拥有，由主线程或者其他线程创建（C 语言调用 pthread_create 函数）</li>
</ul>
<p>综上我们可以得出：</p>
<blockquote>
<p>线程与进程一样拥有独立的 PCB，但是没有独立的地址空间，即线程之间共享了地址空间。这样也让线程之间无需 IPC，直接就能通信！！</p>
</blockquote>
<p>进程的大多数资源会被其内部的线程所共享，如：代码段、数据段、堆、信号处理函数、当前进程持有的文件描述符等。所以，同一进程中的多个线程运行的一定是同一个程序，只不过具体的控制流和执行的函数可能不同。也正因如此，同一进程内的多线程共享数据变得很轻松，创建新线程也无需再复制资源了。</p>
<p>虽然线程带来了通信的便利，如果同一空间的中多个线程同时去使用同一个数据，就会造成资源竞争问题，这是计算机编程中最复杂的问题之一。</p>
<h3 id="13-线程标识"><a class="header" href="#13-线程标识">1.3 线程标识</a></h3>
<p>每个线程也有属于自己的 ID，称为 TID，只在其所属的进程范围内唯一。</p>
<p>注意：Linux 中的线程 ID 在系统范围内也是唯一的，且线程不存在后，该 ID 可被其他线程复用。</p>
<h3 id="14-线程调度"><a class="header" href="#14-线程调度">1.4 线程调度</a></h3>
<p>线程之间不存在类似进程的树形关系，任何线程都可以对同一进程的其他线程进行有限的管理。</p>
<p>调度器会把事件划分为极小的时间片，并把这些时间片分配给不同的线程，以使众多线程都有机会在 CPU 上运行，也造成了我们多线程被并行运行的幻觉。</p>
<h3 id="15-线程的应用"><a class="header" href="#15-线程的应用">1.5 线程的应用</a></h3>
<p>对于多线程并发模型的 web 服务器，如果需要同时处理多个请求，当请求到达时，web 服务器会创建一个线程，或者从线程池中获取一个线程，然后将请求来委派给线程来实现并发。</p>
<h2 id="二-线程同步"><a class="header" href="#二-线程同步">二 线程同步</a></h2>
<h3 id="20-同步的概念"><a class="header" href="#20-同步的概念">2.0 同步的概念</a></h3>
<p>由于多进程、多线程、协程等都可以抢占共享资源，我们就必须保证他们访问时数据的一致性，这种保持数据内容一致的机制称为<strong>同步</strong>。</p>
<p>多个控制流操作一个共享资源的情况，都需要同步！！</p>
<p>一般情况下，只要让共享区域的操作串行化，就可以实现同步，这种实现了串行化的共享区域称为<strong>临界区</strong>。</p>
<p>这里主要研究线程同步的方式，包括：</p>
<ul>
<li>互斥量</li>
<li>条件变量</li>
<li>原子操作</li>
</ul>
<h3 id="21-互斥量"><a class="header" href="#21-互斥量">2.1 互斥量</a></h3>
<blockquote>
<p>互斥（mutex）：在同一时刻，只允许一个线程处于临界区内。</p>
</blockquote>
<p>线程将对象锁定后，才能进入临界区，否则线程就会阻塞，这个对象我们称之为互斥对象或者互斥量。</p>
<p>由此可知，互斥量有已锁定、未锁定两种状态，且一旦被锁，则不能再次锁定，只有解锁后才能再次锁定（即不允许别的线程二次加锁）。多个线程为了能够访问临界区，将会争夺锁的所有权。</p>
<p>线程在离开临界区的时候，必须对互斥量进行解锁，此时其他想进入该临界区的线程将会被唤醒再次争夺锁。</p>
<p>如果不同的临界区中包含了对同一个共享资源的同一种操作，此时会产生死锁。</p>
<p>解决死锁的办法有两种：</p>
<ul>
<li>试锁定 - 回退：操作系统的线程库中提供了该功能。在执行一个代码块时，如果需要先后锁定多个互斥量，成功锁定其中一个互斥量后应该使用试锁定的方法来锁定后续互斥量，如果后续任一互斥量锁定失败，则解锁刚才被锁的互斥量，重新进行争夺锁尝试。</li>
<li>注意：多个互斥量被成功加锁后，解锁顺序和加锁顺序相反，这样可以减少回退次数。</li>
<li>固定顺序锁定：举例，线程 A 和线程 B 总是先锁定互斥量 1，再锁定互斥量 2，那么就不会产生死锁。</li>
</ul>
<p>第一种方案更加有效，但是程序变得复杂了，后一种方法简单实用，但是因为存在固定顺序，降低了程序的灵活性。</p>
<h3 id="22-条件变量"><a class="header" href="#22-条件变量">2.2 条件变量</a></h3>
<p>互斥量有时候也不能完美解决问题，比如最常见的生产消费模型中：</p>
<pre><code class="language-txt">数据队列：具备一定大小的空间，用于存储生产的数据
生产者线程：向数据队列不断的添加数据
消费者线程：向数据队列不断的取出数据
</code></pre>
<p>由于生产者线程和消费者线程都会对数据队列进行并发访问，那么我们肯定会为数据队列进行加锁操作，以实现同步。</p>
<p>此时如果生产者线程获得互斥量，发现数据队列已满，无法添加新数据，生产者线程就可能在临界区一直等待，直到有空闲区间。这种做法明显是错误的，因为该线程一直阻塞在临界区，直接影响了其他消费者线程的使用！生产者线程应该在发现没有空闲区间时直接解锁退出。</p>
<p>同样的，消费者线程在获取锁后，如果发现数据队列为空，则也会一直等待，这都是不合理的，应该发现为空后直接解锁。</p>
<p>引入条件变量，与互斥量配合使用，可以解决上述问题。</p>
<blockquote>
<p>条件变量：条件变量一般与互斥量组合使用，在对应的共享数据状态发生变化时，通知其他被阻塞线程。</p>
</blockquote>
<p>条件变量有三种操作：</p>
<ul>
<li>等待通知（wait）：如果当前数据状态不满足条件，则解锁与该条件变量绑定在一起的互斥量，然后阻塞当前线程，直到收到该条件变量发来的通知</li>
<li>单发通知（signal）：让条件变量向至少一个正在等待它通知的线程发送通知，以表示共享数据状态发生了改变</li>
<li>广播通知（broadcast）：给等待通知的所有线程发送通知</li>
</ul>
<h3 id="23-原子操作"><a class="header" href="#23-原子操作">2.3 原子操作</a></h3>
<p>原子操作的执行过程不能被中断，因为此时 CPU 不会去执行其他对该值进行的操作，这也能有效的解决一部分竞争问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="023-并发模型-非阻塞-io"><a class="header" href="#023-并发模型-非阻塞-io">02.3-并发模型-非阻塞 IO</a></h1>
<h2 id="一-unix-内核中的-io-模型"><a class="header" href="#一-unix-内核中的-io-模型">一 Unix 内核中的 I/O 模型</a></h2>
<h3 id="10-io-模型概述"><a class="header" href="#10-io-模型概述">1.0 I/O 模型概述</a></h3>
<p>在操作系统中，内核对于 I/O 只有<strong>两</strong>种操作方式：</p>
<ul>
<li><strong>阻塞调用</strong>：在调用阻塞 I/O 时，应用程序需要等待 I/O 完成后才返回结果</li>
<li><strong>非阻塞调用</strong>：在调用非阻塞 I/O 时，应用程序无需等待 I/O 完成，可以立即返回，可以明显提升性能。</li>
</ul>
<p>非阻塞 I/O 立即返回后，CPU 的时间片就用可以用来处理其他事务，性能提升明显，但是也带来了新的问题：立即返回的结果并不是业务期望的数据。为了获得完整的数据，应用程序需要不断的通过重复调用 I/O 操作来确认是否完成（轮询），最终拿到期望数据。</p>
<p>所以阻塞调用和非阻塞调用多有其不完美的地方，前者浪费了 CPU 资源，后者的轮询也造成了 CPU 的损耗。</p>
<p><strong>千万注意</strong>：异步 I/O 与非阻塞 I/O 并不是完全相等的概念。</p>
<h3 id="11-阻塞-io"><a class="header" href="#11-阻塞-io">1.1 阻塞 I/O</a></h3>
<p>阻塞 I/O 是最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象，其特点是调用之后一定要等到系统内核层面完成所有操作，调用才结束。</p>
<p>当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。</p>
<p>典型的阻塞 IO 模型的例子为：</p>
<pre><code class="language-c">    data = socket.read();
</code></pre>
<p>如果数据没有就绪，就会一直阻塞在 read() 方法。</p>
<h3 id="12-非阻塞-io"><a class="header" href="#12-非阻塞-io">1.2 非阻塞 I/O</a></h3>
<p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p>
<p>所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO 不会交出 CPU，而会一直占用 CPU，典型的非阻塞 IO 模型一般如下：</p>
<pre><code class="language-c">    while(true){ 
        data = socket.read(); 
        if(data!= error){ 
            // 处理数据 
            break; 
        } 
    } 
</code></pre>
<p>但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。</p>
<h2 id="二-非阻塞-io-中轮询技术的发展"><a class="header" href="#二-非阻塞-io-中轮询技术的发展">二 非阻塞 I/O 中轮询技术的发展</a></h2>
<h3 id="21-read"><a class="header" href="#21-read">2.1 read</a></h3>
<p>read 是最原始、性能最低的轮询方式。通过重复调用检查 I/O 的状态来完成数据的完整读取，在完整读取前，CPU 一直耗用在等待上，如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/thread-04.svg" alt="read" /></p>
<h3 id="22-select-多路复用"><a class="header" href="#22-select-多路复用">2.2 select 多路复用</a></h3>
<p>select 是在 read 基础上的改进方案，通过对文件描述符上的事件状态来进行判断，即 select 采用了一个 1024 长度的数组来存储状态，如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/thread-05.svg" alt="select" /></p>
<p>贴士：由于 select 数组的限制，也导致 select 最多只能同时检查 1024 个文件描述符。</p>
<p>多路复用 IO 模型是目前使用得比较多的模型，如 Java 的 NIO。在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。</p>
<p>在 Java NIO 中，是通过 selector.select() 去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。</p>
<p>采用 多线程 + 阻塞 IO 也能达到类似的效果，但是此时每个 socket 对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。而多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当 socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。</p>
<p>另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态是通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。</p>
<p>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<h3 id="23-poll"><a class="header" href="#23-poll">2.3 poll</a></h3>
<p>poll 是 select 技术的改进，采用链表的方式避免数组长度限制。不过 poll 也能避免不需要的检查。如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/thread-06.svg" alt="poll" /></p>
<p>poll 性能有所改善，但是在文件描述符较多时，poll 的性能仍然十分低下。</p>
<h3 id="24-epoll"><a class="header" href="#24-epoll">2.4 epoll</a></h3>
<p>epoll 是 Linux 下效率最高的 I/O 事件通知机制，在进入轮询时，如果没有检查到 I/O 事件，将会进行休眠，直到事件发生将它唤醒。epoll 真正利用了事件通知机制、执行回调方式，而不是遍历查询，所以不会浪费 CPU，执行效率很高。如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/thread-07.svg" alt="epoll" /></p>
<h3 id="25-kqueue"><a class="header" href="#25-kqueue">2.5 kqueue</a></h3>
<p>kequeue 与 epoll 原理差不多，但是是 FreeBSD 系统上的实现。</p>
<h3 id="26-总结"><a class="header" href="#26-总结">2.6 总结</a></h3>
<p>轮询技术满足了非阻塞 I/O 确保数据完整的需求，但是对于应用程序而言，仍然是一种同步，因为应用程序仍然在浪费时间等待 I/O 完全返回。在这等待期间，CPU 要么用于遍历文件描述符的状态，要么用于休眠等待时间发生，这都是不够友好的做法。</p>
<h2 id="三-异步-io"><a class="header" href="#三-异步-io">三 异步 I/O</a></h2>
<h3 id="30-异步-io-概念"><a class="header" href="#30-异步-io-概念">3.0 异步 I/O 概念</a></h3>
<p>异步 IO 模型是最理想的 IO 模型：当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，接着将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。在此过程中用户线程完全不需要知道实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。</p>
<p>在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 iO 函数进行实际的读写操作。</p>
<p>异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。也只有异步 IO 才真正的异步 IO，其他的 IO 模型都是同步 IO，因为无论是多路复用 IO 还是信号驱动模型，IO 操作的第 2 个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p>
<h3 id="31-理想状态下"><a class="header" href="#31-理想状态下">3.1 理想状态下</a></h3>
<p>epoll 有效减少了轮询操作的消耗，但是休眠期间 CPU 几乎是闲置的，对当前线程来说，利用率明显不够。</p>
<p>理想状态下，异步 I/O 应该是：应用程序发起非阻塞调用，无需事件唤醒，直接就可以处理下一个任务。当 I/O 完成后，通过信号、回调函数将数据传递给应用程序即可。</p>
<p>如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/thread-08.svg" alt="异步 IO" /></p>
<p>该理想方式在 Linux 中已经实现，即 AIO，通过信号、回调传递回来数据，但是该方式仍然有缺陷：AIO 仅支持内核 I/O 中的 O_DIRECT 方式读取，无法利用系统缓存。</p>
<h3 id="32-实际场景中的异步-io"><a class="header" href="#32-实际场景中的异步-io">3.2 实际场景中的异步 I/O</a></h3>
<p>可以通过线程池的方式来模拟，让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 的带的数据进行传递，这样就可以模拟出异步 I/O。</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/thread-09.svg" alt="实际 IO" /></p>
<p>现有的实现：</p>
<ul>
<li>glibc 的 AIO：使用典型线程池模拟异步 I/O</li>
<li>libeio：lubev 作者实现的异步 I/O 库，依然使用线程池与阻塞 I/O 模拟异步 I/O</li>
<li>IOCP：Windows 中的异步方案，无需轮询，I/O 完成后会进行通知，执行回调，也是使用线程池实现，但是线程池由内核管理。</li>
</ul>
<h2 id="四-杰出代表-nodejs"><a class="header" href="#四-杰出代表-nodejs">四 杰出代表 Node.js</a></h2>
<p>Node.js 是在 v8 引擎基础上开发的 javascript 运行时，为 javascript 提供了模块化、文件 IO、Socket 编程等支持。其架构如图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-15.png" alt="NodeJS" /></p>
<p>他们分别是：</p>
<ul>
<li>Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。</li>
<li>Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 node.cc</li>
<li>这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。
<ul>
<li>V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。</li>
<li>Libuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。</li>
<li>C-ares：提供了异步处理 DNS 相关的能力。</li>
<li>http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。</li>
</ul>
</li>
</ul>
<p>一个基础的 node http web server：</p>
<pre><code class="language-js">const http = require('http')

http
  .createServer((req, res) =&gt; {
    res.writeHeader(200, { 'Content-Type': 'text/plain' })
    res.write('Hello world!')
    res.end()
  })
  .listen(9000)
</code></pre>
<p>Node.js 的 http 模型：<br />
<img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-16.png" alt="node-http" /></p>
<p>Node 中的事件驱动：Event Loop is a programming construct that waits for and dispatches events or messages in a program</p>
<ul>
<li>1、每个 Node.js 进程只有一个主线程在执行程序代码，形成一个执行栈（execution context stack)。</li>
<li>2、主线程之外，还维护了一个&quot;事件队列&quot;（Event queue）。当用户的网络请求或者其它的异步操作到来时，node 都会把它放到 Event Queue 之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。</li>
<li>3、主线程代码执行完毕完成后，然后通过 Event Loop，也就是事件循环机制，开始到 Event Queue 的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从线程池中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交 EventLoop 处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。</li>
<li>4、主线程不断重复上面的第三步。</li>
</ul>
<h2 id="五-深入理解进程阻塞"><a class="header" href="#五-深入理解进程阻塞">五 深入理解进程阻塞</a></h2>
<p>进程间的通信时通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计：</p>
<blockquote>
<p>消息的传递有可能是<strong>阻塞的</strong>或<strong>非阻塞的</strong>，也被称为<strong>同步</strong>或<strong>异步</strong>的。----《操作系统概论》</p>
</blockquote>
<ul>
<li>阻塞式发送：blocking send，发送方进程会被一直阻塞，直到消息被接受方进程收到</li>
<li>非阻塞式发送：nonblocking send），发送方进程调用 send() 后，立即就可以其他操作</li>
<li>阻塞式接收：blocking receive，接收方调用 receive() 后一直阻塞，直到消息到达可用</li>
<li>非阻塞式接受：nonblocking receive，接收方调用 receive() 函数后，要么得到一个有效的结果，要么得到一个空值，即不会被阻塞。</li>
</ul>
<p>上述不同类型的发送方式和不同类型的接收方式，可以自由组合，即从进程级通信的维度讨论时，阻塞和同步（非阻塞和异步）就是一对同义词，且需要针对发送方和接收方作区分对待。</p>
<p>概念解释：</p>
<ul>
<li>中断（interrupt）：CPU 微处理器有一个中断信号位，在每个 CPU 时钟周期的末尾，CPU 会去检测那个中断信号位是否有中断信号到达，如果有，则会根据中断优先级决定是否要暂停当前执行的指令，转而去执行处理中断的指令。 （其实就是 CPU 层级的 while 轮询）</li>
<li>时钟中断 ( Clock Interrupt )：一个硬件时钟会每隔一段（很短）的时间就产生一个中断信号发送给 CPU，CPU 在响应这个中断时，就会去执行操作系统内核的指令，继而将 CPU 的控制权转移给了操作系统内核，可以由操作系统内核决定下一个要被执行的指令。</li>
<li>系统调用（system call）：system call 是操作系统提供给应用程序的接口。用户通过调用 systemcall 来完成那些需要操作系统内核进行的操作，例如硬盘，网络接口设备的读写等。</li>
</ul>
<p>进程在从用户空间切换到内核空间，需要以下步骤：</p>
<ul>
<li>1.当一个程序正在执行的过程中，中断（interrupt）或 系统调用（system call）发生可以使得 CPU 的控制权会从当前进程转移到操作系统内核。</li>
<li>2.操作系统内核负责保存进程 i 在 CPU 中的上下文（程序计数器，寄存器）到 PCB$_i$（操作系统分配给进程的一个内存块）中</li>
<li>3.从 PCB$_j$取出进程 j 的 CPU 上下文，将 CPU 控制权转移给进程 j，开始执行进程 j 的指令。</li>
</ul>
<p>操作系统在进行进切换时，需要进行一系列的内存读写操作，这带来了一定的开销：对于一个运行着 UNIX 系统的现代 PC 来说，进程切换至少需要花费 300 us 的时间。我们所说的“阻塞”是指进程在发起了一个系统调用（System Call）后，由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为**等待（waiting）**状态，以确保它不会被调度执行，占用 CPU 资源。</p>
<p>综上所述，<strong>阻塞和非阻塞描述的是进程的一个操作是否会使得进程转变为“等待”的状态</strong>，又因为阻塞这个词是与系统调用 System Call 紧紧联系在一起的，因为要让一个进程进入 等待（waiting）的状态，要么是它主动调用 wait() 或 sleep() 等挂起自己的操作，要么是它调用 System Call，而 System Call 因为涉及到了 I/O 操作，不能立即完成，于是内核就会先将该进程置为等待状态，调度其他进程的运行，等到它所请求的 I/O 操作完成了以后，再将其状态更改回 ready。</p>
<p>操作系统内核在执行 System Call 时，CPU 需要与 IO 设备完成一系列物理通信上的交互，其实再一次会涉及到阻塞和非阻塞的问题，例如，操作系统发起了一个读硬盘的请求后，其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待 IO 设备的返回结果，也可以非阻塞式的继续其他的操作。在现代计算机中，这些物理通信操作基本都是异步完成的，即发出请求后，等待 I/O 设备的中断信号后，再来读取相应的设备缓冲区。但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用（blocking systemcall）接口，因为阻塞式的调用，使得应用级代码的编写更容易（代码的执！行顺序和编写顺序是一致的）。</p>
<p>但同样，现在的大部分操作系统也会提供非阻塞 I/O 系统调用接口（Nonblocking I/O system call）。一个非阻塞调用不会挂起调用程序，而是会立即返回一个值，表示有多少 bytes 的数据被成功读取（或写入）。</p>
<p>非阻塞 I/O 系统调用 ( nonblocking system call ) 的另一个替代品是 异步 I/O 系统调用（asychronous system call）。与非阻塞 I/O 系统调用类似，asychronous system call 也是会立即返回，不会等待 I/O 操作的完成，应用程序可以继续执行其他的操作，等到 I/O 操作完成了以后，操作系统会通知调用进程（设置一个用户空间特殊的变量值 或者 触发一个 signal 或者 产生一个软中断 或者 调用应用程序的回调函数）。</p>
<p>非阻塞 I/O 系统调用 ( nonblocking system call ) 和 **异步 I/O 系统调用（asychronous system call）**的区别是：</p>
<ul>
<li>一个非阻塞 I/O 系统调用 read() 操作立即返回的是任何可以立即拿到的数据，可以是完整的结果，也可以是不完整的结果，还可以是一个空值。</li>
<li>异步 I/O 系统调用 read（）结果必须是完整的，但是这个操作完成的通知可以延迟到将来的一个时间点。</li>
</ul>
<p>总结：</p>
<ul>
<li>阻塞/非阻塞，同步/异步的概念要注意讨论的上下文
<ul>
<li>在进程通信层面，阻塞/非阻塞，同步/异步基本是同义词，但是需要注意区分讨论的对象是发送方还是接收方，发送方阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步）是互不影响的。</li>
<li>在 IO 系统调用层面（IO system call）层面，非阻塞 IO 系统调用 和 异步 IO 系统调用存在着一定的差别，它们都不会阻塞进程，但是返回结果的方式和内容有所差别，但是都属于非阻塞系统调用（non-blocing system call）</li>
</ul>
</li>
<li>阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call）的存在可以用来实现线程级别的 I/O 并发，与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="024-并发模型-协程"><a class="header" href="#024-并发模型-协程">02.4-并发模型-协程</a></h1>
<h2 id="一-理解协程"><a class="header" href="#一-理解协程">一 理解协程</a></h2>
<blockquote>
<p>协程：也称为纤程（Coroutine）, 是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。</p>
</blockquote>
<p>协程与进程、线程相比并不是一个维度的概念，协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>
<p>正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程（目前的协程框架一般都是设计成 1:N 模式）。</p>
<p>注意：</p>
<ul>
<li>多个进程或一个进程内的多个线程是可以并行运行的</li>
<li>一个线程内的多个协程却是串行的，无论 CPU 有多少个核，因为协程本质上还是一个函数，当一个协程运行时，其它协程必须挂起</li>
<li>但是协程的切换过程只有用户态，即没有陷入内核态，因此切换效率比进程和线程高很多</li>
</ul>
<p>协程自己会主动适时的让出 CPU，也就是说每个协程池里面有一个调度器，这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了（比如异步等待网络的数据回来，但是当前还没有数据到)，这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要 CPU 的协程。切换这个协程的 CPU 上下文把 CPU 的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出 CPU 的 API 之类，触发下一次调度。</p>
<h2 id="二-协程的优缺点"><a class="header" href="#二-协程的优缺点">二 协程的优缺点</a></h2>
<p>优点：</p>
<ul>
<li>占用小：协程更加轻量，创建成本更小，降低了内存消耗，协程一般只占据极小的内存（2~5KB），而线城市 1MB 左右。虽然线程和协程都是独有栈，但是线程栈是固定的，比如在 Java 中，基本是 2M，假如一个栈只有一个打印方法，还要为此开辟一个 2M 的栈，就太浪费了。而 Go 的的协程具备动态收缩功能，初始化为 2KB，最大可达 1GB</li>
<li>运行效率高：线程切换需要从用户态-&gt;内核态-&gt;用户态，而协程切换是在用户态上，即用户态-&gt;用户态-&gt;用户态，其切换过程由语言层面的调度器（coroutine）或者语言引擎（goroutine）实现。</li>
<li>减少了同步锁：协程最终还是运行在线程上，本质上还是单线程运行，没有临界区域的话自然不需要锁的机制。多协程自然没有竞争关系。但是，如果存在临界区域，依然需要使用锁，协程可以减少以往必须使用锁的场景</li>
<li>同步代码思维写出异步代码</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法利用多核资源：协程运行在线程上，单线程应用无法很好的利用多核，只能以多进程方式启动。</li>
<li>协程不能有阻塞操作：线程是抢占式，线程在遇见 IO 操作时候，线程从运行态 → 阻塞态，释放 cpu 使用权。这是由操作系统调度。协程是非抢占式，如果遇见 IO 操作时候，协程是主动释放执行权限的，如果无法主动释放，程序将阻塞，无法往下执行，随之而来是整个线程被阻塞。</li>
<li>CPU 密集型不是长处：假设这个线程中有一个协程是 CPU 密集型的他没有 IO 操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。</li>
</ul>
<p>应用场景：</p>
<ul>
<li>高性能计算，牺牲公平性换取吞吐。协程最早来自高性能计算领域的成功案例，协作式调度相比抢占式调度而言，可以在牺牲公平性时换取吞吐</li>
<li>IO Bound 的任务：虽然异步 IO 在数据到达的时候触发回调，减少了线程切换带来性能损失，但是该思想不符合人类的思维模式。异步回调在破坏点思维连贯性的同时也破坏掉了程序的连贯性，让你在阅读程序的时候花费更多的精力。但是协程可以很好解决这个问题。比如把一个 IO 操作 写成一个协程。当触发 IO 操作的时候就自动让出 CPU 给其他协程。要知道协程的切换很轻的。协程通过这种对异步 IO 的封装既保留了性能也保证了代码的容易编写和可读性。</li>
</ul>
<h2 id="三-协程的简单实现"><a class="header" href="#三-协程的简单实现">三 协程的简单实现</a></h2>
<p>ES6 提供了一种新的方法名叫 Generator。Generator 的执行过程可以被暂停和恢复，所以它被认为是 ES6 中的协程，但严格地说，Generator 只是半协程（semi-coroutine），因为虽然它可以主动放弃执行权，但是它并没有告知运行环境，下一步哪个协程会被调用。当一个 Generator 被调用时，它的代码并不会被执行，调用者得到的是它的观察者（Observer）。调用者通过调用这个观察者的方法，比如 next 方法，来执行 Generator 的代码。</p>
<pre><code class="language-js">const Q = []
const Q_LEN = 10

function* produce() {
  while (Q.length &lt; Q_LEN) {
    const item = Date.now()
    Q.push(item)
    console.log(`Item ${item} is produced`)
    if (Q.length === Q_LEN) {
      yield
    }
  }
}

function* consume() {
  while (Q.length &gt; 0) {
    const item = Q.pop()
    console.log(`Item ${item} is consumed`)
    if (Q.length === 0) {
      yield
    }
  }
}

function bootstrap() {
  const producer = produce()
  const consumer = consume()
  while (true) {
    producer.next()
    consumer.next()
  }
}
bootstrap()
</code></pre>
<p>在上面代码中，produce 和 consume 是两个协程。bootstrap 方法是这两个协程的调用者，它首先获取 produce 和 consume 协程的观察者，然后循环调用观察者的 next 方法，从而使得生产者和消费者的关系持续运行。在循环过程中，如果 produce 检测队列已满，它就主动放弃执行权从而被暂停，consume 将获得执行权，如果 consume 检测队列已空，它就主动放弃执行权从而被暂停，produce 将重新获得执行权。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="025-并发模型-模型对比"><a class="header" href="#025-并发模型-模型对比">02.5-并发模型-模型对比</a></h1>
<h2 id="一-高性能-io-设计模式"><a class="header" href="#一-高性能-io-设计模式">一 高性能 I/O 设计模式</a></h2>
<h3 id="11-多进程"><a class="header" href="#11-多进程">1.1 多进程</a></h3>
<p>每到达一个请求，们为这个请求新创建一个进程来处理。这样，一个进程在等待 IO 时，其他的进程可以被调度执行，更加充分地利用 CPU 等资源。但是每新创建一个进程都会消耗一定的内存空间，且进程切换也会有时间消耗，高并发时，大量进程来回切换的时间开销会变得明显起来。</p>
<h3 id="12-多线程模式"><a class="header" href="#12-多线程模式">1.2 多线程模式</a></h3>
<p>在传统的网络服务设计模式中，有两种比较经典的模式：一种是 多线程，一种是线程池。</p>
<p>对于多线程模式，也就说来了 client，服务器就会新建一个线程来处理该 client 的读写事件，如下图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-13.png" alt="线程池" /></p>
<p>这种模式虽然处理起来简单方便，但是由于服务器为每个 client 的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。</p>
<h3 id="13-线程池模式"><a class="header" href="#13-线程池模式">1.3 线程池模式</a></h3>
<p>为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。</p>
<h3 id="14-reactor-模式"><a class="header" href="#14-reactor-模式">1.4 Reactor 模式</a></h3>
<p>在 Reactor 模式中，会先对每个 client 注册感兴趣的事件，然后有一个线程专门去轮询每个 client 是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-14.png" alt="reactor" /></p>
<p>从这里可以看出，上面的五种 IO 模型中的多路复用 IO 就是采用 Reactor 模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。</p>
<h3 id="15-proactor-模式"><a class="header" href="#15-proactor-模式">1.5 Proactor 模式</a></h3>
<p>在 Proactor 模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成 IO 操作之后，发送一个通知告知操作已完成，可以得知，异步 IO 模型采用的就是 Proactor 模式。</p>
<h3 id="16-总结"><a class="header" href="#16-总结">1.6 总结</a></h3>
<p>交换数据方式：</p>
<ul>
<li>多进程交换数据方式复杂（管道、消息队列、信号量、共享内存）</li>
<li>多线程之间交换数据很简单，但会产生竞态条件，需要解决同步问题</li>
</ul>
<p>综合而言，多线程方式具备大量优势，但是在处理信号、同时运行多套不同程序以及包含多个需要超大内存支持的任务等，多进程方式更适合，而协程和非阻塞 IO 则更能充分的提升程序的运行效率。</p>
<h2 id="二-线程不一定比进程轻量"><a class="header" href="#二-线程不一定比进程轻量">二 线程不一定比进程轻量</a></h2>
<p>理论上，线程之间共享内存，创建新线程的时候不需要创建真正的虚拟内存空间，也不需要 MMU（内存管理单元）上下文切换。此外，线程间通信比进程之间通信更加简单，主要是因为线程之间有共享内存，而进程通信往往需要利用各种模式的 IPC（进程间通信），如信号量，消息队列，管道等。</p>
<p>但是在多处理器操作系统中，线程并不一定比进程更高效：例如 Linux 就是不区分线程和进程的，两者在 Linux 都被称作任务（task）。每个任务在 cloned 的时候都有一个介于最小到最大之间的共享级别。</p>
<ul>
<li>调用 fork() 创建任务时，创建的是一个没有共享文件描述符，PID 和内存空间的新任务。而调用 pthread_create() 创建任务时，创建的任务将包含上述所有共享资源。</li>
<li>线程之间保持共享内存与多核的 L1 缓存中的数据同步，与在隔离内存中运行不同的进程相比，需要付出更加大的代价。</li>
</ul>
<h2 id="三-线程的改进方向"><a class="header" href="#三-线程的改进方向">三 线程的改进方向</a></h2>
<p>线程变慢的主要三个原因：</p>
<ul>
<li>线程自身有一个很大的堆（≥ 1MB）占用了大量内存，如果一下创建 1000 个线程意味着需要 1GB 的内存！！！！！</li>
<li>线程需要重复存储许多寄存器，其中一些包括 AVX（高级向量扩展），SSE（流式 SIMD 外设），浮点寄存器，程序计数器（PC），堆栈指针（SP），这会降低应用程序性能。</li>
<li>线程创建和消除需要调用操作系统以获取资源（例如内存），而这一操作相对是比较慢的。</li>
</ul>
<h2 id="四-goroutine"><a class="header" href="#四-goroutine">四 goroutine</a></h2>
<p>Goroutines 是在 Golang 中执行并发任务的方式，不过要切记：</p>
<blockquote>
<p>Goroutines 仅存在于 Go 运行时而不存在于 OS 中，因此需要 Go 调度器（GoRuntimeScheduler）来管理它们的生命周期。</p>
</blockquote>
<p>Go 运行时为此维护了三个 C 结构（<a href="https://golang.org/src/runtime/runtime2.go">https://golang.org/src/runtime/runtime2.go</a>）：</p>
<ul>
<li>G 结构：表示单个 Goroutine，包含跟踪其堆栈和当前状态所需的对象。还包含自己负责的代码的引用。</li>
<li>M 结构：表示 OS 线程。包含一些对象指针，例如全局可执行的 Goroutines 队列，当前运行的 Goroutine，它自己的缓存以及对 Go 调度器的引用。</li>
<li>P 结构：也做 Sched 结构，它是一个单一的全局对象，用于跟踪 Goroutine 和 M 的不同队列以及调度程序运行时需要的其他一些信息，例如单一全局互斥锁（Global Sched Lock）。</li>
</ul>
<p>G 结构主要存在于两种队列之中，一个是 M（线程）可以找到任务的可执行队列，另外一个是一个空闲的 Goroutine 列表。调度程序维护的 M（执行线程）只能每次关联其中一个队列。为了维护这两种队列并进行切换，就必须维持单一全局互斥锁（Global Sched Lock）。</p>
<p>因此，在启动时，go 运行空间会为 GC，调度程序和用户代码启动许多 Goroutine。并创建 OS 线程来处理这些 Goroutine。不过创建的线程数量最多可以等于 GOMAXPROCS（默认为 1，但为了获得最佳性能，通常设置为计算机上的处理器数量）。</p>
<h2 id="五-协程对比线程的改进"><a class="header" href="#五-协程对比线程的改进">五 协程对比线程的改进</a></h2>
<p>为了使运行时的堆栈更小，go 在运行期间使用了大小可调整的有限堆栈，并且初始大小只有 2KB/goroutine。新的 Goroutine 通常会分配几 kb 的空间，这几乎总是足够的。如果不够的话，运行空间还能自动增长（或者缩小）内存来实现堆栈的管理，从而让大部分 Goroutine 存在于适量的内存中。每个函数调用的平均 CPU 开销大概是三个简单指令。因此在同一地址空间中创建数十万个 Goroutine 是切实可行的。但是如果 Goroutine 是线程的话，系统资源将很快被消耗完。</p>
<h2 id="六-协程阻塞"><a class="header" href="#六-协程阻塞">六 协程阻塞</a></h2>
<p>当 Goroutine 进行阻塞调用时，例如通过调用阻塞的系统调用，这时调用的线程必须阻塞，go 的运行空间会操作自动将同一操作系统线程上的其他 Goroutine，将它们移动到从调度程序（Sched Struct）的线程队列中取出的另一个可运行的线程上，所以这些 Goroutine 不会被阻塞。因此，运行空间应至少创建一个线程，以继续执行不在阻塞调用中的其他 Goroutine。而且关键的是程序员是看不到这一点的。结论是，我们称之为 Goroutines 的事物，可以是很低廉的：它们在堆栈的内存之外几乎没有开销，而内存中也只有几千字节。</p>
<p>Go 协程也可以很好地扩展。</p>
<p>但是，如果你使用只存在于 Go 的虚拟空间的 channels 进行通信（产生阻塞时），操作系统将不会阻塞该线程。只是让该 Goroutine 进入等待状态，并安排另一个可运行的 Goroutine（来自 M 结构关联的可执行队列）它的位置。</p>
<h2 id="七-go-runtime-scheduler"><a class="header" href="#七-go-runtime-scheduler">七 Go Runtime Scheduler</a></h2>
<p>Go Runtime Scheduler 跟踪记录每个 Goroutine，并安排它们依次地在进程的线程池中运行。</p>
<p>Go Runtime Scheduler 执行协作调度，这意味着只有在当前 Goroutine 阻塞或完成时才会调度另一个 Goroutine，这通过代码可以轻松完成。这里有些例子：</p>
<ul>
<li>调用系统调用如文件或网络操作阻塞时</li>
<li>因为垃圾收集被停止后</li>
</ul>
<p>这样比定时阻塞并调度新线程的抢占式调度要好得多，因为当线程数量增加，或者当高优先级任务将被调度运行时，有低优先级的任务已经在运行了（此时低优先级队列将被阻塞），定时抢占调度可能导致某些任务完成花费的时间大大超过实际所需时间。</p>
<p>另一个优点是，因为 Goroutine 在代码中隐式调用的，例如在睡眠或 channel 等待期间，编译只需要安全地恢复在这些时刻处存活的寄存器。在 Go 中，这意味着在上下文切换期间仅更新 3 个寄存器，即 PC，SP 和 DX（数据寄存器）而不是所有寄存器（例如 AVX，浮点，MMX）。</p>
<h2 id="八-goroutine-与-coroutine"><a class="header" href="#八-goroutine-与-coroutine">八 goroutine 与 coroutine</a></h2>
<p>C#、Lua、Python 语言都支持协程 coroutine（Java 也有一些第三方库支持）。</p>
<p>coroutine 与 goroutine 都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同：</p>
<ul>
<li>goroutine 可能发生并行执行，coroutine 始终顺序执行</li>
<li>goroutine 使用 channel 通信，coroutine 使用 yield 和 resume</li>
</ul>
<blockquote>
<p>coroutine 程序需要主动交出控制权，宿主才能获得控制权并将控制权交给其他 coroutine</p>
</blockquote>
<p>coroutine 的运行机制属于协作式任务处理。在早期的操作系统中，应用程序在不需要使用 CPU 时，会主动交出 CPU 使用权。如果开发者故意让应用程序长时间占用 CPU，操作系统也无能为力。coroutine 始终发生在单线程。</p>
<blockquote>
<p>goroutine 可能发生在多线程环境下，goroutine 无法控制自己获取高优先度支持</p>
</blockquote>
<p>goroutine 属于抢占式任务处理，和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。</p>
<h2 id="九-go-协程总结"><a class="header" href="#九-go-协程总结">九 Go 协程总结</a></h2>
<p>Go 协程的特点：</p>
<ul>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
</ul>
<p>注意：</p>
<ul>
<li>Go 程序在启动时，就会为 main 函数创建一个默认的 goroutine，也就是入口函数 main 本身也是一个协程</li>
<li>如果主线程退出了，则协程即使还没有执行完毕也退出</li>
</ul>
<p>单纯的将函数并发执行是没有意义的，函数与函数之间必须能够交换数据才能体现并发执行函数的意义。为了实现数据的通信，有两种常见并发模型：</p>
<ul>
<li>共享数据：一般使用共享内存方式来共享数据，Go 中的实现方式为互斥锁（sync 包）。</li>
<li>消息：消息机制认为每个并发单元都是独立个体，拥有自己的变量。不同的并发单元之间不共享各自的变量，只通过消息来进行数据输入输出，Go 中的实现方式为 channle。</li>
</ul>
<p>在 Go 中对上述两种方式都进行了实现，但是 Go 不推荐共享数据方式，推荐 channel 的方式进行协程通信。因为多个 goroutine 为了争抢数据，容易发生竞态问题，会造成执行的低效率，使用队列的方式是最高效的，channel 就是一种队列一样的结构。</p>
<p>如图所示：
<img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/02-04.svg" alt="channel" /></p>
<p>channel 特性：</p>
<ul>
<li>channel 的本质是一个数据结构 - 队列，先进先出</li>
<li>channel 是线程安全的，多 goroutine 访问时，不需要加锁，因为在任何时候，同时只能有一个 goroutine 访问通道。</li>
<li>channel 拥有类型，一个 string 的 channle 只能存放 string 类型数据</li>
</ul>
<p>golang 奉行通过通信来共享内存，而不是通过共享内存来通信。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-事件循环-浏览器事件循环"><a class="header" href="#031-事件循环-浏览器事件循环">03.1-事件循环-浏览器事件循环</a></h1>
<h2 id="一-javascript-的运行时"><a class="header" href="#一-javascript-的运行时">一 JavaScript 的运行时</a></h2>
<h3 id="11-运行时特点简介"><a class="header" href="#11-运行时特点简介">1.1 运行时特点简介</a></h3>
<p>在多线程开发中，创建线程、执行线程上下文切换会产生巨大开销。多线程编程也需要应对锁、同步等问题，开发时的心智负担较大。</p>
<p>JavaScript 在浏览器、Node 这两个运行时中都采用了单线程异步 I/O 模型，可以避免上述缺点的同时，也能实现较大并发。当然这也带来了缺点：无法利用多核 CPU。</p>
<p>不过要注意的是：浏览器和 Node 这两个运行时都不是单纯的单线程环境。</p>
<p>浏览器内部存在很多线程，最重要的线程是：JS 解析线程、UI 绘制线程，二者不能同时运行，因为二者如果操作同一个 DOM 则会出现渲染的异常。</p>
<p>同样，Node 在使用单线程运行 JS 时，其内部完成 I/O 任务则是依赖一个线程池（在 Linux 中，Node 的异步是靠着 libuv 库实现的，在 Windows 中，则依赖于 IOCP 实现）。</p>
<p>阻塞/非阻塞，同步异步简单理解：</p>
<pre><code class="language-txt">阻塞与非阻塞：多用于调用方。
    客户端发起请求后，客户端可以等待（阻塞），也可以不等待（非阻塞）

同步与异步：多用于被调用方。
    客户端发起请求后，服务端可以使用同步的方式返回消息，也可以使用异步的方式返回消息。

所以：如果服务端采用异步方式返回消息，客户端既可以继续一直等待（阻塞），也可以选择执行其他任务（非阻塞）。
</code></pre>
<h3 id="12-javascript-单线程模型原理"><a class="header" href="#12-javascript-单线程模型原理">1.2 JavaScript 单线程模型原理</a></h3>
<p>由于 JavaScript 的单线程模型设计，大量的任务如果都交给这一个线程处理，势必引起整个系统的卡顿。如：假设浏览器中的：DOM 解析、事件处理、UI 绘制、JS 脚本执行等任务都由一个线程负责，处理速度是难以想象的。</p>
<p>假设现在有三个任务：</p>
<pre><code class="language-txt">任务 1：计算 1 + 1 的结果，假设耗时 1 秒
任务 2：控制台打印 hello world，假设耗时 2 秒
任务 3：向文件 demo.txt 内写入 hello world，假设耗时 5 秒
</code></pre>
<p>传统的思维中，单线程处理方式如下：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/zen/eventloop-01.svg" alt="单线程模型" /></p>
<p>如果单线程只负责这些任务的调度，任务的具体执行交给其他具体的执行人，就会该线程拥有较大的自由度，如下所示，将任务 3 中的 I/O 交给磁盘自己处理：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/zen/eventloop-02.svg" alt="单线程模型" /></p>
<p>从上图看出，任务三交给磁盘自己处理后，单线程的运行时间只需要 3 秒，极大缩短了线程的卡顿时间，但是这时候依然有问题需要处理：</p>
<ul>
<li>磁盘处理完文件读写后，业务单线程如何知道读写结束？</li>
<li>线程全部任务处理完毕，运行结束，又来一个新的任务，这个线程又要重启一次（重启非常耗时）</li>
</ul>
<p>我们可以让这个核心业务线程一直运行下去，并在任务调度时设计一个通知行为，让磁盘在完成 IO 后将结果通知给线程，这样就能完整的解决上述问题了，该调度系统我们可以简单的视为：事件循环，其解决机制如下：</p>
<ul>
<li>使用死循环确保线程一直运行</li>
<li>将任务存储在队列中，线程从队列中取出进行调度</li>
<li>通过事件机制将被调度任务的处理结果通知给线程</li>
</ul>
<p>如下所示：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/zen/eventloop-03.svg" alt="单线程模型" /></p>
<p>线程从队列的队首中依次循环取出任务：</p>
<ul>
<li>取出任务一，运算出结果</li>
<li>取出任务二，运算出结果</li>
<li>取出任务三，发现是耗时较长的 I/O，将该任务交给系统的 I/O 线程处理。</li>
</ul>
<p>任务 3 处理如图：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/zen/eventloop-04.svg" alt="单线程模型" /></p>
<p>总结：<strong>事件循环的本质其实是：对 JS 脚本的调度方式。</strong></p>
<h3 id="13-单线程模型问题"><a class="header" href="#13-单线程模型问题">1.3 单线程模型问题</a></h3>
<p>任务队列由于结构特性，必须先进先出（FIFO），可以保证任务的执行顺序不会发生变化。一般称任务队列中的任务为 <strong>宏任务</strong>，每完成一个任务才会从队列中取出下一个任务。</p>
<p>问题是：如果该宏任务比较耗时，队列也会被阻塞！我们当然想到让任务异步执行，通过事件通知方式回调即可解决这个问题，但是这样的后果是实时性变差，如果要实时监听界面中的 DOM 变化，这里就很难实现。为了权衡效率、实时性，新增了微任务。</p>
<p>每个宏任务中，都包含一个<strong>微任务队列</strong>。细粒度的任务可以加入微任务队列中，如果当前宏任务完成，引擎不会立即执行下一个宏任务，而是执行当前宏任务中的微任务。</p>
<h2 id="二-浏览器中的事件循环"><a class="header" href="#二-浏览器中的事件循环">二 浏览器中的事件循环</a></h2>
<h3 id="20-浏览器事件循环概念"><a class="header" href="#20-浏览器事件循环概念">2.0 浏览器事件循环概念</a></h3>
<p>浏览器的事件循环（event loops）主要用来协调：事件（event，如 PostMessae、MutationObserver）、用户交互（user interaction）、脚本（script）、渲染（rendering）、网络（networking）。</p>
<h3 id="21-事件循环中的执行队列"><a class="header" href="#21-事件循环中的执行队列">2.1 事件循环中的执行队列</a></h3>
<p>异步事件对应的回调函数是在一个队列中完成执行的：</p>
<pre><code class="language-js">console.log('aaa')

setTimeout(() =&gt; {
  console.log(111)
})

console.log('bbb')

setTimeout(() =&gt; {
  console.log(222)
})

console.log('ccc')

setTimeout(() =&gt; {
  console.log(333)
})

console.log('ddd')
</code></pre>
<p>其执行结果：</p>
<pre><code class="language-txt">aaa
bbb
ccc
ddd
111
222
333
</code></pre>
<p>执行原理图：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/concurrent/eventloop1.svg" alt="eventloop" /></p>
<p>注意：上述的定时器在栈中其实是直接执行了定时器本身，只有其回调函数才是等到<strong>时间到了之后</strong>进入回调队列！</p>
<h3 id="22-宏任务与微任务"><a class="header" href="#22-宏任务与微任务">2.2 宏任务与微任务</a></h3>
<p>不同的任务会被分发到不同的队列中：</p>
<ul>
<li>微任务（micro-task）：Promise、MutationObserve、MessageChannel</li>
<li>宏任务（macro-task）：setTimeout、setInterval、setImmediate（IE 浏览器 才拥有）、I/O</li>
</ul>
<p>一般情况下微任务会优于宏任务执行，其具体执行规则是：先完全执行微任务队列，然后每执行一个宏任务，就会重新再去完全执行微任务队列：</p>
<pre><code class="language-js">console.log('aaa')

// 宏任务
setTimeout(() =&gt; {
  console.log(111)
})

console.log('bbb')

// 微任务
Promise.resolve().then((data) =&gt; {
  console.log(222)
})

console.log('ccc')
</code></pre>
<p>执行结果：</p>
<pre><code class="language-txt">aaa
bbb
ccc
222
111
</code></pre>
<p>其原理是：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/concurrent/eventloop2.svg" alt="eventloop" /></p>
<p>那么如果二者进行了混合：</p>
<pre><code class="language-js">console.log('aaa')

setTimeout(() =&gt; {
  console.log(222, '-t1')
  Promise.resolve().then((data) =&gt; {
    console.log(222, '-p1')
  })
})

console.log('bbb')

Promise.resolve().then((data) =&gt; {
  console.log(333, '-p2')
  setTimeout(() =&gt; {
    console.log(333, '-t2')
  })
})

console.log('ccc')
</code></pre>
<p>执行结果：</p>
<pre><code class="language-txt">aaa
bbb
ccc
333 -p2
222 -t1
222 -p1
</code></pre>
<h3 id="23-事件循环描述"><a class="header" href="#23-事件循环描述">2.3 事件循环描述</a></h3>
<p>事件循环即任务队列。在执行时，其顺序才真正决定了 JS 代码的输出结果顺序：</p>
<pre><code class="language-txt">第一次循环：
    从 macro-task 中的 script 开始，全局上下文进入函数调用栈，此时如果遇到任务分发器，就会将任务放入对应队列
    调用栈清空只剩下全局上下文后，执行所有的 micro-task
    micro-task 全部执行结束后，第一次循环结束

第二次循环：
    再次从 macro-task 开始执行，
    此时 macro-task 中的 script 队列没有任务，但是可能会有其他的队列任务，而 micro-task 中暂时没有任务，
    此时会选择其中一个宏任务队列，如 setTimeout，将改对垒中所有任务全部执行完毕，再执行此过程中可能产生的微任务
    微任务执行完毕后，再回头执行其他宏任务队列中的任务
    依次类推，直到所有宏任务队列中的任务都被执行一遍，并清空了微任务，第二次循环结束

    如果在第二次循环中，产生了新的宏任务队列，或者之前的宏任务队列中的任务暂时没有满足执行条件，例如延迟时间不够或者事件没有触发，将会继续以同样的顺序重复循环。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="032-事件循环-node-事件循环"><a class="header" href="#032-事件循环-node-事件循环">03.2-事件循环-Node 事件循环</a></h1>
<h2 id="一-node-中的事件循环与浏览器事件循环区别"><a class="header" href="#一-node-中的事件循环与浏览器事件循环区别">一 Node 中的事件循环与浏览器事件循环区别</a></h2>
<p>Node 旧版与浏览器的循环有少许不同，为了与社区同步，Node11 之后也采取了浏览器中实现的事件循环机制，即：执行完一个宏任务，去清空微任务队列，Node 中会接着执行 nextTick，这一轮完毕后，再次去执行宏任务。</p>
<p>在 Node11 之前，Node 的一轮 evetnloop 包含六个循环阶段</p>
<ul>
<li>timers（定时器）：执行由 <code>setTimeout()</code>、<code>setInterval()</code>调度的回调函数</li>
<li>I/O callbacks(I/O 回调)：执行几乎所有回调函数，除了 close callbacks、timers、setImmediate() 调度的回调。</li>
<li>idle(空转),prepare()：Node 内部使用</li>
<li><strong>poll（轮询）</strong>：检索新的 I/O 事件，在恰当的时候 Node 会在该阶段阻塞</li>
<li>check（检查）：调用 <code>setImmediate()</code> 回调</li>
<li>close callbacks（关闭事件回调）：调用如 <code>socket.on('close')</code>等回调</li>
</ul>
<p>poll 是最重要的阶段，进入 poll 阶段后：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/concurrent/eventloop3.svg" alt="eventloop" /></p>
<h2 id="二-setimmdiate"><a class="header" href="#二-setimmdiate">二 setImmdiate()</a></h2>
<h3 id="21-setimmdiate-的使用"><a class="header" href="#21-setimmdiate-的使用">2.1 setImmdiate() 的使用</a></h3>
<p>setImmdiate 是 Node 独有的标准，不接受时间作为参数，他的事件总是在当前事件循环的结尾触发，对应的回调方法会在当前时间循环末尾（check）阶段执行，但是由于 nextTick 会在当前操作完成后立刻执行，因此总会在 setImmdiate 前执行。</p>
<pre><code class="language-js">setImmediate(function (args) {
  console.log('executing immediate', args)
}, 'so immediate')

process.nextTick(function () {
  console.log('tick...')
})
console.log('console...')
</code></pre>
<p>依次输出：</p>
<pre><code class="language-txt">console...
tick...
executing immediate so immediate
</code></pre>
<p>注意：node 限制了 bextTickQueue 队列的大小，如果使用很大的循环来产生该队列，则会抛出错误，而 setImmediate 不会出现该问题，因为它不会生成 call stack。</p>
<p>下列代码不会报错：</p>
<pre><code class="language-js">function recurse(i, end) {
  if (i &gt; end) {
    console.log('Done!')
  } else {
    console.log(i)
    setImmediate(recurse, i + 1, end)
  }
}

recurse(0, 9999999999)
</code></pre>
<p>下列代码报错：Maximum call stack size exceeded</p>
<pre><code class="language-js">function recurse(i) {
  while (i &lt; 9999) {
    process.nextTick(recurse(i++))
  }
}

recurse(0)
</code></pre>
<pre><code class="language-js">/*
二者类似，但是调用时机不同，setTimeout 位于 timer 队列，setImmediate 位于 check 队列
*/

// 在主模块调用，会根据性能影响，执行的顺序有所不同
setTimeout(() =&gt; {
  console.log('1-setTimeout')
})

setImmediate(() =&gt; {
  console.log('2-setImmediate')
})

// 但是在 IO 中，是固定的。
// poll 队列并不一定是在无限循环，如果有 setImmediate，会进入 check，执行 setImmediate，然后回到第一步从 timer 阶段开始重新循环
// 如果没有 setImmediate，则会等待然后回到 timer 阶段
fs.readFile('./demo.txt', (data) =&gt; {
  setTimeout(() =&gt; {
    console.log('1-setTimeout')
  })

  setImmediate(() =&gt; {
    console.log('2-setImmediate')
  })
})
</code></pre>
<pre><code class="language-js">setTimeout(() =&gt; {
  console.log('timeout1')
  process.nextTick(() =&gt; {
    console.log('nextTick1')
  })
})

setTimeout(() =&gt; {
  console.log('timeout2')
  process.nextTick(() =&gt; {
    console.log('nextTick2')
  })
})
</code></pre>
<h3 id="22-setimmediate-与-settimeout"><a class="header" href="#22-setimmediate-与-settimeout">2.2 setImmediate 与 setTimeout</a></h3>
<p>setImmediate 方法会在 poll 阶段结束后执行，而 setImmediate 会在规定时间到期后执行，由于无法预测执行代码时时间循环处于哪个阶段，因此当代码中同时存在这个两个方法时，回调函数的执行顺序不是固定的：</p>
<pre><code class="language-js">setTimeout(function () {
  console.log('setTimeout')
}, 0)
setImmediate(function () {
  console.log('setImmediate')
})
</code></pre>
<p>但是如故将二者放在一个 IO 操作的 callback 中，则永远是 setImmediate 先执行：</p>
<pre><code class="language-js">require('fs').readFile('./foo.js', function () {
  setTimeout(function () {
    console.log('setTimeout')
  }, 0)
  setImmediate(function () {
    console.log('setImmediate')
  })
})
</code></pre>
<h2 id="三-node-的事件循环原理"><a class="header" href="#三-node-的事件循环原理">三 Node 的事件循环原理</a></h2>
<p>在 Node 项目进程启动时，会创建一个类似于 <code>while(true)</code> 的死循环，每执行一次循环体的过程可以称呼为 Tick。每轮 Tick 中，都在查看是否有事件在等待处理，如果有，则取出事件，并执行器关联的回调函数，没有关联的回调函数则不执行。</p>
<p>查看是否有事件等待处理利用了观察者模式：每个事件循环中有一到多个观察者，只需要向观察者循环是否有要处理的事件即可。</p>
<p>事件循环是一个典型的生产者、消费者模型，异步 I/O、网络请求等是事件的生产者，产生的事件被传递到对应的观察者，事件循环则从观察者取出事件并处理。</p>
<p>Node 将事件循环分成了 6 个阶段，每个阶段都维护了一个回调函数队列，在不同的阶段，事件循环处理不同类型的事件，事件循环的阶段依次是：</p>
<ul>
<li>Timers:用来处理 setTimeout 和 setTimeInterval 的回调</li>
<li>IO callbacks:大多数的回调方法在这个阶段执行，除了 timers、close、setImmediate 事件的回调</li>
<li>idle,prepare:仅仅 Node 内部使用</li>
<li>Poll:轮询，不断检查有没有新的 IO 事件，事件循环可能会在这里阻塞</li>
<li>Check:处理 setImmediate 事件回调</li>
<li>close.callback:处理一些 close 相关的事件，如：socket.on(&quot;close&quot;,...)</li>
</ul>
<p>上述的处理用伪代码展示：</p>
<pre><code class="language-js">while (true) {
  uv_run_timers()
  uv_run_pending(loop)
  uv_run_idle()
  uv_io_poll()
  uv_run_check()
  uv_run_closeing_handles()
}
</code></pre>
<p>上述代码中，每个方法代表一个阶段，假设事件循环现在进入了某阶段（即开始执行删哪个面其中一个方法），即使在这期间有其他队列中的事件就绪，也会将当前阶段队列里的全部回调方法执行完毕后，再进入到下个阶段。</p>
<h3 id="35-深入理解-node-的事件监听"><a class="header" href="#35-深入理解-node-的事件监听">3.5 深入理解 Node 的事件监听</a></h3>
<p>在 Node 中，事件队列不止一个，定时器相关的事件和磁盘 IO 产生的事件需要不同的处理方式。如果把所有的事件都放在一个队列里，势必要增加许多类似 switch/case 的代码，还不如直接归类到不同的事件队列，然后一层层遍历。</p>
<p>示例：</p>
<pre><code class="language-js">let fs = require('fs')

let startTime = Date.now()

//setTimeout 的异步
setTimeout(function () {
  let delay = Date.now() - startTime
  console.log(delay + ' 毫秒后才开始执行 setTimeout 回调')
}, 100)

//文件读取的异步：假设耗时 95ms
fs.readFile('./foo.js', function (err, data) {
  let beginCallbackTime = Date.now()
  while (Date.now() - beginCallbackTime &lt; 10) {
    // 使用 while 阻塞 10ms
    console.log('阻塞中')
  }
})
</code></pre>
<p>上述代码中，存在 readfile 和 timer 两个异步操作，启动文件后，运行时开始轮询：</p>
<ul>
<li>首先检查 timers，timers 对应的事件队列目前还为空，因为 100ms 后才会有事件产生</li>
<li>进入 poll 阶段，没有事件出现，代码中也没有 setImmediate 操作，事件循环便在此一直等待新的事件出现</li>
<li>直到 95ms 读取文件完毕，产生了一个事件，加入 poll 队列中，此时事件循环将该队列的事件去除，准备执行之后的 callback，readFile 的回调方法什么都没做，只是暂停了 10ms。</li>
<li>事件循环本身也被阻塞 10ms，按照通常的思维，95+10=105&gt;100，timers 队列的事件已经就绪，应该先执行对应的回调方法才对，但是由于事件循环本身是单线程运行，因为也会被停止 10ms，如果 readFile 中出现了一个死循环，那么整个事件循环都会被阻塞，setTimeout 回调永远不会执行。</li>
<li>readFile 的回调完成后，事件循环切换到了 timers 阶段，接着取出 timers 队列中的事件执行对应的回调方法</li>
</ul>
<h3 id="36-node-中回调的完成"><a class="header" href="#36-node-中回调的完成">3.6 Node 中回调的完成</a></h3>
<p>在普通开发中，回调函数一般由开发者自己调用，如：</p>
<pre><code class="language-js">var forEach = funtion(list, cb) {
    for (var i = 0; i &lt; list.length; i++&gt;) {
        cb(list[i], i, list);
    }
}
</code></pre>
<p>但是在 Node 中，回调函数并不是有开发者调用。JS 发起调用后，一直到内核完成 I/O 的过程中，会产生一个名为 请求对象 的中间产物，示例：</p>
<pre><code class="language-js">fs.open = function (path, flags, callback) {
  // ...
  binding.open(pathModule._makeLong(path), stringToFlags(flags), mode, callback)
}
</code></pre>
<p><code>fs.open()</code>的作用是根据指定路径和参数去打开文件得到其描述符，其调用步骤是：JS 代码--&gt;Node 核心模块--&gt;C++内建模块--&gt;libuv 进行系统调用。最终调用的是 libuve 内部的<code>_uv_fs_open()</code>方法，在此方法中，会创建一个 FSReqWrap 请求对象，所有 JS 代码中的参数、方法都会封装在该请求对象中，回调函数会被设置在对象的<code>oncomplete_sym</code>属性上：</p>
<pre><code class="language-c">req_wrap-&gt;object_-&gt;Set(oncomplete_sym, callback);
</code></pre>
<p>对象包装完毕后，则会其推入线程池中等待执行。也就是说当前的 I/O 操作在线程池中开始等待，不管是否阻塞，都不会影响 JS 线程的后续执行，达到了异步目的。</p>
<p>线程池中 I/O 操作调用完毕后，会将获取的结果存储在 req-&gt;result 属性上，然后通过一些方法通知完成，即取出请求对象的 result 属性作为参数，取出 oncomplete_sym 属性作为方法，然后调用执行，以此达到调用 JS 中传入的回调函数的目的。</p>
<h3 id="37-processnexttick"><a class="header" href="#37-processnexttick">3.7 process.nextTick()</a></h3>
<p>Node 的 nextTick() 方法，不是事件循环的一部分，只是一个异步 API，不过其回调方法是由事件循环调用的，该方法定义的回调方法被加入到名为 nextTickQueue 的队列中。在事件循环的任何阶段，如果 nextTikcQueue 不为空，都会在当前阶段操作结束后优先执行 nextTickQueue 中的回调函数，执行完该队列中的回调后，事件循环才会继续向下执行。</p>
<pre><code class="language-js">// 宏任务
setTimeout(() =&gt; {
  console.log('1-setTimeout')
})

// 微任务
Promise.resolve().then(() =&gt; {
  console.log('2-Promise')
})

// 微任务：但是该微任务在当前执行站执行完毕后会立即调用，优于 Promise.then()
process.nextTick(() =&gt; {
  console.log('3-nextTick')
})
</code></pre>
<p>注意：多个 nextTick 在一起，则会按照顺序执行，且会依次阻塞后面的 nextTick。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="033-事件循环-node-的事件模块"><a class="header" href="#033-事件循环-node-的事件模块">03.3-事件循环-Node 的事件模块</a></h1>
<h2 id="一-使用发布订阅模式"><a class="header" href="#一-使用发布订阅模式">一 使用发布订阅模式</a></h2>
<p>异步编程中使用最广的设计模式是发布订阅模式，也常称呼为事件监听机制。Node 的 events 模块是其简单实现，大多 Node 的其他模块都继承自它。</p>
<pre><code class="language-js">const events = require('events')

let emitter = new events()

// 订阅事件 event1
emitter.on('event1', () =&gt; {
  console.log('1--')
})

emitter.on('event1', (msg) =&gt; {
  console.log('2--', msg)
})

// 发布
emitter.emit('event1', 'hello world')
</code></pre>
<p>输出结果为：</p>
<pre><code class="language-txt">1--
2-- hello world
</code></pre>
<p>事实上，其本质是操作了一个这样的对象：</p>
<pre><code class="language-json">{
  &quot;event1&quot;: [fn1, fn2]
}
</code></pre>
<p>事件的发布订阅模式可以实现一个事件和多个回调函数的关联，这些回调函数可以称为事件侦听器，使用 emit() 发布事件后，消息会立即传递给当前事件的所有侦听器执行。</p>
<p>此外该对象的方法还有：once（执行一次）、off（取消订阅）。</p>
<p>Node 还有一个内部定义的特殊事件：<code>newListener</code>：</p>
<pre><code class="language-js">// 每次用户调用了一次 on，则执行该事件的方法
emitter.on('newListener', (type) =&gt; {})
</code></pre>
<h2 id="二-理解发布订阅模式"><a class="header" href="#二-理解发布订阅模式">二 理解发布订阅模式</a></h2>
<p>发布订阅只是一种设计模式，无关异步、同步，但是在 Node 中，emit() 调用多半伴随了事件循环而异步触发，所以说事件发布/订阅可以广泛用于异步编程。</p>
<p>同样的，发布订阅也解耦了应用程序：事件的发布者无序关注订阅者（即侦听器）如何实现业务，消息只要能在订阅者和发布者之间流转即可。</p>
<p>当然，事件的侦听器模式也可以理解为一种钩子机制（hooks），利用钩子导出内部数据、状态给外部的调用者，比如在 Node 中：</p>
<pre><code class="language-js">var options = {
  host: 'www.google.com',
  port: 80,
  path: '/upload',
  method: 'POST',
}

var req = http.request(options, function (res) {
  console.log('STATUS: ' + res.statusCode)
  console.log('HEADERS: ' + JSON.stringify(res.headers))

  res.setEncoding('utf8')

  res.on('data', function (chunk) {
    console.log('BODY: ' + chunk)
  })

  res.on('end', function () {
    // TODO
  })
})

req.on('error', function (e) {
  console.log('problem with request: ' + e.message)
})

// write data to request body
req.write('data\n')
req.write('data\n')
req.end()
</code></pre>
<p>在上述代码中，开发者只需要把视线放在 error、data、end 这些业务中即可，内部流程的运转，无需过多关注。</p>
<p>Node 对发布订阅机制增加了健壮性处理：</p>
<ul>
<li>事件侦听器超过 10 个，将会触发警告，以避免内存泄露等现象产生</li>
<li>在运行期间如果触发了 error 事件，EventEmitter 对象会检查是否有对 error 事件添加过侦听器，如果添加了则 erro 事件由侦听器处理，否则将抛出异常</li>
</ul>
<p>实现一个继承自 EventEmitter 类的方式：</p>
<pre><code class="language-js">var events = require('events')

function Stream() {
  events.EventEmitter.call(this)
}
util.inherits(Stream, events.EventEmitter)
</code></pre>
<h2 id="三-事件队列解决雪崩问题"><a class="header" href="#三-事件队列解决雪崩问题">三 事件队列解决雪崩问题</a></h2>
<p>缓存是软件系统中基于内存的数据存储系统，访问速度极快，常用于一些对性能要求较高的场景。但是在高并发场景中，缓存容易失效，大量的请求穿过缓存同时涌入数据库，会引起数据库服务宕机。</p>
<p>事件的发布订阅模式中，once() 方法可以解决雪崩问题。</p>
<p>普通的数据库查询：</p>
<pre><code class="language-js">function select(callback) {
  db.select('SQL', function (results) {
    callback(results)
  })
}
</code></pre>
<p>第一种改进方案是添加一个类似锁的变量：</p>
<pre><code class="language-js">var status = 'ready'
function select(callback) {
  if (status === 'ready') {
    status = 'pending'
    db.select('SQL', function (results) {
      status = 'ready'
      callback(results)
    })
  }
}
</code></pre>
<p>上述场景中，连续多次调用 select() 时，只有第一次调用是生效的，后续的 select() 是没有数据服务的，这时候可以引入事件队列：</p>
<pre><code class="language-js">var proxy = new events.EventEmitter()
var status = 'ready'
function select(callback) {
  proxy.once('selected', callback)

  if (status === 'ready') {
    status = 'pending'
    db.select('SQL', function (results) {
      proxy.emit('selected', results)
      status = 'ready'
    })
  }
}
</code></pre>
<p>上述的 once 方法会将所有请求压入事件队列中，利用其执行一次就移除监视器的特点，保证每一个回调函数只会被执行一次。此处可能引发侦听器过多警告，可以通过调用<code>setMaxListeners(0)</code>移除警告或者设置更大值。</p>
<h2 id="四-手写-eventemitter"><a class="header" href="#四-手写-eventemitter">四 手写 EventEmitter</a></h2>
<pre><code class="language-js">function Event() {
  this._events = {}
}

Event.prototype.on = function (eName, callback) {
  // 支持继承类调用
  if (!this._events) {
    this._events[eName] = Object.create(null)
  }

  if (this._events[eName]) {
    this._events[eName].push(callback)
  } else {
    this._events[eName] = [callback]
  }
}

Event.prototype.emit = function (eName, ...args) {
  if (this._events[eName]) {
    this._events[eName].forEach((fn) =&gt; fn(...args))
  }
}

Event.prototype.off = function (eName, callback) {
  if (!this._events) {
    return
  }
  this._events[eName] = this._events[eName].filter((fn) =&gt; {
    fn !== callback &amp;&amp; fn.l !== callback
  })
}

Event.prototype.once = function (eName, callback) {
  const once = (...args) =&gt; {
    callback(...args)
    this.off(eName, once)
  }
  // 标识这个 once 是谁的
  once.l = callback
  this.on(eName, once)
}

module.exports = Event
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-node-的多进程-进程对象-process"><a class="header" href="#041-node-的多进程-进程对象-process">04.1-Node 的多进程-进程对象 process</a></h1>
<h2 id="一-全局对象-process"><a class="header" href="#一-全局对象-process">一 全局对象 process</a></h2>
<h3 id="11-process-上挂载的属性"><a class="header" href="#11-process-上挂载的属性">1.1 process 上挂载的属性</a></h3>
<p>process 是 Node 默认提供的一个全局对象，用于保存当前进程相关信息</p>
<p>常见方法有：</p>
<pre><code class="language-js">process.pid // 获取程序进程 id
process.version // 获取 node 版本号
process.config // 查看 node 配置
process.title // 获取进程名称
process.argv // 获取当前进程命令行参数数组
process.platform // 获取操作系统信息
process.env // 获取当前 shell 环境变量参数
</code></pre>
<h3 id="12-process-提供的标准流"><a class="header" href="#12-process-提供的标准流">1.2 process 提供的标准流</a></h3>
<p>Node 的 console 其实是通过 process 模块实现的：</p>
<p>标准输出流：</p>
<pre><code class="language-js">process.stdout.write('hello world\n') // 添加换行符后，其功能与 log 一致
</code></pre>
<p>标准错误流：</p>
<pre><code class="language-js">process.stderr.write('err\n')
</code></pre>
<p>标准输入流：</p>
<pre><code class="language-js">process.stdin.setEncoding('utf8') //控制台接受输入
process.stdin.on('readable', function () {
  let chunk = process.stdin.read()
  if (chunk != null) {
    process.stdout.write(chunk)
  }
})

process.stdin.on('end', function () {
  process.stdout.write('end') //控制台结案数输入
})
</code></pre>
<h3 id="13-process-操作信号"><a class="header" href="#13-process-操作信号">1.3 process 操作信号</a></h3>
<p>杀死进程：</p>
<pre><code class="language-js">process.on('SIGHUP', function () {
  console.log('get SIGHUP')
})
setTimeout(function () {
  process.exit(0) //真正的杀死进程
}, 1000)
process.kill(process.pid, 'SIGHUP') //kill 方法只是发送一个 sighup 信号
</code></pre>
<h3 id="14-process-的-nexttick-方法"><a class="header" href="#14-process-的-nexttick-方法">1.4 process 的 nextTick() 方法</a></h3>
<p>异步方法：<code>process.nextTick();</code> 比 setTimeout 效率高很多：</p>
<pre><code class="language-js">console.time('timeout---')
setTimeout(function () {
  console.log('test timeout')
}, 0)
console.timeEnd('timeout---')

console.time('timeout---')
process.nextTick(function () {
  console.log('test nextTick')
})
console.timeEnd('timeout---')
</code></pre>
<h2 id="二-processenv-与-环境变量-node_env"><a class="header" href="#二-processenv-与-环境变量-node_env">二 process.env 与 环境变量 NODE_ENV</a></h2>
<h3 id="21-node_env-概念"><a class="header" href="#21-node_env-概念">2.1 NODE_ENV 概念</a></h3>
<p><code>process.env</code> 是非常常见的一个属性，仅仅表示当前系统的环境变量！</p>
<p>在很多前端项目中都需要配置 Node 的环境变量，通常在 <code>package.json</code> 的 <code>scripts</code> 命令内容和 webpack 配置文件中可以看到 <code>NODE_ENV</code> 这个变量，值一般为 <code>production</code> 或者 <code>product</code>，也可以简写为 <code>dev</code> 或 <code>prod</code>。但是 <code>NODE_ENV</code> 并不是 process 对象上的，而是开发者自定义的环境变量，<code>process.env</code> 中也没有该变量相关信息。</p>
<p><code>NODE_ENV</code> 仅仅用来区分开发与生产环境，用来加载不同的配置，或这执行不同命令。若该值配置过后，就可以在 js 中直接获取：</p>
<pre><code class="language-js">process.env.NODE_ENV
</code></pre>
<h3 id="22-配置-node_env-环境变量"><a class="header" href="#22-配置-node_env-环境变量">2.2 配置 NODE_ENV 环境变量</a></h3>
<p>由于 <code>NODE_ENV</code> 是个环境变量，自然可以直接在操作系统中配置，但是笔者推荐在项目的<code>package.json</code> 中配置：</p>
<pre><code class="language-json">&quot;scripts&quot;: {
    &quot;start&quot;: &quot;export NODE_ENV='development' &amp;&amp; node app.js&quot; // 在 Mac 和 Linux 上使用 export，在 Win 上 export 要换成 set
},
</code></pre>
<p>为了解决上述平台兼容问题，可以安装第三方包 cross-env 来解决：</p>
<pre><code class="language-json">// 安装第三方包：npm install cross-env -D

// 配置 package.json
&quot;scripts&quot;: {
  &quot;start&quot;: &quot;cross-env NODE_ENV=development &amp;&amp; node app&quot;,
  &quot;build&quot;: &quot;cross-env NODE_ENV=production &amp;&amp; node app&quot;
}
</code></pre>
<p>webpack 中如果需要对 <code>NODE_ENV</code> 做默认值处理，则可以添加如下键值对：</p>
<pre><code class="language-js">NODE_ENV: process.env.NODE_ENV || 'development',
</code></pre>
<h2 id="三-获取启动参数"><a class="header" href="#三-获取启动参数">三 获取启动参数</a></h2>
<p>项目启动命令中可以输入额外参数，通过 process 可以获取：</p>
<pre><code class="language-js">// 在 app.js 中输入以下代码
console.log(process.argv.slice(2))
</code></pre>
<p>此时使用命令 <code>node app.js a b c</code> 得到运行结果为：</p>
<pre><code class="language-txt">[ 'a', 'b', 'c' ]
</code></pre>
<p>通常命令行参数都使用 <code>--port 3000</code> 方式：</p>
<pre><code class="language-js">let cfg = process.argv.slice(2).reduce((mem, cur, index, arr) =&gt; {
  if (cur.startsWith('--')) {
    mem[cur.slice(2)] = arr[index + 1]
  }
  return mem
}, {})

// 启动命令：node app --port 3000 --config webpack.config.js
console.log(cfg) // { port: '3000', config: 'webpac.config.js' }
</code></pre>
<p>当然实际开发中推荐使用第三方模块：<a href="https://www.npmjs.com/package/commander">https://www.npmjs.com/package/commander</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="042-node-的多进程-创建进程"><a class="header" href="#042-node-的多进程-创建进程">04.2-Node 的多进程-创建进程</a></h1>
<h2 id="一-node-的进程管理"><a class="header" href="#一-node-的进程管理">一 Node 的进程管理</a></h2>
<p>Node 由于单线程运行的原因，潜在的错误会导致线程崩溃，进程也随之退出。同时，单进程也无法充分利用当前多核 CPU。</p>
<p>Node 从 0.1 版本开始提供了 child_process 模块，提供多进程支持，并暴露了全局对象 process。</p>
<p>新建一个文件：worker.js</p>
<pre><code class="language-js">let http = require('http')

http
  .createServer(function (req, res) {
    res.writeHead(200, { 'Content-Type': 'text/plian' })
    res.end('hello world\n')
  })
  .listen()
</code></pre>
<p>新建一个文件：master.js</p>
<pre><code class="language-js">let child_process = require('child_process')
let os = require('os')

let cpuNum = os.cpus().length
console.log('当前 CPU 数量为：', cpuNum)

for (let i = 0; i &lt; cpuNum; i++) {
  child_process.fork('./worker.js')
}
</code></pre>
<p>启动并查看 node 进程数量 (和 cpu 数量相等)：</p>
<pre><code class="language-txt">node master.js

# 新开启一个命令行查看进程数
ps aux|grep worker.js
</code></pre>
<p>这时候 Node 就以多进程的方式启动了，这是著名的主从模式（Master-Worker），整个系统进程为了两部分：</p>
<ul>
<li>主进程：不负责具体业务，而是负责调度和管理工作进程</li>
<li>工作进程：负责具体的业务处理</li>
</ul>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/process-01.svg" alt="工作进程" /></p>
<p>通过 fork() 复制的进程都是一个独立的进程，每个进程中都包含着一个独立、全新的 V8 实例，需要至少 30 毫秒启动时间，至少 10MB 的内存。</p>
<p>fork() 是非常消耗资源的，但是 Node 本身的单线程非阻塞 I/O 已经解决了大并发问题，fork() 的作用仅仅是为了充分利用 CPU，而不是像以前的高并发架构中描述的使用多进程应对并发。</p>
<h2 id="二-child_process-模块"><a class="header" href="#二-child_process-模块">二 child_process 模块</a></h2>
<h3 id="20-创建进程的方法"><a class="header" href="#20-创建进程的方法">2.0 创建进程的方法</a></h3>
<p>child_process 模块提供了四种创建子进程的方法：</p>
<ul>
<li>spawn()：启动一个子进程来执行命令</li>
<li>exec()：与 spawn() 类似，但是该函数额外有一个回调函数可以获知子进程状况</li>
<li>fork()：与 spawn() 类似，但是创建的紫禁城只需要执行指定的 JS 文件模块即可</li>
<li>execFile()：启动一个子进程来执行可执行文件</li>
</ul>
<p>四者在执行第一节中 worker 的代码分别如下：</p>
<pre><code class="language-js">let cp = require('child_process')

cp.spwan('node', ['worker.js'])
cp.exec('node worker.js', function (err, stdout, stderr) {})
cp.execFile('worker.js', function (err, stdout, stderr) {})
cp.fork('./worker.js')
</code></pre>
<p>注意：</p>
<ul>
<li>exec，execFile、fork 基本都是借助于 spawn 方式实现的。</li>
<li>exec()，execFile() 创建子进程时，可以指定子进程的运行时间（timeout）。</li>
<li>execFile() 执行 JS 文件时，其首行内容必须添加：<code>#!/usr/bin/env node</code></li>
</ul>
<h3 id="21-spawn-创建进程"><a class="header" href="#21-spawn-创建进程">2.1 spawn 创建进程</a></h3>
<p>spawn 会使用指定的 command 生成一个新的进程，执行完对应的 command 后子进程自动退出。</p>
<p>示例：</p>
<pre><code class="language-js">let spawn = require('child_process').spawn

let ls = spawn('ls', ['-lh', '/usr']) // win 需要修改为： (&quot;powershell&quot;,[&quot;dir&quot;])

ls.stdout.on('data', function (data) {
  console.log('stdout:', data.toString())
})

ls.stderr.on('data', function (err) {
  console.log('stderr:', err.toString())
})

ls.on('close', function (code) {
  console.log('exited with code:', code)
})
</code></pre>
<h3 id="22-fork-创建进程"><a class="header" href="#22-fork-创建进程">2.2 fork 创建进程</a></h3>
<p>在 Linux 环境中，创建一个新进程的本质是复制一个当前继承，用户调用 fork 后，操作系统会为该进程分配新的空间，然后将父进程的数据原样复制一份过去（除了少数值不复制，如进程标识符 PID）。</p>
<p>在 Node 环境中，fork 并不会复制父进程，父子进程都有独立的内存空间和 V8 实例，父子进程之间唯一联系是用来进程间通信的 IPC Channel。</p>
<p>fork 接收的第一个参数是文件名，相当于在命令行调用了<code>node **.js</code>，父子进程之间通过 process.send 通信。</p>
<p>fork 内部会通过 spawn 调用 process.executePath，即 node 可执行文件地址，生成一个 node 实例，然后用这个实例来执行 for 方法的 modulePath 参数。</p>
<p>master.js:</p>
<pre><code class="language-js">let child_process = require('child_process')

let worker = child_process.fork('worker.js', ['args1'])

// 父进程向子进程发送信息
worker.send({
  hello: 'child',
})

worker.on('message', function (msg) {
  console.log('父进程接收的消息：', msg)
})

worker.on('exit', function () {
  console.log('child process exit')
})
</code></pre>
<p>worker.js:</p>
<pre><code class="language-js">let begin = process.argv[2]
console.log('子进程启动：', begin)

// 子进程向父进程发送信息
process.send({
  hello: 'parent',
})

process.on('message', function (msg) {
  console.log('子进程接收的消息：', msg)
  process.exit()
})
</code></pre>
<p>注意：</p>
<ul>
<li>fork 创建的进程运行完成后不会自动退出，需要 process.exit()</li>
<li>这些派生的 node 进程是全新的 V8 实例，假设每个 node 进程大致需要至少 30 毫秒启动时间和 10M 内存，也就是说不能创建成百上千的实例。</li>
<li>node 本身存在多个线程，但是运行在 V8 上的 JS 是单线程的。</li>
<li>node 中的 exit 和 close 事件虽然都是退出、结束的意思，但是 exit 事件后，标准输入输出流仍然在开启，而 close 事件后是在一个子进程中所有的标准输入、输出流被终止时触发，因为多进程有时候会共享一个标准输入、输出流。</li>
<li>在 Node 中，正常退出时，退出码定义为 0，非正常为 1-3 之间的数字。</li>
</ul>
<h3 id="23-exec-和-execfile"><a class="header" href="#23-exec-和-execfile">2.3 exec 和 execFile</a></h3>
<p>在一个庞大的系统中，不同的模块可能使用不同的技术开发，比如 web 服务使用 Node 开发，消息队列使用 Java 开发，二者之间通信通常使用进程通信方式实现，但是有时候开发者认为该方式过于复杂，采用折中的方式，例如通过 shell 调用目标服务，拿到结果。</p>
<p>spawn、exec、execFile 都可以在 shell 中执行命令，运行文件：</p>
<ul>
<li>spawn：spawn 会调用系统的 shell 工具，使用流式处理方式，子进程产生数据时，主进程可以通过监听事件获取消息</li>
<li>exec：exec 会根据当前环境初始化一个 shell 工具，将所有返回的信息放在 stdout 里一次性返回，如果返回的数据大小超过了 exec 方法参数 maxBuffer，报错</li>
<li>execFile：execFile 是 exec 的内部实现方式，更底层，无须启动一个 shell，效率更高</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="043-node-的多进程-进程间通信"><a class="header" href="#043-node-的多进程-进程间通信">04.3-Node 的多进程-进程间通信</a></h1>
<h2 id="一-node-进程间通信演示"><a class="header" href="#一-node-进程间通信演示">一 Node 进程间通信演示</a></h2>
<p>在 Master-Worker 模式中，如果要实现主进程管理和调度，就需要主进程与工作进程之间通信。HTML5 规范中，WebWorker 雷公了工作者与主进程通信的方法，Node 与该方式相似。</p>
<p>创建 master.js：</p>
<pre><code class="language-js">let cp = require('child_process')

let childP = cp.fork('./worker.js')

childP.on('message', function (msg) {
  console.log('master get：', msg)
})

childP.send({
  name: 'father',
})
</code></pre>
<p>创建 worker.js：</p>
<pre><code class="language-js">process.on('message', function (msg) {
  console.log('worker get: ', msg)
})

process.send({
  name: 'child',
})
</code></pre>
<p>启动：</p>
<pre><code class="language-txt">node master.js
</code></pre>
<h2 id="二-进程间通信原理"><a class="header" href="#二-进程间通信原理">二 进程间通信原理</a></h2>
<p>进程间通信 Inter-Process Communication 简称 IPC。其目的是为了让不同的进程能够互相访问资源并进行协调工作。进程间通信的实现方式很多，如：命名管道、匿名管道、socket、信号量、共享内存、消息队列等。</p>
<p>Node 中进程间通信的实现依靠的是底层的 libuv 提供的一层类似管道的抽象，该抽象在 Linux 上采用 Unix Domain Socket 实现，在 Win 上通过命名管道实现。</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/process-02.png" alt="进程通信原理" /></p>
<p>父进程在实际创建子进程之前，会创建 IPC 通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个 IPC 通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已经存在的 IPC 通道，从而完成父子进程之间的连接：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/process-03.png" alt="进程通信原理" /></p>
<p>建立连接之后的父子进程可以进行自由通信，因为 Node 使用的是 Domain Socket，与网络 Socket 非常相似，属于双向通信，而且是在内核中直接完成了进程间通信，无需网络层，非常高效。在 Node 中，IPC 通道被抽象为了 Stream 对象，调用 send() 时会发送数据（类似 write()），接收到的消息会通过 message 事件触发给应用层。</p>
<p>注意：子进程为 Node 进程时，子进程才能根据环境变量去连接 IPC 通道，进行通信，除非其他进程按照约定去连接这个已经创建好的 IPC 通道。</p>
<h2 id="三-句柄传递"><a class="header" href="#三-句柄传递">三 句柄传递</a></h2>
<h3 id="31-句柄概念"><a class="header" href="#31-句柄概念">3.1 句柄概念</a></h3>
<p>在 fork Node 的 web 服务进程时，并没有指定端口，一旦指定端口，将会出现只有一个工作进程能够正常监听端口，其他工作进程会抛出端口已被占用的错误，无法复制出子进程。</p>
<p>上述为问题的解决方式一般是：主进程监听主端口，负责接收所有的请求，然后再将这些请求分别代理到不同的端口的工作进程上。</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/process-04.png" alt="句柄" /></p>
<p>这里会暴露一个问题：主进程每接收到一个连接，就会创建一个新的文件描述符，并将请求负载（代理）到某个工作进程，文件描述符在操作系统中是有限的（双倍浪费！）。Node 为了解决该问题，在 send() 方法中额外提供了第二个可选参数：句柄。</p>
<pre><code class="language-js">child.send(message, [sendHandle])
</code></pre>
<p>句柄就是一种用来标识资源的引用，它的内部包含了指向对象的文件描述符，所以句柄可以用来标识一个服务端 socket 对象、一个 UDP 套接字、一个管道等。</p>
<p>在代理方案中，主进程接收到 socket 请求后，不再重新与工作进程之间创建新的 socket 连接来转发数据，而是直接将这个 socket 传递给工作进程！</p>
<h3 id="32-句柄示例"><a class="header" href="#32-句柄示例">3.2 句柄示例</a></h3>
<p>主进程：</p>
<pre><code class="language-js">let cp = require('child_process')

let child = cp.fork('child.js')

let server = require('net').createServer()

server.on('connection', function (socket) {
  socket.end('handled by parent\n')
})

server.listen(1337, function () {
  child.send('server', server)
})
</code></pre>
<p>子进程：</p>
<pre><code class="language-js">process.on('message', function (msg, server) {
  if (msg === 'server') {
    server.on('connection', function (socket) {
      socket.end('handled by child\n')
    })
  }
})
</code></pre>
<p>在该示例中，直接将一个 TCP 连接发送给了子进程，启动方式如下：</p>
<pre><code class="language-txt"># 启动
node master.js

# 新建命令行，发送请求，会发现主进程与子进程进来来回切换处理请求
curl &quot;http://127.0.0.1:1337/&quot;
curl &quot;http://127.0.0.1:1337/&quot;
curl &quot;http://127.0.0.1:1337/&quot;
curl &quot;http://127.0.0.1:1337/&quot;
</code></pre>
<h3 id="33-测试将服务发送给多个子进程"><a class="header" href="#33-测试将服务发送给多个子进程">3.3 测试将服务发送给多个子进程</a></h3>
<p>master.js 如下：</p>
<pre><code class="language-js">let cp = require('child_process')

let child1 = cp.fork('child.js')
let child2 = cp.fork('child.js')

let server = require('net').createServer()

server.on('connection', function (socket) {
  socket.end('handled by parent\n')
})

server.listen(1337, function () {
  child1.send('server', server)
  child2.send('server', server)
})
</code></pre>
<p>子进程打印出 pid：</p>
<pre><code class="language-js">process.on('message', function (msg, server) {
  if (msg === 'server') {
    server.on('connection', function (socket) {
      socket.end('handled by child, pid is ' + process.pid + '\n')
    })
  }
})
</code></pre>
<p>再次测试：</p>
<pre><code class="language-txt"># 启动
node master.js

# 新建命令行，发送请求，会发现主进程与子进程进来来回切换处理请求
curl &quot;http://127.0.0.1:1337/&quot;
curl &quot;http://127.0.0.1:1337/&quot;
curl &quot;http://127.0.0.1:1337/&quot;
curl &quot;http://127.0.0.1:1337/&quot;
</code></pre>
<p>此时出现的结果中，父进程、两个子进程都有可能在处理业务</p>
<h3 id="34-切换到-http"><a class="header" href="#34-切换到-http">3.4 切换到 HTTP</a></h3>
<p>现在可以测试父进程的 YCP 服务在发送完句柄后直接关闭，并且让子进程启动一个 HTTP 服务来处理实际业务。</p>
<p>master.js 在传递出句柄后，直接关闭：</p>
<pre><code class="language-js">let cp = require('child_process')

let child1 = cp.fork('worker.js')
let child2 = cp.fork('worker.js')

let server = require('net').createServer()

server.listen(1337, function () {
  child1.send('server', server)
  child2.send('server', server)
  server.close() // 关闭服务
})
</code></pre>
<p>child.js 使用 http 模块处理业务：</p>
<pre><code class="language-js">let http = require('http')

let server = http.createServer(function (req, res) {
  res.writeHead(200, { 'Content-Type': 'text/plain' })
  res.end('handled by child, pid is ' + process.pid + '\n')
})

process.on('message', function (msg, tcpSocket) {
  if (msg === 'server') {
    tcpSocket.on('connection', function (socket) {
      server.emit('connection', socket)
    })
  }
})
</code></pre>
<p>再次启动测试，此时所有的请求都是由子进程进行处理了。在整个服务中，发生了一次转变：</p>
<p>主进程将请求发送给工作进程：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/process-05.png" alt="主进程将请求发送给工作进程" /></p>
<p>主进程发送完句柄并关闭监听后：</p>
<p><img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/process-06.png" alt="主进程将请求发送给工作进程" /></p>
<p>此时多个子进程就可以同时监听相同的端口，没有端口重复监听的异常了。</p>
<h2 id="四-句柄原理"><a class="header" href="#四-句柄原理">四 句柄原理</a></h2>
<p>目前子进程对象 send() 方法可以发送的句柄类型有：</p>
<ul>
<li>net.Socket:TCP 套接字</li>
<li>net.Server:TCP 服务器，可以是任意建立在 TCP 服务商应用服务</li>
<li>net.Native:C++层面的 TCP 套接字或者 IPC 管道</li>
<li>dgram.Socket:UDP 套接字</li>
<li>dgram.Native:C++层面的 UDP 套接字</li>
</ul>
<p>send() 方法在讲消息发送到 IPC 管道前，将消息组装成 2 个对象，一个是参数 handle，另外一个 message，message 参数如下：</p>
<pre><code class="language-json">{
  &quot;cmd&quot;: &quot;NODE_HANDLE&quot;,
  &quot;type&quot;: &quot;net.Server&quot;,
  &quot;msg&quot;: message
}
</code></pre>
<p>发送到 IPC 管道中的实际上是我们要发送的句柄文件描述符，即一个整数值。以发送 TCP 服务器句柄为例，子进程收到消息后还原过程如下：</p>
<pre><code class="language-js">function(message, handle, emit){
    let self = this;
    let server = new net.Server();
    server.listen(handle, function(){
        emit(server);
    });
}
</code></pre>
<p>在上述代码中，子进程根据 message.type 创建对饮的 TCP 服务器对象，然后监听到文件描述符上，由于底层细节不被应用层感知，所以在子进程中，开发者有一种服务器就是从父进程中直接传递过来的错觉。注意：Node 进程组回见只有消息传递，不会真正传递对象，错觉是封装的结果，消息在发送时候序列化为字符串，接收到后再反序列化为对象。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="044-node-的多进程-多进程服务部署"><a class="header" href="#044-node-的多进程-多进程服务部署">04.4-Node 的多进程-多进程服务部署</a></h1>
<h2 id="零-服务部署"><a class="header" href="#零-服务部署">零 服务部署</a></h2>
<p>使用多进程架构搭建了 Node 集群环境，充分利用了多核 CPU 资源，但是仍然有很多细节要考虑：</p>
<ul>
<li>多个工作进程的存活状态管理</li>
<li>工作进程的平滑重启</li>
<li>配置数据的动态载入</li>
<li>等等</li>
</ul>
<h2 id="一-进程事件"><a class="header" href="#一-进程事件">一 进程事件</a></h2>
<p>send() 方法除了 message 事件外，还有其他以下事件：</p>
<ul>
<li>error：子进程无法被复制，无法被杀死，无法发送消息时触发</li>
<li>exit：子进程退出时触发，如果是正常退出，该事件第一个参数为退出码，否则为 null。如果子进程是通过 kill 退出，则会得到第二个参数，表示杀死进程时的信号</li>
<li>close：在子进程的标准输入、输出流终止时触发，参数与 exit 相同</li>
<li>disconnect：在父进程或子进程中调用 disconnect() 方法时触发该事件，在调用该方法时将关闭监听 IPC 通道</li>
</ul>
<p>kill() 方法并不能真正将通过 IPC 相连的子基础讷航杀死，只是给子进程发送了一个系统信号：</p>
<pre><code class="language-js">// 子进程
child.kill([signal])

// 当前进程
process.kill(pid, [signal])
</code></pre>
<p>上述代码一个发送给子进程，一个发送给目标进程。Node 提供了大部分信号的事件操作用来通知进程：</p>
<pre><code class="language-js">process.on('SIGTERM', function () {
  console.log('Got a SIGTERM, exiting...')
  process.exit(1)
})

console.log('server running with PID:', process.pid)

process.kill(process.pid, 'SIGTERM')
</code></pre>
<h2 id="二-自动重启"><a class="header" href="#二-自动重启">二 自动重启</a></h2>
<h3 id="21-自动重启的实现"><a class="header" href="#21-自动重启的实现">2.1 自动重启的实现</a></h3>
<p>有了父子进程之间的事件机制，可以通过监听子进程的 exit 事件来获知退出的信息，就可以重新启动一个工作进程来继续服务。</p>
<p>master 代码如下：</p>
<pre><code class="language-js">var cp = require('child_process')
var os = require('os')
var net = require('net')

var server = net.createServer()
server.listen(1337)

var workers = {}

// 启动时，循环创建多个工作进程
var cpuNum = os.cpus().length
for (var i = 0; i &lt; cpuNum; i++) {
  createWorker()
}

// 进程自己退出时，让所有工作进程退出
process.on('exit', function () {
  for (var pid in workers) {
    workers[pid].kill()
  }
})

function createWorker() {
  var worker = fork('./worker.js')

  // 退出时重新启动进程
  worker.on('exit', function () {
    delete workers[worker.pid]
    createWorker()
  })

  // 句柄转发
  worker.send('server', server)
  workers[worker.pid] = worker
}
</code></pre>
<p>此时产生的工作进程如果使用 kill 命令杀死，则会再次重新启动一个新的工作进程。</p>
<p>实际场景中，也会有 bug 导致的工作进程退出，需要对该异常进行处理，worker.js 如下：</p>
<pre><code class="language-js">var http = require('http')

var server = http.createServer(function (req, res) {
  res.writeHead(200, { 'Content-Type': 'text/plain' })
  res.end('handled by child, pid is ' + process.pid + '\n')
})

var worker

process.on('message', function (msg, tcpSocket) {
  if (msg === 'server') {
    worker = tcpSocket
    worker.on('connection', function (socket) {
      server.emit('connection', socket)
    })
  }
})

process.on('uncaughtException', function () {
  // 停止接收新的连接
  worker.close(function () {
    // 所有连接断开后，退出进程
    process.exit(1)
  })
})
</code></pre>
<p>在上述代码中，一旦有未捕获的异常出现，工作进程就会立即停止接收新的连接，当所有连接断开后，退出进程。主进程在真挺到工作进程的 exit 后，将会立即启动新的进程服务，以此保证整个集群中总是有进程在为用户服务。</p>
<h3 id="22-自杀信号"><a class="header" href="#22-自杀信号">2.2 自杀信号</a></h3>
<p>在 2.1 中的代码，仍然有问题：所有连接断开后进程才退出，在极端场景下，所有工作进程都停止接收新的连接，全部处在等待退出状态，在此过程中，所有新来的请求都无法正常获得服务！</p>
<p>为了解决上述问题，必须不能再工作进程退出后才重新启动新的工作进程，当然更不能直接退出工作进程，这样会断开当前正在服务的用户。可以在退出流程中增加自杀信号（suicide），工作进程在得知要退出时，向主进程发送一个自杀信号，然后才停止接收新的连接，当所有连接断开后才退出。主进程接收到自杀信号后，立即创建新的工作进程服务。</p>
<p>worker.js：</p>
<pre><code class="language-js">process.on('uncaughtException', function () {
  process.send({
    act: 'suicide',
  })

  // 停止接收新连接
  worker.close(function () {
    // 所有已有连接断开后，退出进程
    process.exit(1)
  })
})
</code></pre>
<p>master.js 的修改：</p>
<pre><code class="language-js">// 进程自己退出时，让所有工作进程退出
process.on('exit', function () {
  for (var pid in workers) {
    workers[pid].kill()
  }
})

function createWorker() {
  var worker = fork('./worker.js')

  // 启动新进程
  worker.on('message', function (msg) {
    if (msg.act === 'suicide') {
      createWorker()
    }
  })

  // 退出时重新启动进程
  worker.on('exit', function () {
    delete workers[worker.pid]
    createWorker()
  })

  // 句柄转发
  worker.send('server', server)
  workers[worker.pid] = worker
}
</code></pre>
<p>现在模拟异常退出，将工作进程的业务处理代码改为抛出异常，一旦有用户请求，就会有一个工作进程退出：</p>
<pre><code class="language-js">var server = http.createServer(function (req, res) {
  res.writeHead(200, { 'Content-Type': 'text/plain' })
  res.end('handled by child, pid is ' + process.pid + '\n')
  throw new Error('throw exception')
})
</code></pre>
<p>上述方案：创建新的工作进程在前，退出异常进程在后，每个异常进程退出前，都有新的工作进程来替换！应用的健壮性就大幅提升。</p>
<h3 id="23-长连接问题"><a class="header" href="#23-长连接问题">2.3 长连接问题</a></h3>
<p>在 2.2 中，如果不是 HTTP 短连接，而是长连接，等待长连接断开耗时较久，可以为已有连接的断开设置一个超时时间：</p>
<pre><code class="language-js">process.on('uncaughtException', function () {
  // 记录一些系统日志

  // 发送自杀信号
  process.send({
    act: 'suicide',
  })

  // 停止接收新连接
  worker.close(function () {
    // 所有已有连接断开后，退出进程
    process.exit(1)
  })

  // 5 秒后退出进程
  setTimeout(function () {
    process.exit(1)
  }, 5000)
})
</code></pre>
<h3 id="24-限量重启"><a class="header" href="#24-限量重启">2.4 限量重启</a></h3>
<p>还有一个极端情况：工作进程不能被无限制重启，比如一些程序 BUG 上线后导致频繁重启是无意义的，必须保证程序不能反复无意义重启。比如在规定在单位时间内只能重启多少次，超过触发 giveup 事件：</p>
<pre><code class="language-js">var cp = require('child_process')
var os = require('os')
var net = require('net')

var server = net.createServer()
server.listen(1337)

var workers = {}

// 启动时，循环创建多个工作进程
var cpuNum = os.cpus().length
for (var i = 0; i &lt; cpuNum; i++) {
  createWorker()
}

// 进程自己退出时，让所有工作进程退出
process.on('exit', function () {
  for (var pid in workers) {
    workers[pid].kill()
  }
})

var limit = 10 // 重启次数
var during = 60000 // 时间单位
var restart = [] //
function isTooFrequently() {
  // 记录重启时间
  var time = Date.now()
  var length = restart.push(time)
  if (length &gt; limit) {
    // 取出最后 10 个记录
    restart = restart.slice(limit * -1)
  }

  // 最后一次重启到钱 10 次重启之间的时间间隔
  return (
    restart.length &gt;= limit &amp;&amp; restart[restart.length - 1] - restart[0] &lt; during
  )
}

function createWorker() {
  // 检查是否太频繁
  if (isTooFrequently()) {
    process.emit('giveup', length, during)
    return
  }

  var worker = fork('./worker.js')

  // 启动新进程
  worker.on('message', function (msg) {
    if (msg.act === 'suicide') {
      createWorker()
    }
  })

  // 退出时重新启动进程
  worker.on('exit', function () {
    delete workers[worker.pid]
    createWorker()
  })

  // 句柄转发
  worker.send('server', server)
  workers[worker.pid] = worker
}
</code></pre>
<h2 id="三-负载均衡"><a class="header" href="#三-负载均衡">三 负载均衡</a></h2>
<p>在多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，让 CPU 被充分利用了，但是还有一个极端情况：某个特定的 CPU 还没处理完任务就被分配一个新的任务，久而久之，这个 CPU 相较于其他 CPU 负载更大。</p>
<p>负载均衡策略就是让各个工作进程能够合理分配到任务。Node 在 0.11 之后，引入的负载均衡策略是 Round-Robin，即轮叫调度：</p>
<pre><code class="language-txt">由主进程接收连接，依次分发给工作进程
分发策略：在 N 个工作进程中，每次选择第 i = (i + 1)mod n 个进程来发送连接
</code></pre>
<p>启用轮叫调度的方式：</p>
<pre><code class="language-txt"># 方式一：在 cluster 模块中启动
cluster.schedulingPolicy = cluster.SCHED_RR     # 关闭为：cluster.schedulingPolicy = cluster.SCHED_NONE

# 方式二：环境变量中设置 NODE_CLUSTER_SCHED_POLICY 的值
export NODE_CLUSTER_SCHED_POLICY=rr             # 关闭为：export NODE_CLUSTER_SCHED_POLICY=none
</code></pre>
<h2 id="四-企业级进程管理工具-pm2"><a class="header" href="#四-企业级进程管理工具-pm2">四 企业级进程管理工具 pm2</a></h2>
<p>针对上面中 Node 的问题，有些第三方专业工具可以进行 Node 的多进程管理，如进程管理工具 pm2，pm2 可以有效的监控服务器状况，并让 node 服务器自动重启，支持守护进程。</p>
<p>安装 pm2：</p>
<pre><code class="language-txt">npm install pm2 -g
</code></pre>
<p>使用 pm2：</p>
<pre><code class="language-txt">开启：pm2 start ***.js                      # node 关闭窗口仍然运行，且会自动重启
参数启动：pm2 start **.js --name=”test”    # 启动应用程序并命名为 &quot;api&quot;
关闭：pm2 stop **.js
重启：pm2 restart **.js
</code></pre>
<p>pm2 可以监控并管理多个应用程序，并对其进行日志监控。</p>
<p>进程监控命令：<code>pm2 list</code>，监控界面：
<img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/pm2list.png" alt="pm2 监控界面" /></p>
<p>日志监控：<code>pm2 logs 项目名/id名</code>，监控界面：
<img src="06-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../images/node/pm2logs.png" alt="pm2 监控界面" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="045-node-的多进程-集群模块-cluster"><a class="header" href="#045-node-的多进程-集群模块-cluster">04.5-Node 的多进程-集群模块 cluster</a></h1>
<h2 id="一-cluster-模块概述"><a class="header" href="#一-cluster-模块概述">一 cluster 模块概述</a></h2>
<p>child_process 模块虽然提供了大多数多进程架构所需的功能，但是构建一个健壮的单机集群，仍然需要很多细节处理，如考虑上一节中的自动重启、负载均衡等。</p>
<p>cluster 模块在 Node v0.8 版本推出，解决了 child_process 的问题，既能解决多核 CPU 利用率问题，也提供了完善的 API，解决程序健壮性问题，如：子进程管理、负载均衡等。</p>
<p>使用 cluster 实现一个 Node 进程集群：</p>
<pre><code class="language-js">var cluster = require('cluster')
var http = require('http')
var os = require('os')

var numCPUs = os.cpus().length

if (cluster.isMaster) {
  for (var i = 0; i &lt; numCPUs; i++) {
    cluster.fork()
  }

  cluster.on('exit', function (worker, code, signal) {
    console.log('worker ' + worker.process.pid + ' died')
  })
} else {
  http
    .createServer(function (req, res) {
      res.writeHead(200)
      res.end('hello world\n')
    })
    .listen(8000)
}
</code></pre>
<p>在进程中判断是主进程还是工作进程，取决于环境变量中是否有<code>NODE_UNIQUE_ID</code>：</p>
<pre><code class="language-js">cluster.isWorker = 'NODE_UNIQUE_ID' in process.env
cluster.isMaster = cluster.isWorker === false
</code></pre>
<h2 id="二-cluster-事件"><a class="header" href="#二-cluster-事件">二 cluster 事件</a></h2>
<p>cluster 为健壮性提供了很多事件：</p>
<ul>
<li>fork：复制一个工作进城后触发该事件</li>
<li>online：复制一个工作进程后，工作进程主动发送一条 online 消息给主进程，主进程收到消息后，触发该事件</li>
<li>listening：工作进程中调用 listen()，发送一条 listening 消息给主进程，主进程收到消息后，触发该事件</li>
<li>disconnect：主进程和工作进程之间 IPC 通道断开后回触发该事件</li>
<li>exit：有工作进程退出时触发该事件</li>
<li>setup：cluster.setupMaster() 执行后触发该事件</li>
</ul>
<h2 id="三-cluster-工作原理"><a class="header" href="#三-cluster-工作原理">三 cluster 工作原理</a></h2>
<p>cluster 模块本质上就是 child_process 和 net 模块的组合，cluster 在启动时，会在内部启动 TCP 服务器，cluster.fork() 时，将这个 TCP 服务器端的 socket 文件描述符发送给工作进程。如果进程是通过 cluster.fork() 出来的，那么其环境变量存在 NODE_UNIQUE_ID，如工作进程中存在 listen() 真挺网络端口的地爱用，它将拿到该文件描述符，并通过 SO_REQUSEADDR 端口重用，从而实现多个子进程共享端口。</p>
<p>使用 cluster 方式没有 child_process 灵活，因为自己通过 child_process 操作子进程时，可以隐式创建多个 TCP 服务器，使得子进程可以共享多个服务端的 socket。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-js-的多线程-工作者概念"><a class="header" href="#051-js-的多线程-工作者概念">05.1-JS 的多线程-工作者概念</a></h1>
<h2 id="一-工作者初识"><a class="header" href="#一-工作者初识">一 工作者初识</a></h2>
<h3 id="11-工作者概念"><a class="header" href="#11-工作者概念">1.1 工作者概念</a></h3>
<p>JavaScript 的业务代码在浏览器中是以单线程方式运行的，所以 JS 不可能像 Java 那样把工作委托给独立的线程去做，而且 JS 的 DOM API 也会因为多线程执行并发更改出现问题，所以 Java 这种线程模型也不适合 JavaSCript。</p>
<p>浏览器每打开一个页面，其实就会分配一个虚拟的运行环境，这个环境有自己的内存、事件循环、DOM 等。每个页面都是一个独立的沙盒，不会干扰其他页面，而且他们是并行执行的。</p>
<p>新推出的工作者，可以让浏览器在原始页面环境之外再分配一个完全独立的二级子环境。<strong>类似线程，这个子环境可以与父环境并行执行代码</strong>，但是不能与依赖单线程交互的 API（如 DOM）进行互操作。</p>
<h3 id="12-工作者与传统线程比较"><a class="header" href="#12-工作者与传统线程比较">1.2 工作者与传统线程比较</a></h3>
<p>工作者与传统执行线程有很多相似的地方：</p>
<ul>
<li>创建线程的底层核心类似：工作者也是由传统的线程实现的。</li>
<li>都能够在父环境中并行执行代码</li>
<li>都可以共享一些内存：工作者线程能够使用 SharedArrayBuffer 在多个环境间共享内容。</li>
</ul>
<p>工作者与传统执行线程的区别：</p>
<ul>
<li>工作者创建开销很大：工作者有自己独立的事件循环、全局对象等 JS 必须的特性，创建开销较大。</li>
<li>工作者不一定在同一个进程：传统情况下，一个进程内部产生多个线程实现并发，但是工作者可能与当前页面属于同一个进程，也可能不属于。例如：Blink 引擎对共享工作者线程和服务工作者线程使用独立的进程。</li>
<li>并发控制不同：传统线程采用锁进行并发控制，JS 采用 Atomics 接口实现并发控制。</li>
<li>工作者不共享所有内存：在传统线程模型中，多线程有能力读写共享内存空间。除了 SharedArrayBuffer 外，从工作者线程进出的数据需要复制或转移。</li>
</ul>
<p>综合以上发现，工作者线程相对比较重，不是用于替代线程而出现的。工作者线程应该是长期运行的，启动成本比较高，每个实例占用内存也比较大。</p>
<h3 id="13-工作者分类"><a class="header" href="#13-工作者分类">1.3 工作者分类</a></h3>
<p>Web 规范定义了多种工作者，主要有三种：</p>
<ul>
<li>专用工作者：通常简称为工作者线程、Web Worker 或 Worker，是一种实用的工具，可以让脚本单独创建一个 JavaScript 线程，以执行委托的任务，所以其只能被创建它的页面使用。</li>
<li>共享工作者：与专用工作者线程相似，但共享工作者线程可以被多个不同的上下文使用，包括不同的页面。任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或从中接收消息。</li>
<li>服务工作者：与上述二者不同，用于拦截、重定向和修改页面发出的请求，充当网络请求的仲裁者的角色。</li>
</ul>
<h3 id="14-workerglobalscope"><a class="header" href="#14-workerglobalscope">1.4 WorkerGlobalScope</a></h3>
<p>工作者环境是没有 window 对象的，其全局对象是 WorkerGlobalScope 的实例，通过 self 关键字获取。</p>
<p>WorkerGlobalScope 属性和方法：</p>
<pre><code class="language-txt">navigator：返回与工作者线程关联的 WorkerNavigator。
self：返回 WorkerGlobalScope 对象。
location：返回与工作者线程关联的 WorkerLocation。
performance：返回（只包含特定属性和方法的）Performance 对象。
console：返回与工作者线程关联的 Console 对象；对 API 没有限制。
caches：返回与工作者线程关联的 CacheStorage 对象；对 API 没有限制。
indexedDB：返回 IDBFactory 对象。
isSecureContext：返回布尔值，表示工作者线程上下文是否安全。
origin：返回 WorkerGlobalScope 的源。
</code></pre>
<p>self 对象上暴露的一些方法也是 window 上方法的子集。这些 self 上的方法也与 window 上对应的方法操作一样：</p>
<pre><code class="language-js">atob()
btoa()
clearInterval()
clearTimeout()
createImageBitmap()
fetch()
setInterval()
setTimeout()
importScripts() // 工作者线程专用
</code></pre>
<p>每种类型的工作者线程都使用了自己特定的全局对象，他们继承自 WorkerGlobalScope：</p>
<ul>
<li>专用工作者线程使用 DedicatedWorkerGlobalScope</li>
<li>共享工作者线程使用 SharedWorkerGlobalScope</li>
<li>服务工作者线程使用 ServiceWorkerGlobalScope</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="052-js-的多线程-专用工作者线程的基本使用"><a class="header" href="#052-js-的多线程-专用工作者线程的基本使用">05.2-JS 的多线程-专用工作者线程的基本使用</a></h1>
<h2 id="一-专用工作者线程基本使用"><a class="header" href="#一-专用工作者线程基本使用">一 专用工作者线程基本使用</a></h2>
<h3 id="11-创建专用工作者线程"><a class="header" href="#11-创建专用工作者线程">1.1 创建专用工作者线程</a></h3>
<p>专用工作者线程是最简单的工作者，可以在当前网页执行页面线程之外的其他任务，如：与父页面交换信息、发送网络请求、执行文件输出/输出、密集计算等。由此可见，专用工作者线程其实可以称为后台脚本（background script）。</p>
<p>main.js：使用 vscode 的 liveserver 插件启动</p>
<pre><code class="language-js">const worker = new Worker(
  './worker.js', // 脚本路径：只能从与父页面相同的源加载
  // 可选配置参数
  {
    name: 'worker1', // 工作者可以通过 self.name 获取
    type: 'classic', // 脚本运行方式，classic 为常规脚本执行，module 为模块执行
    credentials: 'omit', // 默认 omit。type 为 module 时指定如何获取相关的工作者线程模块脚本
  }
)
console.log('worker:', worker)
</code></pre>
<p>worker.js：</p>
<pre><code class="language-js">console.log('self:', self)
</code></pre>
<p>Worker()构造函数允许将可选的配置对象作为第二个参数。该配置对象支持下列属性。</p>
<ul>
<li>name：可以在工作者线程中通过 self.name 读取到的字符串标识符。</li>
<li>type：表示加载脚本的运行方式，可以是&quot;classic&quot;或&quot;module&quot;。 &quot;classic&quot;将脚本作为常规脚本来执行， &quot;module&quot;将脚本作为模块来执行。</li>
<li>credentials：在 type 为&quot;module&quot;时，指定如何获取与传输凭证数据相关的工作者线程模块脚本。值可以是&quot;omit&quot;、&quot;same-orign&quot;或&quot;include&quot;这些选项与 fetch()的凭证选项相同。在 type 为&quot;classic&quot;时，默认为&quot;omit&quot;。</li>
</ul>
<h3 id="12-工作者线程安全限制"><a class="header" href="#12-工作者线程安全限制">1.2 工作者线程安全限制</a></h3>
<p>基于加载脚本创建的工作者线程不受文档的内容安全策略限制，因为工作者线程在与父文档不同的上下文中运行。不过，如果工作者线程加载的脚本带有全局唯一标识符（与加载自一个二进制大文件一样），就会受父文档内容安全策略的限制。</p>
<p><code>new Worker()</code> 返回的实例是与创建的对应专用工作者线程通信的连接点，用来在父上下文与工作者线程之间传输信息、捕获专用工作者线程发出的事件。</p>
<h3 id="13-使用-worker-对象"><a class="header" href="#13-使用-worker-对象">1.3 使用 Worker 对象</a></h3>
<p>Worker 对象支持的事件处理程序：</p>
<ul>
<li>onerror：在工作者线程中发生 ErrorEvent 类型的错误事件时会调用指定给该属性的处理程序。
<ul>
<li>该事件会在工作者线程中抛出错误时发生。</li>
<li>该事件也可以通过 worker.addEventListener('error', handler) 的形式处理。</li>
</ul>
</li>
<li>onmessage：在工作者线程中发生 MessageEvent 类型的消息事件时会调用指定给该属性的处
理程序。
<ul>
<li>该事件会在工作者线程向父上下文发送消息时发生。</li>
<li>该事件也可以通过使用 worker.addEventListener('message', handler) 处理。</li>
</ul>
</li>
<li>onmessageerror：在工作者线程中发生 MessageEvent 类型的错误事件时会调用指定给该属
性的处理程序。
<ul>
<li>该事件会在工作者线程收到无法反序列化的消息时发生。</li>
<li>该事件也可以通过使用 worker.addEventListener('messageerror', handler) 处理。</li>
</ul>
</li>
</ul>
<p>Worker 对象支持的方法：</p>
<ul>
<li>postMessage()：用于通过异步消息事件向工作者线程发送信息。</li>
<li>terminate()：用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。</li>
</ul>
<h3 id="14-全局作用域对象-dedicatedworkerglobalscope"><a class="header" href="#14-全局作用域对象-dedicatedworkerglobalscope">1.4 全局作用域对象 DedicatedWorkerGlobalScope</a></h3>
<p>在专用工作者线程内部，全局作用域是 DedicatedWorkerGlobalScope 的实例，继承自 WorkerGlobalScope，通过 self 获取：</p>
<pre><code class="language-js">globalScopeWorker.js
console.log('inside worker:', self)
main.js
const worker = new Worker('./globalScopeWorker.js')
console.log('created worker:', worker)
// created worker: Worker {}
// inside worker: DedicatedWorkerGlobalScope {}
</code></pre>
<p>DedicatedWorkerGlobalScope 在 WorkerGlobalScope 基础上增加了以下属性和方法。</p>
<ul>
<li>name：可以提供给 Worker 构造函数的一个可选的字符串标识符。</li>
<li>postMessage()：与 worker.postMessage()对应的方法，用于从工作者线程内部向父上下文发送消息。</li>
<li>close()：与 worker.terminate()对应的方法，用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。</li>
<li>importScripts()：用于向工作者线程中导入任意数量的脚本。</li>
</ul>
<h2 id="二-专用工作者线程的生命周期"><a class="header" href="#二-专用工作者线程的生命周期">二 专用工作者线程的生命周期</a></h2>
<p>调用 Worker()构造函数是一个专用工作者线程生命的起点。调用之后，它会初始化对工作者线程脚本的请求，并把 Worker 对象返回给父上下文。虽然父上下文中可以立即使用这个 Worker 对象，但与之关联的工作者线程可能还没有创建，因为存在请求脚本的网格延迟和初始化延迟。</p>
<p>一般来说，专用工作者线程可以非正式区分为处于下列三个状态： 初始化（ initializing）、 活动（ active）和终止（ terminated）。这几个状态对其他上下文是不可见的。虽然 Worker 对象可能会存在于父上下文中，但也无法通过它确定工作者线程当前是处理初始化、活动还是终止状态。换句话说，与活动的专用工作者线程关联的 Worker 对象和与终止的专用工作者线程关联的 Worker 对象无法分别。</p>
<p>初始化时，虽然工作者线程脚本尚未执行，但可以先把要发送给工作者线程的消息加入队列。这些消息会等待工作者线程的状态变为活动，再把消息添加到它的消息队列。下面的代码演示了这个过程：</p>
<pre><code class="language-js">initializingWorker.js
self.addEventListener('message', ({ data }) =&gt; console.log(data))
main.js
const worker = new Worker('./initializingWorker.js')
// Worker 可能仍处于初始化状态
// 但 postMessage()数据可以正常处理
worker.postMessage('foo')
worker.postMessage('bar')
worker.postMessage('baz')
// foo
// bar
// baz
</code></pre>
<p>创建之后，专用工作者线程就会伴随页面的整个生命期而存在，除非自我终止（ self.close()）或通过外部终止（ worker.terminate()）。即使线程脚本已运行完成，线程的环境仍会存在。只要工作者线程仍存在，与之关联的 Worker 对象就不会被当成垃圾收集掉。</p>
<p>自我终止和外部终止最终都会执行相同的工作者线程终止例程。来看下面的例子，其中工作者线程在发送两条消息中间执行了自我终止：</p>
<pre><code class="language-js">closeWorker.js
self.postMessage('foo')
self.close()
self.postMessage('bar')
setTimeout(() =&gt; self.postMessage('baz'), 0)
main.js
const worker = new Worker('./closeWorker.js')
worker.onmessage = ({ data }) =&gt; console.log(data)
// foo
// bar
</code></pre>
<p>虽然调用了 close()，但显然工作者线程的执行并没有立即终止。 close()在这里会通知工作者线程取消事件循环中的所有任务，并阻止继续添加新任务。这也是为什么&quot;baz&quot;没有打印出来的原因。工作者线程不需要执行同步停止，因此在父上下文的事件循环中处理的&quot;bar&quot;仍会打印出来。下面来看外部终止的例子。</p>
<pre><code class="language-js">terminateWorker.js
self.onmessage = ({ data }) =&gt; console.log(data)
main.js
const worker = new Worker('./terminateWorker.js')
// 给 1000 毫秒让工作者线程初始化
setTimeout(() =&gt; {
  worker.postMessage('foo')
  worker.terminate()
  worker.postMessage('bar')
  setTimeout(() =&gt; worker.postMessage('baz'), 0)
}, 1000)
// foo
</code></pre>
<p>在整个生命周期中，一个专用工作者线程只会关联一个网页（ Web 工作者线程规范称其为一个文档）。除非明确终止，否则只要关联文档存在，专用工作者线程就会存在。如果浏览器离开网页（通过导航或关闭标签页或关闭窗口），它会将与其关联的工作者线程标记为终止，它们的执行也会立即停止。</p>
<h2 id="三-使用细节"><a class="header" href="#三-使用细节">三 使用细节</a></h2>
<h3 id="31-在-javascript-行内创建工作者线程"><a class="header" href="#31-在-javascript-行内创建工作者线程">3.1 在 JavaScript 行内创建工作者线程</a></h3>
<p>构造函数的脚本文件参数可以是本地脚本、远程资源，也可以通过 Blob 对象 URL 在行内脚本创建：</p>
<pre><code class="language-js">// 创建要执行的 JavaScript 代码字符串
const workerScript = `self.onmessage = ({data}) =&gt; console.log(data);`
// 基于脚本字符串生成 Blob 对象
const workerScriptBlob = new Blob([workerScript])
// 基于 Blob 实例创建对象 URL
const workerScriptBlobUrl = URL.createObjectURL(workerScriptBlob)
// 基于对象 URL 创建专用工作者线程
const worker = new Worker(workerScriptBlobUrl)
worker.postMessage('blob worker script') // blob worker script
</code></pre>
<p>可以简写为：</p>
<pre><code class="language-js">const worker = new Worker(
  URL.createObjectURL(
    new Blob([
      `self.onmessage =
({data}) =&gt; console.log(data);`,
    ])
  )
)
worker.postMessage('blob worker script') // blob worker script
</code></pre>
<p>工作者线程也可以利用函数序列化来初始化行内脚本。这是因为函数的 toString()方法返回函数代码的字符串，而函数可以在父上下文中定义但在子上下文中执行。来看下面这个简单的例子：</p>
<pre><code class="language-js">function fibonacci(n) {
  return n &lt; 1 ? 0 : n &lt;= 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2)
}
const workerScript = `
  self.postMessage(
    (${fibonacci.toString()})(9)
  );
`
const worker = new Worker(URL.createObjectURL(new Blob([workerScript])))
worker.onmessage = ({ data }) =&gt; console.log(data)
// 34
</code></pre>
<p>贴士：这样使用序列化的函数内不能使用通过闭包获得的引用，也包括全局变量，比如 window，因为这些引用在工作者线程中执行时会出错。</p>
<h3 id="32-在工作者线程中动态执行脚本"><a class="header" href="#32-在工作者线程中动态执行脚本">3.2 在工作者线程中动态执行脚本</a></h3>
<p>importScripts() 可以按照加载顺序同步执行其他脚本，该方法可用于全局 Worker 对象。这个方法会加载脚本并按照加载顺序同步执行，比如，下面的例子加载并执行了两个脚本：</p>
<pre><code class="language-js">// main.js
const worker = new Worker('./worker.js')

// importing scripts
// scriptA executes
// scriptB executes
// scripts imported

// scriptA.js
console.log('scriptA executes')

// scriptB.js
console.log('scriptB executes')

// worker.js
console.log('importing scripts')
importScripts('./scriptA.js')
importScripts('./scriptB.js')
console.log('scripts imported')
</code></pre>
<p>importScripts()方法可以接收任意数量的脚本作为参数。浏览器下载它们的顺序没有限制，但执行则会严格按照它们在参数列表的顺序进行。因此，下面的代码与前面的效果一样：</p>
<pre><code class="language-js">console.log('importing scripts')
importScripts('./scriptA.js', './scriptB.js')
console.log('scripts imported')
</code></pre>
<p>贴士：脚本加载受到常规 CORS 的限制，但在工作者线程内部可以请求来自任何源的脚本。这里的脚本导入策略类似于使用生成的<code>&lt;script&gt;</code>标签动态加载脚本。在这种情况下，所有导入的脚本也会共享作用域：</p>
<pre><code class="language-js">// main.js
const worker = new Worker('./worker.js', { name: 'foo' })

// importing scripts in foo with bar
// scriptA executes in foo with bar
// scriptB executes in foo with bar
// scripts imported

// scriptA.js
console.log(`scriptA executes in ${self.name} with ${globalToken}`)

// scriptB.js
console.log(`scriptB executes in ${self.name} with ${globalToken}`)

// worker.js
const globalToken = 'bar'
console.log(`importing scripts in ${self.name} with ${globalToken}`)
importScripts('./scriptA.js', './scriptB.js')
console.log('scripts imported')
</code></pre>
<h3 id="33-委托任务给子工作者线程"><a class="header" href="#33-委托任务给子工作者线程">3.3 委托任务给子工作者线程</a></h3>
<p>在工作者线程中，还可以再次创建子工作者线程，适合多核心 CPU 环境中的并行计算。加载的源也必须与主页相同，不过脚本路径是根据父工作者线程来说，而不是网页。</p>
<pre><code class="language-js">// main.js
const worker = new Worker('./js/worker.js')

// worker
// subworker

// js/worker.js
console.log('worker')
const worker = new Worker('./subworker.js')

// js/subworker.js
console.log('subworker')
</code></pre>
<p>使用多个子工作者线程前要考虑周全，确保并行计算的投入确实能够得到收益，毕竟同时运行多个子线程会有很大计算成本。</p>
<h3 id="34-工作者线程错误处理"><a class="header" href="#34-工作者线程错误处理">3.4 工作者线程错误处理</a></h3>
<p>工作者线程的错误会冒泡到全局上下文，而且会打断父线程的执行，不过在父线程中使用 try/catch 却无法捕获到这个错误，需要在 worker 的 onerror 上侦听：</p>
<pre><code class="language-js">// main.js
try {
  const worker = new Worker('./worker.js')
  console.log('no error')
} catch (e) {
  console.log('caught error')
}

// no error

// worker.js
throw Error('foo')
</code></pre>
<p>不过，相应的错误事件仍然会冒泡到工作者线程的全局上下文，因此可以通过在 Worker 对象上设置错误事件侦听器访问到。下面看这个例子：</p>
<pre><code class="language-js">// main.js
const worker = new Worker('./worker.js')
worker.onerror = console.log

// ErrorEvent {message: &quot;Uncaught Error: foo&quot;}
// worker.js
throw Error('foo')
</code></pre>
<h2 id="四-线程池"><a class="header" href="#四-线程池">四 线程池</a></h2>
<p>启用工作者线程代价很大，某些情况下可以考虑始终保持固定数量的线程活动，需要时才把任务分派给它们。工作者线程在执行计算时，会被标记为忙碌状态。直到它通知线程池自己空闲了，才准备好接收新任务。这些活动线程就称为“线程池”或“工作者线程池”。</p>
<p>线程池中维持的线程数量没有标准，推荐参考 <code>navigator.hardware Concurrency</code>返回的操作系统可用核心数量。</p>
<p>一种使用线程池的策略是每个线程都执行同样的任务，但具体执行什么任务由几个参数来控制。通过使用特定于任务的线程池，可以分配固定数量的工作者线程，并根据需要为他们提供参数。工作者线程会接收这些参数，执行耗时的计算，并把结果返回给线程池。然后线程池可以再将其他工作分派给工作者线程去执行。</p>
<p>线程池示例：首先定义一个继承自 Worker 的类 TaskWorker，该类负责跟踪线程知否正在工作，管理进出线程的信息与事件。传入给这个工作者线程的任务会封装到一个期约中，然后正确地解决和拒绝。</p>
<pre><code class="language-js">class TaskWorker extends Worker {
  constructor(notifyAvailable, ...workerArgs) {
    super(...workerArgs)
    // 初始化为不可用状态
    this.available = false
    this.resolve = null
    this.reject = null
    // 线程池会传递回调
    // 以便工作者线程发出它需要新任务的信号
    this.notifyAvailable = notifyAvailable
    // 线程脚本在完全初始化之后
    // 会发送一条&quot;ready&quot;消息
    this.onmessage = () =&gt; this.setAvailable()
  }
  // 由线程池调用，以分派新任务
  dispatch({ resolve, reject, postMessageArgs }) {
    this.available = false
    this.onmessage = ({ data }) =&gt; {
      resolve(data)
      this.setAvailable()
    }
    this.onerror = (e) =&gt; {
      reject(e)
      this.setAvailable()
    }
    this.postMessage(...postMessageArgs)
  }
  setAvailable() {
    this.available = true
    this.resolve = null
    this.reject = null
    this.notifyAvailable()
  }
}
</code></pre>
<p>接着定义线程池类：WorkerPool。该类必须维护尚未分派给工作者线程的任务队列。两个事件可以表明应该分派一个新任务：新任务被添加到队列中，或者工作者线程完成了一个任务，应该再发送另一个任务。</p>
<pre><code class="language-js">class WorkerPool {
  constructor(poolSize, ...workerArgs) {
    this.taskQueue = []
    this.workers = []
    // 初始化线程池
    for (let i = 0; i &lt; poolSize; ++i) {
      this.workers.push(
        new TaskWorker(() =&gt; this.dispatchIfAvailable(), ...workerArgs)
      )
    }
  }
  // 把任务推入队列
  enqueue(...postMessageArgs) {
    return new Promise((resolve, reject) =&gt; {
      this.taskQueue.push({ resolve, reject, postMessageArgs })
      this.dispatchIfAvailable()
    })
  }
  // 把任务发送给下一个空闲的线程（如果有的话）
  dispatchIfAvailable() {
    if (!this.taskQueue.length) {
      return
    }
    for (const worker of this.workers) {
      if (worker.available) {
        let a = this.taskQueue.shift()
        worker.dispatch(a)
        break
      }
    }
  }
  // 终止所有工作者线程
  close() {
    for (const worker of this.workers) {
      worker.terminate()
    }
  }
}
</code></pre>
<p>定义了这两个类之后，现在可以把任务分派到线程池，并在工作者线程可用时执行它们。在这个例子中，假设我们想计算 1000 万个浮点值之和。为节省转移成本，我们使用 SharedArrayBuffer。工作者线程的脚本（worker.js）大致如下：</p>
<pre><code class="language-js">self.onmessage = ({ data }) =&gt; {
  let sum = 0
  let view = new Float32Array(data.arrayBuffer)
  // 求和
  for (let i = data.startIdx; i &lt; data.endIdx; ++i) {
    // 不需要原子操作，因为只需要读
    sum += view[i]
  }
  // 把结果发送给工作者线程
  self.postMessage(sum)
}
// 发送消息给 TaskWorker
// 通知工作者线程准备好接收任务了
self.postMessage('ready')
</code></pre>
<p>有了以上代码，利用线程池分派任务的代码可以这样写：</p>
<pre><code class="language-js">const totalFloats = 1e8
const numTasks = 20
const floatsPerTask = totalFloats / numTasks
const numWorkers = 4
// 创建线程池
const pool = new WorkerPool(numWorkers, './worker.js')
// 填充浮点值数组
let arrayBuffer = new SharedArrayBuffer(4 * totalFloats)
let view = new Float32Array(arrayBuffer)
for (let i = 0; i &lt; totalFloats; ++i) {
  view[i] = Math.random()
}
let partialSumPromises = []
for (let i = 0; i &lt; totalFloats; i += floatsPerTask) {
  partialSumPromises.push(
    pool.enqueue({
      startIdx: i,
      endIdx: i + floatsPerTask,
      arrayBuffer: arrayBuffer,
    })
  )
}
// 等待所有期约完成，然后求和
Promise.all(partialSumPromises)
  .then((partialSums) =&gt; partialSums.reduce((x, y) =&gt; x + y))
  .then(console.log)
//（在这个例子中，和应该约等于 1E8/2）
// 49997075.47203197
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="052-js-的多线程-专用工作者线程的通信"><a class="header" href="#052-js-的多线程-专用工作者线程的通信">05.2-JS 的多线程-专用工作者线程的通信</a></h1>
<h2 id="一-通信机制"><a class="header" href="#一-通信机制">一 通信机制</a></h2>
<h3 id="11-隐式-messageports"><a class="header" href="#11-隐式-messageports">1.1 隐式 MessagePorts</a></h3>
<p>专用工作者线程的 Worker 对象和 DedicatedWorkerGlobalScope 与 MessagePorts 有一些相同接口处理程序和方法：onmessage、onmessageerror、close() 和 postMessage()。因为专用工作者线程隐式使用了 MessagePorts 在两个上下文之间通信。</p>
<p>父上下文中的 Worker 对象和 DedicatedWorkerGlobalScope 实际上融合了 MessagePort，并在自己的接口中分别暴露了相应的处理程序和方法。换句话说，消息还是通过 MessagePort 发送，只是没有直接使用 MessagePort 而已</p>
<p>也有不一致的地方，比如 start() 和 close() 约定。专用工作者线程会自动发送排队的消息，因此 start() 也就没有必要了。另外，close() 在专用工作者线程的上下文中没有意义，因为这样关闭 MessagePort 会使工作者线程孤立。因此，在工作者线程内部调用 close()（或在外部调用 terminate()）不仅会关闭 MessagePort，也会终止线程。</p>
<h3 id="12-使用-postpostmessage-进行通信"><a class="header" href="#12-使用-postpostmessage-进行通信">1.2 使用 postpostMessage() 进行通信</a></h3>
<p>main 示例：</p>
<pre><code class="language-js">const worker = new Worker('./worker.js')

worker.onmessage = ({ data }) =&gt; {
  console.log('接收工作者线程数据：', data)
}

worker.postMessage(5)
worker.postMessage(7)
worker.postMessage(10)
</code></pre>
<p>worker 示例：</p>
<pre><code class="language-js">function factorial(n) {
  let result = 1
  while (n) {
    result *= n--
  }
  return result
}

self.onmessage = ({ data }) =&gt; {
  self.postMessage(`${data}! = ${factorial(data)}`)
}
</code></pre>
<h3 id="13-使用-messagechannel-进行通信"><a class="header" href="#13-使用-messagechannel-进行通信">1.3 使用 MessageChannel 进行通信</a></h3>
<p>通过 postMessage() 进行通信的方式可以被 Channel Messaging API 取代，基于该 API 可以在两个上下文间明确建立通信渠道。</p>
<p>MessageChannel 实例有两个端口，分别代表两个通信端点。要让父页面和工作者通过 MessageChannel 通信，需要把一个端口传到工作者线程中。</p>
<p>main.js：</p>
<pre><code class="language-js">const channel = new MessageChannel()
const factorialWorker = new Worker('./worker.js')

// 把`MessagePort`对象发送到工作者线程
// 工作者线程负责处理初始化信道
factorialWorker.postMessage(null, [channel.port1])

// 通过信道实际发送数据
channel.port2.onmessage = ({ data }) =&gt; console.log(data)

// 工作者线程通过信道响应
channel.port2.postMessage(5)
</code></pre>
<p>worker.js：</p>
<pre><code class="language-js">// 在监听器中存储全局 messagePort
let messagePort = null
function factorial(n) {
  let result = 1
  while (n) {
    result *= n--
  }
  return result
}

// 在全局对象上添加消息处理程序
self.onmessage = ({ ports }) =&gt; {
  if (messagePort) {
    console.log('已经设置了端口')
    return
  }

  // 只初始化一次消息发送端口
  messagePort = ports[0] // 给变量赋值并重置监听器
  self.onmessage = null

  // 在全局对象上设置消息处理程序
  messagePort.onmessage = ({ data }) =&gt; {
    // 收到消息后发送数据
    messagePort.postMessage(`${data}! = ${factorial(data)}`)
  }
}
</code></pre>
<p>使用 MessageChannel 实例与父页面通信很大程度上是多余的。这是因为全局 postMessage() 方法本质上与 channel.postMessage() 执行的是同样的操作（不考虑 MessageChannel 接口的其他特性）。</p>
<p>MessageChannel 真正有用的地方是让两个工作者线程之间直接通信，这可以通过把端口传给另一个工作者线程实现。比如把一个数据传递给工作者线程后，工作者线程又继续传递给了另外一个工作者线程。</p>
<p>main.js：</p>
<pre><code class="language-js">const channel = new MessageChannel()
const workerA = new Worker('./worker.js')
const workerB = new Worker('./worker.js')
workerA.postMessage('workerA', [channel.port1])
workerB.postMessage('workerB', [channel.port2])
workerA.onmessage = ({ data }) =&gt; console.log(data)
workerB.onmessage = ({ data }) =&gt; console.log(data)
workerA.postMessage(['page'])
// ['page', 'workerA', 'workerB']
workerB.postMessage(['page'])
// ['page', 'workerB', 'workerA']
</code></pre>
<p>worker.js：</p>
<pre><code class="language-js">let messagePort = null
let contextIdentifier = null
function addContextAndSend(data, destination) {
  // 添加标识符以标识当前工作者线程
  data.push(contextIdentifier)
  // 把数据发送到下一个目标
  destination.postMessage(data)
}
self.onmessage = ({ data, ports }) =&gt; {
  // 如果消息里存在端口（ports）
  // 则初始化工作者线程
  if (ports.length) {
    // 记录标识符
    contextIdentifier = data
    // 获取 MessagePort
    messagePort = ports[0]
    // 添加处理程序把接收的数据
    // 发回到父页面
    messagePort.onmessage = ({ data }) =&gt; {
      addContextAndSend(data, self)
    }
  } else {
    addContextAndSend(data, messagePort)
  }
}
</code></pre>
<h3 id="14-同源脚本广播-broadcastchannel"><a class="header" href="#14-同源脚本广播-broadcastchannel">1.4 同源脚本广播 BroadcastChannel</a></h3>
<p>同源脚本能够通过 BroadcastChannel 相互之间发送和接收消息。这种通道类型的设置比较简单，不需要像 MessageChannel 那样转移乱糟糟的端口。</p>
<p>main.js：</p>
<pre><code class="language-js">const channel = new BroadcastChannel('worker_channel')
const worker = new Worker('./worker.js')
channel.onmessage = ({ data }) =&gt; {
  console.log(`heard ${data} on page`)
}
setTimeout(() =&gt; channel.postMessage('foo'), 1000)

// heard foo in worker
// heard bar on page
</code></pre>
<p>worker.js：</p>
<pre><code class="language-js">const channel = new BroadcastChannel('worker_channel')
channel.onmessage = ({ data }) =&gt; {
  console.log(`heard ${data} in worker`)
  channel.postMessage('bar')
}
</code></pre>
<p>页面在通过 BroadcastChannel 发送消息之前会先等 1 秒钟。因为这种信道没有端口所有权的概念，所以如果没有实体监听这个信道，广播的消息就不会有人处理。在这种情况下，如果没有 setTimeout()，则由于初始化工作者线程的延迟，就会导致消息已经发送了，但工作者线程上的消息处理程序还没有就位。</p>
<h2 id="二-工作者线程数据传输"><a class="header" href="#二-工作者线程数据传输">二 工作者线程数据传输</a></h2>
<h3 id="20-上下文间转移信息方式"><a class="header" href="#20-上下文间转移信息方式">2.0 上下文间转移信息方式</a></h3>
<p>使用工作者线程时，经常需要为它们提供某种形式的数据负载。工作者线程是独立的上下文，因此在上下文之间传输数据就会产生消耗。在支持传统多线程模型的语言中，可以使用锁、互斥量，以及 volatile 变量。</p>
<p>在 JavaScript 中，有三种在上下文间转移信息的方式：</p>
<ul>
<li>结构化克隆算法（ structured clonealgorithm）</li>
<li>可转移对象（ transferable objects）</li>
<li>共享数组缓冲区（ shared array buffers）</li>
</ul>
<h3 id="21-结构化克隆算法"><a class="header" href="#21-结构化克隆算法">2.1 结构化克隆算法</a></h3>
<p>结构化克隆算法可用于在两个独立上下文间共享数据。该算法由浏览器在后台实现，不能直接调用。</p>
<p>在通过 postMessage() 传递对象时，浏览器会遍历该对象，并在目标上下文中生成它的一个副本。复制之后，源上下文中对该对象的修改，不会传播到目标上下文中的对象，而且可以识别对象中包含的循环引用，不会无穷遍历对象。</p>
<p>列类型是结构化克隆算法支持的类型：</p>
<ul>
<li>除 Symbol 之外的所有原始类型</li>
<li>Boolean 对象</li>
<li>String 对象</li>
<li>BDate</li>
<li>RegExp</li>
<li>Blob</li>
<li>File</li>
<li>FileList</li>
<li>ArrayBuffer</li>
<li>ArrayBufferView</li>
<li>ImageData</li>
<li>Array</li>
<li>Object</li>
<li>Map</li>
<li>Set</li>
</ul>
<p>关于结构化克隆算法，有以下几点需要注意：</p>
<ul>
<li>复制之后，源上下文中对该对象的修改，不会传播到目标上下文中的对象。</li>
<li>结构化克隆算法可以识别对象中包含的循环引用，不会无穷遍历对象。</li>
<li>克隆 Error 对象、 Function 对象或 DOM 节点会抛出错误。</li>
<li>结构化克隆算法并不总是创建完全一致的副本。</li>
<li>对象属性描述符、获取方法和设置方法不会克隆，必要时会使用默认值。</li>
<li>原型链不会克隆。</li>
<li>RegExp.prototype.lastIndex 属性不会克隆。</li>
</ul>
<h3 id="22-可转移对象"><a class="header" href="#22-可转移对象">2.2 可转移对象</a></h3>
<p>使用可转移对象（transferable objects）可以把所有权从一个上下文转移到另一个上下文。在不太可能在上下文间复制大量数据的情况下，这个功能特别有用。可转移对象包括：</p>
<ul>
<li>ArrayBuffer</li>
<li>MessagePort</li>
<li>ImageBitmap</li>
<li>OffscreenCanvas</li>
</ul>
<p>postMessage()方法的第二个可选参数是数组，它指定应该将哪些对象转移到目标上下文。在遍历消息负载对象时，浏览器根据转移对象数组检查对象引用，并对转移对象进行转移而不复制它们。这意味着被转移的对象可以通过消息负载发送，消息负载本身会被复制，比如对象或数组。</p>
<p>下面的例子演示了工作者线程对 ArrayBuffer 的常规结构化克隆。这里没有对象转移：</p>
<pre><code class="language-js">// main.js
const worker = new Worker('./worker.js')
// 创建 32 位缓冲区
const arrayBuffer = new ArrayBuffer(32)
console.log(`page's buffer size: ${arrayBuffer.byteLength}`) // 32
worker.postMessage(arrayBuffer)
console.log(`page's buffer size: ${arrayBuffer.byteLength}`) // 32

// worker.js
self.onmessage = ({ data }) =&gt; {
  console.log(`worker's buffer size: ${data.byteLength}`) // 32
}
</code></pre>
<p>如果把 ArrayBuffer 指定为可转移对象，那么对缓冲区内存的引用就会从父上下文中抹去，然后分配给工作者线程。下面的例子演示了这个操作，结果分配给 ArrayBuffer 的内存从父上下文转移到了工作者线程：</p>
<pre><code class="language-js">// main.js
const worker = new Worker('./worker.js')
// 创建 32 位缓冲区
const arrayBuffer = new ArrayBuffer(32)
console.log(`page's buffer size: ${arrayBuffer.byteLength}`) // 32
worker.postMessage(arrayBuffer, [arrayBuffer])
console.log(`page's buffer size: ${arrayBuffer.byteLength}`) // 0

// worker.js
self.onmessage = ({ data }) =&gt; {
  console.log(`worker's buffer size: ${data.byteLength}`) // 32
}
</code></pre>
<p>在其他类型的对象中嵌套可转移对象也完全没有问题。包装对象会被复制，而嵌套的对象会被转移：</p>
<pre><code class="language-js">// main.js
const worker = new Worker('./worker.js')
// 创建 32 位缓冲区
const arrayBuffer = new ArrayBuffer(32)
console.log(`page's buffer size: ${arrayBuffer.byteLength}`) // 32
worker.postMessage({ foo: { bar: arrayBuffer } }, [arrayBuffer])
console.log(`page's buffer size: ${arrayBuffer.byteLength}`) // 0

// worker.js
self.onmessage = ({ data }) =&gt; {
  console.log(`worker's buffer size: ${data.foo.bar.byteLength}`) // 32
}
</code></pre>
<h3 id="23-sharedarraybuffer"><a class="header" href="#23-sharedarraybuffer">2.3 SharedArrayBuffer</a></h3>
<p>既不克隆，也不转移， SharedArrayBuffer 作为 ArrayBuffer 能够在不同浏览器上下文间共享。在把 SharedArrayBuffer 传给 postMessage()时，浏览器只会传递原始缓冲区的引用。结果是，两个不同的 JavaScript 上下文会分别维护对同一个内存块的引用。每个上下文都可以随意修改这个缓冲区，就跟修改常规 ArrayBuffer 一样。来看下面的例子：</p>
<pre><code class="language-js">// main.js
const worker = new Worker('./worker.js')
// 创建 1 字节缓冲区
const sharedArrayBuffer = new SharedArrayBuffer(1)
// 创建 1 字节缓冲区的视图
const view = new Uint8Array(sharedArrayBuffer)
// 父上下文赋值 1
view[0] = 1
worker.onmessage = () =&gt; {
  console.log(`buffer value after worker modification: ${view[0]}`)
}
// 发送对 sharedArrayBuffer 的引用
worker.postMessage(sharedArrayBuffer)
// buffer value before worker modification: 1
// buffer value after worker modification: 2

// worker.js
self.onmessage = ({ data }) =&gt; {
  const view = new Uint8Array(data)
  console.log(`buffer value before worker modification: ${view[0]}`)
  // 工作者线程为共享缓冲区赋值
  view[0] += 1
  // 发送空消息，通知赋值完成
  self.postMessage(null)
}
</code></pre>
<p>当然，在两个并行线程中共享内存块有资源争用的风险。换句话说， SharedArrayBuffer 实例实际上会被当成易变（ volatile）内存。下面的例子演示了这一点：</p>
<pre><code class="language-js">// main.js
// 创建包含 4 个线程的线程池
const workers = []
for (let i = 0; i &lt; 4; ++i) {
  workers.push(new Worker('./worker.js'))
}

// 在最后一个工作者线程完成后打印最终值
let responseCount = 0
for (const worker of workers) {
  worker.onmessage = () =&gt; {
    if (++responseCount == workers.length) {
      console.log(`Final buffer value: ${view[0]}`)
    }
  }
}

// 初始化 SharedArrayBuffer
const sharedArrayBuffer = new SharedArrayBuffer(4)
const view = new Uint32Array(sharedArrayBuffer)
view[0] = 1

// 把 SharedArrayBuffer 发给每个线程
for (const worker of workers) {
  worker.postMessage(sharedArrayBuffer)
}
// （期待结果为 4000001。实际输出类似于：）
// Final buffer value: 2145106

// worker.js
self.onmessage = ({ data }) =&gt; {
  const view = new Uint32Array(data)
  // 执行 100 万次加操作
  for (let i = 0; i &lt; 1e6; ++i) {
    view[0] += 1
  }
  self.postMessage(null)
}
</code></pre>
<p>这里，每个工作者线程都顺序执行了 100 万次加操作，每次都读取共享数组的索引、执行一次加操作，然后再把值写回数组索引。在所有工作者线程读/写操作交织的过程中就会发生资源争用。例如：</p>
<ul>
<li>(1) 线程 A 读取到值 1；</li>
<li>(2) 线程 B 读取到值 1；</li>
<li>(3) 线程 A 加 1 并将 2 写回数组；</li>
<li>(4) 线程 B 仍然使用陈旧的数组值 1，同样把 2 写回数组。</li>
</ul>
<p>为解决该问题，可以使用 Atomics 对象让一个工作者线程获得 SharedArrayBuffer 实例的锁，在执行完全部读/写/读操作后，再允许另一个工作者线程执行操作。把 Atomics.add()放到这个例子中就可以得到正确的最终值：</p>
<pre><code class="language-js">// main.js
// 创建包含 4 个线程的线程池
const workers = []
for (let i = 0; i &lt; 4; ++i) {
  workers.push(new Worker('./worker.js'))
}
// 在最后一个工作者线程完成后打印最终值
let responseCount = 0
for (const worker of workers) {
  worker.onmessage = () =&gt; {
    if (++responseCount == workers.length) {
      console.log(`Final buffer value: ${view[0]}`)
    }
  }
}
// 初始化 SharedArrayBuffer
const sharedArrayBuffer = new SharedArrayBuffer(4)
const view = new Uint32Array(sharedArrayBuffer)
view[0] = 1
// 把 SharedArrayBuffer 发给每个线程
for (const worker of workers) {
  worker.postMessage(sharedArrayBuffer)
}
//（期待结果为 4000001）
// Final buffer value: 4000001

// worker.js
self.onmessage = ({ data }) =&gt; {
  const view = new Uint32Array(data)
  // 执行 100 万次加操作
  for (let i = 0; i &lt; 1e6; ++i) {
    Atomics.add(view, 0, 1)
  }
  self.postMessage(null)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="054-js-的多线程-共享工作者线程"><a class="header" href="#054-js-的多线程-共享工作者线程">05.4-JS 的多线程-共享工作者线程</a></h1>
<h2 id="一-共享工作者线程概念"><a class="header" href="#一-共享工作者线程概念">一 共享工作者线程概念</a></h2>
<p>共享工作者线程或共享线程与专用工作者线程类似，但可以被多个可信任的执行上下文访问。例如，同源的两个标签页可以访问同一个共享工作者线程。SharedWorker 与 Worker 的消息接口稍有不同，包括外部和内部。</p>
<p>共享线程适合开发者希望通过在多个上下文间共享线程减少计算性消耗的情形。比如，可以用一个共享线程管理多个同源页面 WebSocket 消息的发送与接收。共享线程也可以用在同源上下文希望通过一个线程通信的情形。</p>
<p>共享工作者线程可以看作是专用工作者线程的一个扩展。线程创建、线程选项、安全限制和 importScripts() 的行为都是相同的。与专用工作者线程一样，共享工作者线程也在独立执行上下文中运行，也只能与其他上下文异步通信。</p>
<h2 id="二-使用共享工作者线程"><a class="header" href="#二-使用共享工作者线程">二 使用共享工作者线程</a></h2>
<h3 id="21-创建共享工作者线程"><a class="header" href="#21-创建共享工作者线程">2.1 创建共享工作者线程</a></h3>
<pre><code class="language-js">const worker = new SharedWorker('./worker.js')
console.log(worker) // SharedWorker {port: MessagePort, onerror: null}
</code></pre>
<p>也可以在行内脚本中创建共享工作者线程，但这样做没什么意义。因为每个基于行内脚本字符串创建的 Blob 都会被赋予自己唯一的浏览器内部 URL，所以行内脚本中创建的共享工作者线程始终是唯一的。</p>
<h3 id="22-sharedworker-标识与独占"><a class="header" href="#22-sharedworker-标识与独占">2.2 SharedWorker 标识与独占</a></h3>
<p><strong>共享工作者线程与专用工作者线程核心区别是：Worker() 构造函数始终会创建新实例，SharedWorker() 只会在相同的标识不存在的情况下才创建新实例。如果的确存在与标识匹配的共享工作者线程，则只会与已有共享者线程建立新的连接。</strong></p>
<p>共享工作者线程标识源自解析后的脚本 URL、工作者线程名称和文档源。例如，下面的脚本将实例化一个共享工作者线程并添加两个连接：</p>
<pre><code class="language-js">// 下面三个脚本字符串都解析到相同的 URL，所以也只会创建一个共享工作者线程：
// 实例化一个共享工作者线程
// - 全部基于同源调用构造函数
// - 所有脚本解析为相同的 URL
// - 所有线程都有相同的名称
new SharedWorker('./sharedWorker.js')
new SharedWorker('sharedWorker.js') // 注意这里如果后面带参数问号之类的则不会是一个线程！！！！
new SharedWorker('https://www.demo.com/sharedWorker.js')
</code></pre>
<p>类似地，因为下面三个脚本字符串都解析到相同的 URL，所以也只会创建一个共享工作者线程：</p>
<pre><code class="language-js">// 实例化一个共享工作者线程
// - 全部基于同源调用构造函数
// - 所有脚本解析为相同的 URL
// - 所有线程都有相同的名称
new SharedWorker('./sharedWorker.js')
new SharedWorker('sharedWorker.js')
new SharedWorker('https://www.example.com/sharedWorker.js')
</code></pre>
<p>因为可选的工作者线程名称也是共享工作者线程标识的一部分，所以不同的线程名称会强制浏览器创建多个共享工作者线程。对下面的例子而言，一个名为'foo'，另一个名为'bar'，尽管它们同源且脚本 URL 相同：</p>
<pre><code class="language-js">// 实例化一个共享工作者线程
// - 全部基于同源调用构造函数
// - 所有脚本解析为相同的 URL
// - 一个线程名称为'foo'，一个线程名称为'bar'
new SharedWorker('./sharedWorker.js', { name: 'foo' })
new SharedWorker('./sharedWorker.js', { name: 'foo' })
new SharedWorker('./sharedWorker.js', { name: 'bar' })
</code></pre>
<p>共享线程，顾名思义，可以在不同标签页、不同窗口、不同内嵌框架或同源的其他工作者线程之间共享。因此，下面的脚本如果在多个标签页运行，只会在第一次执行时创建一个共享工作者线程，后续执行会连接到该线程：</p>
<pre><code class="language-js">// 实例化一个共享工作者线程
// - 全部基于同源调用构造函数
// - 所有脚本解析为相同的 URL
// - 所有线程都有相同的名称
new SharedWorker('./sharedWorker.js')
</code></pre>
<p>初始化共享线程的脚本只会限制 URL，因此下面的代码会创建两个共享工作者线程，尽管加载了相同的脚本：</p>
<pre><code class="language-js">// 实例化一个共享工作者线程
// - 全部基于同源调用构造函数
// - '?'导致了两个不同的 URL
// - 所有线程都有相同的名称
new SharedWorker('./sharedWorker.js')
new SharedWorker('./sharedWorker.js?')
</code></pre>
<p>如果该脚本在两个不同的标签页中运行，同样也只会创建两个共享工作者线程。每个构造函数都会检查匹配的共享工作者线程，然后连接到已存在的那个。</p>
<h3 id="23-使用-sharedworker-对象"><a class="header" href="#23-使用-sharedworker-对象">2.3 使用 SharedWorker 对象</a></h3>
<p>SharedWorker() 构造函数返回的 SharedWorker 对象被用作与新创建的共享工作者线程通信的连接点。它可以用来通过 MessagePort 在共享工作者线程和父上下文间传递信息，也可以用来捕获共享线程中发出的错误事件：</p>
<ul>
<li>onerror：在共享线程中发生 ErrorEvent 类型的错误事件时会调用指定给该属性的处理程序。
<ul>
<li>此事件会在共享线程抛出错误时发生。</li>
<li>此事件也可以通过使用 sharedWorker.addEventListener('error', handler) 处理。</li>
</ul>
</li>
<li>port：专门用来跟共享线程通信的 MessagePort。</li>
</ul>
<h3 id="24-sharedworkerglobalscope"><a class="header" href="#24-sharedworkerglobalscope">2.4 SharedWorkerGlobalScope</a></h3>
<p>在共享线程内部，全局作用域是 SharedWorkerGlobalScope 的实例。SharedWorkerGlobalScope 继承自 WorkerGlobalScope，因此包括它所有的属性和方法。与专用工作者线程一样，共享工作者线程也可以通过 self 关键字访问该全局上下文。</p>
<p>SharedWorkerGlobalScope 扩展 WorkerGlobalScope 的成员有：</p>
<ul>
<li>name：可选的字符串标识符，可以传给 SharedWorker 构造函数。</li>
<li>importScripts()：用于向工作者线程中导入任意数量的脚本。</li>
<li>close()：与 worker.terminate() 对应，用于立即终止工作者线程。没有给工作者线程提供终止前清理的机会；脚本会突然停止。</li>
<li>onconnect：与共享线程建立新连接时，应将其设置为处理程序。connect 事件包括 MessagePort 实例的 ports 数组，可用于把消息发送回父上下文
<ul>
<li>在通过 worker.port.onmessage 或 worker.port.start() 与共享线程建立连接时都会触发 connect 事件。</li>
<li>connect 事件也可以通过使用 sharedWorker.addEventListener('connect', handler) 处理。</li>
</ul>
</li>
</ul>
<h2 id="三-共享工作者线程的生命周期"><a class="header" href="#三-共享工作者线程的生命周期">三 共享工作者线程的生命周期</a></h2>
<p>专用工作者线程只跟一个页面绑定，而共享工作者线程只要还有一个上下文连接就会持续存在。</p>
<p><code>new Worker('./worker.js')</code> 的执行效果：</p>
<pre><code class="language-txt">事件                        结果                事件发生后的线程数
标签页 1 执行 main.js       创建专用线程 1          1
标签页 2 执行 main.js       创建专用线程 2          2
标签页 3 执行 main.js       创建专用线程 3          3
标签页 1 关闭               专用线程 1 终止         2
标签页 2 关闭               专用线程 2 终止         1
标签页 3 关闭               专用线程 3 终止         0
</code></pre>
<p><code>new SharedWorker('./worker.js')</code> 的执行效果：</p>
<pre><code class="language-txt">事件                        结果                事件发生后的线程数
标签页 1 执行 main.js       创建共享线程 1          1
标签页 2 执行 main.js       连接专用线程 1          1
标签页 3 执行 main.js       连接专用线程 1          1
标签页 1 关闭               断开与共享线程 1 的连接   1
标签页 2 关闭               断开与共享线程 1 的连接   1
标签页 3 关闭               断开与共享线程 1 的连接   0（没有连接了，因此终止共享线程 1）
</code></pre>
<p>没有办法以编程方式终止共享线程。SharedWorker 对象上没有 terminate() 方法。在共享线程端口（稍后讨论）上调用 close() 时，只要还有一个端口连接到该线程就不会真的终止线程。</p>
<p>SharedWorker 的“连接”与关联 MessagePort 或 MessageChannel 的状态无关。只要建立了连接，浏览器会负责管理该连接。建立的连接会在页面的生命周期内持续存在，只有当页面销毁且没有连接时，浏览器才会终止共享线程</p>
<h2 id="四-连接到共享工作者线程"><a class="header" href="#四-连接到共享工作者线程">四 连接到共享工作者线程</a></h2>
<p>每次调用 SharedWorker() 构造函数，无论是否创建了工作者线程，都会在共享线程内部触发 connect 事件。下面的例子演示了这一点，在循环中调用 SharedWorker() 构造函数：</p>
<p>在循环中调用 SharedWorker() 构造函数：</p>
<pre><code class="language-js">// main.js
for (let i = 0; i &lt; 5; ++i) {
  new SharedWorker('./sharedWorker.js')
}
// connected 1 times
// connected 2 times
// connected 3 times
// connected 4 times
// connected 5 times

// sharedWorker.js
let i = 0
self.onconnect = () =&gt; console.log(`connected ${++i} times`)
</code></pre>
<p>发生 connect 事件时，SharedWorker() 构造函数会隐式创建 MessageChannel 实例，并把 MessagePort 实例的所有权唯一地转移给该 SharedWorker 的实例。这个 MessagePort 实例会保存在 connect 事件对象的 ports 数组中。一个连接事件只能代表一个连接，因此可以假定 ports 数组的长度等于 1。</p>
<p>使用 Set 来保证只跟踪唯一的对象实例：</p>
<pre><code class="language-js">// main.js
for (let i = 0; i &lt; 5; ++i) {
  new SharedWorker('./sharedWorker.js')
}
// 1 unique connected ports
// 2 unique connected ports
// 3 unique connected ports
// 4 unique connected ports
// 5 unique connected ports

// sharedWorker.js
const connectedPorts = new Set()
self.onconnect = ({ ports }) =&gt; {
  connectedPorts.add(ports[0])
  console.log(`${connectedPorts.size} unique connected ports`)
}
</code></pre>
<p>共享线程与父上下文的启动和关闭不是对称的。每个新 SharedWorker 连接都会触发一个事件，但没有事件对应断开 SharedWorker 实例的连接（如页面关闭）。在前面的例子中，随着与相同共享线程连接和断开连接的页面越来越多，connectedPorts 集合中会受到死端口的污染，没有办法识别它们。一个解决方案是在 beforeunload 事件即将销毁页面时，
明确发送卸载消息，让共享线程有机会清除死端口。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="055-js-的多线程-服务工作者线程"><a class="header" href="#055-js-的多线程-服务工作者线程">05.5-JS 的多线程-服务工作者线程</a></h1>
<h2 id="一-服务工作者线程概念"><a class="header" href="#一-服务工作者线程概念">一 服务工作者线程概念</a></h2>
<p>服务工作者线程（ service worker）是一种类似浏览器中代理服务器的线程，可以拦截外出请求和缓存响应。这可以让网页在没有网络连接的情况下正常使用，因为部分或全部页面可以从服务工作者线程缓存中提供服务。服务工作者线程也可以使用 Notifications API、 Push API、 Background Sync API 和 Channel Messaging API。</p>
<p>与共享工作者线程类似，来自一个域的多个页面共享一个服务工作者线程。不过，为了使用 Push API 等特性，服务工作者线程也可以在相关的标签页或浏览器关闭后继续等待到来的推送事件。</p>
<p>服务工作者线程在两个主要任务上最有用：充当网络请求的缓存层和启用推送通知。在这个意义上，服务工作者线程就是用于把网页变成像原生应用程序一样的工具。</p>
<p>服务工作者线程的生命周期取决于打开的同源标签页（称为“客户端”）数量、页面是否发生导航，以及服务脚本是否改变（以及其他一些因素）。在调试服务工作者线程时，要谨慎使用浏览器的强制刷新功能（ Ctrl+Shift+R）。强制刷新会强制浏览器忽略所有网络缓存，而服务工作者线程对大多数主流浏览器而言就是网络缓存。</p>
<p>工作者线程最终用途：让网页能够模拟原生应用程序。</p>
<h2 id="二-服务工作者线程的使用"><a class="header" href="#二-服务工作者线程的使用">二 服务工作者线程的使用</a></h2>
<h3 id="21-线程容器对象-serviceworkercontainer"><a class="header" href="#21-线程容器对象-serviceworkercontainer">2.1 线程容器对象 ServiceWorkerContainer</a></h3>
<p>服务工作者线程与专用工作者线程或共享工作者线程的一个区别是没有全局构造函数。服务工作者线程是通过 ServiceWorkerContainer 来管理的，它的实例保存在 navigator.serviceWorker 属性中。该对象是个顶级接口，通过它可以让浏览器创建、更新、销毁或者与服务工作者线程交互。</p>
<pre><code class="language-js">console.log(navigator.serviceWorker) // ServiceWorkerContainer { ... }
</code></pre>
<h3 id="22-创建服务工作者线程"><a class="header" href="#22-创建服务工作者线程">2.2 创建服务工作者线程</a></h3>
<p>与共享工作者线程类似，服务工作者线程同样是在还不存在时创建新实例，在存在时连接到已有实例。ServiceWorkerContainer 没有通过全局构造函数创建，而是暴露了 register()方法：</p>
<pre><code class="language-js">// main.js
// register()方法返回一个期约，该期约解决为 ServiceWorkerRegistration 对象，或在注册失败时拒绝。
// 注册成功，成功回调（解决）
navigator.serviceWorker
  .register('./emptyServiceWorker.js')
  .then(console.log, console.error) // ServiceWorkerRegistration { ... }

// 使用不存在的文件注册，失败回调（拒绝）
navigator.serviceWorker
  .register('./doesNotExist.js')
  .then(console.log, console.error) // TypeError
</code></pre>
<p>在第一次调用 register()激活服务工作者线程后，后续在同一个页面使用相同 URL 对 register()的调用实际上什么也不会执行。此外，即使浏览器未全局支持服务工作者线程，服务工作者线程本身对页面也应该是不可见的。这是因为它的行为类似代理，就算有需要它处理的操作，也仅仅是发送常规的网络请求。</p>
<p>所以，注册服务工作者线程的一种非常常见的模式是基于特性检测，并在页面的 load 事件中操作。比如：</p>
<pre><code class="language-js">if ('serviceWorker' in navigator) {
  //  先load可以避免创建线程与加载页面重叠，拖慢页面渲染
  window.addEventListener('load', () =&gt; {
    navigator.serviceWorker.register('./serviceWorker.js')
  })
}
</code></pre>
<h3 id="23-使用-serviceworkercontainer-对象"><a class="header" href="#23-使用-serviceworkercontainer-对象">2.3 使用 ServiceWorkerContainer 对象</a></h3>
<p>ServiceWorkerContainer 接口是浏览器对服务工作者线程生态的顶部封装。它为管理服务工作者线程状态和生命周期提供了便利。</p>
<p>ServiceWorkerContainer 始终可以在客户端上下文中访问：</p>
<pre><code class="language-js">console.log(navigator.serviceWorker)
// ServiceWorkerContainer { ... }
</code></pre>
<p>ServiceWorkerContainer 支持以下事件处理程序：</p>
<ul>
<li>oncontrollerchange：在 ServiceWorkerContainer 触发 controllerchange 事件时会调用指定的事件处理程序。
<ul>
<li>此事件在获得新激活的 ServiceWorkerRegistration 时触发。</li>
<li>此事件也可以使用 navigator.serviceWorker.addEventListener('controllerchange',handler)处理。</li>
</ul>
</li>
<li>onerror：在关联的服务工作者线程触发 ErrorEvent 错误事件时会调用指定的事件处理程序。
<ul>
<li>此事件在关联的服务工作者线程内部抛出错误时触发。</li>
<li>此事件也可以使用 navigator.serviceWorker.addEventListener('error', handler)处理。</li>
</ul>
</li>
<li>onmessage：在服务工作者线程触发 MessageEvent 事件时会调用指定的事件处理程序。
<ul>
<li>此事件在服务脚本向父上下文发送消息时触发。</li>
<li>此事件也可以使用 navigator.serviceWorker.addEventListener('message', handler)处理。</li>
</ul>
</li>
</ul>
<p>ServiceWorkerContainer 支持下列成员：</p>
<ul>
<li>ready：返回期约，解决为激活的 ServiceWorkerRegistration 对象。该期约不会拒绝</li>
<li>controller：返回与当前页面关联的激活的 ServiceWorker 对象，如果没有激活的服务工作者线程则返回 null</li>
</ul>
<p>ServiceWorkerContainer 支持下列方法：</p>
<ul>
<li>register()：使用接收的 url 和 options 对象创建或更新 ServiceWorkerRegistration。</li>
<li>getRegistration()：返回期约，解决为与提供的作用域匹配的 ServiceWorkerRegistration 对象；如果没有匹配的服务工作者线程则返回 undefined。</li>
<li>getRegistrations()：返回期约，解决为与 ServiceWorkerContainer 关联的 ServiceWorkerRegistration 对象的数组；如果没有关联的服务工作者线程则返回空数组。</li>
<li>startMessage()：开始传送通过 Client.postMessage()派发的消息</li>
</ul>
<h3 id="24-使用-serviceworkerregistration-对象"><a class="header" href="#24-使用-serviceworkerregistration-对象">2.4 使用 ServiceWorkerRegistration 对象</a></h3>
<p>ServiceWorkerRegistration 对象表示注册成功的服务工作者线程。该对象可以在 register()返回的解决期约的处理程序中访问到。通过它的一些属性可以确定关联服务工作者线程的生命周期状态。</p>
<p>调用 navigator.serviceWorker.register()之后返回的期约会将注册成功的 ServiceWorkerRegistration 对象（注册对象）发送给处理函数。在同一页面使用同一 URL 多次调用该方法会返回相同的注册对象：</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js').then((registrationA) =&gt; {
  console.log(registrationA)
  navigator.serviceWorker
    .register('./serviceWorker2.js')
    .then((registrationB) =&gt; {
      console.log(registrationA === registrationB)
    })
})
</code></pre>
<p>ServiceWorkerRegistration 支持以下事件处理程序：</p>
<ul>
<li>onupdatefound：在服务工作者线程触发 updatefound 事件时会调用指定的事件处理程序。
<ul>
<li>此事件会在服务工作者线程开始安装新版本时触发，表现为 ServiceWorkerRegistration.installing 收到一个新的服务工作者线程。</li>
<li>此事件也可以使用 serv serviceWorkerRegistration.addEventListener('updatefound',handler)处理。</li>
</ul>
</li>
</ul>
<p>ServiceWorkerRegistration 支持以下通用属性：</p>
<ul>
<li>scope：返回服务工作者线程作用域的完整 URL 路径。该值源自接收服务脚本的路径和在 register()中提供的作用域。</li>
<li>navigationPreload：返回与注册对象关联的 NavigationPreloadManager 实例。</li>
<li>pushManager：返回与注册对象关联的 pushManager 实例。</li>
</ul>
<p>ServiceWorkerRegistration 还支持以下属性，可用于判断服务工作者线程处于生命周期的什么阶段：</p>
<ul>
<li>installing：如果有则返回状态为 installing（安装）的服务工作者线程，否则为 null。</li>
<li>waiting：如果有则返回状态为 waiting（等待）的服务工作者线程，否则为 null。</li>
<li>active：如果有则返回状态 activating 或 active（活动）的服务工作者线程，否则为 null。</li>
</ul>
<p>注意：这些属性都是服务工作者线程状态的一次性快照。这在大多数情况下是没有问题的，因为活动状态的服务工作者线程在页面的生命周期内不会改变状态，除非强制这样做（比如调用 ServiceWorkerGlobalScope.skipWaiting()）。</p>
<h3 id="25-serviceworker-对象"><a class="header" href="#25-serviceworker-对象">2.5 ServiceWorker 对象</a></h3>
<p>ServiceWorker 对象可以通过两种方式获得：通过 ServiceWorkerContainer 对象的 controller 属性和通过 ServiceWorkerRegistration 的 active 属性。该对象继承 Worker 原型，但没有 terminate()方法。</p>
<p>ServiceWorker 支持的事件处理程序：</p>
<ul>
<li>onstatechange： ServiceWorker 发生 statechange 事件时会调用指定的事件处理程序。
<ul>
<li>此事件会在 ServiceWorker.state 变化时发生。</li>
<li>此事件也可以使用 serviceWorker.addEventListener('statechange', handler)处理。</li>
</ul>
</li>
</ul>
<p>ServiceWorker 支持以下属性：</p>
<ul>
<li>scriptURL：解析后注册服务工作者线程的 URL。例如，如果服务工作者线程是通过相对路径'./serviceWorker.js'创建的，
且注 册在 <a href="https://www.example.com">https://www.example.com</a> 上，则 scriptURL 属性将返回&quot;https://www.example.com/serviceWorker.js&quot;。</li>
<li>state：表示服务工作者线程状态的字符串，可能的值有：installing、installed、activating、activated、redundant</li>
</ul>
<h3 id="26-服务工作者线程的安全限制"><a class="header" href="#26-服务工作者线程的安全限制">2.6 服务工作者线程的安全限制</a></h3>
<p>与其他工作者线程一样，服务工作者线程也受加载脚本对应源的常规限制。此外，由于服务工作者线程几乎可以任意修改和重定向网络请求，以及加载静态资源，服务工作者线程 API 只能在安全上下文（ HTTPS）下使用。在非安全上下文（ HTTP）中， navigator.serviceWorker 是 undefined。为方便开发，浏览器豁免了通过 localhost 或 127.0.0.1 在本地加载的页面的安全上下文规则。</p>
<p>可以通过 window.isSecureContext 确定当前上下文是否安全。</p>
<h3 id="27-serviceworkerglobalscope"><a class="header" href="#27-serviceworkerglobalscope">2.7 ServiceWorkerGlobalScope</a></h3>
<p>在服务工作者线程内部，全局上下文是 ServiceWorkerGlobalScope 的实例，ServiceWorkerGlobalScope 继承自 WorkerGlobalScope，因此拥有它的所有属性和方法。服务工作者线程可以通过 self 关键字访问该全局上下文。</p>
<p>ServiceWorkerGlobalScope 通过以下属性和方法扩展了 WorkerGlobalScope：</p>
<ul>
<li>caches：返回服务工作者线程的 CacheStorage 对象。</li>
<li>clients：返回服务工作者线程的 Clients 接口，用于访问底层 Client 对象。</li>
<li>registration：返回服务工作者线程的 ServiceWorkerRegistration 对象。</li>
<li>skipWaiting()：强制服务工作者线程进入活动状态；需要跟 Clients.claim()一起使用。</li>
<li>fetch()：在服务工作者线程内发送常规网络请求；用于在服务工作者线程确定有必要发送实际网络请求（而不是返回缓存值）时。</li>
</ul>
<p>虽然专用工作者线程和共享工作者线程只有一个 message 事件作为输入，但服务工作者线程则可以接收很多事件，包括页面操作、通知操作触发的事件或推送事件。</p>
<p>注意：根据浏览器实现，在 SeviceWorker 中把日志打印到控制台不一定能在浏览器默认控制台中看到。</p>
<p>服务工作者线程的全局作用域可以监听以下事件：</p>
<pre><code class="language-txt"># 服务工作者线程状态
install：
    在服务工作者线程进入安装状态时触发（在客户端可以通过 ServiceWorkerRegistration.installing 判断）。
    也可以在 self.onintall 属性上指定该事件的处理程序。
    这是服务工作者线程接收的第一个事件，在线程一开始执行时就会触发。
    每个服务工作者线程只会调用一次。
activate ：
    在服务工作者线程进入激活或已激活状态时触发（在客户端可以通过ServiceWorkerRegistration.active 判断）。
    也可以在 self.onactive 属性上指定该事件的处理程序。
    此事件在服务工作者线程准备好处理功能性事件和控制客户端时触发。
    此事件并不代表服务工作者线程在控制客户端，只表明具有控制客户端的条件。

# Fetch API
fetch：
    在服务工作者线程截获来自主页面的 fetch()请求时触发。
    服务工作者线程的 fetch事件处理程序可以访问 FetchEvent，可以根据需要调整输出。
    也可以在 self.onfetch 属性上指定该事件的处理程序。

# Message API
message：
    在服务工作者线程通过 postMesssage()获取数据时触发。
    也可以在 self.onmessage属性上指定该事件的处理程序。

# Notification API
notificationclick：
    在系统告诉浏览器用户点击了 ServiceWorkerRegistration.showNotification()生成的通知时触发。
    也可以在 self.onnotificationclick 属性上指定该事件的处理程序。
notificationclose：
    在系统告诉浏览器用户关闭或取消显示了 ServiceWorkerRegistration.
    showNotification()生成的通知时触发。
    也可以在 self.onnotificationclose 属性上指定该事件的处理程序。

# Push API
push：
    在服务工作者线程接收到推送消息时触发。也可以在 self.onpush 属性上指定该事件的处理程序。
pushsubscriptionchange：
    在应用控制外的因素（非 JavaScript 显式操作）导致推送订阅状态变化时触发。
    也可以在 self.onpushsubscriptionchange 属性上指定该事件的处理程序。
</code></pre>
<h3 id="28-服务工作者线程作用域限制"><a class="header" href="#28-服务工作者线程作用域限制">2.8 服务工作者线程作用域限制</a></h3>
<p>服务工作者线程只能拦截其作用域内的客户端发送的请求。作用域是相对于获取服务脚本的路径定义的。如果没有在 register()中指定，则作用域就是服务脚本的路径。</p>
<p>通过根目录获取服务脚本对应的默认根作用域：</p>
<pre><code class="language-js">navigator.serviceWorker
  .register('/serviceWorker.js')
  .then((serviceWorkerRegistration) =&gt; {
    console.log(serviceWorkerRegistration.scope)
    // https://example.com/
  })

// 以下请求都会被拦截：
// fetch('/foo.js');
// fetch('/foo/fooScript.js');
// fetch('/baz/bazScript.js');
</code></pre>
<p>通过根目录获取服务脚本但指定了同一目录作用域：</p>
<pre><code class="language-js">navigator.serviceWorker
  .register('/serviceWorker.js', { scope: './' })
  .then((serviceWorkerRegistration) =&gt; {
    console.log(serviceWorkerRegistration.scope)
    // https://example.com/
  })

// 以下请求都会被拦截：
// fetch('/foo.js');
// fetch('/foo/fooScript.js');
// fetch('/baz/bazScript.js');
</code></pre>
<p>通过根目录获取服务脚本但限定了目录作用域：</p>
<pre><code class="language-js">navigator.serviceWorker
  .register('/serviceWorker.js', { scope: './foo' })
  .then((serviceWorkerRegistration) =&gt; {
    console.log(serviceWorkerRegistration.scope)
    // https://example.com/foo/
  })

// 以下请求都会被拦截：
// fetch('/foo/fooScript.js');
// 以下请求都不会被拦截：
// fetch('/foo.js');
// fetch('/baz/bazScript.js');
</code></pre>
<p>通过嵌套的二级目录获取服务脚本对应的同一目录作用域：</p>
<pre><code class="language-js">navigator.serviceWorker
  .register('/foo/serviceWorker.js')
  .then((serviceWorkerRegistration) =&gt; {
    console.log(serviceWorkerRegistration.scope)
    // https://example.com/foo/
  })

// 以下请求都会被拦截：
// fetch('/foo/fooScript.js');
// 以下请求都不会被拦截：
// fetch('/foo.js');
// fetch('/baz/bazScript.js');
</code></pre>
<p>服务工作者线程的作用域实际上遵循了目录权限模型，即只能相对于服务脚本所在路径缩小作用域。像下面这样扩展作用域会抛出错误：</p>
<pre><code class="language-js">navigator.serviceWorker.register('/foo/serviceWorker.js', { scope: '/' })
// Error: The path of the provided scope 'https://example.com/'
// is not under the max scope allowed 'https://example.com/foo/'
</code></pre>
<p>服务工作者线程作用域会使用末尾带斜杠的绝对路径来定义，比如：</p>
<pre><code class="language-js">navigator.serviceWorker.register('/serviceWorker.js', { scope: '/foo/' })
</code></pre>
<p>这样定义作用域有两个目的：将脚本文件的相对路径与作用域的相对路径分开，同时将该路径本身排除在作用域之外。例如，对于前面的代码片段而言，可能不需要在服务工作者线程的作用域中包含路径/foo。在末尾加上一个斜杠就可以明确排除/foo。当然，这要求绝对作用域路径不能扩展到服务工作者线程路径外。</p>
<p>如果想扩展服务工作者线程的作用域，主要有两种方式:</p>
<ul>
<li>通过包含想要的作用域的路径提供（获取）服务脚本。</li>
<li>给服务脚本的响应添加 Service-Worker-Allowed 头部，把它的值设置为想要的作用域。该作用域值应该与 register()中的作用域值一致</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="056-js-的多线程-服务工作者线程的线程缓存"><a class="header" href="#056-js-的多线程-服务工作者线程的线程缓存">05.6-JS 的多线程-服务工作者线程的线程缓存</a></h1>
<h2 id="一-线程缓存概念"><a class="header" href="#一-线程缓存概念">一 线程缓存概念</a></h2>
<p>在服务工作者线程之前，网页缺少缓存网络请求的稳健机制。浏览器一直使用 HTTP 缓存，但 HTTP 缓存并没有对 JavaScript 暴露编程接口，且其行为是受 JavaScript 运行时外部控制的。可以开发临时缓存机制，缓存响应字符串或 blob，但这种策略比较麻烦且效率低。</p>
<p>服务工作者线程的一个主要能力是可以通过编程方式实现真正的网络请求缓存机制。与 HTTP 缓存或 CPU 缓存不同：</p>
<ul>
<li>服务工作者线程缓存不自动缓存任何请求。所有缓存都必须明确指定。</li>
<li>服务工作者线程缓存没有到期失效的概念。除非明确删除，否则缓存内容一直有效。</li>
<li>服务工作者线程缓存必须手动更新和删除。</li>
<li>缓存版本必须手动管理。每次服务工作者线程更新，新服务工作者线程负责提供新的缓存键以保存新缓存。</li>
<li>唯一的浏览器强制逐出策略基于服务工作者线程缓存占用的空间。服务工作者线程负责管理自己缓存占用的空间。缓存超过浏览器限制时，浏览器会基于最近最少使用（ LRU， Least RecentlyUsed）原则为新缓存腾出空间。</li>
</ul>
<p>服务工作者线程缓存机制是一个双层字典，其中顶级字典的条目映射到二级嵌套字典。顶级字典是 CacheStorage 对象，可以通过服务工作者线程全局作用域的 caches 属性访问。顶级字典中的每个值都是一个 Cache 对象，该对象也是个字典，是 Request 对象到 Response 对象的映射。与 LocalStorage 一样， Cache 对象在 CacheStorage 字典中无限期存在，会超出浏览器会话的
界限。此外，Cache 条目只能以源为基础存取。</p>
<h2 id="二-cachestorage-对象"><a class="header" href="#二-cachestorage-对象">二 CacheStorage 对象</a></h2>
<p>CacheStorage 对象是映射到 Cache 对象的字符串键/值存储，通过全局对象的 caches 属性暴露出来，CacheStorage 中的每个缓存可以通过给 caches.open()传入相应字符串键取得。非字符串键会转换为字符串。如果缓存不存在，就会创建。Cache 对象是通过期约返回的：</p>
<pre><code class="language-js">caches.open('v1').then(console.log) // Cache {}
</code></pre>
<p>与 Map 类似， CacheStorage 也有 has()、 delete()和 keys()方法。这些方法与 Map 上对应方法类似，但都基于期约：</p>
<pre><code class="language-js">// 打开新缓存 v1
// 检查缓存 v1 是否存在
// 检查不存在的缓存 v2
caches
  .open('v1')
  .then(() =&gt; caches.has('v1'))
  .then(console.log) // true
  .then(() =&gt; caches.has('v2'))
  .then(console.log) // false

// 打开新缓存 v1
// 检查缓存 v1 是否存在
// 删除缓存 v1
// 再次检查缓存 v1 是否存在

caches
  .open('v1')
  .then(() =&gt; caches.has('v1'))
  .then(console.log) // true
  .then(() =&gt; caches.delete('v1'))
  .then(() =&gt; caches.has('v1'))
  .then(console.log) // false
// 打开缓存 v1、 v3 和 v2
// 检查当前缓存的键
// 注意：缓存键按创建顺序输出
caches
  .open('v1')
  .then(() =&gt; caches.open('v3'))
  .then(() =&gt; caches.open('v2'))
  .then(() =&gt; caches.keys())
  .then(console.log) // [&quot;v1&quot;, &quot;v3&quot;, &quot;v2&quot;]
</code></pre>
<p>CacheStorage 接口还有一个 match()方法，可以根据 Request 对象搜索 CacheStorage 中的所有 Cache 对象。搜索顺序是 CacheStorage.keys()的顺序，返回匹配的第一个响应：</p>
<pre><code class="language-js">// 创建一个请求键和两个响应值
const request = new Request('')
const response1 = new Response('v1')
const response2 = new Response('v2')
// 用同一个键创建两个缓存对象，最终会先找到 v1
// 因为它排在 caches.keys()输出的前面
caches
  .open('v1')
  .then((v1cache) =&gt; v1cache.put(request, response1))
  .then(() =&gt; caches.open('v2'))
  .then((v2cache) =&gt; v2cache.put(request, response2))
  .then(() =&gt; caches.match(request))
  .then((response) =&gt; response.text())
  .then(console.log) // v1
</code></pre>
<h2 id="三-cache-对象"><a class="header" href="#三-cache-对象">三 Cache 对象</a></h2>
<p>CacheStorage 通过字符串映射到 Cache 对象。 Cache 对象跟 CacheStorage 一样，类似于异步的 Map。 Cache 键可以是 URL 字符串，也可以是 Request 对象。这些键会映射到 Response 对象。</p>
<p>服务工作者线程缓存只考虑缓存 HTTP 的 GET 请求。这样是合理的，因为 GET 请求的响应通常不会随时间而改变。另一方面，默认情况下， Cache 不允许使用 POST、 PUT 和 DELETE 等请求方法。这些方法意味着与服务器动态交换信息，因此不适合客户端缓存。</p>
<p>为填充 Cache，可能使用以下三个方法:</p>
<pre><code class="language-txt">put(request, response)：
    在键（ Request 对象或 URL 字符串）和值（ Response 对象）
    同时存在时用于添加缓存项。该方法返回期约，在添加成功后会解决。

add(request)：
    在只有 Request 对象或 URL 时使用此方法发送 fetch()请求，并缓存响应。
    该方法返回期约，期约在添加成功后会解决。

addAll(requests)：
    在希望填充全部缓存时使用，比如在服务工作者线程初始化时也初始化缓存。
    该方法接收 URL 或 Request 对象的数组。
    addAll()会对请求数组中的每一项分别调用add()。该方法返回期约，期约在所有缓存内容添加成功后会解决。
</code></pre>
<p>与 Map 类似， Cache 也有 delete()和 keys()方法。</p>
<p>缓存是否命中取决于 URL 字符串和/或 Request 对象 URL 是否匹配。 URL 字符串和 Request 对象是可互换的，因为匹配时会提取 Request 对象的 URL：</p>
<pre><code class="language-js">const request1 = 'https://www.foo.com'
const request2 = new Request('https://www.bar.com')
const response1 = new Response('fooResponse')
const response2 = new Response('barResponse')
caches.open('v1').then((cache) =&gt; {
  cache
    .put(request1, response1)
    .then(() =&gt; cache.put(request2, response2))
    .then(() =&gt; cache.match(new Request('https://www.foo.com')))
    .then((response) =&gt; response.text())
    .then(console.log) // fooResponse
    .then(() =&gt; cache.match('https://www.bar.com'))
    .then((response) =&gt; response.text())
    .then(console.log) // barResponse
})
</code></pre>
<p>Cache 对象使用 Request 和 Response 对象的 clone()方法创建副本，并把它们存储为键/值对。下面的例子演示了这一点，因为从缓存中取得的实例并不等于原始的键/值对：</p>
<pre><code class="language-js">const request1 = new Request('https://www.foo.com')
const response1 = new Response('fooResponse')
caches.open('v1').then((cache) =&gt; {
  cache
    .put(request1, response1)
    .then(() =&gt; cache.keys())
    .then((keys) =&gt; console.log(keys[0] === request1)) // false
    .then(() =&gt; cache.match(request1))
    .then((response) =&gt; console.log(response === response1)) // false
})
</code></pre>
<p>Cache.match()、 Cache.matchAll()和 CacheStorage.match()都支持可选的 options 对象，它允许通过设置以下属性来配置 URL 匹配的行为：</p>
<ul>
<li>cacheName：只有 CacheStorage.matchAll()支持。设置为字符串时，只会匹配 Cache 键为指定字符串的缓存值。</li>
<li>ignoreSearch：设置为 true 时，在匹配 URL 时忽略查询字符串，包括请求查询和缓存键。例如， https://example.com?foo=bar 会匹配 https://example.com。</li>
<li>ignoreMethod：设置为 true 时，在匹配 URL 时忽略请求查询的 HTTP 方法</li>
<li>ignoreVary：匹配的时候考虑 HTTP 的 Vary 头部，该头部指定哪个请求头部导致服务器响应不同的值。 ignoreVary 设置为 true 时，在匹配 URL 时忽略 Vary 头部。</li>
</ul>
<p>POST 请求匹配 GET 请求：</p>
<pre><code class="language-js">const request1 = new Request('https://www.foo.com')
const response1 = new Response('fooResponse')
const postRequest1 = new Request('https://www.foo.com', { method: 'POST' })
caches.open('v1').then((cache) =&gt; {
  cache
    .put(request1, response1)
    .then(() =&gt; cache.match(postRequest1))
    .then(console.log) // undefined
    .then(() =&gt; cache.match(postRequest1, { ignoreMethod: true }))
    .then(console.log) // Response {}
})
</code></pre>
<p>ignoreVary：</p>
<pre><code class="language-js">const request2 = new Request('https://www.foo.com')
const response2 = new Response('fooResponse', { headers: { Vary: 'Accept' } })
const acceptRequest2 = new Request('https://www.foo.com', {
  headers: { Accept: 'text/json' },
})
caches.open('v1').then((cache) =&gt; {
  cache
    .put(request1, response2)
    .then(() =&gt; cache.match(acceptRequest2))
    .then(console.log) // undefined
    .then(() =&gt; cache.match(acceptRequest2, { ignoreVary: true }))
    .then(console.log) // Response {}
})
</code></pre>
<h2 id="四-最大存储空间"><a class="header" href="#四-最大存储空间">四 最大存储空间</a></h2>
<p>浏览器需要限制缓存占用的磁盘空间，否则无限制存储势必会造成滥用。该存储空间的限制没有任何规范定义，完全由浏览器供应商的个人喜好决定。</p>
<p>使用 StorageEstimate API 可以近似地获悉有多少空间可用（以字节为单位），以及当前使用了多少空间。此方法只在安全上下文中可用：</p>
<pre><code class="language-js">navigator.storage.estimate().then(console.log)
// 不同浏览器的输出可能不同：
// { quota: 2147483648, usage: 590845 } // 不精确
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="057-js-的多线程-服务工作者线程的生命周期"><a class="header" href="#057-js-的多线程-服务工作者线程的生命周期">05.7-JS 的多线程-服务工作者线程的生命周期</a></h1>
<h2 id="一-状态触发"><a class="header" href="#一-状态触发">一 状态触发</a></h2>
<p>Service Worker 规范定义了 6 种服务工作者线程可能存在的状态： 已解析（ parsed）、 安装中（ installing）、 已安装（ installed）、 激活中（ activating）、 已激活（ activated）和已失效（ redundant）。完整的服务工作者线程生命周期会以该顺序进入相应状态，尽管有可能不会进入每个状态。安装或激活服务工作者线程时遇到错误会跳到已失效状态。</p>
<p>上述状态的每次变化都会在 ServiceWorker 对象上触发 statechange 事件，可以像下面这样为它添加一个事件处理程序：</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  registration.installing.onstatechange = ({ target: { state } }) =&gt; {
    console.log('state changed to', state)
  }
})
</code></pre>
<h2 id="二-状态介绍"><a class="header" href="#二-状态介绍">二 状态介绍</a></h2>
<h3 id="21-已解析状态"><a class="header" href="#21-已解析状态">2.1 已解析状态</a></h3>
<p>调用 navigator.serviceWorker.register()会启动创建服务工作者线程实例的过程。刚创建的服务工作者线程实例会进入已解析状态。该状态没有事件，也没有与之相关的 ServiceWorker.state 值。</p>
<p>浏览器获取脚本文件，然后执行一些初始化任务，服务工作者线程的生命周期就开始了：</p>
<ul>
<li>(1) 确保服务脚本来自相同的源。</li>
<li>(2) 确保在安全上下文中注册服务工作者线程。</li>
<li>(3) 确保服务脚本可以被浏览器 JavaScript 解释器成功解析而不会抛出任何错误。</li>
<li>(4) 捕获服务脚本的快照。下一次浏览器下载到服务脚本，会与这个快照对比差异，并据此决定是否应该更新服务工作者线程。</li>
</ul>
<p>所有这些任务全部成功，则 register()返回的期约会解决为一个 ServiceWorkerRegistration 对象。新创建的服务工作者线程实例进入到安装中状态</p>
<h3 id="22-安装中状态"><a class="header" href="#22-安装中状态">2.2 安装中状态</a></h3>
<p>安装中状态是执行所有服务工作者线程设置任务的状态。这些任务包括在服务工作者线程控制页面前必须完成的操作。</p>
<p>在客户端，这个阶段可以通过检查 ServiceWorkerRegistration.installing 是否被设置为 ServiceWorker 实例：</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  if (registration.installing) {
    console.log('Service worker is in the installing state')
  }
})
</code></pre>
<p>关联的 ServiceWorkerRegistration 对象也会在服务工作者线程到达该状态时触发 updatefound 事件：</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js')
  .then((registration) =&gt; {
    registration.onupdatefound = () =&gt;
    console.log('Service worker is in the installing state');
  };
});
</code></pre>
<p>在服务工作者线程中，这个阶段可以通过给 install 事件添加处理程序来确定：</p>
<pre><code class="language-js">self.oninstall = (installEvent) =&gt; {
  console.log('Service worker is in the installing state')
}
</code></pre>
<p>安装中状态频繁用于填充服务工作者线程的缓存。服务工作者线程在成功缓存指定资源之前可以一直处于该状态。如果任何资源缓存失败，服务工作者线程都会安装失败并跳至已失效状态。</p>
<p>服务工作者线程可以通过 ExtendableEvent 停留在安装中状态。InstallEvent 继承自 ExtendableEvent，因此暴露了一个 API，允许将状态过渡延迟到期约解决。为此要调用 ExtendableEvent.waitUntil()方法，该方法接收一个期约参数，会将状态过渡延迟到这个期约解决。例如，下面的例子可以延迟 5 秒再将状态过渡到已安装状态：</p>
<pre><code class="language-js">self.oninstall = (installEvent) =&gt; {
  installEvent.waitUntil(
    new Promise((resolve, reject) =&gt; setTimeout(resolve, 5000))
  )
}
</code></pre>
<p>更接近实际的例子是通过 Cache.addAll()缓存一组资源之后再过渡：</p>
<pre><code class="language-js">const CACHE_KEY = 'v1'
self.oninstall = (installEvent) =&gt; {
  installEvent.waitUntil(
    caches
      .open(CACHE_KEY)
      .then((cache) =&gt; cache.addAll(['foo.js', 'bar.html', 'baz.css']))
  )
}
</code></pre>
<p>如果没有错误发生或者没有拒绝，服务工作者线程就会前进到已安装状态。</p>
<h3 id="23-已安装状态"><a class="header" href="#23-已安装状态">2.3 已安装状态</a></h3>
<p>已安装状态也称为等待中（ waiting）状态，意思是服务工作者线程此时没有别的事件要做，只是准备在得到许可的时候去控制客户端。如果没有活动的服务工作者线程，则新安装的服务工作者线程会跳到这个状态，并直接进入激活中状态，因为没有必要再等了。</p>
<p>在客户端，这个阶段可以通过检查 ServiceWorkerRegistration.waiting 是否被设置为一个 ServiceWorker 实例来确定：</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  if (registration.waiting) {
    console.log('Service worker is in the installing/waiting state')
  }
})
</code></pre>
<p>如果已有了一个活动的服务工作者线程，则已安装状态是触发逻辑的好时机，这样会把这个新服务工作者线程推进到激活中状态。可以通过 self.skipWaiting()强制推进服务工作者线程的状态，也可以通过提示用户重新加载应用程序，从而使浏览器可以按部就班地推进。</p>
<h3 id="24-激活中状态"><a class="header" href="#24-激活中状态">2.4 激活中状态</a></h3>
<p>激活中状态表示服务工作者线程已经被浏览器选中即将变成可以控制页面的服务工作者线程。如果浏览器中没有活动服务工作者线程，这个新服务工作者线程会自动到达激活中状态。如果有一个活动服务工作者线程，则这个作为替代的服务工作者线程可以通过如下方式进入激活中状态。</p>
<ul>
<li>原有服务工作者线程控制的客户端数量变为 0。这通常意味着所有受控的浏览器标签页都被关闭。在下一个导航事件时，新服务工作者线程会到达激活中状态。</li>
<li>已安装的服务工作者线程调用 self.skipWaiting()。这样可以立即生效，而不必等待一次导航事件</li>
</ul>
<p>在激活中状态下，不能像已激活状态中那样执行发送请求或推送事件的操作。</p>
<p>在客户端，这个阶段大致可以通过检查 ServiceWorkerRegistration.active 是否被设置为一个 ServiceWorker 实例来确定：</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  if (registration.active) {
    console.log('Service worker is in the activating/activated state')
  }
})
</code></pre>
<p>注意， ServiceWorkerRegistration.active 属性表示服务工作者线程可能在激活中状态，也可能在已激活状态。
在这个服务工作者线程内部，可以通过给 activate 事件添加处理程序来获悉：</p>
<pre><code class="language-js">self.oninstall = (activateEvent) =&gt; {
  console.log('Service worker is in the activating state')
}
</code></pre>
<p>activate 事件表示可以将老服务工作者线程清理掉了，该事件经常用于清除旧缓存数据和迁移数据库。例如，下面的代码清除了所有版本比较老的缓存：</p>
<pre><code class="language-js">const CACHE_KEY = 'v3';
self.oninstall = (activateEvent) =&gt; {
caches.keys()
.then((keys) =&gt; keys.filter((key) =&gt; key != CACHE_KEY))
.then((oldKeys) =&gt; oldKeys.forEach((oldKey) =&gt; caches.delete(oldKey));
};
</code></pre>
<p>activate 事件也继承自 ExtendableEvent，因此也支持 waitUntil()方法，可以延迟过渡到已激活状态，或者基于期约拒绝过渡到已失效状态。</p>
<p>注意:服务工作者线程中的 activate 事件并不代表服务工作者线程正在控制客户端。</p>
<h3 id="25-已激活状态"><a class="header" href="#25-已激活状态">2.5 已激活状态</a></h3>
<p>已激活状态表示服务工作者线程正在控制一个或多个客户端。在这个状态，服务工作者线程会捕获其作用域中的 fetch()事件、通知和推送事件。</p>
<p>在客户端，这个阶段大致可以通过检查 ServiceWorkerRegistration.active 是否被设置为一个 ServiceWorker 实例来确定：</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  if (registration.active) {
    console.log('Service worker is in the activating/activated state')
  }
})
</code></pre>
<p>ServiceWorkerRegistration.active 属性表示服务工作者线程可能在激活中状态，也可能在已激活状态。</p>
<p>更可靠的确定服务工作者线程处于已激活状态一种方式是检查 ServiceWorkerRegistration 的 controller 属性。该属性会返回激活的 ServiceWorker 实例，即控制页面的实例：</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  if (registration.controller) {
    console.log('Service worker is in the activated state')
  }
})
</code></pre>
<p>在新服务工作者线程控制客户端时，该客户端中的 ServiceWorkerContainer 会触发 controllerchange 事件：</p>
<pre><code class="language-js">navigator.serviceWorker.oncontrollerchange = () =&gt; {
  console.log('A new service worker is controlling this client')
}
</code></pre>
<p>另外，也可以使用 ServiceWorkerContainer.ready 期约来检测活动服务工作者线程。该期约会在当前页面拥有活动工作者线程时立即解决：</p>
<pre><code class="language-js">navigator.serviceWorker.ready.then(() =&gt; {
  console.log('A new service worker is controlling this client')
})
</code></pre>
<h3 id="26-已失效状态"><a class="header" href="#26-已失效状态">2.6 已失效状态</a></h3>
<p>已失效状态表示服务工作者线程已被宣布死亡。不会再有事件发送给它，浏览器随时可能销毁它并回收它的资源。</p>
<h3 id="27-更新服务工作者线程"><a class="header" href="#27-更新服务工作者线程">2.7 更新服务工作者线程</a></h3>
<p>因为版本控制的概念根植于服务工作者线程的整个生命周期，所以服务工作者线程会随着版本变化。为此，服务工作者线程提供了稳健同时也复杂的流程，以安装替换过时的服务工作者线程。</p>
<p>这个更新流程的初始阶段是更新检查，也就是浏览器重新请求服务脚本。以下事件可以触发更新检查。</p>
<pre><code class="language-txt">以创建当前活动服务工作者线程时不一样的 URL 调用 navigator.serviceWorker.register()。
浏览器导航到服务工作者线程作用域中的一个页面。
发生了 fetch()或 push()等功能性事件， 且至少 24 小时内没有发生更新检查。
</code></pre>
<p>新获取的服务脚本会与当前服务工作者线程的脚本比较差异。如果不相同，浏览器就会用新脚本初始化一个新的服务工作者线程。更新的服务工作者线程进入自己的生命周期，直至抵达已安装状态。到达已安装状态后，更新服务工作者线程会等待浏览器决定让它安全地获得页面的控制权（或用户强制它获得页面控制权）。</p>
<p>关键在于，刷新页面不会让更新服务工作者线程进入激活状态并取代已有的服务工作者线程。 比如，有个打开的页面，其中有一个服务工作者线程正在控制它，而一个更新服务工作者线程正在已安装状态中等待。客户端在页面刷新期间会发生重叠，即旧页面还没有卸载，新页面已加载了。因此，现有的服务工作者线程永远不会让出控制权，毕竟至少还有一个客户端在它的控制之下。为此，取代现有服务工作者线程唯一的方式就是关闭所有受控页面。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="058-js-的多线程-服务工作者线程的补充"><a class="header" href="#058-js-的多线程-服务工作者线程的补充">05.8-JS 的多线程-服务工作者线程的补充</a></h1>
<h2 id="一-服务工作者线程客户端"><a class="header" href="#一-服务工作者线程客户端">一 服务工作者线程客户端</a></h2>
<p>服务工作者线程会使用 Client 对象跟踪关联的窗口、工作者或服务工作者线程。服务工作者线程可以通过 Clients 接口访问这些 Client 对象。该接口暴露在全局上下文的 self.clients 属性上。</p>
<p>Client 对象支持以下属性和方法：</p>
<ul>
<li>id：返回客户端的全局唯一标识符，可用于通过 Client.get()获取客户端的引用。</li>
<li>type：返回表示客户端类型的字符串。 type 可能的值是 window、 worker 或 sharedworker。</li>
<li>url：返回客户端的 URL。</li>
<li>postMessage()：用于向单个客户端发送消息。</li>
</ul>
<p>Clients 接口支持通过 get()或 matchAll()访问 Client 对象。这两个方法都通过期约返回结果。matchAll()也可以接收 options 对象：</p>
<ul>
<li>includeUncontrolled：在设置为 true 时，返回结果包含不受当前服务工作者线程控制的客户端。默认为 false。</li>
<li>type：可以设置为 window、 worker 或 sharedworker，对返回结果进行过滤。默认为 all，返回所有类型的客户端</li>
</ul>
<p>Clients 接口也支持以下方法：</p>
<ul>
<li>openWindow(url)：在新窗口中打开指定 URL，实际上会给当前服务工作者线程添加一个新 Client。这个新 Client 对象以解决的期约形式返回。该方法可用于回应点击通知的操作，此时服务工作者线程可以检测单击事件并作为响应打开一个窗口。</li>
<li>claim()：强制性设置当前服务工作者线程以控制其作用域中的所有客户端。 claim()可用于不
希望等待页面重新加载而让服务工作者线程开始管理页面。</li>
</ul>
<h2 id="二-服务工作者线程与一致性"><a class="header" href="#二-服务工作者线程与一致性">二 服务工作者线程与一致性</a></h2>
<p>理解服务工作者线程最终用途十分重要：让网页能够模拟原生应用程序。要像原生应用程序一样，服务工作者线程必须支持版本控制（ versioning）。</p>
<p>从全局角度说，服务工作者线程的版本控制可以确保任何时候两个网页的操作都有一致性。该一致性可以表现为如下两种形式：</p>
<pre><code class="language-txt">代码一致性:
    网页不是像原生应用程序那样基于一个二进制文件创建，而是由很多 HTML、 CSS、JavaScript、图片、 JSON，
    以及页面可能加载的任何类型的文件创建。网页经常会递增更新，即版本升级，以增加或修改行为。
    如果网页总共加载了 100 个文件，而加载的资源同时来自第 1版和第 2 版，那么就会导致完全无法预测，而且很可能出错。
    服务工作者线程为此提供了一种强制机制，确保来自同源的所有并存页面始终会使用来自相同版本的资源

数据一致性:
    网页并非与外界隔绝的应用程序。它们会通过各种浏览器 API 如 LocalStorage或 IndexedDB 在本地读取并写入数据；
    也会向远程 API 发送请求并获取数据。这些获取和写入数据的格式在不同版本中可能也会变化。
    如果一个页面以第 1 版中的格式写入了数据，第二个页面以第 2 版中的格式读取该数据就会导致无法预测的结果甚至出错。
    服务工作者线程的资源一致性机制可以保证网页输入/输出行为对同源的所有并存网页都相同。
</code></pre>
<p>为确保一致性，服务工作者线程的生命周期不遗余力地避免出现有损一致性的现象。比如下面这些可能：</p>
<pre><code class="language-txt">服务工作者线程提早失败：
    在安装服务工作者线程时，任何预料之外的问题都可能阻止服务工作者线程成功安装。
    包括服务脚本加载失败、服务脚本中存在语法或运行时错误、无法通过importScripts()加载工作者线程依赖，甚至加载某个缓存资源失败。

服务工作者线程激进更新：
    浏览器再次加载服务脚本时（无论通过 register()手动加载还是基于页面重载），
    服务脚本或通过 importScripts()加载的依赖中哪怕有一个字节的差异，也会启动安装新版本的服务工作者线程。

未激活服务工作者线程消极活动：
    当页面上第一次调用 register()时，服务工作者线程会被安装，但不会被激活，
    并且在导航事件发生前不会控制页面。
    这应该是合理的：可以认为当前页面已加载了资源，因此服务工作者线程不应该被激活，否则就会加载不一致的资源。

活动的服务工作者线程粘连：
    只要至少有一个客户端与关联到活动的服务工作者线程，浏览器就会在该源的所有页面中使用它。
    浏览器可以安装新服务工作者线程实例以替代这个活动的实例，
    但浏览器在与活动实例关联的客户端为 0（或强制更新服务工作者线程）之前不会切换到新工作者线程。
    这个服务工作者线程逐出策略能够防止两个客户端同时运行两个不同版本的服务工作者线程。
</code></pre>
<h2 id="三-控制反转与服务工作者线程持久化"><a class="header" href="#三-控制反转与服务工作者线程持久化">三 控制反转与服务工作者线程持久化</a></h2>
<p>虽然专用工作者线程和共享工作者线程是有状态的，但服务工作者线程是无状态的。更具体地说，服务工作者线程遵循控制反转（ IoC， Inversion of Control）模式并且是事件驱动的。</p>
<p>这样就意味着服务工作者线程不应该依赖工作者线程的全局状态。服务工作者线程中的绝大多数代码应该在事件处理程序中定义。当然，服务工作者线程的版本作为全局常量是个显而易见的例外。服务脚本执行的次数变化很大，高度依赖浏览器状态，因此服务脚本的行为应该是幂等的。</p>
<p>理解服务工作者线程的生命周期与它所控制的客户端的生命周期无关非常重要。大多数浏览器将服务工作者线程实现为独立的进程，而该进程由浏览器单独控制。如果浏览器检测到某个服务工作者线程空闲了，就可以终止它并在需要时再重新启动。这意味着可以依赖服务工作者线程在激活后处理事件，但不能依赖它们的持久化全局状态。</p>
<h2 id="四-通过-updateviacache-管理服务文件缓存"><a class="header" href="#四-通过-updateviacache-管理服务文件缓存">四 通过 updateViaCache 管理服务文件缓存</a></h2>
<p>正常情况下，浏览器加载的所有 JavaScript 资源会按照它们的 Cache-Control 头部纳入 HTTP 缓存管理。因为服务脚本没有优先权，所以浏览器不会在缓存文件失效前接收更新的服务脚本。</p>
<p>为了尽可能传播更新后的服务脚本，常见的解决方案是在响应服务脚本时设置 Cache-Control:max-age=0 头部。这样浏览器就能始终取得最新的脚本文件。</p>
<p>这个即时失效的方案能够满足需求，但仅仅依靠 HTTP 头部来决定是否更新意味着只能由服务器控制客户端。为了让客户端能控制自己的更新行为，可以通过 updateViaCache 属性设置客户端对待服务脚本的方式。该属性可以在注册服务工作者线程时定义，可以是如下三个字符串值。</p>
<ul>
<li>imports：默认值。顶级服务脚本永远不会被缓存，但通过 importScripts()在服务工作者线程内部导入的文件会按照 Cache-Control 头部设置纳入 HTTP 缓存管理。</li>
<li>all：服务脚本没有任何特殊待遇。所有文件都会按照 Cache-Control 头部设置纳入 HTTP 缓存管理。</li>
<li>none：顶级服务脚本和通过 importScripts()在服务工作者线程内部导入的文件永远都不会被缓存。</li>
</ul>
<p>可以像下面这样使用 updateViaCache 属性：</p>
<pre><code class="language-js">navigator.serviceWorker.register('/serviceWorker.js', {
  updateViaCache: 'none',
})
</code></pre>
<p>浏览器仍在渐进地支持这个选项，因此强烈推荐读者同时使用 updateViaCache 和 CacheControl 头部指定客户端的缓存行为。</p>
<h2 id="五-强制性服务工作者线程操作"><a class="header" href="#五-强制性服务工作者线程操作">五 强制性服务工作者线程操作</a></h2>
<p>某些情况下，有必要尽可能快地让服务工作者线程进入已激活状态，即使可能会造成资源版本控制不一致。该操作通常适合在安装事件中缓存资源，此时要强制服务工作者线程进入活动状态，然后再强制活动服务工作者线程去控制关联的客户端。</p>
<pre><code class="language-js">const CACHE_KEY = 'v1'
self.oninstall = (installEvent) =&gt; {
  // 填充缓存，然后强制服务工作者线程进入已激活状态
  // 这样会触发 activate 事件
  installEvent.waitUntil(
    caches
      .open(CACHE_KEY)
      .then((cache) =&gt; cache.addAll(['foo.css', 'bar.js']))
      .then(() =&gt; self.skipWaiting())
  )
}
// 强制服务工作者线程接管客户端
// 这会在每个客户端触发 controllerchange 事件
self.onactivate = (activateEvent) =&gt; clients.claim()
</code></pre>
<p>浏览器会在每次导航事件中检查新服务脚本，但有时候这样也太不够了。 ServiceWorkerRegistration 对象为此提供了一个 update()方法，可以用来告诉浏览器去重新获取服务脚本，与现有的比较，然后必要时安装更新的服务工作者线程。可以这样来实现：</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  // 每 17 分钟左右检查一个更新版本
  setInterval(() =&gt; registration.update(), 1e6)
})
</code></pre>
<h2 id="六-服务工作者线程消息"><a class="header" href="#六-服务工作者线程消息">六 服务工作者线程消息</a></h2>
<p>与专用工作者线程和共享工作者线程一样，服务工作者线程也能与客户端通过 postMessage()交换消息。实现通信的最简单方式是向活动工作者线程发送一条消息，然后使用事件对象发送回应。发送给服务工作者线程的消息可以在全局作用域处理，而发送回客户端的消息则可以在 ServiceWorkerContext 对象上处理：</p>
<pre><code class="language-js">// ServiceWorker.js
self.onmessage = ({ data, source }) =&gt; {
  console.log('service worker heard:', data)
  source.postMessage('bar')
}

// main.js
navigator.serviceWorker.onmessage = ({ data }) =&gt; {
  console.log('client heard:', data)
}
navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  if (registration.active) {
    registration.active.postMessage('foo')
  }
})
// service worker heard: foo
// client heard: bar
</code></pre>
<p>也可以简单地使用 serviceWorker.controller 属性：</p>
<pre><code class="language-js">// ServiceWorker.js
self.onmessage = ({ data, source }) =&gt; {
  console.log('service worker heard:', data)
  source.postMessage('bar')
}

// main.js
navigator.serviceWorker.onmessage = ({ data }) =&gt; {
  console.log('client heard:', data)
}
navigator.serviceWorker.register('./serviceWorker.js').then(() =&gt; {
  if (navigator.serviceWorker.controller) {
    navigator.serviceWorker.controller.postMessage('foo')
  }
})
// service worker heard: foo
// client heard: bar
</code></pre>
<p>前面的例子在每次页面重新加载时都会运行。这是因为服务工作者线程会回应每次刷新后客户端脚本发送的消息。在通过新标签页打开这个页面时也一样。如果服务工作者线程需要率先发送消息，可以像下面这样获得客户端的引用：</p>
<pre><code class="language-js">// ServiceWorker.js
self.onmessage = ({ data }) =&gt; {
  console.log('service worker heard:', data)
}
self.onactivate = () =&gt; {
  self.clients
    .matchAll({ includeUncontrolled: true })
    .then((clientMatches) =&gt; clientMatches[0].postMessage('foo'))
}

// main.js
navigator.serviceWorker.onmessage = ({ data, source }) =&gt; {
  console.log('client heard:', data)
  source.postMessage('bar')
}
navigator.serviceWorker.register('./serviceWorker.js')
// client heard: foo
// service worker heard: bar
</code></pre>
<p>前面的例子只会运行一次，因为活动事件在每个服务工作者线程上只会触发一次。因为客户端和服务工作者线程可以相互之间发送消息，所以通过 MessageChannel 或 BroadcastChannel 实现通信也是可能的。</p>
<h2 id="七-拦截-fetch-事件"><a class="header" href="#七-拦截-fetch-事件">七 拦截 fetch 事件</a></h2>
<p>服务工作者线程最重要的一个特性就是拦截网络请求。服务工作者线程作用域中的网络请求会注册为 fetch 事件。这种拦截能力不限于 fetch()方法发送的请求，也能拦截对 JavaScript、 CSS、图片和 HTML（包括对主 HTML 文档本身）等资源发送的请求。这些请求可以来自 JavaScript，也可以通过<code>&lt;script&gt;</code>、 <code>&lt;link&gt;</code>或<code>&lt;img&gt;</code>标签创建。直观地说，这样是合理的：如果想让服务工作者线程模拟离线应用程序，它就必须能够把控页面正常运行所需的所有请求资源。</p>
<p>FetchEvent 继承自 ExtendableEvent。让服务工作者线程能够决定如何处理 fetch 事件的方法是 event.respondWith()。该方法接收期约，该期约会解决为一个 Response 对象。当然，该 Response 对象实际上来自哪里完全由服务工作者线程决定。可以来自网络，来自缓存，或者动态创建。下面几节将介绍几种网络/缓存策略，可以在。</p>
<p>服务工作者线程中使用的网络缓存策略很多：</p>
<p><strong>策略一：从网络返回</strong>：单地转发 fetch 事件。那些绝对需要发送到服务器的请求例如 POST 请求就适合该策略。</p>
<pre><code class="language-js">self.onfetch = (fetchEvent) =&gt; {
  fetchEvent.respondWith(fetch(fetchEvent.request))
}
</code></pre>
<p><strong>策略二：从缓存返回</strong>：即缓存检查。对于任何肯定有缓存的资源（如在安装阶段缓存的资源），可以采用该策略：</p>
<pre><code class="language-js">self.onfetch = (fetchEvent) =&gt; {
  fetchEvent.respondWith(caches.match(fetchEvent.request))
}
</code></pre>
<p><strong>策略三：从网络返回，缓存作后备</strong>：这个策略把从网络获取最新的数据作为首选，但如果缓存中有值也会返回缓存的值。如果应用程序需要尽可能展示最新数据，但在离线的情况下仍要展示一些信息，就可以采用该策略：</p>
<pre><code class="language-js">self.onfetch = (fetchEvent) =&gt; {
  fetchEvent.respondWith(
    fetch(fetchEvent.request).catch(() =&gt; caches.match(fetchEvent.request))
  )
}
</code></pre>
<p><strong>策略四：从缓存返回，网络作后备</strong>：这个策略优先考虑响应速度，但仍会在没有缓存的情况下发送网络请求。这是大多数渐进式 Web
应用程序（ PWA， Progressive Web Application）采取的首选策略：</p>
<pre><code class="language-js">self.onfetch = (fetchEvent) =&gt; {
  fetchEvent.respondWith(
    caches
      .match(fetchEvent.request)
      .then((response) =&gt; response || fetch(fetchEvent.request))
  )
}
</code></pre>
<p><strong>策略五：通用后备</strong>：应用程序需要考虑缓存和网络都不可用的情况。服务工作者线程可以在安装时缓存后备资源，然后
在缓存和网络都失败时返回它们：</p>
<pre><code class="language-js">self.onfetch = (fetchEvent) =&gt; {
  fetchEvent.respondWith(
    // 开始执行“从缓存返回，以网络为后备”策略
    caches
      .match(fetchEvent.request)
      .then((response) =&gt; response || fetch(fetchEvent.request))
      .catch(() =&gt; caches.match('/fallback.html'))
  )
}
</code></pre>
<p>这里的 catch()子句可以扩展为支持不同类型的后备，例如点位图、哑数据，等等。</p>
<h2 id="八-推送通知"><a class="header" href="#八-推送通知">八 推送通知</a></h2>
<h3 id="81-推送通知需求"><a class="header" href="#81-推送通知需求">8.1 推送通知需求</a></h3>
<p>对于模拟原生应用程序的 Web 应用程序而言，必须支持推送消息。这意味着网页必须能够接收服务器的推送事件，然后在设备上显示通知（即使应用程序没有运行）。当然，这在常规网页中肯定是不可能的。不过，有了服务工作者线程就可以实现该行为。</p>
<p>为了在 PWA 应用程序中支持推送通知，必须支持以下 4 种行为：</p>
<pre><code class="language-txt">服务工作者线程必须能够显示通知。
服务工作者线程必须能够处理与这些通知的交互。
服务工作者线程必须能够订阅服务器发送的推送通知。
服务工作者线程必须能够处理推送消息，即使应用程序没在前台运行或者根本没打开。
</code></pre>
<h3 id="82-显示通知"><a class="header" href="#82-显示通知">8.2 显示通知</a></h3>
<p>服务工作者线程可以通过它们的注册对象使用 Notification API。这样做有很好的理由：与服务工作者线程关联的通知也会触发服务工作者线程内部的交互事件。</p>
<p>显示通知要求向用户明确地请求授权。授权完成后，可以通过 ServiceWorkerRegistration.showNotification()显示通知。下面是示例实现：</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  Notification.requestPermission().then((status) =&gt; {
    if (status === 'granted') {
      registration.showNotification('foo')
    }
  })
})
</code></pre>
<p>类似地，在服务工作者线程内部可以使用全局 registration 属性触发通知：</p>
<pre><code class="language-js">self.onactivate = () =&gt; self.registration.showNotification('bar')
</code></pre>
<p>在上面的例子中，获得显示通知的授权后，会把 foo 通知显示在浏览器中。该通知与使用 new Notification()创建的通知看不出有任何差别。此外，显示该通知不需要服务工作者线程额外做任何事情。服务工作者线程只在需要处理通知事件时才会发挥作用。</p>
<h3 id="83-处理通知事件"><a class="header" href="#83-处理通知事件">8.3 处理通知事件</a></h3>
<p>通过 ServiceWorkerRegistration 对象创建的通知会向服务工作者线程发送 notificationclick 和 notificationclose 事件。假设前面例子中的服务脚本定义了如下事件处理程序：</p>
<pre><code class="language-js">self.onnotificationclick = ({ notification }) =&gt; {
  console.log('notification click', notification)
}
self.onnotificationclose = ({ notification }) =&gt; {
  console.log('notification close', notification)
}
</code></pre>
<p>在这个例子中，与通知的两种交互操作都在服务工作者线程中注册了处理程序。这里的 notification 事件对象暴露了 notification 属性，其中包含着生成该事件 Notification 对象。这些处理程序可以决定交互操作之后的响应方式。</p>
<p>一般来说，单击通知意味着用户希望转到某个具体的页面。在服务工作者线程处理程序中，可以通过 clients.openWindow()打开相应的 URL，例如：</p>
<pre><code class="language-js">self.onnotificationclick = ({ notification }) =&gt; {
  clients.openWindow('https://foo.com')
}
</code></pre>
<h3 id="84-订阅推送事件"><a class="header" href="#84-订阅推送事件">8.4 订阅推送事件</a></h3>
<p>对于发送给服务工作者线程的推送消息，必须通过服务工作者线程的 PushManager 来订阅。这样服务工作者线程就可以在 push 事件处理程序中处理推送消息。</p>
<pre><code class="language-js">navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  registration.pushManager.subscribe({
    applicationServerKey: key, // 来自服务器的公钥
    userVisibleOnly: true,
  })
})
</code></pre>
<p>另外，服务工作者线程也可以使用全局的 registration 属性自己订阅：</p>
<pre><code class="language-js">self.onactivate = () =&gt; {
  self.registration.pushManager.subscribe({
    applicationServerKey: key, // 来自服务器的公钥
    userVisibleOnly: true,
  })
}
</code></pre>
<h3 id="85-处理推送事件"><a class="header" href="#85-处理推送事件">8.5 处理推送事件</a></h3>
<p>订阅之后，服务工作者线程会在每次服务器推送消息时收到 push 事件。 这时候它可以这样来处理：</p>
<pre><code class="language-js">self.onpush = (pushEvent) =&gt; {
  console.log('Service worker was pushed data:', pushEvent.data.text())
}
</code></pre>
<p>为实现真正的推送通知，这个处理程序只需要通过注册对象创建一个通知即可。不过，完善的推送通知需要创建它的服务工作者线程保持活动足够长时间，以便处理后续的交互事件。要实现这一点， push 事件继承了 ExtendableEvent。可以把 showNotification()返回的期约传给 waitUntil()，这样就会让服务工作者线程一直活动到通知的期约解决。</p>
<pre><code class="language-js">// main.js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) =&gt; {
  // 请求显示通知的授权
  Notification.requestPermission().then((status) =&gt; {
    if (status === 'granted') {
      // 如果获得授权，只订阅推送消息
      registration.pushManager.subscribe({
        applicationServerKey: key, // 来自服务器的公钥
        userVisibleOnly: true,
      })
    }
  })
})

// ServiceWorker.js
// 收到推送事件后，在通知中以文本形式显示数据
self.onpush = (pushEvent) =&gt; {
  // 保持服务工作者线程活动到通知期约解决
  pushEvent.waitUntil(self.registration.showNotification(pushEvent.data.text()))
}
// 如果用户单击通知，则打开相应的应用程序页面
self.onnotificationclick = ({ notification }) =&gt; {
  clients.openWindow('https://example.com/clicked-notification')
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="056-js-的多线程-竞争锁"><a class="header" href="#056-js-的多线程-竞争锁">05.6-JS 的多线程-竞争锁</a></h1>
<h2 id="一-sharedarraybuffer-的使用"><a class="header" href="#一-sharedarraybuffer-的使用">一 SharedArrayBuffer 的使用</a></h2>
<p>上下文信息转移方式有三种：结构化克隆算法、可转移对象、共享数组缓冲区三种。</p>
<p>共享数组缓冲区的方式中，主要是利用了一个对象：SharedArrayBuffer。SharedArrayBuffer 与 ArrayBuffer 具有相同的 API，但是在使用上差距极大：ArrayBuffer 必须在不同执行上下文之间进行切换，SharedArrayBuffer 则可以被任意多个执行上文同时引用。</p>
<p>对 SharedArrayBuffer 引用并非是信息转移中的克隆、转移，而是在把 SharedArrayBuffer 传给 postMessage() 时，浏览器只会传递原始缓冲区的引用。结果是，两个不同的 JavaScript 上下文会分别维护对同一个内存块的引用。每个上下文都可以随意修改这个缓冲区，就跟修改常规 ArrayBuffer 一样：</p>
<pre><code class="language-js">// main.js
const worker = new Worker('./worker.js')
// 创建 1 字节缓冲区
const sharedArrayBuffer = new SharedArrayBuffer(1)
// 创建 1 字节缓冲区的视图
const view = new Uint8Array(sharedArrayBuffer)
// 父上下文赋值 1
view[0] = 1
worker.onmessage = () =&gt; {
  console.log(`buffer value after worker modification: ${view[0]}`)
}
// 发送对 sharedArrayBuffer 的引用
worker.postMessage(sharedArrayBuffer)
// buffer value before worker modification: 1
// buffer value after worker modification: 2

// worker.js
self.onmessage = ({ data }) =&gt; {
  const view = new Uint8Array(data)
  console.log(`buffer value before worker modification: ${view[0]}`)
  // 工作者线程为共享缓冲区赋值
  view[0] += 1
  // 发送空消息，通知赋值完成
  self.postMessage(null)
}
</code></pre>
<h2 id="二-竞争锁"><a class="header" href="#二-竞争锁">二 竞争锁</a></h2>
<h3 id="21-资源竞争问题"><a class="header" href="#21-资源竞争问题">2.1 资源竞争问题</a></h3>
<p>在多个执行上下文中共享内存就可能产生并发线程操作，通俗的说就是：多个并行线程中共享内存，有资源竞争的风险。比如多个上下文访问 SharedArrayBuffer 时，如果同时对缓冲区执行操作，就可能出现资源争用问题，此时 SharedArrayBuffer 实例实际上会被当成易变（volatile）内存。</p>
<p>这里使用 express 的静态服务加载一个网页文件：</p>
<pre><code class="language-js">app.all('*', function (req, res, next) {
  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin')
  res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp')
  next()
})
app.use(express.static('public'))
</code></pre>
<p>网页文件引入的 JS 代码</p>
<pre><code class="language-js">// 必须由网络进行访问，且server需要如下配置，这里是express配置：

// main.js
// 创建包含 4 个线程的线程池
const workers = []
for (let i = 0; i &lt; 4; ++i) {
  workers.push(new Worker('./worker.js'))
}
// 在最后一个工作者线程完成后打印最终值
let responseCount = 0
for (const worker of workers) {
  worker.onmessage = () =&gt; {
    if (++responseCount == workers.length) {
      console.log(`Final buffer value: ${view[0]}`)
    }
  }
}
// 初始化 SharedArrayBuffer
const sharedArrayBuffer = new SharedArrayBuffer(4)
const view = new Uint32Array(sharedArrayBuffer)
view[0] = 1
// 把 SharedArrayBuffer 发给每个线程
for (const worker of workers) {
  worker.postMessage(sharedArrayBuffer)
}
// （期待结果为 4000001。实际输出类似于：）
// Final buffer value: 2145106

// worker.js
self.onmessage = ({ data }) =&gt; {
  const view = new Uint32Array(data)
  // 执行 100 万次加操作
  for (let i = 0; i &lt; 1e6; ++i) {
    view[0] += 1
  }
  self.postMessage(null)
}
</code></pre>
<p>这里，每个工作者线程都顺序执行了 100 万次加操作，每次都读取共享数组的索引、执行一次加操作，然后再把值写回数组索引。在所有工作者线程读/写操作交织的过程中就会发生资源争用。例如：</p>
<pre><code class="language-txt">(1) 线程 A 读取到值 1；
(2) 线程 B 读取到值 1；
(3) 线程 A 加 1 并将 2 写回数组；
(4) 线程 B 仍然使用陈旧的数组值 1，同样把 2 写回数组。
</code></pre>
<p>贴士上面的 2 个脚本文件可以通过创建脚本地址方式在一个 main.js 文件中完成：</p>
<pre><code class="language-js">// 类似在worker.js 中添加如下代码，这里使用加载脚本方式
const workerScript = `
    self.onmessage = ({data}) =&gt; {
        const view = new Uint32Array(data);
        // 执行 1 000 000 次加操作
        for (let i = 0; i &lt; 1E6; ++i) {
            // 线程不安全加操作会导致资源争用
            view[0] += 1;
        }
        self.postMessage(null);
    };
`

// 创建容量为 4 的工作者池
const workerScriptBlobUrl = URL.createObjectURL(new Blob([workerScript]))
const workers = []
for (let i = 0; i &lt; 4; ++i) {
  workers.push(new Worker(workerScriptBlobUrl))
}
</code></pre>
<h3 id="22-原子操作"><a class="header" href="#22-原子操作">2.2 原子操作</a></h3>
<p>为解决该问题，ES2017 推出了 Atomics API，通过强制同一时刻只能对缓冲区执行一个操作，可以让多个上下文安全地读写一个 SharedArrayBuffer。</p>
<p>Atomics 可以让一个工作者线程获得 SharedArrayBuffer 实例的锁，在执行完全部读/写/读操作后，再允许另一个工作者线程执行操作。把 Atomics.add() 放到上述例子中就可以得到正确的最终值，这样就保证了 SharedArrayBuffer 上的 JavaScript 操作是线程安全的：</p>
<pre><code class="language-js">// worker.js
self.onmessage = ({ data }) =&gt; {
  const view = new Uint32Array(data)
  // 执行 100 万次加操作
  for (let i = 0; i &lt; 1e6; ++i) {
    Atomics.add(view, 0, 1) // 线程安全的加操作！！！
  }
  self.postMessage(null)
}
</code></pre>
<p>原子操作的本质会排斥操作系统或计算机硬件通常会自动执行的优化（比如指令重新排序）。原子操作也让并发访问内存变得不可能，如果应用不当就可能导致程序执行变慢。为此， Atomics API 的设计初衷是在最少但很稳定的原子行为基础之上，构建复杂的多线程 JavaScript 程序。</p>
<h2 id="三-原子操作原理"><a class="header" href="#三-原子操作原理">三 原子操作原理</a></h2>
<h3 id="31-算术及位操作方法"><a class="header" href="#31-算术及位操作方法">3.1 算术及位操作方法</a></h3>
<p>任何全局上下文中都有 Atomics 对象，这个对象上暴露了用于执行线程安全操作的一套静态方法，其中多数方法以一个 TypedArray 实例（一个 SharedArrayBuffer 的引用）作为第一个参数，以相关操作数作为后续参数。</p>
<p>在 ECMASceript 中，AtomicsAPI 执行修改的操作被定义为：AtomicReadModifyWrite 操作，其底层都会从 SharedArrayBuffer 中某个位置读取值，然后执行算术或位操作，最后再把计算结果写回相同的位置。这些操作的原子本质意味着上述读取、修改、写回操作会按照顺序执行，不会被其他线程中断。</p>
<p>相关算术方法：</p>
<pre><code class="language-js">// 创建大小为 1 的缓冲区
let sharedArrayBuffer = new SharedArrayBuffer(1)
// 基于缓冲创建 Uint8Array
let typedArray = new Uint8Array(sharedArrayBuffer)
// 所有 ArrayBuffer 全部初始化为 0
console.log(typedArray) // Uint8Array[0]

const index = 0
const increment = 5

// 对索引 0 处的值执行原子加 5
Atomics.add(typedArray, index, increment)
console.log(typedArray) // Uint8Array[5]

// 对索引 0 处的值执行原子减 5
Atomics.sub(typedArray, index, increment)
console.log(typedArray) // Uint8Array[0]
</code></pre>
<p>相关位方法：</p>
<pre><code class="language-js">// 创建大小为 1 的缓冲区
let sharedArrayBuffer = new SharedArrayBuffer(1)
// 基于缓冲创建 Uint8Array
let typedArray = new Uint8Array(sharedArrayBuffer)
// 所有 ArrayBuffer 全部初始化为 0
console.log(typedArray) // Uint8Array[0]

const index = 0

// 对索引 0 处的值执行原子或 0b1111
Atomics.or(typedArray, index, 0b1111)
console.log(typedArray) // Uint8Array[15]

// 对索引 0 处的值执行原子与 0b1111
Atomics.and(typedArray, index, 0b1100)
console.log(typedArray) // Uint8Array[12]

// 对索引 0 处的值执行原子异或 0b1111
Atomics.xor(typedArray, index, 0b1111)
console.log(typedArray) // Uint8Array[3]
</code></pre>
<h3 id="32-原子读和原子写"><a class="header" href="#32-原子读和原子写">3.2 原子读和原子写</a></h3>
<p>浏览器的 JavaScript 编译器和 CPU 架构本身都有权限重排指令以提升程序执行效率。正常情况下，JavaScript 的单线程环境是可以随时进行这种优化的。但多线程下的指令重排可能导致资源争用，而且极难排错。</p>
<p>针对该问题，Atomics API 的解决方式有：</p>
<ul>
<li>所有原子指令相互之间的顺序永远不会重排</li>
<li>使用原子读或原子写保证所有指令（包括原子和非原子指令）都不会相对原子读/写重新排序。即位于原子读/写之前的所有指令会在原子读/写发生前完成，而位于原子读/写之后的所有指令会在原子读/写完成后才会开始</li>
</ul>
<p>除了读写缓冲区的值，Atomics.load() 和 Atomics.store() 还可以构建“代码围栏”。JavaScript 引擎保证非原子指令可以相对于 load() 或 store() 本地重排，但这个重排不会侵犯原子读/写的边界：</p>
<pre><code class="language-js">const sharedArrayBuffer = new SharedArrayBuffer(4)
const view = new Uint32Array(sharedArrayBuffer)
// 执行非原子写
view[0] = 1
// 非原子写可以保证在这个读操作之前完成，因此这里一定会读到 1
console.log(Atomics.load(view, 0)) // 1
// 执行原子写
Atomics.store(view, 0, 2)
// 非原子读可以保证在原子写完成后发生，因此这里一定会读到 2
console.log(view[0]) // 2
</code></pre>
<h3 id="33-原子交换"><a class="header" href="#33-原子交换">3.3 原子交换</a></h3>
<p>为了保证连续、不间断的先读后写，Atomics API 提供了两种方法：exchange() 和 compareExchange()。Atomics.exchange() 执行简单的交换，以保证其他线程不会中断值的交换：</p>
<pre><code class="language-js">const sharedArrayBuffer = new SharedArrayBuffer(4)
const view = new Uint32Array(sharedArrayBuffer)
// 在索引 0 处写入 3
Atomics.store(view, 0, 3)
// 从索引 0 处读取值，然后在索引 0 处写入 4
console.log(Atomics.exchange(view, 0, 4)) // 3
// 从索引 0 处读取值
console.log(Atomics.load(view, 0)) // 4
</code></pre>
<p>在多线程程序中，一个线程可能只希望在上次读取某个值之后没有其他线程修改该值的情况下才对共享缓冲区执行写操作。如果这个值没有被修改，这个线程就可以安全地写入更新后的值；如果这个值被修改了，那么执行写操作将会破坏其他线程计算的值。对于这种任务，Atomics API 提供了 compareExchange() 方法。这个方法只在目标索引处的值与预期值匹配时才会执行写操作。</p>
<pre><code class="language-js">const sharedArrayBuffer = new SharedArrayBuffer(4)
const view = new Uint32Array(sharedArrayBuffer)
// 在索引 0 处写入 5
Atomics.store(view, 0, 5)
// 从缓冲区读取值
let initial = Atomics.load(view, 0)
// 对这个值执行非原子操作
let result = initial ** 2
// 只在缓冲区未被修改的情况下才会向缓冲区写入新值
Atomics.compareExchange(view, 0, initial, result)
// 检查写入成功
console.log(Atomics.load(view, 0)) // 25
</code></pre>
<p>如果值不匹配，compareExchange() 调用则什么也不做：</p>
<pre><code class="language-js">const sharedArrayBuffer = new SharedArrayBuffer(4)
const view = new Uint32Array(sharedArrayBuffer)
// 在索引 0 处写入 5
Atomics.store(view, 0, 5)
// 从缓冲区读取值
let initial = Atomics.load(view, 0)
// 对这个值执行非原子操作
let result = initial ** 2
// 只在缓冲区未被修改的情况下才会向缓冲区写入新值
Atomics.compareExchange(view, 0, -1, result)
// 检查写入失败
console.log(Atomics.load(view, 0)) // 5
</code></pre>
<h3 id="34-原子-futex-操作与加锁"><a class="header" href="#34-原子-futex-操作与加锁">3.4 原子 Futex 操作与加锁</a></h3>
<p>如果没有某种锁机制，多线程程序就无法支持复杂需求。为此，Atomics API 提供了模仿 Linux Futex（快速用户空间互斥量，fast user-space mutex）的方法。这些方法本身虽然非常简单，但可以作为更复杂锁机制的基本组件。</p>
<p>贴士：所有原子 Futex 操作只能用于 Int32Array 视图。而且，也只能用在工作者内部。</p>
<p>Atomics.wait() 和 Atomics.notify() 通过示例很容易理解。下面这个简单的例子创建了 4 个工作者，用于对长度为 1 的 Int32Array 进行操作。这些工作者会依次取得锁并执行自己的加操作：</p>
<pre><code class="language-js">const workerScript = `
  self.onmessage = ({data}) =&gt; {
    const view = new Int32Array(data);
    console.log('Waiting to obtain lock');
    // 遇到初始值则停止，10 000 毫秒超时
    Atomics.wait(view, 0, 0, 1E5);
    console.log('Obtained lock');
    // 在索引 0 处加 1
    Atomics.add(view, 0, 1);
    console.log('Releasing lock');
    // 只允许 1 个工作者继续执行
    Atomics.notify(view, 0, 1);
    self.postMessage(null);
  };
`
const workerScriptBlobUrl = URL.createObjectURL(new Blob([workerScript]))
const workers = []
for (let i = 0; i &lt; 4; ++i) {
  workers.push(new Worker(workerScriptBlobUrl))
}
// 在最后一个工作者完成后打印出最终值
let responseCount = 0
for (const worker of workers) {
  worker.onmessage = () =&gt; {
    if (++responseCount == workers.length) {
      console.log(`Final buffer value: ${view[0]}`)
    }
  }
}
// 初始化 SharedArrayBuffer
const sharedArrayBuffer = new SharedArrayBuffer(8)
const view = new Int32Array(sharedArrayBuffer)
// 把 SharedArrayBuffer 发送到每个工作者
for (const worker of workers) {
  worker.postMessage(sharedArrayBuffer)
}
// 1000 毫秒后释放第一个锁
setTimeout(() =&gt; Atomics.notify(view, 0, 1), 1000)
// Waiting to obtain lock
// Waiting to obtain lock
// Waiting to obtain lock
// Waiting to obtain lock
// Obtained lock
// Releasing lock
// Obtained lock
// Releasing lock
// Obtained lock
// Releasing lock
// Obtained lock
// Releasing lock
// Final buffer value: 4
</code></pre>
<p>因为是使用 0 来初始化 SharedArrayBuffer，所以每个工作者都会到达 Atomics.wait() 并停止执行。在停止状态下，执行线程存在于一个等待队列中，在经过指定时间或在相应索引上调用 Atomics.notify() 之前，一直保持暂停状态。1000 毫秒之后，顶部执行上下文会调用 Atomics.notify() 释放其中一个等待的线程。这个线程执行完毕后会再次调用 Atomics.notify()释放另一个线程。这个过程会持续到所有线程都执行完毕并通过 postMessage() 传出最终的值。</p>
<p>Atomics API 还提供了 Atomics.isLockFree() 方法。不过我们基本上应该不会用到。这个方法在高性能算法中可以用来确定是否有必要获取锁。规范中的介绍如下：</p>
<pre><code class="language-txt">Atomics.isLockFree() 是一个优化原语。
基本上，如果一个原子原语（compareExchange、load、store、add、sub、and、or、xor 或 exchange）
在 n 字节大小的数据上的原子步骤在不调用代理在组成数据的 n 字节之外获得锁的情况下可以执行，
则 Atomics.isLockFree(n) 会返回 true。

高性能算法会使用 Atomics.isLockFree 确定是否在关键部分使用锁或原子操作。
如果原子原语需要加锁，则算法提供自己的锁会更高效。

Atomics.isLockFree(4) 始终返回 true，因为在所有已知的相关硬件上都是支持的。能够如此假设通常可以简化程序。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-模块系统-理解模块系统"><a class="header" href="#011-模块系统-理解模块系统">01.1-模块系统-理解模块系统</a></h1>
<h2 id="一-模块模式的作用"><a class="header" href="#一-模块模式的作用">一 模块模式的作用</a></h2>
<p>在项目开发中，对不同的项目功能需要做文件切割，以更好的产出可维护性代码，对分割后的不同功能代码的引入也需要编程语言的模块机制支持。同样的，大量的第三方库的使用也会出现连接这些文件的工作。</p>
<p>将代码拆分成独立的块，然后再把这些块连接起来可以通过模块模式来实现。这种模式背后的思想很简单：把逻辑分块，各自封装，相互独立，每个块自行决定对外暴露什么，同时自行决定引入执行哪些外部代码。不同的实现和特性让这些基本的概念变得有点复杂，但这个基本的思想是所有 JavaScript
模块系统的基础。</p>
<p>模块化的优势有：</p>
<ul>
<li>防止命名冲突</li>
<li>代码复用</li>
<li>提升可维护性</li>
</ul>
<h2 id="二-模块模式原理"><a class="header" href="#二-模块模式原理">二 模块模式原理</a></h2>
<h3 id="21-模块标识符"><a class="header" href="#21-模块标识符">2.1 模块标识符</a></h3>
<p>模块标识符是所有模块系统通用的概念。模块系统本质上是键/值实体，其中每个模块都有个可用于引用它的标识符。这个标识符在模拟模块的系统中可能是字符串，在原生实现的模块系统中可能是模块文件的实际路径。</p>
<p>有的模块系统支持明确声明模块的标识，还有的模块系统会隐式地使用文件名作为模块标识符。不管怎样，完善的模块系统一定不会存在模块标识冲突的问题，且系统中的任何模块都应该能够无歧义地引用其他模块。</p>
<p>将模块标识符解析为实际模块的过程要根据模块系统对标识符的实现。原生浏览器模块标识符必须提供实际 JavaScript 文件的路径。除了文件路径， Node.js 还会搜索 node_modules 目录，用标识符去匹配包含 index.js 的目录。</p>
<h3 id="22-模块依赖"><a class="header" href="#22-模块依赖">2.2 模块依赖</a></h3>
<p>模块系统的核心是管理依赖。指定依赖的模块与周围的环境会达成一种契约。本地模块向模块系统声明一组外部模块（依赖），这些外部模块对于当前模块正常运行是必需的。模块系统检视这些依赖，进而保证这些外部模块能够被加载并在本地模块运行时初始化所有依赖。</p>
<p>每个模块都会与某个唯一的标识符关联，该标识符可用于检索模块。这个标识符通常是 JavaScript 文件的路径，但在某些模块系统中，这个标识符也可以是在模块本身内部声明的命名空间路径字符串。</p>
<h3 id="23-模块加载"><a class="header" href="#23-模块加载">2.3 模块加载</a></h3>
<p>加载模块的概念派生自依赖契约。当一个外部模块被指定为依赖时，本地模块期望在执行它时，依赖已准备好并已初始化。</p>
<p>在浏览器中，加载模块涉及几个步骤。加载模块涉及执行其中的代码，但必须是在所有依赖都加载并执行之后。如果浏览器没有收到依赖模块的代码，则必须发送请求并等待网络返回。收到模块代码之后，浏览器必须确定刚收到的模块是否也有依赖。然后递归地评估并加载所有依赖，直到所有依赖模块
都加载完成。只有整个依赖图都加载完成，才可以执行入口模块。</p>
<h3 id="24-入口"><a class="header" href="#24-入口">2.4 入口</a></h3>
<p>相互依赖的模块必须指定一个模块作为入口（ entry point），这也是代码执行的起点。这是理所当然的，因为 JavaScript 是顺序执行的，并且是单线程的，所以代码必须有执行的起点。入口模块也可能依赖其他模块，其他模块同样可能有自己的依赖。于是模块化 JavaScript 应用程序的所有模块会构成依赖图。</p>
<p>可以通过有向图来表示应用程序中各模块的依赖关系：</p>
<p><img src="07-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/../images/module/01.svg" alt="模块" /></p>
<p>图中的箭头表示依赖方向：模块 A 依赖模块 B 和模块 C，模块 B 依赖模块 D 和模块 E，模块 C 依赖模块 E。因为模块必须在依赖加载完成后才能被加载，所以这个应用程序的入口模块 A 必须在应用程序的其他部分加载后才能执行。</p>
<p>在 JavaScript 中，“加载”的概念可以有多种实现方式。因为模块是作为包含将立即执行的 JavaScript 代码的文件实现的，所以一种可能是按照依赖图的要求依次请求各个脚本。对于前面的应用程序来说，下面的脚本请求顺序能够满足依赖图的要求：</p>
<pre><code class="language-html">&lt;script src=&quot;moduleE.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;moduleD.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;moduleC.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;moduleB.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;moduleA.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>模块加载是“阻塞的”，这意味着前置操作必须完成才能执行后续操作。每个模块在自己的代码到达浏览器之后完成加载，此时其依赖已经加载并初始化。不过，这个策略存在一些性能和复杂性问题。为一个应用程序而按顺序加载五个 JavaScript 文件并不理想，并且手动管理正确的加载顺序也颇为棘手。</p>
<h3 id="25-异步依赖"><a class="header" href="#25-异步依赖">2.5 异步依赖</a></h3>
<p>因为 JavaScript 可以异步执行，所以如果能按需加载就好了。换句话说，可以让 JavaScript 通知模块系统在必要时加载新模块，并在模块加载完成后提供回调。在代码层面，可以通过下面的伪代码来实现：</p>
<pre><code class="language-js">// 在模块 A 里面
load('moduleB').then(function (moduleB) {
  moduleB.doStuff()
})
</code></pre>
<p>模块 A 的代码使用了 moduleB 标识符向模块系统请求加载模块 B，并以模块 B 作为参数调用回调。模块 B 可能已加载完成，也可能必须重新请求和初始化，但这里的代码并不关心。这些事情都交给了模块加载器去负责。</p>
<p>如果重写前面的应用程序，只使用动态模块加载，那么使用一个<code>&lt;script&gt;</code>标签即可完成模块 A 的加载。模块 A 会按需请求模块文件，而不会生成必需的依赖列表。这样有几个好处，其中之一就是性能，因为在页面加载时只需同步加载一个文件。</p>
<p>这些脚本也可以分离出来，比如给<code>&lt;script&gt;</code>标签应用 defer 或 async 属性，再加上能够识别异步脚本何时加载和初始化的逻辑。此行为将模拟在 ES6 模块规范中实现的行为，本章稍后会对此进行讨论。</p>
<h3 id="26-动态依赖"><a class="header" href="#26-动态依赖">2.6 动态依赖</a></h3>
<p>有些模块系统要求开发者在模块开始列出所有依赖，而有些模块系统则允许开发者在程序结构中动态添加依赖。动态添加的依赖有别于模块开头列出的常规依赖，这些依赖必须在模块执行前加载完毕：</p>
<pre><code class="language-js">if (loadCondition) {
  require('./moduleA')
}
</code></pre>
<p>在这个模块中，是否加载 moduleA 是运行时确定的。加载 moduleA 时可能是阻塞的，也可能导致执行，且只有模块加载后才会继续。无论怎样，模块内部的代码在 moduleA 加载前都不能执行，因为 moduleA 的存在是后续模块行为正确的关键。</p>
<p>动态依赖可以支持更复杂的依赖关系，但代价是增加了对模块进行静态分析的难度。</p>
<h3 id="27-静态分析"><a class="header" href="#27-静态分析">2.7 静态分析</a></h3>
<p>模块中包含的发送到浏览器的 JavaScript 代码经常会被静态分析，分析工具会检查代码结构并在不实际执行代码的情况下推断其行为。对静态分析友好的模块系统可以让模块打包系统更容易将代码处理为较少的文件。它还将支持在智能编辑器里智能自动完成。</p>
<p>更复杂的模块行为，例如动态依赖，会导致静态分析更困难。不同的模块系统和模块加载器具有不同层次的复杂度。至于模块的依赖，额外的复杂度会导致相关工具更难预测模块在执行时到底需要哪些依赖。</p>
<h3 id="28-循环依赖"><a class="header" href="#28-循环依赖">2.8 循环依赖</a></h3>
<p>要构建一个没有循环依赖的 JavaScript 应用程序几乎是不可能的，因此包括 CommonJS、 AMD 和 ES6 在内的所有模块系统都支持循环依赖。在包含循环依赖的应用程序中，模块加载顺序可能会出人意料。不过，只要恰当地封装模块，使它们没有副作用，加载顺序就应该不会影响应用程序的运行。</p>
<p>在下面的模块代码中（其中使用了模块中立的伪代码），任何模块都可以作为入口模块，即使依赖图中存在循环依赖：</p>
<pre><code class="language-js">require('./moduleD')
require('./moduleB')
console.log('moduleA')
require('./moduleA')
require('./moduleC')
console.log('moduleB')
require('./moduleB')
require('./moduleD')
console.log('moduleC')
require('./moduleA')
require('./moduleC')
console.log('moduleD')
</code></pre>
<p>修改主模块中用到的模块会改变依赖加载顺序。如果 moduleA 最先加载，则会打印如下输出，这表示模块加载完成时的绝对顺序：</p>
<pre><code class="language-txt">moduleB
moduleC
moduleD
moduleA
</code></pre>
<p>以上模块加载顺序可以用依赖图来表示，其中加载器会执行深度优先的依赖加载，如果 moduleC 最先加载，则会打印如下输出，这表示模块加载的绝对顺序：</p>
<pre><code class="language-txt">moduleD
moduleA
moduleB
moduleC
</code></pre>
<p>以上模块加载顺序通过依赖图演示如下，其中加载器会执行深度优先的依赖加载：</p>
<p><img src="07-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/../images/module/02.svg" alt="模块" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="012-模块系统-模块化方案"><a class="header" href="#012-模块系统-模块化方案">01.2-模块系统-模块化方案</a></h1>
<h2 id="一-早期模块方案"><a class="header" href="#一-早期模块方案">一 早期模块方案</a></h2>
<p>在早期，通常使用函数作用域、立即执行函数将模块定义封装在匿名闭包中，将该立即执行函数的返回值赋值给一个变量，其实就是为模块创建了命名空间：</p>
<pre><code class="language-js">var Foo = (function () {
  // 私有 Foo 模块的代码
  console.log('bar') // bar
})()
</code></pre>
<p>为了暴露公共 API，模块 IIFE 会返回一个对象，其属性就是模块命名空间中的公共成员：</p>
<pre><code class="language-js">var Foo = (function () {
  return {
    bar: 'baz',
    baz: function () {
      console.log(this.bar)
    },
  }
})()

console.log(Foo.bar) // 'baz'
Foo.baz() // 'baz'
</code></pre>
<p>类似地，还有一种模式叫作“泄露模块模式”（ revealing module pattern）。这种模式只返回一个对象，其属性是私有数据和成员的引用：</p>
<pre><code class="language-js">var Foo = (function () {
  var bar = 'baz'
  var baz = function () {
    console.log(bar)
  }
  return {
    bar: bar,
    baz: baz,
  }
})()
console.log(Foo.bar) // 'baz'
Foo.baz() // 'baz'
</code></pre>
<p>在模块内部也可以定义模块，这样可以实现命名空间嵌套：</p>
<pre><code class="language-js">var Foo = (function () {
  return {
    bar: 'baz',
  }
})()
Foo.baz = (function () {
  return {
    qux: function () {
      console.log('baz')
    },
  }
})()
console.log(Foo.bar) // 'baz'
Foo.baz.qux() // 'baz'
</code></pre>
<p>为了让模块正确使用外部的值，可以将它们作为参数传给 IIFE：</p>
<pre><code class="language-js">// 全局对象，浏览器中是 window
var globalObj = 'baz'

// 赋值给变量后，就为模块创建了命名空间
var Foo = (function (globalObj) {
  // 私有 Foo 模块的代码
  return {
    // 返回对象以暴露 API
    bar: globalObj,
    baz: function () {
      console.log(this.bar)
    },
  }
})(globalObj)

// 使用 AOI
Foo.baz()
</code></pre>
<p>因为这里的模块实现其实就是在创建 JavaScript 对象的实例，所以完全可以在定义之后再扩展模块：：</p>
<pre><code class="language-js">// 原始的 Foo
var Foo = (function (bar) {
  var bar = 'baz'
  return {
    bar: bar,
  }
})()

// 扩展 Foo
var Foo = (function (FooModule) {
  FooModule.baz = function () {
    console.log(FooModule.bar)
  }
  return FooModule
})(Foo)

console.log(Foo.bar) // 'baz'
Foo.baz() // 'baz'
</code></pre>
<p>无论模块是否存在，配置模块扩展以执行扩展也很有用：</p>
<pre><code class="language-js">// 扩展 Foo 以增加新方法
var Foo = (function (FooModule) {
  FooModule.baz = function () {
    console.log(FooModule.bar)
  }
  return FooModule
})(Foo || {})

// 扩展 Foo 以增加新数据
var Foo = (function (FooModule) {
  FooModule.bar = 'baz'
  return FooModule
})(Foo || {})

console.log(Foo.bar) // 'baz'
Foo.baz() // 'baz'
</code></pre>
<h2 id="二-现代模块化方案"><a class="header" href="#二-现代模块化方案">二 现代模块化方案</a></h2>
<p>为了适应现在的发展，JavaScript 先后诞生了各种模块规范，如 AMD、CMD：</p>
<ul>
<li>CommonJS：主张文件即模块，通过 <code>module.exports</code> 导出接口，通过 <code>require()</code> 加载模块，被 Node.js 采用。</li>
<li>AMD：一种异步加载模块的实现规范，提倡依赖前置，提前加载（函数运行前加载好依赖），Require.js 是其代表，目前已经逐渐淘汰。</li>
<li>CMD：一种异步加载模块的实现规范，提倡依赖就近，按需加载（函数运行时才加载依赖），sea.js 是其代表，目前已经逐渐淘汰。</li>
<li>ES Module：目前 ECMAScript 在 ES6 中提出的官方方案</li>
</ul>
<p>目前的主流模块化方案是：CommonJS、ES Module。但是 CommonJS 的文件加载是同步的，由于服务端的文件都位于服务器的本地磁盘中，所以 Node 采用该方式没有太大问题，但是该方式不适合前端中需要网络来加载远程模块！而 Node 现在也是 JavaScript 社区的一部分，也需要跟进 JavaScript 的更新，所以 ES Module 最后将会成为 JavaScript 最主要的模块化方案，没有之一。</p>
<h2 id="三-commonjs-与-amd"><a class="header" href="#三-commonjs-与-amd">三 CommonJS 与 AMD</a></h2>
<h3 id="31-commonjs-规范的使用"><a class="header" href="#31-commonjs-规范的使用">3.1 CommonJS 规范的使用</a></h3>
<p>CommonJS 规范概述了同步声明依赖的模块定义。这个规范主要用于在服务器端实现模块化代码组织，但也可用于定义在浏览器中使用的模块依赖。CommonJS 模块语法不能在浏览器中直接运行。</p>
<p>贴士：Node.js 主要在服务器环境下使用，不需要考虑网络延迟问题，所以 NodeJS 使用了轻微修改版的 CommonJS。</p>
<p>使用示例：</p>
<pre><code class="language-js">// 无论一个模块在 require() 中被引用多少次，模块永远是单例。
// 模块第一次加载后会被缓存，后续加载会取得缓存的模块
var moduleB = require('./moduleB')

module.exports = {
  stuff: moduleB.doStuff(),
}
</code></pre>
<p>无论一个模块在 require()中被引用多少次，模块永远是单例。在下面的例子中， moduleA 只会被打印一次。这是因为无论请求多少次， moduleA 只会被加载一次。</p>
<pre><code class="language-js">console.log('moduleA')
var a1 = require('./moduleA')
var a2 = require('./moduleA')
console.log(a1 === a2) // true
</code></pre>
<p>模块第一次加载后会被缓存，后续加载会取得缓存的模块（如下代码所示）。模块加载顺序由依赖图决定。</p>
<pre><code class="language-js">console.log('moduleA')
require('./moduleA')
require('./moduleB') // &quot;moduleA&quot;
require('./moduleA')
</code></pre>
<p>在 CommonJS 中，模块加载是模块系统执行的同步操作。因此 require() 可以像下面这样以编程方式嵌入在模块中：</p>
<pre><code class="language-js">console.log('moduleA')
if (loadCondition) {
  require('./moduleA')
}
</code></pre>
<h3 id="32-amd-模块规范的使用"><a class="header" href="#32-amd-模块规范的使用">3.2 AMD 模块规范的使用</a></h3>
<p>CommonJS 以服务器端为目标环境，能够一次性把所有模块都加载到内存，而异步模块定义（AMD，Asynchronous Module Definition）的模块定义系统则以浏览器为目标执行环境，这需要考虑网络延迟的问题。AMD 的一般策略是让模块声明自己的依赖，而运行在浏览器中的模块系统会按需获取依赖，并在依赖加载完成后立即执行依赖它们的模块。</p>
<p>AMD 模块实现的核心是用函数包装模块定义。这样可以防止声明全局变量，并允许加载器库控制何时加载模块。包装函数也便于模块代码的移植，因为包装函数内部的所有模块代码使用的都是原生 JavaScript 结构。包装模块的函数是全局 define 的参数，它是由 AMD 加载器库的实现定义的。</p>
<pre><code class="language-js">// ID 为'moduleA'的模块定义。moduleA 依赖 moduleB，
// moduleB 会异步加载
define('moduleA', ['moduleB'], function (moduleB) {
  return {
    stuff: moduleB.doStuff(),
  }
})
</code></pre>
<p>AMD 也支持 require 和 exports 对象，通过它们可以在 AMD 模块工厂函数内部定义 CommonJS 风格的模块。这样可以像请求模块一样请求它们，但 AMD 加载器会将它们识别为原生 AMD 结构，而不是模块定义：</p>
<pre><code class="language-js">define('moduleA', ['require', 'exports'], function (require, exports) {
  var moduleB = require('moduleB')
  exports.stuff = moduleB.doStuff()
})
</code></pre>
<p>动态依赖也是通过这种方式支持的：</p>
<pre><code class="language-js">define('moduleA', ['require'], function (require) {
  if (condition) {
    var moduleB = require('moduleB')
  }
})
</code></pre>
<h3 id="33-通用模块定义"><a class="header" href="#33-通用模块定义">3.3 通用模块定义</a></h3>
<p>为了统一 CommonJS 和 AMD 生态系统，通用模块定义（UMD，Universal Module Definition）规范应运而生。UMD 可用于创建这两个系统都可以使用的模块代码。本质上，UMD 定义的模块会在启动时检测要使用哪个模块系统，然后进行适当配置，并把所有逻辑包装在一个立即调用的函数表达式（IIFE）中。</p>
<p>虽然这种组合并不完美，但在很多场景下足以实现两个生态的共存。下面是只包含一个依赖的 UMD 模块定义的示例（来源为 GitHub 上的 UMD 仓库）：</p>
<pre><code class="language-js">;(function (root, factory) {
  if (typeof define === 'function' &amp;&amp; define.amd) {
    // AMD。注册为匿名模块
    define(['moduleB'], factory)
  } else if (typeof module === 'object' &amp;&amp; module.exports) {
    // Node。不支持严格 CommonJS
    // 但可以在 Node 这样支持 module.exports 的
    // 类 CommonJS 环境下使用
    module.exports = factory(require(' moduleB '))
  } else {
    // 浏览器全局上下文（root 是 window）
    root.returnExports = factory(root.moduleB)
  }
})(this, function (moduleB) {
  // 以某种方式使用 moduleB
  // 将返回值作为模块的导出
  // 这个例子返回了一个对象
  // 但是模块也可以返回函数作为导出值
  return {}
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="013-模块系统-esmodule"><a class="header" href="#013-模块系统-esmodule">01.3-模块系统-ESModule</a></h1>
<h2 id="一-es-module-概念"><a class="header" href="#一-es-module-概念">一 ES Module 概念</a></h2>
<p>ES Modlue 是 ES6 引入的最强改进之一，全方位简化了模块加载器，浏览器原生支持模块也就不再需要预处理了。同样，旧的社区模块化规范也会逐渐没落。</p>
<p>ES Module 可以嵌入网页，也可以直接引入，通过 <code>type=module</code> 告知浏览器以模块方式执行，而非传统脚本：</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
  // 模块代码
&lt;/script&gt;

&lt;script type=&quot;module&quot; src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="32-执行顺序"><a class="header" href="#32-执行顺序">3.2 执行顺序</a></h3>
<p>模块文件类似 defer 效果，解析到 <code>&lt;script type='module'&gt;&lt;/script&gt;</code> 后回立即下载模块文件，但是会等到文档解析完成后才执行。引入的模块也会按照顺序进行执行：</p>
<pre><code class="language-html">&lt;!-- 第二个执行 --&gt;
&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;
&lt;!-- 第三个执行 --&gt;
&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;
&lt;!-- 第一个执行 --&gt;
&lt;script&gt;&lt;/script&gt;
</code></pre>
<p>也可以给模块标签添加 async 属性。这样影响就是双重的：不仅模块执行顺序不再与<code>&lt;script&gt;</code>标签在页面中的顺序绑定，模块也不会等待文档完成解析才执行。不过，入口模块仍必须等待其依赖加载完成。</p>
<p>与<code>&lt;script type=&quot;module&quot;&gt;</code>标签关联的 ES6 模块被认为是模块图中的入口模块。一个页面上有多少个入口模块没有限制，重复加载同一个模块也没有限制。同一个模块无论在一个页面中被加载多少次，也不管它是如何加载的，实际上都只会加载一次。</p>
<p>与<code>&lt;script type=&quot;module&quot;&gt;</code>标签关联的 ES6 模块被认为是模块图中的入口模块。一个页面上有多少个入口模块没有限制，重复加载同一个模块也没有限制。同一个模块无论在一个页面中被加载多少次，也不管它是如何加载的，实际上都只会加载一次，如下面的代码所示：</p>
<pre><code class="language-html">&lt;!-- moduleA 在这个页面上只会被加载一次 --&gt;
&lt;script type=&quot;module&quot;&gt;
  import './moduleA.js'
  &lt;script&gt;
  &lt;script type=&quot;module&quot;&gt;
  import './moduleA.js'
  &lt;script&gt;
  &lt;script type=&quot;module&quot; src=&quot;./moduleA.js&quot;&gt;
&lt;/script&gt;
&lt;script type=&quot;module&quot; src=&quot;./moduleA.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>贴士：嵌入的模块定义代码不能使用 import 加载到其他模块。只有通过外部文件加载的模块才可以使用 import 加载。因此，嵌入模块只适合作为入口模块。</p>
<h3 id="33-模块加载"><a class="header" href="#33-模块加载">3.3 模块加载</a></h3>
<p>ECMAScript 6 模块的独特之处在于，既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载。有些浏览器还没有原生支持 ES6 模块，因此可能还需要第三方工具。事实上，很多时候使用第三方工具可能会更方便。</p>
<p>完全支持 ECMAScript 6 模块的浏览器可以从顶级模块加载整个依赖图，且是异步完成的。浏览器会解析入口模块，确定依赖，并发送对依赖模块的请求。这些文件通过网络返回后，浏览器就会解析它们的内容，确定它们的依赖，如果这些二级依赖还没有加载，则会发送更多请求。这个异步递归加载过程会持续到整个应用程序的依赖图都解析完成。解析完依赖图，应用程序就可以正式加载模块了。</p>
<p>这个过程与 AMD 风格的模块加载非常相似。模块文件按需加载，且后续模块的请求会因为每个依赖模块的网络延迟而同步延迟。即，如果 moduleA 依赖 moduleB，moduleB 依赖 moduleC。浏览器在对 moduleB 的请求完成之前并不知道要请求 moduleC。这种加载方式效率很高，也不需要外部工具，但加载大型应用程序的深度依赖图可能要花费很长时间。</p>
<h3 id="34-模块行为"><a class="header" href="#34-模块行为">3.4 模块行为</a></h3>
<p>ECMAScript 6 模块借用了 CommonJS 和 AMD 的很多优秀特性：</p>
<ul>
<li>模块代码只在加载后执行。</li>
<li>模块只能加载一次。</li>
<li>模块是单例。</li>
<li>模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。</li>
<li>模块可以请求加载其他模块。</li>
<li>支持循环依赖。</li>
</ul>
<p>ES6 模块系统也增加了一些新行为：</p>
<ul>
<li>ES6 模块默认在严格模式下执行。</li>
<li>ES6 模块不共享全局命名空间。</li>
<li>模块顶级 this 的值是 undefined（常规脚本中是 window）。</li>
<li>模块中的 var 声明不会添加到 window 对象。</li>
<li>ES6 模块是异步加载和执行的。</li>
</ul>
<p>浏览器运行时在知道应该把某个文件当成模块时，会有条件地按照上述 ECMAScript 6 模块行为来施加限制。与<code>&lt;script type=&quot;module&quot;&gt;</code>关联或者通过 import 语句加载的 JavaScript 文件会被认定为模块。</p>
<h2 id="四-es-module-的使用"><a class="header" href="#四-es-module-的使用">四 ES Module 的使用</a></h2>
<h3 id="40-es-module-的简单使用"><a class="header" href="#40-es-module-的简单使用">4.0 ES Module 的简单使用</a></h3>
<p>示例：模块文件 mylib.js，该文件现在要暴露一些数据给其他人员使用：</p>
<pre><code class="language-js">export let username = 'Jerry'

export function fn1() {
  console.log('1111')
}
</code></pre>
<p>其他文件使用 <code>mylib.js</code> 的方式：</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;script type=&quot;module&quot;&gt;
    import * as mylib from './mylib.js'
    console.log(mylib)
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>由于安全性限制，此时这个 html 文件必须放在一个静态文件目录内，使用服务端访问方式打开网页，才能正确实现模块化。输出的结果为：</p>
<pre><code class="language-js">fn1: ƒ fn1()
username: &quot;Jerry&quot;
Symbol(Symbol.toStringTag): &quot;Module&quot;
</code></pre>
<h3 id="41-模块导出"><a class="header" href="#41-模块导出">4.1 模块导出</a></h3>
<p>导出方式一：命名导出（ named export）方式</p>
<pre><code class="language-js">export let username = 'Jerry'
export function fn1() {
  console.log('1111')
}
</code></pre>
<p>上述格式可以简写为：</p>
<pre><code class="language-js">let username = 'Jerry'
function fn1() {
  console.log('1111')
}
export { username, fn1 }
</code></pre>
<p>导出方式二：默认导出（ default export）方式</p>
<pre><code class="language-js">let username = 'Lisi'
export default username // 导出的数据是 Lisi
</code></pre>
<p>注意：默认导出时，在引入时，其数据默认被包裹在了对出对象的 default 属性中，且默认导出数据</p>
<pre><code class="language-js">let username = 'Lisi'
export default username = 'ZS' // 导出的数据是 ZS
</code></pre>
<p>每个模块只能有一个默认导出。重复的默认导出会导致 SyntaxError。</p>
<p>默认导出与命名导出不冲突：</p>
<pre><code class="language-js">const foo = 'foo'
const bar = 'bar'
export { bar }
export default foo
</code></pre>
<p>这两个 export 语句可以组合为一行：</p>
<pre><code class="language-js">const foo = 'foo'
const bar = 'bar'
export { foo as default, bar }
</code></pre>
<h3 id="42-模块导入"><a class="header" href="#42-模块导入">4.2 模块导入</a></h3>
<p>命名导出数据的引入：</p>
<pre><code class="language-js">// 直接全局引入
import * as mylib from './mylib.js' // 将所有导出属性引入，并挂载在 名为 mylib 的变量中

// 解构赋值方式引入：此时如果使用了未导出、不存在的数据，则会报错。
import { username } from './mylib.js'
</code></pre>
<p>默认导出数据的引入：</p>
<pre><code class="language-js">// import { username } from &quot;./mylib.js&quot;; // 报错
import { default as username } from './mylib.js'

// 可以简写为：
import username from './mylib.js'
</code></pre>
<h3 id="43-别名解决冲突"><a class="header" href="#43-别名解决冲突">4.3 别名解决冲突</a></h3>
<p>引入多个文件时，很容易出现多个模块内使用了同一个变量的问题。别名方式可以解决命名冲突：</p>
<pre><code class="language-js">import { name } from './module1.js'
import { name as username } from './module2.js'
</code></pre>
<h3 id="44-动态导入"><a class="header" href="#44-动态导入">4.4 动态导入</a></h3>
<p><code>import { username } from &quot;./mylib.js&quot;;</code> 这种写法必须放在业务代码上方，如果业务代码内部有判断条件才会使用该模块，那么判断条件始终不满足使用该模块时，模块就白白引入了。这时候可以动态的导入：</p>
<pre><code class="language-js">if (flag) {
  import('./libs.js').then(({ name, age }) =&gt; {
    console.log(name)
  })
}
</code></pre>
<h3 id="45-优化写法"><a class="header" href="#45-优化写法">4.5 优化写法</a></h3>
<p>可以对上述引入方式进行优化，将引入部分独立写入一个文件，如 app.js，作为一个入口文件。app.js 的内容如下所示：</p>
<pre><code class="language-js">import { default as username } from './mylib.js'
</code></pre>
<p>在 html 中直接导入入口文件，而不需要导入其他文件：</p>
<pre><code class="language-html">&lt;script src=&quot;./app.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-工作流工具-gulp"><a class="header" href="#021-工作流工具-gulp">02.1-工作流工具-Gulp</a></h1>
<h2 id="一-工作流概念"><a class="header" href="#一-工作流概念">一 工作流概念</a></h2>
<p>在开发阶段，我们往往使用 ES6、less、coffeescript 来提升开发效率，但是这些文件不能直接部署在生产环境中，即在开发部署时，需要对 css、js 等文件执行编译、压缩等等一系列流程任务，我们称之为工作流。</p>
<p>人工处理这些任务的代价是很高的，利用构建工具可以编写一些任务，按照我们需要的流程来执行。</p>
<p>常见的处理任务包括：预处理语言的编译、代码压缩混淆、图片体积优化；</p>
<p>常见的构建工具包括：</p>
<ul>
<li>Grunt：已衰落</li>
<li>Gulp：主流工作流工具，基于 NodeJS 开发的前端构建工具，国内还有对应产品 F.I.S（百度出品）。</li>
<li>Webpack：也能承担一部分工作流任务，但其核心功能是打包。</li>
<li>Rollup：适合打包第三方库的工具。</li>
<li>Vite：新一代构建工具，性能更高，内部采用 ESBuilder。最大优点是：直接支持<code>hmr update</code>，速度极快。</li>
</ul>
<p>贴士：Vue 的构建工具 Vue-cli 目前内部采用的仍然是 webpack，webpack 在开发时，从入口文件开始，将源码打包为一个文件，若某一个模块改变，webpack 也会根据路由变化进行差异化 build，但是 build 完之后，webpack 仍然需要将 build 完毕的内容替换进内存。</p>
<p>Vite 由于使用了 ES6 的模块化加载规则，浏览器原生支持，无需打包，在开发模式下不需要打包可以直接运行，速度极快。</p>
<h2 id="二-工作流工具-gulp"><a class="header" href="#二-工作流工具-gulp">二 工作流工具 Gulp</a></h2>
<h3 id="21-gulp-基本使用"><a class="header" href="#21-gulp-基本使用">2.1 Gulp 基本使用</a></h3>
<p>Gulp 的作用：</p>
<ul>
<li>对 HTML/CSS/JS 等文件进行压缩合并</li>
<li>语法转换：es6 转换为 es5，less 转换为 css</li>
<li>公共文件抽取</li>
</ul>
<p>Gulp 也提供了大量的插件来完成更多、更复杂的任务。</p>
<p>Gulp 基础示例：</p>
<pre><code class="language-txt">第一步：本地安装 gulp。进入项目文件夹后执行下列操作
npm i gulp -D

第二步：在根目录创建配置文件 gulpfile.js
    const gulp = require('gulp');
    //创建一个默认任务
    gulp.task('default',function () {
        console.log(&quot;hello gulp&quot;);
    });

第三步：执行命令。这里要注意如果 npm 版本小于 5.2，则不支持 npx 命令，需要全局安装一次 gulp，然后直接运行 gulp 命令即可
npx gulp default // 由于 default 是默认任务，这里可以省略
</code></pre>
<h3 id="22-使用-gulp-创建任务"><a class="header" href="#22-使用-gulp-创建任务">2.2 使用 Gulp 创建任务</a></h3>
<p>示例：</p>
<pre><code class="language-js">const gulp = reuqire('gulp')

gulp.task('copyJS', function () {
  // 定义一个任务，名称为 copyJS
  gulp
    .src('src/js/**/*.js') // src() 获取资源路径
    .pipe(gulp.dest('dist/')) // pipe() 将资源传输给插件。dest() 资源构建完毕后自动创建的路径
})
</code></pre>
<p>gulp.src() 也可以使用 [] 参数/正则，! 表示不匹配， **代表递归：</p>
<pre><code class="language-js">gulp.src(['src/js/**/*.*', '!src/demo.html'])
</code></pre>
<p>执行任务：</p>
<pre><code class="language-txt">npx gulp copyJS
</code></pre>
<h3 id="23-gulp-常见-api"><a class="header" href="#23-gulp-常见-api">2.3 Gulp 常见 API</a></h3>
<ul>
<li>gulp.src()：获取资源文件</li>
<li>gulp.dest()：输出资源文件</li>
<li>gulp.task()：建立 gulp 任务</li>
<li>gulp.watch()：监控文件变化</li>
<li>gulp.pipe()：导出获取到的资源</li>
</ul>
<p>watch 用于监视文件的改变，自动构建：</p>
<pre><code class="language-js">gulp.task('js', function () {
  //src 下文件发生改变，自动执行 default 任务
  gulp.watch('src/*', ['default'])
})
</code></pre>
<p>不同任务间存在依赖关系时，可以指定依赖，如下图：</p>
<pre><code class="language-js">gulp.task('less', ['依赖 1', '依赖 2', '依赖 3'], function () {})
</code></pre>
<h3 id="24-gulp-插件"><a class="header" href="#24-gulp-插件">2.4 Gulp 插件</a></h3>
<p>Gulp 本身只有文件复制等基础 API，通过不同的插件实现构建任务，Gulp 只是按着配置文件调用执行了这些插件。</p>
<p>比如需要编译 less，需要先安装编译 less 的 gulp 插件：<code>npm install gulp-less -S</code></p>
<pre><code class="language-js">const gulp = require('gulp')
const less = require('gulp-less')

gulp.task('less', function () {
  gulp
    .src('src/**/*.less')
    .pipe(less()) // 调用插件
    .pipe(gulp.dest('dist/'))
})
</code></pre>
<p>常用 gulp 插件：</p>
<pre><code class="language-txt">gulp-less   编译 LESS 文件
gulp-cssmin   压缩 CSS
gulp-rname  重命名
gulp-imagemin  图片压缩
gulp-uglify   压缩 JS
gulp-concat   合并
gulp-htmlmin  压缩 HTML
gulp-autoprefixer 添加 CSS 私有前缀
gulp-rev   添加版本号
gulp-rev-collector 内容替换
gulp-connect  创建服务器，默认监听 8080 端口
gulp-useref
gulp-if
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-webpack-简介"><a class="header" href="#031-webpack-简介">03.1-Webpack 简介</a></h1>
<h2 id="一-webpack-概念"><a class="header" href="#一-webpack-概念">一 webpack 概念</a></h2>
<p>在开发环境中，现代前端开发技术提倡模块化开发，以降低代码耦合度，便于后期扩展、维护。在生产环境中，前端代码也需要压缩、合并等以提升网页性能。</p>
<p>这些操作手动操作自然是相当繁琐，Webpack 就是这样一款模块打包工具，他会分析项目的结构，找到 JS 模块之间的依赖关系，按照一定的规则把这些模块组织为 JavaScript 文件，让浏览器能直接使用。</p>
<p>webpack 认为一切皆模块，包括：js 文件、css 文件、图片文件等等，都会被其合并为一个 js 文件，这是其本质工作。</p>
<p>webpack 的优点：</p>
<ul>
<li>
<ol>
<li>对 CommonJS、AMD、ES6 的语法规范都做了兼容</li>
</ol>
</li>
<li>
<ol start="2">
<li>对 js、css、图片等资源文件都支持打包</li>
</ol>
</li>
<li>
<ol start="3">
<li>串联式模块加载器以及插件机制，使用更加灵活，扩展性更强</li>
</ol>
</li>
<li>
<ol start="4">
<li>有独立的配置文件 webpack.config.js</li>
</ol>
</li>
<li>
<ol start="5">
<li>可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li>
</ol>
</li>
<li>
<ol start="6">
<li>支持 SourceUrls 和 SourceMaps，易于调试</li>
</ol>
</li>
</ul>
<p>打包细节：
<img src="07-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/../images/webpack/webpack-00.png" alt="webpack 打包细节" /></p>
<p>webpack 并不能实现 js 的编译，只能识别到 JS 中的 <code>import</code>语法，把 js 中引入的其他 js 文件打包到一起。如果要打包 html、css、编译 ES6 等，则需要 webpack 大量的 loader、plugin 来实现，其本身只是一个模块打包工具。</p>
<h2 id="二-webpack-与-gulp-区别"><a class="header" href="#二-webpack-与-gulp-区别">二 webpack 与 gulp 区别</a></h2>
<p>Gulp 的定位是 Task Runner, 用来跑一个一个任务，但是没有解决 js module 的问题。其工作方式是：指明对某些文件进行类似编译、组合、压缩等任务的具体步骤，之后 gulp 工具可以自动替你完成这些任务。</p>
<p><img src="07-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/../images/webpack/webpack-01.png" alt="gulp 原理" /></p>
<p>Webpack 工作方式：把项目当做一个整体，通过一个给定的主文件（如 index.js），Webpack 将从这个文件开始找到项目的所有依赖文件，使用 loaders 处理它们，最后打包为一个（或多个）浏览器可识别的 JavaScript 文件。</p>
<p><img src="07-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/../images/webpack/webpack-02.png" alt="webpack 原理" /></p>
<h2 id="三-webpack-的安装与运行"><a class="header" href="#三-webpack-的安装与运行">三 webpack 的安装与运行</a></h2>
<h3 id="21-webpack-安装"><a class="header" href="#21-webpack-安装">2.1 webpack 安装</a></h3>
<p>目前，webpack 目前的主要版本是 v5：</p>
<pre><code class="language-txt"># 推荐node14环境
npm i -D webpack webpack-cli

# 查看安装的 webpack 版本
npx webpack -v
</code></pre>
<p>贴士：</p>
<ul>
<li>在本地安装的 webpack 需要使用 <code>npx webpack</code> 命令启动，npx 命令的本质是调用了 <code>.\node_modules\.bin\webpack</code>。</li>
<li>也可以全局安装 webpack，就可以直接使用 webpack 命令了，但是笔者不推荐，因为不同的项目可能使用的 webpack 版本不同，全局安装后会影响对不同版本项目的支持。</li>
</ul>
<h3 id="22-使用-webpack-打包"><a class="header" href="#22-使用-webpack-打包">2.2 使用 webpack 打包</a></h3>
<p>webpack4 之后，无需配置文件即可实现打包，会自动在 src 目录下寻找 index.js 文件，开始执行打包：</p>
<pre><code class="language-txt"># 创建文件 src/index.js
# 也可以手动指定要打包的文件：npx webpack src/main.js
npx webpack
</code></pre>
<p>打包完毕后，会在根目录生成 <code>dist</code> 目录，打包后的文件都放在此处。</p>
<h3 id="23-npm-脚本运行"><a class="header" href="#23-npm-脚本运行">2.3 npm 脚本运行</a></h3>
<p>反复输入上述命令很麻烦，可以配置一个 npm 脚本来替代：</p>
<pre><code class="language-txt"># 在 package.json 中添加一行脚本
&quot;dev&quot;: &quot;webpack --mode development&quot;

# 配置完成后使用 npm 来启动 webpack
npm run dev
</code></pre>
<h3 id="24-webpack-打包概览"><a class="header" href="#24-webpack-打包概览">2.4 webpack 打包概览</a></h3>
<p>现在我们创建 lib 个 js 文件：</p>
<pre><code class="language-js">// src/lib.js
const add = (a, b) =&gt; {
  return a + b
}

export default add

// src/index.js
import add from './lib'

let res = add(3, 4)
console.log(res)
</code></pre>
<p>此时我们新建一个 index.html 文件，引入 <code>src/index.js</code> 文件打开后是无法执行的，这是 es6 模块的原因。如果我们先用 webpack 打包：</p>
<pre><code class="language-txt">npx webpack
</code></pre>
<p>在 index.html 中引入打包后的 js 文件：<code>dist/main.js</code>，打开浏览器即可看到输出 7。这是因为 webpack 从 src/index.js 文件开始将 index.js 文件以来的其他模块全部打包了进来，最后生成了 main.js 文件，此时的 main 就是浏览器直接可执行的。</p>
<h2 id="四-webpack-的配置文件"><a class="header" href="#四-webpack-的配置文件">四 webpack 的配置文件</a></h2>
<p>在实际开发中，webpack 的打包命令需要配置大量的命令参数，如：</p>
<pre><code class="language-txt">--open          打包后自动打开浏览器
--port          设置端口
--contentBase   打开目的文件目录
--hot           浏览器异步更新  主要针对样式的更改
--config a.js   手动指定配置文件，默认为根目录下的 webpack.config.js
</code></pre>
<p>这些参数如果都写在 npm 脚本中也会引起 npm 脚本的臃肿，我们可以指定一个 webpack 的配置文件，让 npm 脚本运行的 webpack 命令去该配置文件查找 webapck 的命令行参数，在项目根目录下创建 webpack.config.js 配置文件：</p>
<pre><code class="language-js">const path = require('path')

module.exports = {
  mode: 'development',
  entry: path.resolve(__dirname, 'src/index.js'), //入口
  output: {
    path: path.resolve(__dirname, 'dist'), //输出目录
    filename: 'bundle.js', //输出文件名
  },
  module: { rules: [] }, // 加载器配置
  plugins: [], // 插件配置
}
</code></pre>
<h2 id="五-webpack-核心概念"><a class="header" href="#五-webpack-核心概念">五 webpack 核心概念</a></h2>
<p>在 webpack 的配置文件中可以追加下列第三方配置：</p>
<ul>
<li>加载器 loader：用于完成图片、css 等文件的打包</li>
<li>插件 plugin：用于优化 webpack 的打包体验</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="032-webpack-基础-基础配置"><a class="header" href="#032-webpack-基础-基础配置">03.2-Webpack 基础-基础配置</a></h1>
<h2 id="一-mode-模式"><a class="header" href="#一-mode-模式">一 mode 模式</a></h2>
<p>Mode 配置会设定 webpack 的环境：</p>
<ul>
<li>development：默认值，为开发环境。其本质是将 <code>process.env.NODE_ENV</code> 的值设置为 development，启用 NamedCunksPlugin 和 NamedModulesPlugin。</li>
<li>production：生产环境，该环境下会压缩 html 与 js 代码。其本质是将 <code>process.env.NODE_ENV</code> 的值设置为 production，启用 FlagDependencyUsagePlugin 和 UglifyJsPlugin 等插件</li>
<li>none：会保留原始构建信息</li>
</ul>
<h2 id="二-entryoutput"><a class="header" href="#二-entryoutput">二 entry、output</a></h2>
<h3 id="21-配置实例"><a class="header" href="#21-配置实例">2.1 配置实例</a></h3>
<p>入口与出口可以分别配置：</p>
<pre><code class="language-js">// npm i html-webpack-plugin -D
const path = require('path')
const htmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  entry: {
    //多个 entry
    main1: path.resolve(__dirname, './src/index1.js'),
    main2: path.resolve(__dirname, './src/index2.js'),
  },
  output: {
    //name 变成了上述的入口名
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash:10].js',
    // publicPath: '', 会将该地址注入到 html 中的 JS 的 src 中
  },
  module: {
    rules: [
      {
        test: /\.(css|scss)$/,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
  plugins: [
    //  html-webpack-plugin 会将多个入口都注入到 html 中
    new htmlWebpackPlugin({
      template: path.resolve(__dirname, 'src/index.html'),
      filename: 'index.html',
    }),
  ],
}
</code></pre>
<h3 id="22-多入口"><a class="header" href="#22-多入口">2.2 多入口</a></h3>
<p>入口支持字符串、数组、对象等写法，入口的多少决定了打包后的文件数量，如下所示会打包为 2 个：</p>
<pre><code class="language-js">module.exports = {
  entry: {
    lib: ['core-js/stable', 'lodash'],
    vendor: './index.js',
  },
}
</code></pre>
<p>贴士：入口是一个相对路径，webpack 的配置还提供了 context 配置，可以设置 webpack 开始工作的目录，是一个绝对路径，默认值就是当前项目的根目录，context 路径配合 entry 路径，就是真正的文件路径。</p>
<h3 id="23-output-文件名"><a class="header" href="#23-output-文件名">2.3 output 文件名</a></h3>
<p>为了应对浏览器缓存问题，输出文件往往需要加上 hash 值，以确保文件名与之前的不同。hash 值是根据文件内容计算而得，有以下三种：</p>
<ul>
<li>fullhash：webpack5 提出的提前之前 hash 值的配置，根据打包中的所有文件计算出 hash 值。在既定一次打包中，所有资源出口的 hash 是一样的。</li>
<li>chunkhash：根据打包过程中当前 chunk 计算出的 hash 值。在既定一次打包中，打包后的文件名可以极大避免重复性。</li>
<li>contenthash：类似 chunkhash，根据打包内容计算 hash，一般用于计算 css 文件的 hash。</li>
</ul>
<h2 id="三-webpack-dev-server"><a class="header" href="#三-webpack-dev-server">三 webpack-dev-server</a></h2>
<h3 id="31--watch-参数"><a class="header" href="#31--watch-参数">3.1 -watch 参数</a></h3>
<p>webpack 的打包命令如果添加了<code>watch</code>参数，则可以监听源码文件，当源码文件有改动时，则自动重新打包。</p>
<h3 id="32-webpack-dev-server"><a class="header" href="#32-webpack-dev-server">3.2 webpack-dev-server</a></h3>
<p>如果我们要实现 watch 的效果，且能自动打开浏览器，刷新浏览器，那么需要使用 webpack-dev-server，该工具会使 contentBase 配置中的目录成为服务器静态文件目录。</p>
<p>第一步：安装</p>
<pre><code class="language-txt">npm i -D webpack-dev-server
</code></pre>
<p>第二步：脚本修改</p>
<pre><code class="language-js">// webpack-dev-server 命令直接替代了 webpack 命令
&quot;dev&quot;: &quot;webpack-dev-server&quot;
</code></pre>
<p>第三步：修改 webpack 配置</p>
<pre><code class="language-js">    devServer: {
        open: true,                 //启动时，会打开浏览器并渲染页面
        port: 3000,                 //默认是 3000
        hot: true,                   //开启 hotModule 功能
        historyApiFallback:true      //单页面应用启用路由时候需要该设置，在遇到404时返回到index.html
    },
</code></pre>
<p>注意：webpack-dev-server 打包的 dist 目录内是没有文件的，文件位于内存中。</p>
<h3 id="33-webpack-配置本地代理"><a class="header" href="#33-webpack-配置本地代理">3.3 webpack 配置本地代理</a></h3>
<p>使用 webpack-dev-server 也可以实现跨域问题解决，但是如果我们要自己为自己设置一定的接口，则需要手动创建一个本地服务器：</p>
<pre><code class="language-js">// server.js
const webpakc = require('webpack')
const middle = require('webpack-dev-middleware')
const webpackCfg = require('./webpack.config.js')

const compiler = webpack(webpackCfg)

app.use(middle(compiler))

app.get('/foo', (req, res) =&gt; {
  res.json({
    data: 'bar',
  })
})

app.listen(3000)
</code></pre>
<p>当使用 <code>node server.js</code> 启动时，会同时启动 webpack。</p>
<h3 id="34-其他参数"><a class="header" href="#34-其他参数">3.4 其他参数</a></h3>
<p>publicPuth：设置 devserver 的请求资源路径，默认情况下，webpack-dev-server 打包的资源存放在内存中，只是映射了一个磁盘路径。如果将其值设置为 <code>/dist/</code>，那么表示静态资源映射到了磁盘的 dist 目录下。示例如下：</p>
<pre><code class="language-txt"># 默认 web 运行在 localhost:3000，访问的某个打包文件的路径是
localhost:3000/bundle.js

# 设置 publicPuth 为 /dist/，访问这个打包后的文件路径是
localhost:3000/dist/bundle.js
</code></pre>
<h2 id="四-webpack-打包模式配置不同配置文件"><a class="header" href="#四-webpack-打包模式配置不同配置文件">四 webpack 打包模式配置不同配置文件</a></h2>
<p>webpack 在打包时有开发模式（development）和生产模式（prodction）两种，在 mode 中配置中。那么为了对应不同的环境就需要不同的配置。</p>
<p>npm 脚本配置：</p>
<pre><code class="language-json">    &quot;dev&quot;: &quot;webpack-dev-server --config webpack.config.dev.js&quot;,
    &quot;build&quot;: &quot;webpack --config webpack.config.prod.js&quot;
</code></pre>
<p>由于 dev 与 prod 的配置有很多相同的地方，推荐将共同部分抽离。</p>
<p>首先：安装 webpack 配置合并插件</p>
<pre><code class="language-js">npm install -D webpack-merge
</code></pre>
<p>然后将通用配置移动到到 webpack 基础配置文件：webpack.config.base.js</p>
<pre><code class="language-js">const path = require('path')
const htmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  entry: {
    main: path.resolve(__dirname, './src/index.js'),
  },
  module: {
    rules: [
      {
        test: /\.(css|scss)$/,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
  plugins: [
    new htmlWebpackPlugin({
      template: path.resolve(__dirname, 'src/index.html'),
      filename: 'index.html',
    }),
  ],
}
</code></pre>
<p>开发配置：webpack.config.dev.js</p>
<pre><code class="language-js">const path = require('path')
const merge = require('webpack-merge')
const webpack = require('webpack')

const baseConfig = require('./webpack.config.base')

const devConfig = {
  mode: 'development',
  devtool: 'cheap-module-source-map',
  output: {
    //name 变成了上述的入口名
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js',
  },
  devServer: {
    contentBase: path.join(__dirname, 'dist'),
    open: true, //启动时，会打开浏览器并渲染页面
    port: 3000, //默认是 3000
    hot: true, //开启 hotModule 功能
    hotOnly: true,
  },
  plugins: [new webpack.HotModuleReplacementPlugin()],
}

module.exports = merge(baseConfig, devConfig)
</code></pre>
<p>生产配置：webpack.config.prod.js</p>
<pre><code class="language-js">const path = require('path')
const merge = require('webpack-merge')

const baseConfig = require('./webpack.config.base')

const prodConfig = {
  mode: 'production',
  output: {
    //name 变成了上述的入口名
    path: path.resolve(__dirname, 'build'),
    filename: '[name].js',
  },
}

module.exports = merge(baseConfig, prodConfig)
</code></pre>
<p>贴士：在开发时，使用 webpack-dev-server 往往不能查看打包后的代码了，也可以在 npm 脚本内再建一个<code>&quot;dev-build&quot;: &quot;webpack --config webpack.config.dev.js&quot;</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="033-webpack-基础-模块加载器-loader"><a class="header" href="#033-webpack-基础-模块加载器-loader">03.3-Webpack 基础-模块加载器 loader</a></h1>
<h2 id="一-webpack-加载器概念"><a class="header" href="#一-webpack-加载器概念">一 webpack 加载器概念</a></h2>
<p>webpack 只能打包 JS 文件，如果要实现对 CSS、图片等文件的打包，就需要大量的加载器 loader。每个加载器都为 webpack 提供了一个功能，多个加载器组合后，才能实现完整的项目打包功能。</p>
<p>loader 在 webpack 配置文件的 module 字段中配置，位于 rules 字段中，其值可以是字符串、数组、json 等五花八门，比如打包 CSS 的加载器为：style-loader，css-loader，实现方式如下：</p>
<pre><code class="language-js">module: {
  rules: [
    {
      test: /(\.jsx|\.js)$/, //正则匹配 哪些文件 需要该加载器
      use: {
        //匹配到的文件使用哪个加载器
        loader: 'babel-loader',
        options: {
          //加载器的参数
          presets: ['env'],
        },
      },
      exclude: /node_modules/, //忽略掉哪些文件不走该加载器
      include: /src/, // 只对src内的文件进行处理
    },
    {
      //后续的其他加载器
    },
  ]
}
</code></pre>
<p>注意事项：</p>
<ul>
<li>每个 loader 都不是 webpack 本身的功能，所以需要安装这些第三方 loader 才能使用</li>
<li><strong>多个 loader 的处理顺序是：从下到上，从右到左！</strong></li>
</ul>
<h2 id="二-常用-loader"><a class="header" href="#二-常用-loader">二 常用 loader</a></h2>
<h2 id="21-babel-loader-编译-js"><a class="header" href="#21-babel-loader-编译-js">2.1 babel-loader 编译 JS</a></h2>
<p>babel-loader 提供对 ES6、ES7 等编译为 ES5 的功能，详细配置见 webpack-babel 章节。</p>
<h3 id="22-style-loader-css-loader-打包-css"><a class="header" href="#22-style-loader-css-loader-打包-css">2.2 style-loader css-loader 打包 css</a></h3>
<p>打包 CSS 需要两个 loader 配合：</p>
<ul>
<li>css-loader：让 JS 支持 <code>import</code> css 模块，会遍历 CSS 文件，然后找到 url() 表达式的关系并处理他们</li>
<li>style-loader：把刚才分析得到的 css 代码插入页面 head 标签的 style 标签中。</li>
</ul>
<p>安装 <code>style-loader</code> <code>css-loader</code>：</p>
<pre><code class="language-txt">npm i -D style-loader css-loader
</code></pre>
<p>配置：</p>
<pre><code class="language-js">module: {
  rules: [
    {
      test: /\.css$/,
      use: ['style-loader', 'css-loader'],
    },
  ]
}
</code></pre>
<h3 id="23-打包-saasless"><a class="header" href="#23-打包-saasless">2.3 打包 saas、less</a></h3>
<p>打包 less 的配置如下：</p>
<pre><code class="language-js">module: {
  rules: [
    {
      test: /\.(css|scss)$/,
      use: ['style-loader', 'css-loader', 'less-loader'],
    },
  ]
}
</code></pre>
<p>如果用到了 saas，需要安装<code>scss-loader</code>与<code>node-sass</code>，但是最新的 saas 已经无需安装环境复杂的 node-sass 了，直接安装：</p>
<pre><code class="language-txt">npm i sass sass-loader -D
</code></pre>
<h3 id="24-解决浏览器-css-兼容性问题加载器-postcss-loader"><a class="header" href="#24-解决浏览器-css-兼容性问题加载器-postcss-loader">2.4 解决浏览器 CSS 兼容性问题加载器 postcss-loader</a></h3>
<p>如果需要给某些 css 加上类<code>moz</code>这样的前缀，需要<code>postcss-loader</code>以及 autoprefixer 插件。postcss-loader 的作用类似 babel，babel 用来支持先进的 JS 语法，postcss-loader 在其自身一些插件的作用下，可以支持更先进的 CSS 语法。</p>
<p>安装：</p>
<pre><code class="language-txt">npm i -D postcss-loader autoprefixer
</code></pre>
<p>webpack 添加 loader：</p>
<pre><code class="language-js">// 需要 package.json 中定义 browserslist
module: {
  rules: [
    {
      test: /\.(css|scss)$/,
      use: ['style-loader', 'css-loader', 'postcss-loader'],
    },
  ]
}
</code></pre>
<p>当然该 loader 还需要自己单的配置，根目录下创建 postcss.config.js，内容如下：</p>
<pre><code class="language-js">module.exports = {
  plugins: [require('autoprefixer')],
}
</code></pre>
<p>postcss-loader 也支持一些自定义配置：</p>
<pre><code class="language-js">module: {
  rules: [
    {
      test: /\.(css|less)$/,
      use: [
        'style-loader',
        'css-loader',
        {
          loader: 'postcss-loader',
          options: {
            ident: 'postcss',
            plugins: () =&gt; [require('postcss-preset-env')],
          },
        },
        'less-loader',
      ],
    },
  ]
}
</code></pre>
<h3 id="25-打包文件-file-loader"><a class="header" href="#25-打包文件-file-loader">2.5 打包文件 file-loader</a></h3>
<p>打包文件需要借助：file-loader，首先需要安装该 loader：</p>
<pre><code class="language-txt">npm i -D file-loader
</code></pre>
<p>项目的整体结构图如下所示：
<img src="07-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/../images/javascript/webpack-04.png" alt="整体结构图" /></p>
<p>file-loader 配置：</p>
<pre><code class="language-js">module: {
  rules: [
    {
      test: /\.(jpg|png|docx|ppt)$/,
      use: {
        loader: 'file-loader',
        options: {
          name: '[name].[ext]',
          outputPath: 'public/images/', // 文件会被打包到哪个目录
        },
      },
    },
  ]
}
</code></pre>
<p>此时若在 js 中引入了一个文件：</p>
<pre><code class="language-js">import demoJpg from './public/images/demo.jpg'

// 输出的是文件名
console.log('demoJpg...', demoJpg) // 输出文件地址，类似可以处理图片等各种类型的文件
</code></pre>
<p>贴士：flie-loader 一般用于打包字体文件，如下所示配置：</p>
<pre><code class="language-js">module: {
  rules: [
    {
      test: /\.(eot|ttf|svg|)$/,
      use: {
        loader: 'file-loader',
      },
    },
  ]
}
</code></pre>
<h3 id="26-打包图片-url-loader"><a class="header" href="#26-打包图片-url-loader">2.6 打包图片 url-loader</a></h3>
<p>url-loader 具备 file-loader 的功能，且额外拥有自己的一些功能：可以把小图片打包为 base64 格式，所以打包图片一般使用 <code>url-loader</code>，可以在一定程度上提升性能。</p>
<p>安装 <code>url-loader</code>：</p>
<pre><code class="language-txt"># url-loader 依赖于 file-loader
npm i file-loader url-loader -D
</code></pre>
<p><code>url-loader</code> 配置如下：</p>
<pre><code class="language-js">module: {
  rules: [
    {
      test: /\.(jpg|png|jpeg|gif)$/,
      use: {
        loader: 'url-loader',
        options: {
          name: '[name]_[hash].[ext]',
          outputPath: 'public/images/',
          limit: 2048, //如果图片超过 2048 字节不生成 base64
        },
      },
    },
  ]
}
</code></pre>
<h3 id="27-压缩图片-img-loader"><a class="header" href="#27-压缩图片-img-loader">2.7 压缩图片 img-loader</a></h3>
<pre><code class="language-js">module: {
  rules: [
    {
      test: /\.(jpe?g|png|gif|svg)$/i,
      use: ['url-loader?limit=10000', 'img-loader'],
      pngquant: {
        quality: 80,
      },
    },
  ]
}
</code></pre>
<h3 id="28-处理-img-标签-html-loader"><a class="header" href="#28-处理-img-标签-html-loader">2.8 处理 img 标签 html-loader</a></h3>
<p>处理 html 中的图片：</p>
<pre><code class="language-js">module: {
  rules: [
    {
      test: /\.html$/,
      use: [
        {
          loader: 'html-loader',
          options: {
            attrs: ['img:src', 'img:data-src'],
            limit: 8 * 1024,
            outputPath: 'public/images',
            esModule: false, // 该加载器使用的是 commonjs
          },
        },
      ],
    },
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="034-webpack-基础-插件-plugin"><a class="header" href="#034-webpack-基础-插件-plugin">03.4-Webpack 基础-插件 plugin</a></h1>
<h2 id="一-webpack-插件概念"><a class="header" href="#一-webpack-插件概念">一 webpack 插件概念</a></h2>
<p>webpack 的各种 loader 提供了对对应类型文件的打包方式，plugins 则是 webpack 打包过程的便利性、增强型工具。</p>
<p>常用插件有：</p>
<ul>
<li>html-webpack-plugin：每次 webpack 打包，该插件可以将源码中的 html 页面从 src 拷贝到 dist 下，且会自动将入口文件打包的 js 文件插入 html 页面的 script 标签中。</li>
<li>clean-webpack-plugin：每次 webpack 打包，该插件会删除 dist 打包目录中原有文件</li>
<li>copy-webpack-plugin：每次 webpack 打包，该插件会拷贝源码中的文件进入 dist 打包目录</li>
<li>webpack-merge：该插件合并不同 webpack 配置文件</li>
<li>webpack.ProgressPlugin()：进度监控插件</li>
</ul>
<h2 id="二-常用插件"><a class="header" href="#二-常用插件">二 常用插件</a></h2>
<h3 id="21-html-webpack-plugin"><a class="header" href="#21-html-webpack-plugin">2.1 html-webpack-plugin</a></h3>
<p>html-webpack-plugin 插件用于 html 文件的一些处理，比如 以指定位置模板创建新模板、压缩 html 等，如下使用方式：</p>
<pre><code class="language-js">const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      filename: 'index.html',
      minify: {
        collapseWhitespace: true,
        removeComments: true,
      },
    }),
  ],
}
</code></pre>
<p>贴士：通过参数设置，HtmlWebpackPlugin 插件还能自定义模版。</p>
<h3 id="22-mini-css-extract-plugin-css-打包插件"><a class="header" href="#22-mini-css-extract-plugin-css-打包插件">2.2 mini-css-extract-plugin CSS 打包插件</a></h3>
<p>mini-css-extract-plugin 插件可以帮助更正 css 打包路径：</p>
<pre><code class="language-js">const MiniCssExtractPlugin = require('mini-css-extract-plugin')

module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: 'css/build.css',
    }),
  ],
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="035-webpack-基础-babel-配置"><a class="header" href="#035-webpack-基础-babel-配置">03.5-Webpack 基础-babel 配置</a></h1>
<h2 id="一-babel-基本使用"><a class="header" href="#一-babel-基本使用">一 babel 基本使用</a></h2>
<p>ES6 React 等写法在浏览器中并未得到完全的支持，利用 Babel 工具可以将 ES6、React 等语法编译为浏览器识别的 ES5。</p>
<p>使用步骤：</p>
<pre><code class="language-txt">1 项目根目录安装：
    旧版：npm i -D babel-cli babel-core babel-preset-env
    新版：npm i -D @babel/cli @babel/core @babel/preset-env

2 项目根目录创建 .babelrc ,内容如下：
    旧版：{&quot;presets&quot;:[&quot;env&quot;]}
    新版：{&quot;presets&quot;:[&quot;@babel/env&quot;]}

3 编译 src 目录下所有文件到 dist 目录下
    npx babel src -d dist                           // 若 npm&lt;5.2，则可以使用 ./node_modules/.bin/babel
</code></pre>
<p>babel-cli 只是一个执行 babel 命令行工具，本身不具备编译功能，编译功能是由插件 babel-preset-env 提供的。</p>
<p>带 env 是指最新的 babel 编译工具，包含了所有的 ES*功能，如果我们不需要这么多的新特性，可以有选择的安装编译插件：</p>
<pre><code class="language-txt"># ES2015 转码规则
$ npm install --save-dev babel-preset-es2015
# react 转码规则
$ npm install --save-dev babel-preset-react
# ES7 不同阶段语法提案的转码规则（共有 4 个阶段），选装一个
$ npm install --save-dev babel-preset-stage-0
$ npm install --save-dev babel-preset-stage-1
$ npm install --save-dev babel-preset-stage-2
$ npm install --save-dev babel-preset-stage-3
</code></pre>
<p>在命令行中敲击大量命令显然不是高效的，可以直接通过配置文件配置 babel，新建文件 <code>.babelrc</code>即可：</p>
<pre><code class="language-js">  {
    &quot;presets&quot;: [
      &quot;es2015&quot;,
      &quot;react&quot;,
      &quot;stage-2&quot;
    ],
    &quot;plugins&quot;: []
  }
</code></pre>
<h2 id="二-webpack-配置-babel"><a class="header" href="#二-webpack-配置-babel">二 webpack 配置 babel</a></h2>
<p>转译 ES6，ES7 需要 babel-loader 加载器。</p>
<p>安装 babel-loader：</p>
<pre><code class="language-txt">npm i -D babel-loader @babel/core @babel/preset-env
</code></pre>
<p>添加 babel-loader 加载器：</p>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      {
        test: /(\.jsx|\.js)$/,
        use: {
          loader: 'babel-loader',
        },
        exclude: /node_modules/,
      },
    ],
  },
}
</code></pre>
<p>此时 babel-loader 不知道用哪种 babel 格式转译，配置 .babelrc</p>
<pre><code class="language-js">{
 &quot;presets&quot;: [&quot;@babel/preset-env&quot;]   // 如果是 babel6，此处配置为：[&quot;babe-preset-env&quot;]，安装的 npm 包名也如此
}
</code></pre>
<p>贴士：也可以不添加.babelrc 文件，在 babel-loader 插件内直接配置：</p>
<pre><code class="language-js"> use: {
  loader: &quot;babel-loader&quot;,
  options: {
   presets: [&quot;@babel/preset-env&quot;]
  }
 },
</code></pre>
<h2 id="三-babel-转换函数"><a class="header" href="#三-babel-转换函数">三 babel 转换函数</a></h2>
<h3 id="31-ppolyfill"><a class="header" href="#31-ppolyfill">3.1 ppolyfill</a></h3>
<p>虽然 babel 把 ES6 解析为了 ES5，但是仍然有许多变量在低版本不支持，比如：Promise,Set,Symbol,Array.from,async 等。</p>
<p>在最初 Babel 的解决方案是使用 polyfill（垫片），不过<strong>该方案已经在芭芭拉 7.4.0 后废弃</strong>。polyfill 作用是当代码中用到了某个浏览器不支持的 ES6 变量，如 Map，则加载一个 Map 的实现类。直接 import 导入 polyfill 文件过大，需要如下优化，进行按需导入：</p>
<pre><code class="language-js">// npm install -S @babel/polyfill

// .babelrc 中添加如下配置，会进行自动导入，无需 import
presets: [['@babel/preset-env', { useBuiltIns: 'usage' }]]
</code></pre>
<h3 id="32-transform-runtime"><a class="header" href="#32-transform-runtime">3.2 transform-runtime</a></h3>
<p>polyfill 的却显示：其生成的 map、promise 都是以全局变量的形式存在，会污染框架的环境。此时推荐使用 transform-runtime：</p>
<pre><code class="language-js">// 安装
// npm i -D @babel/plugin-transform-runtime
// npm i -S @babel/runtime

// 删除 presets 配置，添加 plugins
options: {
  &quot;plugins&quot;:[
    [&quot;@babel/plugin-transform-runtime&quot;,{
      &quot;corejs&quot;: false,
      &quot;helpers&quot;: true,
      &quot;regenerator&quot;: true,
      &quot;useESModules&quot;: false
    }]
  ]
}
</code></pre>
<p>@babel/plugin-transform-runtime 可以对 Babel 编译过程中产生的 helper 方法进行重新聚合，以减少打包体积，并能避免全局污染，因为它提供了一个沙箱式的补丁。</p>
<h3 id="33-原理解读"><a class="header" href="#33-原理解读">3.3 原理解读</a></h3>
<pre><code class="language-js">// 原生代码如下：
const foo = (a, b) =&gt; {
  return Object.assign(a, b)
}

//经过 babel 编译后为：
;('use strict')
var foo = function foo(a, b) {
  return Object.assign(a, b)
}
</code></pre>
<p>Object.assign 作为 ES6 语法被编译成了普通函数，而不是我们理想的结果：</p>
<pre><code class="language-js">Object.assign ||
  function () {
    /*...*/
  }
</code></pre>
<p>这样编译为了保证正确的语义，只能转换语法而不是去增加或修改原有的属性和方法。所以 babel 不处理 Object.assign 反倒是最正确的做法。而处理这些方法的方案则被称为 polyfill。</p>
<p>babel 针对每个 API 都提供了对应的转换插件，如上述案例需要安装的插件是：</p>
<pre><code class="language-txt"># 安装
npm i - S @babel/plugin-transform-object-assign (注意旧版写法)

# .babelrc 配置：
 &quot;plugins&quot;: [&quot;@babel/transform-object-assign&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-webpack-优化-开发环境优化"><a class="header" href="#041-webpack-优化-开发环境优化">04.1-Webpack 优化-开发环境优化</a></h1>
<h2 id="一-开发环境配置优化"><a class="header" href="#一-开发环境配置优化">一 开发环境配置优化</a></h2>
<p>在开发环境下，我们往往关注代码的打包速度、调试便捷度等，所以在开发环境下我们需要优化的是构建、调试相关配置。</p>
<h3 id="11-hmr-热模块替换"><a class="header" href="#11-hmr-热模块替换">1.1 HMR 热模块替换</a></h3>
<p>默认情况下，某个模块发生了替换、添加、删除，则项目所有文件都会被重新打包。在大型项目中，这会极大影响开发效率，webpack 服务 的 HMR 功能，即 <code>hot module replacement（热模块替换）</code>，可以让项目只打包发生变化的模块，以极大提升构建速度。通俗点说，webpack-dev-server 可以自动刷新整个页面实时预览代码变更，当启用 HMR 后，只是通过加载修改过的模块来实现实时预览。</p>
<p>开启方式如下：</p>
<pre><code class="language-js">devServer: {
  hot: true // 默认开启 HMR 功能，必须重启 webpack 服务
}
</code></pre>
<p>虽然开启了 HMR 功能，但是不同类型的文件的 HRM 功能配置不一致：</p>
<ul>
<li>html 文件：默认没有 HMR 功能，开启 devServer 的 hot 后也会导致 html 不能热刷新，需要配置入口：<code>entry:['index.js', 'index.html']</code>，但是其实 html 文件只有一个文件，HMR 功能是不需要的。</li>
<li>css 文件：style-loader 内部实现了 HMR 功能，开启 hot 后即可实现 HMR。</li>
<li>js 文件：默认没有 HMR 功能，即使开启 hot，也仍然是一个 js 文件被修改，所有 JS 文件被重新加载。JS 要实现 HMR 需要在代码中体现。</li>
</ul>
<p>JS 代码中体现 HMR 方式：</p>
<pre><code class="language-js">if (module.hot) {
  // 监听 demo.js 文件变化
  module.hot.accept('./demo.js', function () {
    // demo.js 发生变化则执行该回调函数
  })
}
</code></pre>
<p>贴士：入口文件的修改会一直导致所有文件重新加载的！</p>
<p>示例：</p>
<pre><code class="language-js">// index.js
import { name } from './lib'
console.log('index----', name)
console.log('index----', 123)

//  lib.js
export const name = 'RY'
let age = 30
// age = 20;
console.log('lib age----', age)
console.log('lib ----', 222)
// b 模块调用模块热替换接口
if (module.hot) {
  module.hot.accept()
}
</code></pre>
<p>在不开启 hot 情况下，打开 <code>age = 20</code> 注释后，会发现整个页面重新刷新了，上面的四次输出全部重新执行一次。打开 hot，重启 webpack，这时候执行打开注释，则会发现浏览器没有刷新，但是 lib 文件内的两次输出再次出现，这证明只有 lib 文件被替换了。</p>
<p>从上看出，热模块替换需要开发者手动添加，那么实际开发中，开发者需要判断那些地方可以使用 HMR，手动书写 HMR 接口，这是很大的麻烦。不过 style-loader、vue-loader、react-hot-loader 等加载器已经自动注入了 module.hot 接口，可以自动完成模块热替换工作，无需开发者手动调用，可以大大减少开发者工作量。</p>
<h3 id="12-source-map-配置源码错误追踪"><a class="header" href="#12-source-map-配置源码错误追踪">1.2 source-map 配置源码错误追踪</a></h3>
<p>打包后的代码需要注入很多非原始代码，帮助源码的解析，这就导致了整个源码在打包后面目全非，在大型项目里，很难追踪和调试。想要在浏览器里直接看到打包前的代码，就需要使用 source-map。</p>
<p>source-map 是源码到构建后代码之间的映射，如果构建后代码出错，通过该映射可以追踪到源码中的错误。webpack 中配置如下：</p>
<pre><code class="language-js">devtool: 'source-map'
</code></pre>
<p>配置了 devtool 值为 source-map 后，会在打包后生成一个后缀 .map 的文件，该文件能够准确提供错误代码位置。</p>
<p>由于打包时要额外生成 map 映射文件，所以该配置会降低打包速度，以下这些 source-map 配置可以在一定程度上根据需要缓解打包缓慢：</p>
<ul>
<li><code>inline-source-map</code>：打包后的 JS 文件内部追加一个 source-map 代码，能够准确提供错误代码位置</li>
<li><code>hidden-source-map</code>：打包后生成外部 source-map 文件，只能够提示错误原因，不能追踪到错误的源码位置，只能追踪到构建后的代码错误位置</li>
<li><code>eval-source-map</code>：打包后的 JS 文件内部中，每个被打包的 js 文件后追加一个 eval() 函数，eval 内部执行的是 source-map 源码，源码以 base64 形式存在，也能提供准确的错误代码位置</li>
<li><code>nosources-source-map</code>：打包后生成外部的 source-map 文件，能够准确提供错误代码位置，但是没有源码信息</li>
<li><code>cheap-source-map</code>：打包后生成外部的 source-map 文件，能够准确提供错误代码位置，但是报错位置的全部一行代码都会提示错误</li>
<li><code>module-source-map</code> 可以显示第三方模块的问题</li>
</ul>
<p>由上可见这些值都是由：cheap、module、inline、eval、nosurces、hidden 组成：</p>
<ul>
<li>cheap：速度较快，生成的 map 文件没有列信息只有行信息，且预处理器输出的 source-map 信息不会被采用，看不到预处理器前的原始代码</li>
<li>module：预处理器输出的 source map 会被采用，可以看到预处理器前的原始代码</li>
<li>inline：将生成的 source map 内联到 bundle 中，该 source map 默认是 Base64 编码的 data URL</li>
<li>eval：使用 eval 包裹模块代码，可以提高 rebuild 速度</li>
</ul>
<p>一般如下采用：</p>
<ul>
<li>开发环境：<code>eval&gt;inline&gt;cheap</code>。目的是在提升打包速度时，也能方便调试。调试最友好：<code>eval-cheap-module-source-map</code>，且能保留预处理器处理前的代码</li>
<li>生产环境：可以不开启 source-map，因为有泄露代码的风险。如果要开启，则推荐 npsources-source-map，因为生产环境下会使用 terser-webpack-plugin 插件、css-minimizer-webpack-plugin 插件来分别压缩 JS、CSS，这 2 个压缩插件仅支持：source-map、inline-source-map、npsources-source-map、hidden-source-map。</li>
</ul>
<p>source-map 利于定位线上问题和调试代码，但是其他人都可以通过浏览器开发者工具看到原始代码，有严重的安全风险，inline-source-map 同理。npsources-source-map 安全性稍高，开发者工具可以看到原始代码的目录结构，控制台可以看到原始代码的堆栈信息，通过 webpack:// 协议可以进入错误信息，但是看不到具体代码，如果公司没有错误收集、监控，则可以采用该方式。</p>
<p>hidden-source-map 安全性较高，会打包输出完整的 source-map，但是打包的 bundle 中不会有 source-map 的引用注释，因此开发者工具无法查看原始代码。这时候如果要分析原始代码，则需要使用错误监控系统，将 source-map 文件上传到错误监控系统中，系统利用 JS 错误信息分析原始代码的堆栈。</p>
<p>当然也可以利用白名单策略，只有有权限的用户才能查看 source-map 文件，这种也是比较稳妥的方式。</p>
<h3 id="13-asset-modules"><a class="header" href="#13-asset-modules">1.3 Asset Modules</a></h3>
<p>Asset Modules 是 webpack5 推出的新功能，可以用来取代 file-loader 等加载器，让 webpack 原生具备打包文件的能力。简单来说，其功能类似：解析文件导入地址并将其替换为访问地址，同时把文件输出到相应位置。</p>
<p>配置如下：</p>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      {
        test: /\.jp$/,
        type: 'asset/resource',
        generator: {
          filename: 'static/[hash:8][ext][query]',
        },
      },
    ],
  },
}
</code></pre>
<p>贴士：generator 配置是可选的，也可以在 output 中配置 <code>assetModuleFilename:'static/[hash:8][ext][query]'</code>。</p>
<p>type 的值有四种：</p>
<ul>
<li><code>asset/resource</code>：与 file-loader 类似，处理文件导入地址，将其替换为访问地址，同时将文件输出到相应为止</li>
<li><code>asset/inline</code>：与 url-loaer 类似，处理文件导入地址，将其替换为 dataRL，默认是为 Base64 格式编码</li>
<li><code>asset/source</code>：与 raw-loaader 类似，以字符串形式导出文件资源</li>
<li><code>asset</code>：根据配置在导出单独的文件和 dataURL 之间自动选择，默认对大于 8KB 的资源使用 asset/resource 方式，否则使用 asset/inline 方式。</li>
</ul>
<p>手动配置 <code>asset</code> 下的资源大小：</p>
<pre><code class="language-js">      {
        test: /\.jp$/,
        type: 'asset/resource',
        parser: {
          dataUrlCondition: {
            maxSize: 6 * 1024 //6KB
          },
        },
      },
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="042-webpack-优化-生产环境优化"><a class="header" href="#042-webpack-优化-生产环境优化">04.2-Webpack 优化-生产环境优化</a></h2>
<h2 id="一-配置打包分析工具"><a class="header" href="#一-配置打包分析工具">一 配置打包分析工具</a></h2>
<ul>
<li>打包体积过大提示配置：webpack 自身的配置字段 performance 可以设置打包体积提示</li>
<li>打包体积分析插件：webpack-bundle-analyzer</li>
<li>打包速度分析插件：speed-measure-webpack-plugin</li>
</ul>
<h2 id="二-资源压缩"><a class="header" href="#二-资源压缩">二 资源压缩</a></h2>
<p>生产环境往往需要对打包后的资源进行压缩，针对不同的资源文件，压缩策略也有所不同。</p>
<h3 id="21-js-文件压缩"><a class="header" href="#21-js-文件压缩">2.1 JS 文件压缩</a></h3>
<p>webpack4 中，一般使用 webpack 的插件 webpack.optimize.UglifyJsPlugin。</p>
<p>webpack5 自带压缩 JS 配置，即 terser-webpack-plugin 插件，无需单独安装，该插件有两种配置方式，可以在插件中直接配置：</p>
<pre><code class="language-js">const TerserPlugin = require('terser-webpack-plugin')

module.exports = {
  plugins: [new TerserPlugin()],
}
</code></pre>
<p>也可以在 optimization 中指定：</p>
<pre><code class="language-js">const TerserPlugin = require('terser-webpack-plugin')

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [new TerserPlugin()],
  },
}
</code></pre>
<h3 id="22-css-文件压缩"><a class="header" href="#22-css-文件压缩">2.2 CSS 文件压缩</a></h3>
<p>webpack4 使用 optimize-css-assets-webpack-plugin 压缩 CSS，但是该插件已经放弃了对 webpack5 的支持。</p>
<p>webpack5 使用 css-minimizer-webpack-plugin 插件压缩 css：</p>
<pre><code class="language-js">// npm i -D css-minimizer-webpack-plugin
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin')
const TerserPlugin = require('terser-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')

module.exports = {
  optimization: {
    minimize: true,
    minimizer: [new CssMinimizerPlugin()],
  },
  plugins: [
    new TerserPlugin(),
    new MiniCssExtractPlugin({
      filename: 'css/build.css',
      chunkFilename: '[id].css',
    }),
  ],
}
</code></pre>
<h3 id="23-html-文件压缩"><a class="header" href="#23-html-文件压缩">2.3 HTML 文件压缩</a></h3>
<p>html-webpack-plugin 插件会默认执行 html 压缩。</p>
<h2 id="三-其他优化手段"><a class="header" href="#三-其他优化手段">三 其他优化手段</a></h2>
<h3 id="31-console-移除"><a class="header" href="#31-console-移除">3.1 console 移除</a></h3>
<p>build 阶段可以移除 console 信息，babel 插件：<code>babel-plugin-transform-remove-console</code> 可以帮助实现该功能，babel 中的配置如下：</p>
<pre><code class="language-js">// // 只在发布阶段移除
// const plugins = []
// if (process.env.NODE_ENV === 'production') {
//   plugins.push('transform-remove-console')
// }

plugins: ['transform-remove-console']
</code></pre>
<h3 id="32-oneof-降低加载器加载次数"><a class="header" href="#32-oneof-降低加载器加载次数">3.2 oneOf 降低加载器加载次数</a></h3>
<p>一些文件其实只需要匹配到一个 loader 就可以了，但是 webpack 中默认 loader 配置需要每个文件都走完所有的 loader 的匹配。这时 oneOf 配置就可以强制其只匹配一次：</p>
<pre><code class="language-js">module: {
  rules: [
    {
      oneOf: [
        { test: /\.css$/, use: '' },
        { test: /\.less$/, use: '' },
        { test: /\.js$/, use: '' },
      ],
    },
  ]
}
</code></pre>
<p>贴士：oneOf 中一个类型的文件，只能有一个加载器！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="043-webpack-优化-代码分割"><a class="header" href="#043-webpack-优化-代码分割">04.3-Webpack 优化-代码分割</a></h1>
<h2 id="一-代码分割优化方案"><a class="header" href="#一-代码分割优化方案">一 代码分割优化方案</a></h2>
<p>代码分割师 webpack 优化中的重要部分，有三种分割方法：</p>
<ul>
<li>多入口：配置多个 entry，webpack 会根据入口个数生成多个打包文件以分离代码，但是存在公共代码被多个入口共用时重复打包问题。</li>
<li>动态加载：通过 import 等方法进行按需加载</li>
<li>抽取公共代码：为了解决重复打包问题，可以使用 Entry dependencies 或者代码分割 SplitChunksPlugin 去重、分离代码。</li>
</ul>
<h2 id="二-代码分割方案示例"><a class="header" href="#二-代码分割方案示例">二 代码分割方案示例</a></h2>
<h3 id="21-多入口分离"><a class="header" href="#21-多入口分离">2.1 多入口分离</a></h3>
<p>多入口是最常用的分离方案，配置如下：</p>
<pre><code class="language-js">const path = require('path')

module.exports = {
  mode: 'development',
  entry: {
    main1: path.resolve(__dirname, 'src/main-1.js'),
    main2: path.resolve(__dirname, 'src/main-2.js'),
  },
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true,
  },
}
</code></pre>
<p>此时打包后，dist 目录将会生成 main1 和 main2 两个 bundle 文件，证明二者不会耦合。</p>
<p>但是这里产生的新问题是：如果 main1 和 main2 都引入了共用的 lodash 模块，那么 main1 和 main 的 bundle 都会存在 lodash 的代码，导致 lodash 代码被重复打包了。</p>
<h3 id="22-动态导入"><a class="header" href="#22-动态导入">2.2 动态导入</a></h3>
<p>如果希望某个单独的文件内引入的模块被打包，可以使用<strong>动态导入</strong>，这也会产生代码分割。比如在某个 js 文件中引入了工具类 util.js，而我们希望这个 util.js 不被打包到该 js 文件中，而是单独打包，则可以这样书写：</p>
<pre><code class="language-js">import(/* webpackChubkName: 'httpUtil' */ './httpUtil.js')
  .then((res) =&gt; {
    // 文件加载成功
  })
  .catch((err) =&gt; {
    // 文件加载失败
  })
</code></pre>
<p>这样，util.js 的文件就被打包进入 vendor 的 bundle 中了。</p>
<p>利用动态导入可以实现懒加载，可以很好的优化应用，加快应用的初始加载速度：因为懒加载即在需要某个文件的时候才去加载，而不是在项目启动的时候就完全加载。比如现在需要实现点击按钮时候运行加法方法，而该方法由其他文件提供，如下示例是在项目启动时就加载了 <code>mathUtil</code> 文件：</p>
<pre><code class="language-js">import add from 'mathUtil'
btn.onclick = function () {
  add(1, 1)
}
</code></pre>
<p>使用动态导入如下改动后即可实现懒加载，即点击按钮后才加载 mathUtil：</p>
<pre><code class="language-js">btn.onclick = function () {
  import(/* webpackChunkName: 'mathUtil' */ 'mathUtil').then(() =&gt; {
    add(1, 1)
  })
}
</code></pre>
<p>懒加载仍然会引起问题，即：需要使用文件时，如果因为网络、大小等问题会导致延迟，在示例中就是点击按钮会导致响应过慢。为了解决该问题，可使用预加载。即项目启动时不会加载引入文件，而是在空闲的时候主动加载：</p>
<pre><code class="language-js">btn.onclick = function () {
  import(
    /* webpackChunkName: 'mathUtil', webpackPrefetch:true */ 'mathUtil'
  ).then(() =&gt; {
    add(1, 1)
  })
}
</code></pre>
<p>预加载原理：普通加载情况下多个文件在同一时间是并行加载的，而预加载是等待其他必须的资源加载完毕后才会加载，这才是最合理的效果。</p>
<h3 id="23-splitchunksplugin-代码分割"><a class="header" href="#23-splitchunksplugin-代码分割">2.3 SplitChunksPlugin 代码分割</a></h3>
<p>SplitChunks 技术指的是利用 webpack 插件 SplitChunksPlugin 进行自动代码分割。在 webpack5 中，配置如下：</p>
<pre><code class="language-js">module.exports = {
  optimization: {
    // 代码分割方案：该值如果为{}，则走默认配置
    splitChunks: {
      // 其实只需要 chunks 这一个配置即可，其他地方全部不需要
      chunks: 'all', // 默认 async 只分割动态加载代码，其他值有 all、initial（只从入口chunks提取代码）。
      minSize: 30000, // 引入模块大小大于 30KB 才做代码分割
      minChunks: 1, // 至少引入了多少次才做分割
      maxAsyncRequests: 30, // 按需（异步）加载时的最大并行请求数。webpack5默认30,webpack4默认5
      maxInitialRequest: 3, // 入口文件最大并行请求数，webpack5默认30，webpack4默认3
      // 换粗组：可以继承或覆盖上面一些配置。
      cacheGroups: {
        // defaultVendors 可以抽取 node_modules目录下被使用到的模块
        defaultVendors: {
          // 默认为 false，指定打包后文件名是否有前缀
          test: /[\\/]node_modules[\\/]/, // 引入文件位于 node_modules 时打包方式
          priority: -10, // vendors 和 default 打包优先级
          reuseExistingChunk: true,
        },
        default: {
          // 默认打包配置，如果不符合 vendors 要求，如下打包
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true, // 当前模块之前已经被打包，是否直接引用之前被打包的模块
        },
      },
    },
  },
}
</code></pre>
<p>添加了上述配置后，会起到 2 个作用：</p>
<ul>
<li>将使用到的 <code>node_modules</code> 代码单独打包到一个 chunk，名称类似 <code>vendor.js</code></li>
<li>在多入口情况下，还会将多入口的较大公共文件单独打包为一个 chunk，减少重复引用。</li>
</ul>
<p>贴士：提取模块遇到冲突时，考虑的配置优先级从高到低是：minSize、maxSize、maxInitialRequest/maxInitialRequest。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="044-webpack-优化-其他打包配置"><a class="header" href="#044-webpack-优化-其他打包配置">04.4-Webpack 优化-其他打包配置</a></h1>
<h2 id="一-外部资源加载"><a class="header" href="#一-外部资源加载">一 外部资源加载</a></h2>
<h3 id="11-externals-加载外部-cdn-资源"><a class="header" href="#11-externals-加载外部-cdn-资源">1.1 externals 加载外部 CDN 资源</a></h3>
<p>一些依赖包文件打包文件过大，可以通过 webpack 的 externals 节点配置 CDN 资源解决，声明在 externals 中的第三方依赖包不会被打包：</p>
<p>常用方式：</p>
<pre><code class="language-js">// webpack 配置
module.exports = {
  externals: {
    jquery: 'jQuery',
  },
}
</code></pre>
<p>使用 chainWebpack 方式：</p>
<pre><code class="language-js">// key 为包名
module.exports = {
  chainWebpack: (config) =&gt; {
    config.when(process.env.NODE_ENV === 'production', (config) =&gt; {
      config.set('externals', {
        vue: 'Vue',
        'vue-router': 'VueRouter',
        lodash: '_',
        echarts: 'echarts',
      })
    })
  },
}
</code></pre>
<p>配置完 webpack 后，这些对应资源需要在 <code>public/index.html</code> 头部中配置 CDN 资源：</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.echarts.css&quot;&gt;&lt;/link&gt;
    &lt;script src=&quot;https://cdn.vue.com/2.6/vue.min.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
</code></pre>
<p>而且此时生产环境、开发环境由于已经配置了不同入口，就可以在生产环境的入口中取消 import 上述文件。</p>
<p>webpack 其实提供了自动打包 CDN 的方式，即：不再需要在 html 中手动引入，此时 webpack 配置如下：</p>
<pre><code class="language-js">// webpack 配置
module.exports = {
  externalsType: 'script',
  externals: {
    jquery: ['https://cdn.jquery.com', 'jQuery'],
  },
}
</code></pre>
<h3 id="12-dll-配置"><a class="header" href="#12-dll-配置">1.2 dll 配置</a></h3>
<p>贴士：DLL 技术目前已经不被推荐！！！！</p>
<p>代码分割默认配置下，会将 node_modules 文件夹单独打包为一个 chunk，实际开发中，该文件往往无比巨大，需要对一些库进行单独打包。</p>
<pre><code class="language-js">module.exports = {
  entry: {
    jquery: ['jquery'],
  },
  output: {
    filename: '[name],js',
    path: path.resolve(__dirname, 'dll'), // 打包到 dll 目录下
    library: '[name]', // 打包的库向外暴露的名称
  },
  plugins: [
    // 该插件用于帮助打包生成 manifest 文件，提供 jqueyr 映射关系，告知 webpack jquery 无需打包，位置在哪
    new webpack.DllPlugin({
      name: '[name]', // 映射库暴露的名称
      path: path.resolve(__dirname, 'dll/manifest.json'), // 输出的名称
    }),
  ],
}
</code></pre>
<h2 id="二-模块配置"><a class="header" href="#二-模块配置">二 模块配置</a></h2>
<h3 id="21-modulenoparse"><a class="header" href="#21-modulenoparse">2.1 module.noParse</a></h3>
<p>类似 jQuery、Lodash 我们不希望 webpack 去解析，则配置如下：</p>
<pre><code class="language-js">module.exports = {
  module: {
    noParse: /jquery|lodash/, //值支持字符串、正则、数组
  },
}
</code></pre>
<p>注意：</p>
<ul>
<li>noParse 的模块不应该依赖于其他模块，即内部不能包含类似 import、require 的语法</li>
<li>noParse 只是不解析，如果不做第三方库的处理，这些库仍然会被打包进 bundle。</li>
</ul>
<h3 id="22-resolvemodules"><a class="header" href="#22-resolvemodules">2.2 resolve.modules</a></h3>
<p>resolve.modules 用于配置 webpack 如何搜寻第三方放模块的路径，默认值是 <code>['node_modules']</code>。</p>
<pre><code class="language-js">module.exports = {
  resolve: {
    alias: {
      @: path.resolve(__dirname, 'src ') // 别名
    },
    extensions: ['.js', '.json', 'jsx'],  // 引入文件无需后缀名
    modules: ['node_modules'] // 告诉 webpack 解析模块是去该目录查找
  },
}
</code></pre>
<h3 id="23-第三方库打包问题"><a class="header" href="#23-第三方库打包问题">2.3 第三方库打包问题</a></h3>
<p>引入类似 jqueryui,bootstrap 这样的库，他们依赖于 jquery，打包配置方式如下：</p>
<pre><code class="language-js">const webpack = require('webpack')
//插件数组添加如下元素
new webpack.ProvidePlugin({
  $: 'jquery',
  jQuery: 'jquery',
})
</code></pre>
<p>此时 webpack 在 bootstrap 源码中偷偷加入<code>import &quot;jquery&quot;</code>，业务代码中就无需引入 jquery，当开发者使用 $,jQuery 时，webpack 会自动引入。</p>
<h2 id="三-构建缓存问题"><a class="header" href="#三-构建缓存问题">三 构建缓存问题</a></h2>
<p>构建缓存是指利用缓存，对 webpack 的构建速度进行优化。在 webpack5 之前，没有提供缓存功能，开发时需要利用 chache-loader 或者 dll 动态链接技术做缓存处理。webpack5 默认提供了缓存功能。</p>
<pre><code class="language-js">module.exports = {
  chache: {
    type: 'filesystem',
  },
}
</code></pre>
<p>上述配置开启了文件缓存，值也可以是 memory，表示将打包生成的资源存放在内存中。</p>
<h2 id="四-tree-shaking"><a class="header" href="#四-tree-shaking">四 tree shaking</a></h2>
<p>tree shaking 用于在 import 环境中去除无用的代码，如未引用的代码，开启办法：使用 ES6 模块，并开启生产环境。开发环境下配置如下：</p>
<pre><code class="language-js">optimization: {
  usedExports: true
}
</code></pre>
<p>注意：webpack5 默认就会进行 treeshaking，webpack4 在 package.json 中配置：<code>sideEffects:false</code>后所有代码都可以 tree shaking，此时 js 中引入的 css 模块会在在一些 webpack 版本中构建后被去除，这是危险的，此时需要配置为：<code>sideEffects:[&quot;*.css&quot;]</code></p>
<h2 id="五-多进程打包"><a class="header" href="#五-多进程打包">五 多进程打包</a></h2>
<p>babel-loader 的打包可以交给多进程处理，其处理方式依赖于 <code>thread-loader</code>：</p>
<pre><code class="language-js">{
  test:/\.js$/,
  use:[
    'thread-loader',
    {'loader': 'babel-loader', options:{} }
  ]
}
</code></pre>
<p>贴士：多进程启动会浪费较多时间，只有时间消耗较长的地方需要多进程，比如：babel-loader、eslint-loader。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-环境配置示例-格式化配置"><a class="header" href="#051-环境配置示例-格式化配置">05.1-环境配置示例-格式化配置</a></h1>
<h2 id="一-开发工具配置"><a class="header" href="#一-开发工具配置">一 开发工具配置</a></h2>
<h3 id="11-开发工具推荐"><a class="header" href="#11-开发工具推荐">1.1 开发工具推荐</a></h3>
<p>配置 vscode 自动格式化：项目根目录新建 .vscode/settings.json 文件，内容如下：</p>
<pre><code class="language-json">{
  &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,
  &quot;editor.formatOnSave&quot;: true,
  &quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll&quot;: true
  },
  &quot;markdownlint.config&quot;: {
    &quot;default&quot;: true,
    &quot;MD010&quot;: {
      &quot;code_blocks&quot;: false
    },
    &quot;MD030&quot;: false
  },
  &quot;[markdown]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,
    &quot;editor.wordWrap&quot;: &quot;on&quot;,
    &quot;editor.quickSuggestions&quot;: false,
    &quot;editor.tabSize&quot;: 4,
    &quot;editor.useTabStops&quot;: true
  },
  &quot;workbench.editor.enablePreview&quot;: false
}
</code></pre>
<p>贴士：vscode 在设置中搜索 formatOnType、formatOnSave，设置为允许。</p>
<p>代码风格插件推荐：<code>Atom One Dark Theme</code>，<code>Material Icon Theme</code>，安装完毕后在 vscode 设置内启用即可。</p>
<h3 id="12-文档工具推荐"><a class="header" href="#12-文档工具推荐">1.2 文档工具推荐</a></h3>
<p>统一文档工具：markdown，直接安装使用 vscode 自带 markdown 插件即可：</p>
<ul>
<li><code>Markdown All in One</code>：负责 Markdown 格式标准工具</li>
<li><code>Markdown Preview Enhanced</code>：负责 Markdown 文件可视化</li>
<li><code>Markdown TOC</code>：Markdown 文件内链接跳转</li>
<li><code>markdwonlint</code>：Markdown 格式化插件</li>
<li><code>pangu</code>：Markdown 自动添加英文、汉字空格</li>
</ul>
<h3 id="13-风格工具推荐"><a class="header" href="#13-风格工具推荐">1.3 风格工具推荐</a></h3>
<p>安装 vscode 代码格式化标准插件：</p>
<ul>
<li>Editorconfig：统一不同开发工具代码风格</li>
<li>Prettier：代码风格校验插件</li>
<li>Eslint：代码格式化校验插件</li>
<li>DotENV：负责 env 文件语法高亮</li>
</ul>
<p>如果您使用的是 IDEA 类开发工具，则已经默认集成了这些工具。</p>
<p>如果您的项目是 vue，则需要额外安装插件：Vetur，为了让 Vetur 支持 prettier，需要在 <code>./vscode/settings.json</code> 中加入：</p>
<p>如果您的项目是 vue，则需要加入：</p>
<pre><code class="language-json">{
  &quot;vetur.format.defaultFormatter.html&quot;: &quot;prettyhtml&quot;,
  &quot;vetur.format.defaultFormatter.css&quot;: &quot;prettier&quot;,
  &quot;vetur.format.defaultFormatter.postcss&quot;: &quot;prettier&quot;,
  &quot;vetur.format.defaultFormatter.scss&quot;: &quot;prettier&quot;,
  &quot;vetur.format.defaultFormatter.sass&quot;: &quot;sass-formatter&quot;,
  &quot;vetur.format.defaultFormatter.less&quot;: &quot;prettier&quot;,
  &quot;vetur.format.defaultFormatter.stylus&quot;: &quot;stylus-supremacy&quot;,
  &quot;vetur.format.defaultFormatter.js&quot;: &quot;prettier&quot;,
  &quot;vetur.format.defaultFormatter.ts&quot;: &quot;prettier&quot;
}
</code></pre>
<h2 id="二-代码格式化配置"><a class="header" href="#二-代码格式化配置">二 代码格式化配置</a></h2>
<h3 id="21-editorconfig-限制开发工具"><a class="header" href="#21-editorconfig-限制开发工具">2.1 Editorconfig 限制开发工具</a></h3>
<p>为了限制个别员工使用其他工具引起代码风格不同，这里引入 editorconfig，项目根目录创建 <code>.editorconfig</code> ，内容如下：</p>
<pre><code class="language-txt"># http://editorconfig.org

root=true

# 表示所有文件通用，[*.md] 表示仅适用于 md
[*]
charset = utf-8
indent_style = space
indent_size = 4
</code></pre>
<h3 id="22-prettier-限制代码风格"><a class="header" href="#22-prettier-限制代码风格">2.2 Prettier 限制代码风格</a></h3>
<p>Prettier 是目前最优秀的代码风格设定库。</p>
<p>在项目根目录创建 <code>.prettierrc</code>，内容如下：</p>
<pre><code class="language-json">{
  &quot;printWidth&quot;: 120,
  &quot;tabWidth&quot;: 4,
  &quot;useTabs&quot;: false,
  &quot;semi&quot;: false,
  &quot;singleQuote&quot;: true,
  &quot;ignorePath&quot;: &quot;.prettierignore&quot;,
  &quot;jsxSingleQuote&quot;: false,
  &quot;requireConfig&quot;: false,
  &quot;trailingComma&quot;: &quot;es5&quot;
}
</code></pre>
<p>在项目根目录下创建 <code>.prettierignore</code>，内容如下：</p>
<pre><code class="language-txt">/dist/*
/build/*
/public/*
</code></pre>
<p>此时 vscode 已经可以根据 prettier 配置进行自动格式化了，但是为了限制第三方成员 clone 项目后，其 vscode 没有配置格式化，提供格式化脚本让其强行格式化，需要在项目本地安装 prettier：</p>
<pre><code class="language-txt">npm i prettier -D
</code></pre>
<p>注意：一些脚手架如 vue-cli 在选择代码风格为 prettier 和 eslint 时已经自带了。</p>
<p>添加手动 lint 的脚本：</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;lint&quot;: &quot;prettier --write .&quot;
  }
}
</code></pre>
<h3 id="23-eslint-检查代码风格"><a class="header" href="#23-eslint-检查代码风格">2.3 Eslint 检查代码风格</a></h3>
<p>为了防止错误的代码风格被校验通过，还需要 Eslint 进行风格检查，进行错误提醒。同样的，vscode 经过前面的配置本身也具备 Eslint 功能，这里本地安装也是为了强制他人 clone 的项目使用格式化脚本也强行进行风格检查。</p>
<pre><code class="language-txt"># 如果是 create-react-app 创建的 react 项目，则需要安装
npm i -D eslint eslint-plugin-prettier eslint-config-prettier

# 如果是 vue-cli 创建的 vue 项目：命令行直接选择 eslint+prettier 即可，会默认安装上述插件

# 如果是 vite 创建的 vue 项目：
npm i -D eslint eslint-plugin-vue eslint-plugin-prettier
# 如果是 vite 创建的 vue ts 项目，还需要额外安装
npm i -D @typescript-eslint/eslint-plugin
</code></pre>
<p>贴士：eslint-plugin-prettier eslint-config-prettier 两个插件是为了让 eslint 兼容 prettier。</p>
<p>项目根目录创建 eslint 配置文件 <code>.eslintrc.js</code>。</p>
<pre><code class="language-js">// 该配置会覆盖之前的 extends，并兼容 prettier。

// create-react-app 的 .eslintrc.js 内容如下：
module.exports = {
  extends: 'react-app',
  plugins: ['prettier'],
  rules: {
    'prettier/prettier': 'error',
  },
}

// vue-cli 默认的 .eslintrc.js 内容如下：
module.exports = {
  extends: ['plugin:vue/vue3-essential', 'eslint:recommended', '@vue/prettier'],
  parserOptions: {
    parser: 'babel-eslint',
  },
}

// vite 创建的 vue 项目 .eslintrc.js 内容如下：
module.exports = {
  root: true,
  env: {
    browser: true,
    node: true,
    es2021: true,
  },
  parser: 'vue-eslint-parser',
  extends: [
    'eslint:recommended',
    'plugin:vue/vue3-recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
    'prettier',
  ],
  parserOptions: {
    ecmaVersion: 12,
    parser: '@typescript-eslint/parser',
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true,
    },
  },
  plugins: ['vue', '@typescript-eslint', 'prettier'],
  rules: {
    'no-var': 'error',
    allowEmptyCatch: 'off',
    'prettier/prettier': 'error',
    'prefer-const': 'error',
    '@typescript-eslint/no-unused-vars': 'warn',
    '@typescript-eslint/no-explicit-any': 'off',
    '@typescript-eslint/ban-ts-comment': 'off',
    '@typescript-eslint/no-empty-interface': 'off',
    'no-empty': ['error', { allowEmptyCatch: true }],
    'vue/no-unused-vars': [
      'warn',
      {
        ignorePattern: '^_',
      },
    ],
    'vue/multi-word-component-names': 'off',
    'vue/no-parsing-error': [
      'error',
      {
        'control-character-reference': false,
      },
    ],
    'vue/no-v-html': 'off',
  },
  globals: {
    defineProps: 'readonly',
    defineEmits: 'readonly',
    defineExpose: 'readonly',
    withDefaults: 'readonly',
  },
}
</code></pre>
<p>项目根目录创建 eslint 配置文件 <code>.eslintignore</code>，内容如下：</p>
<pre><code class="language-txt">build/*.js
src/assets
public
dist
</code></pre>
<p>可以更换格式化脚本为：</p>
<pre><code class="language-json">{
  &quot;lint&quot;: &quot;eslint ./src&quot;,
  &quot;lint:fix&quot;: &quot;eslint ./src --fix&quot;
}

// 如果有错误提示，可以替换为：
{
  &quot;lint&quot;: &quot;eslint \&quot;src/**/*\&quot;&quot;,
  &quot;lint:fix&quot;: &quot;eslint \&quot;src/**/*\&quot; --fix&quot;,
}
</code></pre>
<h3 id="24-测试配置正确性"><a class="header" href="#24-测试配置正确性">2.4 测试配置正确性</a></h3>
<p>在项目内随便创建或者找一个 ts、js 文件，书写如下代码：</p>
<pre><code class="language-txt">let a = &quot;zs&quot;
</code></pre>
<p>我们会发现，按保存后，双引号自动替换为单引号，且 a 处出现 eslint 语法错误提示，此时即配置成功。</p>
<h2 id="三-git-提交控制"><a class="header" href="#三-git-提交控制">三 Git 提交控制</a></h2>
<h3 id="30-安装-husky"><a class="header" href="#30-安装-husky">3.0 安装 husky</a></h3>
<p>执行 commit 之前拦截，检查代码风格，使用工具 husky。该工具提供了三个 git 提交的阶段：</p>
<ul>
<li>pre-commit</li>
<li>commit-msg</li>
<li>pre-push</li>
</ul>
<p>使用下列命令自动配置 husky，包括：安装 husky，添加 .husky 文件夹，添加 prepare 脚本等步骤，命令如下：</p>
<pre><code class="language-txt">npx husky-init &amp;&amp; npm install
</code></pre>
<h3 id="31-配置提交前强制格式化"><a class="header" href="#31-配置提交前强制格式化">3.1 配置提交前强制格式化</a></h3>
<p>设置 git 提交前强制 lint，在.husky/pre-commit 中添加如下内容：</p>
<pre><code class="language-bash">#!/bin/sh
. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;

npm run lint
</code></pre>
<p>此时我们每次提交代码，都会执行 <code>npm run lint</code>。</p>
<h3 id="32-配置提交前检查-commit-文本"><a class="header" href="#32-配置提交前检查-commit-文本">3.2 配置提交前检查 commit 文本</a></h3>
<p>首先我们放弃直接 <code>git commit</code> 而是使用 npm 脚本进行提交，添加 npm 脚本：</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;commit&quot;: &quot;git add . &amp;&amp; cz&quot;
    /* 其他配置 */
  }
}
</code></pre>
<p>现在配置实现该命令：</p>
<pre><code class="language-txt"># 安装 规范 commit 工具
npm i commitizen -D

# 安装 changelog 工具，并初始化，且会在 package.json 中配置 config 字段，以及添加 prepare 脚本
npx commitizen init cz-conventional-changelog -D --save-exact

# 安装代码提交信息验证工具
npm i @commitlint/config-conventional @commitlint/cli -D
</code></pre>
<p>根目录创建 commitlint.config.js 配置：</p>
<pre><code class="language-js">module.exports = {
  extends: ['@commitlint/config-conventional'],
}
</code></pre>
<p>使用 husky 生成 commit-msg 文件，验证提交信息：</p>
<pre><code class="language-txt">npx husky add .husky/commit-msg &quot;npx --no-install commitlint --edit $1&quot;
</code></pre>
<p>此时可以使用 npm 脚本 <code>npm run commit</code> 提交代码了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="052-环境配置示例-env-配置"><a class="header" href="#052-环境配置示例-env-配置">05.2-环境配置示例-env 配置</a></h1>
<h2 id="一-环境区分方案"><a class="header" href="#一-环境区分方案">一 环境区分方案</a></h2>
<h3 id="10-常见环境区分方案"><a class="header" href="#10-常见环境区分方案">1.0 常见环境区分方案</a></h3>
<p>通常情况下，我们需要针对不同环境（开发环境、集成环境、生产环境等），进行相应策略的打包（比如是否替换接口地址，代码是否压缩等）。</p>
<p>我们有多种做法：</p>
<ul>
<li>新建 config.js 文件：在该文件内配置不同的域名、端口等。但是每次切换环境都要修改 config.js 中环境判断</li>
<li>在 package.json 的启动脚本中添加环境变量，适合少量配置</li>
<li>使用 .env 文件：适合书写大量配置</li>
</ul>
<h3 id="11-configjs-配置"><a class="header" href="#11-configjs-配置">1.1 config.js 配置</a></h3>
<p>config.js 方案中，每次启动环境，都要注意 config.js 中的核心环境设置是否对应当前环境，不适合书写是否为测试环境等配置，适合书写业务中需要的配置。</p>
<h3 id="12-packagejson-启动脚本"><a class="header" href="#12-packagejson-启动脚本">1.2 package.json 启动脚本</a></h3>
<p>Node 提供了一个专门的 API <code>process.env</code> 来获取环境变量配置。</p>
<p>通常的做法是新建一个环境变量 <code>NODE_ENV</code>，设置其值为 <code>development</code> 代表开发环境，设置其值为 <code>production</code> 代表生产环境，当我们在开发中需要该环境变量便可通过 <code>process.env.NODE_ENV</code> 获取。</p>
<p>可以直接在 shell 环境内设置该环境，但是通常我们不这样做，可以在 Node 项目的 package.json 中直接设置，如下所示：</p>
<pre><code class="language-json">// Win 系统
{
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;set NODE_ENV=development &amp;&amp; webpack-dev-server --open --hot&quot;,
    &quot;build&quot;: &quot;set NODE_ENV=production &amp;&amp; --progress --hide-modules&quot;
  }
}

// Mac 系统
{
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;export NODE_ENV=development &amp;&amp; webpack-dev-server --open --hot&quot;,
    &quot;build&quot;: &quot;export NODE_ENV=production &amp;&amp; --progress --hide-modules&quot;
  }
}
</code></pre>
<p>为了解决操作系统的差异，可以使用 cross-env 包：</p>
<pre><code class="language-json">// 安装：npm i -D cross-env
{
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --open --hot&quot;,
    &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --mode=production  --progress --hide-modules&quot;
  }
}
</code></pre>
<h3 id="13-env-文件配置"><a class="header" href="#13-env-文件配置">1.3 env 文件配置</a></h3>
<p>.env 文件中可以书写大量的配置，一般可以使用三个文件分别代表不同环境的配置：</p>
<ul>
<li>.env：全局默认配置文件，不论什么环境都会加载合并该文件内容</li>
<li>.env.development：开发环境下的配置文件</li>
<li>.env.production：生产环境下的配置文件</li>
</ul>
<p>在使用启动脚本执行时，会依据脚本中的 <code>mode</code> 变量自动加载哪个配置，比如 <code>npm run dev --mode=development</code> 启动本地开发环境，会自动加载 <code>.env.development</code>内的配置，代码中通过 <code>process.env</code> 获取。</p>
<p>.env 配置示例：</p>
<pre><code class="language-txt">VUE_APP_URL='localhost:3000'
</code></pre>
<p>注意：如果 env 内配置了密码等信息，无比在 gitignore 文件中忽略掉。</p>
<p>不同的 env 文件具备不同的优先级，如下所示：</p>
<pre><code class="language-txt">.env：默认。
.env.local：本地覆盖。除 test 之外的所有环境都加载此文件。
.env.development, .env.test, .env.production：设置特定环境。
.env.development.local, .env.test.local, .env.production.local：设置特定环境的本地覆盖。

一般其优先级为：
npm start: .env.development.local, .env.development, .env.local, .env
npm run build: .env.production.local, .env.production, .env.local, .env
npm test: .env.test.local, .env.test, .env (注意没有 .env.local )
</code></pre>
<h2 id="二-常见-env-环境配置"><a class="header" href="#二-常见-env-环境配置">二 常见 env 环境配置</a></h2>
<h3 id="21-env-基础配置"><a class="header" href="#21-env-基础配置">2.1 env 基础配置</a></h3>
<p>项目根目录新建三个配置文件，以应对启动脚本：</p>
<ul>
<li><code>.env</code>：书写最基础、通用的配置</li>
<li><code>.env.developement</code>：书写开发环境配置</li>
<li><code>.env.production</code>：书写生产环境配置</li>
</ul>
<p>注意：现有启动脚本都不支持直接指定某个 env，如果要使用该文件，需要额外配置。</p>
<p>react 配置方式如下：</p>
<pre><code class="language-json">// npm install -D dotenv-cli  用于为命令传递参数
{
  &quot;scripts&quot;: {
    &quot;local&quot;: &quot;dotenv -e .env react-scripts start&quot;,
    &quot;dev&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;
  }
}
</code></pre>
<h3 id="22-打包文件测试"><a class="header" href="#22-打包文件测试">2.2 打包文件测试</a></h3>
<p>我们在打包文件后，希望直接测试，而不是放在生产环境测试，而且我们想在本地先测试下打包文件是否正确，可以这样做：</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;local&quot;: &quot;dotenv -e .env react-scripts start&quot;,
    &quot;dev&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;,
    &quot;lint&quot;: &quot;eslint ./src&quot;,
    &quot;lint:fix&quot;: &quot;eslint ./src --fix&quot;
  }
}
</code></pre>
<h2 id="三-脚手架项目传入启动参数"><a class="header" href="#三-脚手架项目传入启动参数">三 脚手架项目传入启动参数</a></h2>
<p>使用 vue-cli、create-react-app 等脚手架创建的项目，其启动脚本已经传递好了 mode 模式，无需配置，也会自动加载对应的 env 文件（所以 NODE_ENV 是无法配置的）！且必须使用 VUE_APP/REACT_APP 这样开头进行配置。如果此时我们仍然想传递一些启动参数，比如添加一个 DATA_FROM 参数，可以这样设计启动脚本：</p>
<pre><code class="language-json">// npm i cross-env -D
{
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;node_modules/.bin/cross-env REACT_APP_DATA_FROM=local react-scripts start&quot;,
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;
  }
}
</code></pre>
<p>当然笔者推荐使用 dotenv 包，可以自定义环境，使用对应的 env 文件，比如现在我们想创建一个 mine 环境，这个环境下使用 mock 数据，那么配置启动方式如下：</p>
<pre><code class="language-json">// npm install -D dotenv-cli
{
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;dotenv -e .env.mine react-scripts start&quot;,
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;
  }
}
</code></pre>
<h2 id="四-mock-数据"><a class="header" href="#四-mock-数据">四 mock 数据</a></h2>
<p>mock 数据采用技术为：<code>json-server</code>：</p>
<pre><code class="language-json">// npm i -D json-server
// 创建路由文件  mock/routes.json
{
    &quot;/api/*&quot;: &quot;/$1&quot;,
    &quot;/:demo1/:id/show&quot;: &quot;/:demo1/:id&quot;,
    &quot;/demo2/:category&quot;: &quot;/demo2?category=:category&quot;,
    &quot;/demo3\\?id=:id&quot;: &quot;/demo3/:id&quot;
}
// 创建模拟数据文件 mock/db.json
{
    &quot;demo&quot;: [{ &quot;uid&quot;: 1 }]
}
</code></pre>
<p>创建启动本地数据服务的脚本：</p>
<pre><code class="language-json">{
  &quot;local&quot;: &quot;npm run json-server &amp; dotenv -e .env react-scripts start&quot;,
  &quot;json-server&quot;: &quot;json-server --port 3015 --watch mock/db.json --routes mock/routes.json&quot;
}
</code></pre>
<h2 id="五-反向代理"><a class="header" href="#五-反向代理">五 反向代理</a></h2>
<h3 id="51-create-react-app-配置反向代理方式"><a class="header" href="#51-create-react-app-配置反向代理方式">5.1 create-react-app 配置反向代理方式</a></h3>
<p>在 src 目录下创建 setupProxy.js 文件：</p>
<pre><code class="language-js">// npm i -D http-proxy-middleware

const { createProxyMiddleware } = require('http-proxy-middleware')

const REACT_APP_URL = process.env.REACT_APP_URL

module.exports = function (app) {
  app.use(
    '/api',
    createProxyMiddleware({
      target: REACT_APP_URL,
      changeOrigin: true,
    })
  )
}
</code></pre>
<p>注意：此文件会自动被 create-react-app 加载。</p>
<h2 id="六-ts-配置"><a class="header" href="#六-ts-配置">六 ts 配置</a></h2>
<p>在 tsconfig.json 中配置：</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;src&quot;, // 配置后，导入模块无需 ../ 写法
    &quot;experimentalDecorators&quot;: true // 允许装饰器语法
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-typescript-简介"><a class="header" href="#011-typescript-简介">01.1-TypeScript 简介</a></h1>
<h2 id="一-javascript-弱类型"><a class="header" href="#一-javascript-弱类型">一 JavaScript 弱类型</a></h2>
<p>JavaScript 是一种弱类型的动态语言。</p>
<p>弱类型与强类型：</p>
<pre><code class="language-txt">弱类型：变量的数据类型不固定，可以为其赋值任何类型的值。
强类型：变量的类型是严格固定的，给变量赋值其他类型的数据会引发错误。
</code></pre>
<p>动态类型与静态类型：语言的动静特性针对的是代码类型的检查方式。</p>
<pre><code class="language-txt">动态类型：代码运行时进行类型检查。
静态类型：代码编译时进行类型检查，所以静态语言一般都需要先编译、再运行！
</code></pre>
<p>动态类型很容易造成一个现象，即代码错误不易被捕捉到：</p>
<pre><code class="language-js">// 该函数参数数据类型并未限制，可以任意传递 对象、字符串、undefined，
// 产生的结果也会千奇百怪
function add(num) {
  return num + 1
}
</code></pre>
<p>在实际企业开发中，我们往往需要对参数的类型进行判断、限制，否则当数据类型不正确时，就会在运行阶段突然触发：类型错误等提示，这在 JS 语言中非常痛苦！</p>
<p>静态类型的语言在函数定义时会要求 num 必须是整数或者小数等，在书写代码阶段（其实就是编译：开发工具帮助提前编译），一旦出现非法参数，直接报错，无法通过编译，可以大大降低低级错误，而且动态类型语言在开发工具中也不能获得很好的代码提示。</p>
<pre><code class="language-c">// 这是C语言中的一个函数
int add(int num) {
    return num + 1
}
</code></pre>
<p>所以弱类型的语言往往不适合大型项目的开发与协作，有这样一句经典的话来形容：动态一时爽，重构火葬场。</p>
<p>为了解决该问题，JavaScript 涌现了许多类型检查机制，常见的有：</p>
<ul>
<li><strong>Flow</strong>：Facebook 推出的 JavaScript 静态类型检查工具，已渐渐式微</li>
<li><strong>TypeScrip</strong>t：微软推出的编程语言，是 JavaScript 的超集，当前热度极高。</li>
</ul>
<h2 id="二-typescript-初识"><a class="header" href="#二-typescript-初识">二 TypeScript 初识</a></h2>
<h3 id="21-typescript-简介与安装"><a class="header" href="#21-typescript-简介与安装">2.1 TypeScript 简介与安装</a></h3>
<p>TypeScript 是 2012 年由微软发布的编程语言，是一门非常年轻的语言，为 JavaScript 的超集，即：TS 会遵循 ECMAScript 的语法规范，但是额外扩展了原生 JS 语法，适合开发大型企业项目。</p>
<p>环境配置：</p>
<pre><code class="language-txt"># 安装 typescript
npm i -g typescript

# 测试环境：tsc 是在安装 typescript 时默认安装的 TS 编译器
tsc --version
</code></pre>
<h3 id="22-helloworld"><a class="header" href="#22-helloworld">2.2 HelloWorld</a></h3>
<p>helloworld 案例：</p>
<pre><code class="language-ts">//新建一个 hello.ts
export class Hello {
  run() {
    console.log('hello world!')
  }
}
new Hello().run()
</code></pre>
<p>TS 代码是无法直接运行的，因为目前还没有成熟的 TS 运行时（你知道 Deno 吗？），TS 的代码一般要先通过 <code>tsc</code>工具编译为 JS 代码才能真正执行。</p>
<p>上述代码执行步骤：</p>
<pre><code class="language-txt"># 编译 ts 文件
tsc hello.ts

# 运行生成的 js 文件
node hello.js
</code></pre>
<h3 id="23-体验-typescript-的语法联想演示"><a class="header" href="#23-体验-typescript-的语法联想演示">2.3 体验 TypeScript 的语法联想演示</a></h3>
<p>ts 代码如下：</p>
<pre><code class="language-ts">interface Point {
  x: number
  y: number
}

function fn(p: Point): void {
  console.log(p.x + p.y) // 在输入 p. 时候会轻松联想出 x y
}

fn({ x: 1, y: 2 })
</code></pre>
<p>而到了 JS 中：</p>
<pre><code class="language-js">let Point = {
  x: number,
  y: number,
}

function fn(p) {
  console.log(p.x + p.y) // 这里的联想出很多不必要的东西，甚至不会联想！
}

fn({ x: 1, y: 2 })
</code></pre>
<h2 id="三-理解-typescript-的类型检查"><a class="header" href="#三-理解-typescript-的类型检查">三 理解 TypeScript 的类型检查</a></h2>
<h3 id="31-编译器"><a class="header" href="#31-编译器">3.1 编译器</a></h3>
<p>编译器可以将代码文本转换成抽象语法树（abstract syntax tree，即 AST），AST 的本质是去除了空白、注释、缩进等制表符后的数据结构，AST 最终会被编译器转换为字节码（bytecode）底层程序，交给计算机执行。那么大多数编程语言整体执行过程，以 JS 为例为：</p>
<ul>
<li>1、将 JavaScript 程序解析为 JavaScript AST</li>
<li>2、把 JavaScript AST 编译为字节码</li>
<li>3、运行时计算字节码</li>
</ul>
<p>TypeScript 其他编程语言不同的是，其不直接生成字节码，而是编译成了 JavaScript 代码，接着再在浏览器或者 Node 等运行时中运行 JS 代码！TS 对代码安全性的保证就在 TS 编译器生成 AST 后，真正运行代码之前，会对代码做类型检查。所以，TS 编译器的解析步骤为：</p>
<ul>
<li>1、将 TypeScript 程序解析为 TypeScript AST</li>
<li>2、类型检查器检查 TypeScript AST</li>
<li>3、把 TypeScript AST 编译为 JavaScript 源码</li>
<li>4、把 JavaScript AST 编译为字节码</li>
<li>5、运行时计算字节码</li>
</ul>
<p>上述步骤中，1-3 步为 TSC 编译器执行，4-5 步为浏览器/Node 执行。这意味着程序中的类型类型只在类型检查这一步起到作用，对程序输出没有任何影响，这是 TS 与传统编译型语言最大的不同，也是其巧妙之处。（ Node 之父创建的 Deno 能直接运行 TS 是另外一个故事了）</p>
<h3 id="32-类型系统设计"><a class="header" href="#32-类型系统设计">3.2 类型系统设计</a></h3>
<p>在 TS 编译代码运行步骤中的第 2 步，使用的类型检查器其实是一套程序分配类型的规则。一般有两种类型系统：</p>
<ul>
<li>显式设置类型（type annotation，类型注解）：如 Java 需要显式设置几乎所有类型！</li>
<li>自动推导类型（type interface， 类型推断）：如 JS、Python 等在运行时推导类型，Haskell 在编译时推导检查类型</li>
</ul>
<p>这两种方式都各有利弊，TS 都支持了，这样在开发者这里就可以依据需求设计类型。而且 TS 是渐进式类型语言，在编译前不需要知道全部类型，即便是没有类型的程序，TS 也能推导出一部分类型，捕获部分错误。</p>
<p>示例：</p>
<pre><code class="language-ts">// 类型注解
const count: number
// 声明时也可以直接赋值
let age: number = 30

// 类型推断：声明变量之后，再使用时，鼠标移入 num 查看，会显示为 number 类型
let num = 123
</code></pre>
<p>贴士：在实际开发中，如果一个变量拥有了固定的值，推荐让 TS 自动推导，无需手动设置其变量类型。</p>
<p>变量的类型乍一看有点鸡肋，其作用其实很大程度上体现在函数中，比如如下函数，如果参数没有类型，函数内部的运算就会有隐藏问题，如 undefined 等，且其在一连串的函数调用时会引起连锁错误。一般情况下，我们需要对函数的参数进行类型注解，返回值则可以直接推断出来：</p>
<pre><code class="language-ts">function total(num1: number, num2: number) {
  return num1 + num2
}

// res 的值类型可以推断出来
let res = total(1, 2)
</code></pre>
<p>不过要注意 typescript 对类型的严格限定：</p>
<pre><code class="language-ts">let num1: number
console.log(num1) //声明没有赋值报错

let num2: undefined
console.log(num2) //undefined 类型直接输出不会报错

let num3: number | undefined
console.log(num3) //不会报错

let num: null
num = null //正确
num = 123 //报错，定义一个变量为 null 时，变量的值只能是 null
</code></pre>
<p>在隐式转换方面，TS 能发现无效操作，并在<strong>运行代码前就会及时报错</strong>，如：</p>
<pre><code class="language-txt">// 报错
const a = 3 + [1]

// 正确输出31，因为意图清晰，可以推导
(3).toStiring +[1].toString()
</code></pre>
<p>而 JS 在运行上述代码则会导致难以追踪的错误！</p>
<h2 id="四-ts-的配置"><a class="header" href="#四-ts-的配置">四 TS 的配置</a></h2>
<h3 id="41-配置文件-tsconfigjson"><a class="header" href="#41-配置文件-tsconfigjson">4.1 配置文件 tsconfig.json</a></h3>
<p>使用 TS 开发的项目，其根目录都需要 ts 的配置文件：<code>tsconfig.json</code>。使用如下命令即可创建：</p>
<pre><code class="language-txt">tsc --init
</code></pre>
<p>常见配置有：</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;lib&quot;: [&quot;es2018&quot;, &quot;dom&quot;],  /* tsc假定运行环境中包含哪些API */
    &quot;incremental&quot;: true /* 增量编译 */,
    &quot;allowJs&quot;: true /* 支持 JS 编译 */,
    &quot;outDir&quot;: &quot;./dist&quot; /* 输出目录 */,
    &quot;rootDir&quot;: &quot;./src&quot;, /* 源码目录 */
     &quot;target&quot;: &quot;es2015&quot;,  /* tsc编译为哪个版本 */
  },
  &quot;include&quot;: {  /* tsc 在哪个文件夹寻找TS文件 */
    &quot;src&quot;
  }
}
</code></pre>
<p>在上述配置文件支持下，项目中的 TS 文件都会被统一编译到 <code>./dist</code>目录下。</p>
<p>贴士：运行 <code>tsc 具体某一文件名</code>是不会受 ts 配置文件控制的，而是在根目录中直接运行 <code>tsc</code> 才会受到配置文件控制。</p>
<p>package.json 中配置运行脚本：</p>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;compile&quot;: &quot;tsc -w&quot;,
  &quot;build&quot;: &quot;nodemon node ./dist/main.js&quot;,
  &quot;start&quot;: &quot;concurrently npm:compile &amp; npm:build&quot;
}
</code></pre>
<p>nodemon 是自动重启的 node 包，concurrently 是并行执行程序的包，需要开发者自行安装。</p>
<h3 id="42-ts-node"><a class="header" href="#42-ts-node">4.2 ts-node</a></h3>
<p><code>ts-node</code> 模块可以帮助用户直接运行 ts：</p>
<pre><code class="language-txt"># 安装
npm i -g ts-node

# 运行
ts-node hello.ts
</code></pre>
<h3 id="43-使用-webpack-处理-typescript"><a class="header" href="#43-使用-webpack-处理-typescript">4.3 使用 webpack 处理 typescript</a></h3>
<p>如果项目中用到 webpack，则推荐使用官方的 loader：</p>
<pre><code class="language-txt">npm i -D ts-loader
</code></pre>
<p>tsconfig.json 配置：</p>
<pre><code class="language-js">{
    &quot;compilerOptions&quot;: {
        &quot;module&quot;: &quot;commonjs&quot;,
        &quot;target&quot;: &quot;es5&quot;,
        &quot;allowJs&quot;: true
    },
    &quot;include&quot;: [
        &quot;./src/*&quot;
    ],
    &quot;exclude&quot;: [
        &quot;./node_module&quot;
    ]
}

</code></pre>
<p>webpack 配置：</p>
<pre><code class="language-js">{
  test: /\.tsx?$/,
  use: {
    loader: 'ts-loader'
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-typescript-数据类型"><a class="header" href="#021-typescript-数据类型">02.1-TypeScript 数据类型</a></h1>
<h2 id="一-typescript-支持的数据类型"><a class="header" href="#一-typescript-支持的数据类型">一 TypeScript 支持的数据类型</a></h2>
<p>TypeScript 沿用了 ECMAScript 标准，类型有：</p>
<p>基础类型：number、boolean、string、undefined、null、symbol
引用类型：object（包括 function、array）</p>
<p>此外 TS 还额外支持一些自己独有的类型：</p>
<ul>
<li>tuple：元组。</li>
<li>enum：枚举。</li>
<li>any/unknown：any 表示任意类型，支持所有类型；unknown 表示未知类型，可以理解为一种类型安全的 any。</li>
<li>void/never：表示函数没有返回值，void 可以返回 undefined 等值，never 用于函数抛出异常或者进入了无限循环永远没有返回值</li>
</ul>
<p>如图所示：</p>
<p><img src="08-TypeScript/../images/typescript/01.svg" alt="ts数据类型" /></p>
<p>贴士：bigint 是 JavaScript 新引入的类型，能表示的数很大，而且在处理较大整数时，不会丢失精度，声明如：</p>
<pre><code class="language-js">let a = 1234n //bigint
let b = 100 + a

let c = 88.5n // Error：必须是整数

// 在TS中使用bigint类型
let d:bigint = 100n
</code></pre>
<h2 id="二-typescript-常见的独有数据类型"><a class="header" href="#二-typescript-常见的独有数据类型">二 TypeScript 常见的独有数据类型</a></h2>
<h3 id="21-any"><a class="header" href="#21-any">2.1 any</a></h3>
<p>any 是一切类型的祖先，如果无法确认数据的类型在，则默认为 any，是兜底的行为，需要尽量避免使用。因为 any 会让该变量的类型检查器无法发挥作用。</p>
<p>贴士：any 的滥用导致的编译器无法报错示例：</p>
<pre><code class="language-ts">let a: any = 3
let b: any = ['err']

// 该语句不会报错了，因为是开发者主动告知了TS自己的行为是正常的
let c = a + b
</code></pre>
<p>如果想让 TS 避免上述错误，可以在 tsconfig 中启用 <code>noImplicitAny</code>，该属性隶属于 <code>strict</code>，如果启用了严格模式，则无需启用该属性。</p>
<p>在前端开发中通过 getElementById() 获取到的元素是个 object 类型，而 ts 没有该类型，直接赋值就会报错，可以使用 any 类型。</p>
<pre><code class="language-ts">let num: any = 123
console.log(typeof num)
num = false
console.log(typeof num)
num = 'str'
console.log(typeof num)
</code></pre>
<p>注意：声明但未赋值的变量也是 any，如下所示：</p>
<pre><code class="language-ts">let age // any 类型
age = 30 // 此时仍然是 any
</code></pre>
<h3 id="22-数组-array-与-元组-tuple"><a class="header" href="#22-数组-array-与-元组-tuple">2.2 数组 array 与 元组 tuple</a></h3>
<p>在 typescript 中可以直接使用 es5 的定义语法声明数组：</p>
<pre><code class="language-ts">let arr1 = [1, 2, 'str'] //ES5 原生数组
</code></pre>
<p>一般情况下，数组应该保持元素类型相同，TS 也支持对数组类元素类型进行限定，一般在 TS 中使用数组采用下列方式：</p>
<pre><code class="language-ts">let arr2: number[] = [1, 2, 3] //数组元素只能是数字
let arr3: Array&lt;number&gt; = [1, 2, 3] //数组元素只能是数字
</code></pre>
<p>TS 由于是 JS 的超集，所以也支持在数组中存储不同的数据类型，这种数据类型在大多编程语言中都称呼为元组（Tuple）。TS 中的元组类型表示一个<strong>已知元素数量和类型</strong>的数组，各元素的类型不必相同：</p>
<pre><code class="language-ts">let tuple1: [number, string] = [1, 'aaa']

//报错 第二个元素应该是字符串且长度不对
let tuple2: [number, string] = [1, 2, 'aaa']
</code></pre>
<p>贴士：相较于数组，元组的性能更高，声明出来的元组推导的类型会是数组。</p>
<p>TS 也支持创建只读数组，只读数组无法执行 push、slice 等操作：</p>
<pre><code class="language-ts">let arr1: readonly number[] = [1, 2, 3]
let arr2: ReadonlyArray&lt;string&gt; = ['a', 'b', 'c']
</code></pre>
<h3 id="23-枚举-enum"><a class="header" href="#23-枚举-enum">2.3 枚举 enum</a></h3>
<p>枚举用于列举类型中包含的各个值，是一种无序的数据结构，把键映射到值上，即可以理解为编译时键固定的对象，访问键时，TS 将检查指定的键是否存在。</p>
<p>枚举的值可以使用点语法或者方括号访问，示例：</p>
<pre><code class="language-ts">enum Flag {
  success = '成功',
  error = '失败',
}

let f: Flag = Flag.success
console.log(f) //成功

let d: Flag = Flag['success']
console.log(d) //成功
</code></pre>
<p>如果枚举的内部成员没有赋值，它的值就是下标：</p>
<pre><code class="language-ts">enum Color {
  blue,
  red,
  green = 3,
  '红色',
}
let a: Color = Color.blue
let b: Color = Color.red
let c: Color = Color.green
let d: Color = Color.红色
console.log(a) //输出 0
console.log(b) //输出 1
console.log(c) //输出 3
console.log(d) //输出 4
</code></pre>
<h3 id="24-unknown"><a class="header" href="#24-unknown">2.4 unknown</a></h3>
<p>unknown 与 any 类似也表示任意值，但是 TS 会要求 unknow 的数据进行类型检查：</p>
<pre><code class="language-ts">let data: unknown = [1, 2, 3]

// 必须判明类型后才能联想length属性
for (let i = 0; i &lt; (data as Array&lt;Number&gt;).length; i++) {}
</code></pre>
<p>unknown 类型支持比较操作，如 <code>===</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code> 等，可以否定 <code>!</code>，也支持使用 <code>typeof</code>、<code>instanceof</code> 进行类型判定，如下所示：</p>
<pre><code class="language-ts">let a: unknown = 30 // unknow

// 支持比较运算符
let b = a === 123 // boolean

// 不支持 + 类型运算符
// let c = a + 10  // Error: Object is of type 'unknown'

if (typeof a === 'number') {
  let d = a + 10
}
</code></pre>
<p>所以，当无法预知一个数据的类型时，才会考虑 unknow。TS 不会把任何值推导为 unknown 类型，必须显式声明。</p>
<p>注意：与 any 相关的数据都会被污染为 any 类型，而关键字 unknown 不会，如下所示：</p>
<pre><code class="language-ts">// any 类型的 age 将 count 沾染为了 any
let age
age = 30
let count = age + 1 // count 也是 any

// unknown 只影响自己，不会污染其他人
let num: unknown
num = 30 // 此时仍然是 unknown
let result = num + 1 // 这里报错：运算符“+”不能应用于类型“unknown”和“1”
</code></pre>
<p>综上可以看出，unknown 类型不能直接使用，其本质是<strong>类型安全的 any</strong>，需要先进行类型判断、类型断言才能使用：</p>
<pre><code class="language-js">let num: unknown
num = 30 // 此时仍然是 unknown

// 类型判断
if (typeof num === 'number') {
    let result = num + 1 // 这里报错
}

// 类型断言：直接告知编译器 num 类型是 number
let result1 :number = num as number + 1 // 断言方式一
let result2 :number = &lt;number&gt;num + 1   // 断言方式二
</code></pre>
<h3 id="25-void-类型与-never-类型"><a class="header" href="#25-void-类型与-never-类型">2.5 void 类型与 never 类型</a></h3>
<p>在 JS 中 undefined 和 null 是比较特殊的类型，用于数据的缺失，在语义上有细微差别，如 undefined 表示未定义，null 表示没有值（例如在计算过程中出错了）。同时，undefined 类型只有 undefined 一个值，null 类型只有 null 一个值。</p>
<p>TS 为了表示数据缺失，又额外定义了 void、never 类型用来表示函数没有返回值：</p>
<ul>
<li>void 声明的函数中仍然可以返回 undefined 等数据</li>
<li>never 则表示该函数绝对不会有返回值</li>
</ul>
<pre><code class="language-ts">// 一个返回null的函数
const fn1 = (num: number) =&gt; {
  if (num &lt; 10) {
    return num
  }
  return null
}

// 一个返回void的函数: void 可以不写
const fn2 = (): void =&gt; {
  let a = 2 + 2
  console.log(a)
}

// 一个返回never的函数
const fn3 = () =&gt; {
  throw new Error('错误')
}
</code></pre>
<p>如果说 unknown 是每个类型的父类型，那么 never 类型是任何类型的子类型，可以赋值给任何类型，然而除了 never 本身之外，没有类型可以赋值给 never 类型（包括 any）。所以当变量被永不为真的类型保护所约束时使用时，该变量也可以是 never 类型。</p>
<h3 id="26-boolean-string-number-symbbol"><a class="header" href="#26-boolean-string-number-symbbol">2.6 boolean string number symbbol</a></h3>
<p>boolean string number 这些类型在 TS 用法与 JS 一致，但是这里推荐声明该类型数据时让 TS 自动推导：</p>
<pre><code class="language-ts">let b = '666' //ts推导为字符串
</code></pre>
<p>symbbol 类型也可以被推导，也可以显式声明 unique symbol：</p>
<pre><code class="language-ts">let a: unique symbol = Symbol('hello')
let b: unique symbol = Symbol('hello')
console.log(a === b) // false
</code></pre>
<h2 id="三-ts-中的对象类型"><a class="header" href="#三-ts-中的对象类型">三 TS 中的对象类型</a></h2>
<h3 id="31-ts-对象类型的定义"><a class="header" href="#31-ts-对象类型的定义">3.1 TS 对象类型的定义</a></h3>
<p>在 TS 中我们无法通过对象类型，知道一个对象是通过字面量 <code>{}</code> 创建还是复杂对象的 <code>new</code> 创建的，这是 JS 的设计思路，采用了结构化类型，TS 直接沿用了这种设计，没有采用名义化类型。</p>
<p>贴士：结构化类型也可以称为鸭子类型（不以貌取人），只关心对象有哪些属性，而不管属性使用什么名称。</p>
<p>定义 TS 对象类型有三种方法：</p>
<pre><code class="language-ts">// 方式一：使用 object 类型，或者使用 new Object() 方式等，都很鸡肋
let obj1: object = {
  name: 'zs',
}
// Error:不存在name属性，因为object类型只表示该值是一个JS对象，而不是null！
// console.log(obj1.name)

// 方式二：不显示注解，让TS推导
let obj2 = {
  name: 'ls',
}
console.log(obj2.name)

// 方式三：明确类型
let obj3: { name: string } = {
  name: 'ls',
}
console.log(obj3.name)

// 方式三也可以使用常规对象定义方式定义，只要表明其结构即可
let p = {
  name: 'ls',
  country: 'UK',
}

class Person {
  public name: string
  public country: string
  constructor(name: string) {
    this.name = name
    this.country = 'China'
  }
}

p = new Person('ww')
</code></pre>
<h3 id="32-属性缺失"><a class="header" href="#32-属性缺失">3.2 属性缺失</a></h3>
<p>情况一：创建的对象实例上缺失了一些属性，这时候的错误如下：</p>
<pre><code class="language-ts">let a: {
  name: string
  age: number
}

// 类型 &quot;{ name: string; }&quot; 中缺少属性 &quot;age&quot;，但类型 &quot;{ name: string; age: number; }&quot; 中需要该属性。
// a = {
//   name: 'ls',
// }
</code></pre>
<p>情况二：创建的对象实例上访问不存在的属性：</p>
<pre><code class="language-ts">let a: {
  name: string
  age: number
}

a = {
  name: 'ls',
  age: 30,
}

// 类型“{ name: string; age: number; }”上不存在属性“sex”
// console.log(a.sex)
</code></pre>
<h3 id="33-对象属性可选"><a class="header" href="#33-对象属性可选">3.3 对象属性可选</a></h3>
<p>为了解决对象中属性存在一定变数问题，可以在声明对象结构时使用 <code>?</code>、<code>[]</code>：</p>
<pre><code class="language-ts">// ? 解决
let obj1: { name: string; age?: number }

obj1 = {
  name: 'zs',
  age: 40,
}

obj1 = {
  name: 'ls',
}

// 如果可选属性过多，可以使用 []
// propName 是笔者自己定义的名称，表示 key，string 代表 key 的类型，any 代表 value 类型
let obj2: { name: string; [propName: string]: any }

obj2 = {
  name: 'zs',
  work: 'teacher',
  age: 10,
}
</code></pre>
<h2 id="四-并集与交集"><a class="header" href="#四-并集与交集">四 并集与交集</a></h2>
<h3 id="41-并集符合"><a class="header" href="#41-并集符合">4.1 并集符合</a></h3>
<p>并集或符号：</p>
<pre><code class="language-ts">let obj: { name: string } | { age: number }

obj = { name: 'lisi' }
</code></pre>
<h3 id="42-交集符号"><a class="header" href="#42-交集符号">4.2 交集符号</a></h3>
<p>交集与符号：</p>
<pre><code class="language-ts">let obj: { name: string } &amp; { age: number }

obj = { name: 'lisi', age: 30 }
</code></pre>
<p>这 2 个符号经常作用于多个类组成的类型，如：</p>
<pre><code class="language-js">class A {}
class B {}
let obj: A &amp; B // obj 中需要有 A 与 B 的成员
</code></pre>
<h3 id="43-联合类型"><a class="header" href="#43-联合类型">4.3 联合类型</a></h3>
<p>联合类型(Union Types)是可以通过管道(|)将变量设置多种类型，赋值时可以根据设置的类型来赋值。</p>
<p>问题：假定一个函数的参数类型不是很确定，如何定义该函数？</p>
<p>解决：在不使用泛型的情况下，联合类型是很好的解决方案。</p>
<p>示例：创建一个将数字转换为字符串的函数，接收类型为数字或者字符串</p>
<pre><code class="language-ts">function getString(num: number | string): string {
  return String(num)
}

console.log(getString(1))
console.log(getString('2'))
</code></pre>
<h2 id="五-类型别名"><a class="header" href="#五-类型别名">五 类型别名</a></h2>
<p>使用 type 关键字可以给类型起个别名，可以让业务信息更清晰，减少一些重复代码：</p>
<pre><code class="language-ts">type Age = number
let a: Age = 3
</code></pre>
<p>type 支持或、与操作：</p>
<pre><code class="language-ts">class A {}
class B {}

type Cus = A &amp; B

let cusInstance: Cus
</code></pre>
<p>贴士：使用类型别名的地方都可以替换为源类型，程序不会受到影响。</p>
<p>不过要注意的是：同一个别名不能声明两次，且类型别名的定义和普通变量存在一样的作用域限制。</p>
<h2 id="六-类型推断"><a class="header" href="#六-类型推断">六 类型推断</a></h2>
<p>TS 在识别未指定类型的数据时，会进行推断：</p>
<pre><code class="language-ts">// 推断一：推断 num 为数值类型
let num = 100
num = 'hello' // 报错

// 推断二：推断 str 为 any 类型
let str
str = 100
str = 'hello' // 不会报错
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-typescript-函数"><a class="header" href="#031-typescript-函数">03.1-TypeScript 函数</a></h1>
<h2 id="一-函数定义"><a class="header" href="#一-函数定义">一 函数定义</a></h2>
<h3 id="11-函数声明"><a class="header" href="#11-函数声明">1.1 函数声明</a></h3>
<pre><code class="language-ts">// 使用 function 关键字声明
function run(name: string, age: number): boolean {
  return false
}

// 使用箭头函数与表达式
const run = (name: string, age: number): boolean =&gt; {
  return false
}

// 第三种写法：run 后面是函数类型，boolean= 后面是函数实现
const run: (name: string, age: number) =&gt; boolean = (
  name: string,
  age: number
) =&gt; {
  return false
}

// 不推荐使用 Function 构造函数，这会导致无法判别参数和返回值类型
</code></pre>
<p>注意：在 TS 中，如果调用函数没有传入合法的参数，比如传入参数个数不正确或者传入参数类型不正确，则会报错。</p>
<h3 id="12-返回值注意事项"><a class="header" href="#12-返回值注意事项">1.2 返回值注意事项</a></h3>
<p>如果函数没有返回值，可以使用 void：</p>
<pre><code class="language-ts">function fn1(): void {
  console.log('hello')
}

function fn2(): void {
  return
}

function fn3(): void {
  return undefined // 也支持 null
}
</code></pre>
<p>从上述表现看出，void 返回值表示返回值是个空值！而 never 修饰返回值则表示没有值，即如果函数返回值直接不存在，可以使用 never，通常表现为抛出异常或无法执行到终止点（例如无限循环），这种函数永远不会有返回结果：</p>
<pre><code class="language-ts">// 返回值为 never 的函数可以是抛出异常的情况
function error(message: string): never {
  throw new Error(message)
}

// 返回值为 never 的函数可以是无限循环这种无法被执行到的终止点的情况
function loop(): never {
  while (true) {}
}
</code></pre>
<h2 id="二-参数设置"><a class="header" href="#二-参数设置">二 参数设置</a></h2>
<h3 id="21-默认参数"><a class="header" href="#21-默认参数">2.1 默认参数</a></h3>
<p>参数可以设置默认参数：</p>
<pre><code class="language-ts">function test(a: string, b: string = 'hi') {
  console.log(a)
  console.log(b)
}
</code></pre>
<h3 id="22-剩余参数"><a class="header" href="#22-剩余参数">2.2 剩余参数</a></h3>
<p>剩余参数可以限制类型：</p>
<pre><code class="language-ts">function fn(a: number, ...args: number) {
  args.forEach((arg: number) =&gt; {
    console.log(arg)
  })
}

fn(1, 2, 3) //输出 2 3

//无需书写小括号的场景：字符串模板作为参数
fn`test ${name}`
</code></pre>
<h3 id="23-参数解构"><a class="header" href="#23-参数解构">2.3 参数解构</a></h3>
<pre><code class="language-ts">function add({ num1, num2 }: { num1: number; num2: number }): number {
  return num1 + num2
}
let total = add({ num1: 1, num2: 2 })
</code></pre>
<h2 id="三-函数重载"><a class="header" href="#三-函数重载">三 函数重载</a></h2>
<p>ts 中的函数重载与 Java 中的重载不太一样。在 TS 中，名称相同的函数，但是参数或者返回值不同的函数，他们共用一个函数体，则称为函数重载：</p>
<pre><code class="language-ts">function getInfo(name: string): string

function getInfo(age: number): string

function getInfo(str: any): any {
  if (typeof str === 'string') {
    return '我的姓名是：' + str
  } else {
    return '我的年龄是：' + str
  }
}
console.log(getInfo('张三'))
console.log(getInfo(12))
</code></pre>
<p>函数重载可以让代码结构更加分明，核心优势是：每个重载的签名函数可以完成各自功能，输出取值时无需强制转换就能语法提示！</p>
<p>函数重载经常应用于框架中，比如 Vue3 的响应式代码：</p>
<pre><code class="language-ts">export function ref&lt;T extends object&gt;(value: T): ToRef&lt;T&gt;
export function ref&lt;T&gt;(value: T): Ref&lt;UnwrapRef&lt;T&gt;&gt;
export function ref&lt;T = any&gt;(): Ref&lt;T | undefined&gt;
export function ref(value?: unknown) {
  return createRef(value)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-面向对象基础"><a class="header" href="#041-面向对象基础">04.1-面向对象基础</a></h1>
<h2 id="一-封装"><a class="header" href="#一-封装">一 封装</a></h2>
<h3 id="11-类的定义"><a class="header" href="#11-类的定义">1.1 类的定义</a></h3>
<pre><code class="language-ts">class Person {
  // TS 中必须先定义好成员变量
  name: string
  age: number

  constructor(a: string, b: number) {
    this.name = a
    this.age = b
  }

  info(): void {
    console.log(this.name + '的年龄是：' + this.age)
  }
}

let p = new Person('张三', 40)
p.info()
</code></pre>
<p>注意：TS 一样支持 ES6 中的 extends 关键字</p>
<h3 id="12-属性修饰符"><a class="header" href="#12-属性修饰符">1.2 属性修饰符</a></h3>
<p>权限修饰符：</p>
<pre><code class="language-txt">public：默认的修饰符，可以不写，在类里面、子类、类外面都可以访问
private：只能由当前类的实例访问，子类、类外部都没法访问
protected：允许当前类与其子类的实例访问，类外部无法访问
</code></pre>
<p>注意：在新规 ES 新提案中，使用 # 代表私有属性，TS 也必定会追随该提案。</p>
<p>此外：TS 也支持 static、get、set、readonly 等修饰符。</p>
<p>在 TS 中使用 get、set 示例：</p>
<pre><code class="language-ts">class Employee {
  private _salary: number
  name: string
  get salary(): number {
    return this._salary
  }
  set salary(num) {
    this._salary = num
  }
}
</code></pre>
<h2 id="二-继承"><a class="header" href="#二-继承">二 继承</a></h2>
<p>TS 中的继承与 ES6 一致，使用 extends 关键字即可。</p>
<pre><code class="language-js">class Animal {
  name: string
  constructor(name: string) {
    this.name = name
  }
  run() {
    console.log(`${this.name} is running....`)
  }
}

class Dog extends Animal {
  constructor(name: string) {
    // 调用父类构造函数实现子类属性初始化
    super(name)
  }
}

let d = new Dog('大黄')
d.run()
</code></pre>
<h2 id="三-多态"><a class="header" href="#三-多态">三 多态</a></h2>
<p>多态：父类型的引用指向了子类型的对象。</p>
<pre><code class="language-ts">class Animal {
  name: string
  constructor(name: string) {
    this.name = name
  }
  run() {
    console.log(`${this.name} is running....`)
  }
}

class Dog extends Animal {
  constructor(name: string) {
    super(name)
  }
  run(distance: number = 10) {
    console.log(`${this.name} running ${distance} `)
  }
}

class Pig extends Animal {
  constructor(name: string) {
    super(name)
  }
  run(distance: number = 5) {
    console.log(`${this.name} running ${distance} `)
  }
}

// let d = new Dog(&quot;大黄&quot;)
// d.run()

let t1: Animal = new Dog('大黄')
t1.run()

let t2: Animal = new Pig('猪九戒')
t2.run()
</code></pre>
<p>上述案例中，无论是 t1，还是 t2，他们是不同的子类，但是都可以使用父类的类型来使用：</p>
<pre><code class="language-ts">function showName(animal: Animal) {
  console.log(animal.name)
}
showName(t1)
showName(t2)
</code></pre>
<h2 id="四-抽象类"><a class="header" href="#四-抽象类">四 抽象类</a></h2>
<p>如果很多类有共同性，可以使用抽象类来描述。</p>
<pre><code class="language-ts">abstract class Animal {
  weight: number
  constructor(weight: number) {
    this.weight = weight
  }
  // 普通方法：有具体的实现
  eat() {
    console.log('eat...')
  }
  // 抽象方法：不能有具体的实现。抽象方法只能出现在抽象类中
  abstract move()
}
</code></pre>
<p>抽象类并不是用来实例化的，只能被继承，继承者必须实现抽象类的抽象方法：</p>
<pre><code class="language-ts">class Bird extends Animal {
  move() {
    console.log('fly....')
  }
}

class Fish extends Animal {
  move() {
    console.log('swim....')
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-接口"><a class="header" href="#051-接口">05.1-接口</a></h1>
<h2 id="一-接口简介"><a class="header" href="#一-接口简介">一 接口简介</a></h2>
<p>抽象类和抽象方法虽然提供了标准，但是只针对类中的某个函数设立了规范。如果需要对类本身进行规范，则需要使用接口，比如限定一个类中必须有哪些成员：</p>
<p>示例：</p>
<pre><code class="language-ts">interface Person {
  name: string
  run(): void
}

// 接口作为函数参数
function getName(p: Person): string {
  return p.name
}
</code></pre>
<p>接口的本质：在 TS 编译为 JS 后，接口的代码会被抹除，<strong>接口只是提供给 TS 进行语法校验的工具</strong>。当然，在大型项目中，<strong>接口承担了最重要的抽象部分</strong>。</p>
<p>接口与抽象类对比：</p>
<ul>
<li>
<p>抽象类主要针对类中的函数进行抽象，接口针对类本身进行抽象</p>
</li>
<li>
<p>抽象类中抽象的成员可以有实际的属性值，接口只有成员的抽象</p>
</li>
</ul>
<h2 id="二-接口成员限制"><a class="header" href="#二-接口成员限制">二 接口成员限制</a></h2>
<h3 id="21-接口属性修饰"><a class="header" href="#21-接口属性修饰">2.1 接口属性修饰</a></h3>
<p>接口的属性可以修饰为可选的、只读的：</p>
<pre><code class="language-ts">interface Person {
  readonly name: string // 只读的
  age?: number // 可选的
}
</code></pre>
<h3 id="22-接口类型校验的严格性"><a class="header" href="#22-接口类型校验的严格性">2.2 接口类型校验的严格性</a></h3>
<p>在接口作为参数时，如果传递的接口方式不同，校验的严格性也不同。</p>
<pre><code class="language-ts">interface Person {
  name: string // 只读的
  age?: number // 可选的
}
const setName = (p: Person, str: string): void =&gt; {
  p.name = str
}

let p = {
  name: 'dell',
  sex: 'male',
}
setName(p, 'lisi') // 不会发生错误，编译器认为 p 类型就是 Person
// setName({ name: 'dell', sex: 'male' }, 'lisi') // 报错：类型不匹配
</code></pre>
<p>在上述示例中，直接传入字面量出现了错误，如果要支持字面量的写法，则可以将接口设定为：</p>
<pre><code class="language-ts">interface Person {
  name: string // 只读的
  age?: number // 可选的
  [propName: string]: any // 除了 name 和 age，还可以多出其他的字段
}
</code></pre>
<h2 id="三-常见接口用法"><a class="header" href="#三-常见接口用法">三 常见接口用法</a></h2>
<h3 id="32-属性接口"><a class="header" href="#32-属性接口">3.2 属性接口</a></h3>
<p>属性接口更多是对 json 对象提供了约束。</p>
<pre><code class="language-ts">interface Person {
  name: string
  age: number
}

class Student {
  //构造函数支持接口
  constructor(public config: Person) {}
}

//在创建对象时，必须满足接口定义的属性
let s1 = new Student({
  name: 'lisi',
  age: 18,
})
</code></pre>
<h3 id="33-类实现接口"><a class="header" href="#33-类实现接口">3.3 类实现接口</a></h3>
<pre><code class="language-ts">interface Person {
  name: string
  age: number
  run(): void
}

class Student implements Person {
  name: string = ''
  age: number = 0
  constructor() {}
  //实现接口方法
  run() {
    console.log(this.name + ' run....')
  }
}

let s1 = new Student()
s1.name = 'lisi'
s1.age = 15
s1.run()
</code></pre>
<p>贴士：一个类可以实现多个接口。</p>
<p>接口与抽象类作用相似，但是接口更加通用、轻量，而抽象类则更具体，功能更丰富，如构造方法、默认实现、访问修饰符等都是接口无法实现的。</p>
<h3 id="34-函数接口"><a class="header" href="#34-函数接口">3.4 函数接口</a></h3>
<pre><code class="language-ts">interface encrypt {
  (key: string, val: string): string
}

let md5: encrypt = function (key: string, val: string): string {
  return key + val
}

console.log('name', 'zs')
</code></pre>
<h3 id="35-可索引接口"><a class="header" href="#35-可索引接口">3.5 可索引接口</a></h3>
<p>可索引接口可以用来对数组的索引进行限制，如果数组中的索引传入了其他类型，那么报错：</p>
<pre><code class="language-ts">interface UserArr {
  [index: number]: string
}
let arr: UserArr = ['aaa', 'bbb']
console.log(arr[0])
</code></pre>
<p>可索引接口也可以对对象进行限制，如果 json 中多写了字段，则报错：</p>
<pre><code class="language-ts">interface UserObj {
  [index: string]: string
}
let u: UserObj = {
  name: 'lisi',
}
</code></pre>
<h2 id="四-接口可以被继承"><a class="header" href="#四-接口可以被继承">四 接口可以被继承</a></h2>
<pre><code class="language-ts">interface Animal {
  eat(): void
}

interface Person extends Animal {
  work(): void
}
</code></pre>
<h2 id="五-接口与类型别名"><a class="header" href="#五-接口与类型别名">五 接口与类型别名</a></h2>
<p>第一：类型别名的通用性更强，因为接口的限制内容必须是结构性的，而类型别名可以是表达式。</p>
<p>第二：扩展接口时，TS 会对可扩展性进行检查，而交集类型不会。如下所示：</p>
<pre><code class="language-ts">interface A {
  good(x: number): string
  bad(x: number): string
}

// 报错：不能将类型“number”分配给类型“string”
interface B extends A {
  good(x: number | string): string
  bad(x: string): string
}
</code></pre>
<p>这里继承改为类型别名方式，并使用交集 &amp; 则不会产生该错误。</p>
<p>第三：同一个作用域中，同名接口将自动合并，而同名类型别名则报错。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-命名空间"><a class="header" href="#061-命名空间">06.1-命名空间</a></h1>
<h2 id="一-命名空间的使用"><a class="header" href="#一-命名空间的使用">一 命名空间的使用</a></h2>
<h3 id="11-基础示例"><a class="header" href="#11-基础示例">1.1 基础示例</a></h3>
<p>命名空间是在模块系统之外，TS 自身提供的另一种代码封装方式。命名空间的使用示例：</p>
<pre><code class="language-ts">// 使用命名空间的代码
namespace Util {
  export function get() {}
}

// 其他文件调用 get 方法
Util.get()
</code></pre>
<h3 id="12-命名空间嵌套"><a class="header" href="#12-命名空间嵌套">1.2 命名空间嵌套</a></h3>
<p>命名空间内没有导出的代码则为所在块的私有代码。命名空间可以导出函数、变量、类型、接口、其他命名空间，导出命名空间时也代表着命名空间可以嵌套：</p>
<pre><code class="language-ts">namespace Util {
  export function get() {}

  export namespace FetchUtil {
    export fetchGet(){}
  }
}

// 调用fetchGet
Util.FetchUtil.fetchGet()
</code></pre>
<h3 id="13-命名空间合并"><a class="header" href="#13-命名空间合并">1.3 命名空间合并</a></h3>
<p>当命名空间分散在多个文件时，TS 会合并名称相同的命名空间：</p>
<pre><code class="language-ts">namespace Util {
  export function get() {
    console.log('get')
  }
}

namespace Util {
  export function post() {
    console.log('post')
  }
}

Util.post() //post
</code></pre>
<h3 id="14-命名空间别名"><a class="header" href="#14-命名空间别名">1.4 命名空间别名</a></h3>
<p>命名空间也支持别名。</p>
<h3 id="15-命名空间的编译输出"><a class="header" href="#15-命名空间的编译输出">1.5 命名空间的编译输出</a></h3>
<p>命名空间不遵守 tsconfig.json 中的 module 奢姿，始终编译为全局变量：</p>
<pre><code class="language-ts">// 编译前
namespace Util {
  export function get() {
    console.log('get')
  }
}

// 编译后
var Util
;(function (Util) {
  function get() {
    console.log('get')
  }
  Util.get = get
})(Util || (Util = {}))
</code></pre>
<p>Util 在 IIFE（立即调用函数）中声明，创建了衣蛾闭包，放置没有显式导出的变量跳到 Util 模块。</p>
<h2 id="二-命名空间与模块"><a class="header" href="#二-命名空间与模块">二 命名空间与模块</a></h2>
<p>为了更好的符合 JavaScript 标准，更明确的指明依赖，更推荐多使用模块而非命名空间。使用模块，明确指明了依赖，可以提升代码的可读性，可以强制模块隔离（命名空间会自动合并，而模块不会），还可以做静态分析。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="071-泛型"><a class="header" href="#071-泛型">07.1-泛型</a></h1>
<h2 id="一-泛型简介"><a class="header" href="#一-泛型简介">一 泛型简介</a></h2>
<p>在软件工程中，我们不仅要创建一致的 API，也要考虑可重用性，组件不仅能够支持当前的数据类型，同时也支持未来的数据类型。</p>
<p>通俗的理解：泛型就是提升类、接口、方法的复用性，以支持不特定的数据类型。</p>
<p>示例：</p>
<pre><code class="language-ts">function f1(value: string): string {
  return value
}

function f2(value: number): number {
  return value
}
</code></pre>
<p>以上 2 个函数一致性极高，其实使用一个函数即可表示，这时候需要引入泛型：</p>
<pre><code class="language-ts">function fn&lt;T&gt;(value: T): T {
  return value
}
console.log(fn&lt;number&gt;(123))
console.log(fn&lt;string&gt;('test'))
</code></pre>
<p>再假如我们定义一个 filter 函数，传入一个数组和函数用来实现 filter:</p>
<pre><code class="language-ts">type filter = (array: unknow, f: unknow) =&gt; unknow[]

// 可以是数值数组、字符串数组、对象数组
type filter = (array: number[], f: (item: number) =&gt; boolean) =&gt; number[]
type filter = (array: string[], f: (item: string) =&gt; boolean) =&gt; string[]
type filter = (array: object[], f: (item: object) =&gt; boolean) =&gt; object[]
</code></pre>
<p>此时，对象数组在具体的函数签名调用中就会出现错误，因为我们无法知道 object 类型的数据的结构：</p>
<pre><code class="language-ts">type filter = (array: object[], f: (item: object) =&gt; boolean) =&gt; object[]

const myFilter: filter = (array: object[], f: (item: object) =&gt; boolean) =&gt; {
  return array
}

let names = [{ firstname: 'zs' }, { firstname: 'ls' }, { firstname: 'ww' }]
// Err:类型object上不存在属性firstname
let result = myFilter(names, (_) =&gt; _.firstname.startsWith('z'))
</code></pre>
<p>此时使用泛型就能很好地解决：</p>
<pre><code class="language-ts">type filter = &lt;T&gt;(array: T[], f: (item: T) =&gt; boolean) =&gt; T[]

const myFilter: filter = (array, f: (item) =&gt; boolean) =&gt; {
  return array
}

let names = [{ firstname: 'zs' }, { firstname: 'ls' }, { firstname: 'ww' }]
let result = filter(names, (item) =&gt; item.firstname.startsWith('z'))

// 执行语法：tsc --target es6 filename
</code></pre>
<p>T 就像一个占位符类型，当从 array 中推导出 T 类型后，将会替换 T 出现的位置。</p>
<h2 id="二-泛型语法"><a class="header" href="#二-泛型语法">二 泛型语法</a></h2>
<p>泛型支持的数据类型有很多，如下所示：</p>
<pre><code class="language-ts">function map&lt;T&gt;(params: Array&lt;T&gt;) {
  return params
}
</code></pre>
<p>泛型也支持书写多个：</p>
<pre><code class="language-ts">function join&lt;T, P&gt;(first: T, second: P) {
  return `${first}${second}`
}
</code></pre>
<p>泛型的类型也可以被限定：</p>
<pre><code class="language-ts">interface IPerson {
  age: number
}

function fn&lt;T extends IPerson&gt;(p: T) {}
</code></pre>
<p>贴士：当泛型限定的位置不一样时，使用的方式也不一样，如下所示：</p>
<pre><code class="language-ts">type filter1 = &lt;T&gt;(array: T[], f: (item: T) =&gt; boolean) =&gt; T[]
type filter2&lt;T&gt; = (array: T[], f: (item: T) =&gt; boolean) =&gt; T[]

const myFilter1: filter1 = (array, f: (item) =&gt; boolean) =&gt; {
  return array
}

// 报错 filter2需要 1 个类型参数
// const myFilter2: filter2 = (array, f: (item) =&gt; boolean) =&gt; {
//     return array
// }
// 必须显式声明
const myFilter2: filter2&lt;string&gt; = (array, f: (item) =&gt; boolean) =&gt; {
  return array
}
</code></pre>
<h2 id="三-泛型应用场景"><a class="header" href="#三-泛型应用场景">三 泛型应用场景</a></h2>
<h3 id="31-泛型与数组"><a class="header" href="#31-泛型与数组">3.1 泛型与数组</a></h3>
<pre><code class="language-ts">// 效果一致
let arr1: number[] = [1, 2, 3]
let arr2: Array&lt;number&gt; = [1, 2, 3]
</code></pre>
<h3 id="32-泛型应用于函数"><a class="header" href="#32-泛型应用于函数">3.2 泛型应用于函数</a></h3>
<p>如上所示，泛型最基础的用法就是在函数参数、返回值中使用。</p>
<pre><code class="language-ts">function fn&lt;T&gt;(value: T): T {
  return value
}
console.log(fn&lt;number&gt;(123))
console.log(fn&lt;string&gt;('test'))

// 使用类型推导
console.log(fn(123))
console.log(fn('test'))
</code></pre>
<p>示例二：多个泛型，比如元组类型数据存储了 2 个不同数据类型，现在要实现其数据位置交换：</p>
<pre><code class="language-ts">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]]
}
</code></pre>
<p>示例三：直接使用泛型数据无法获取其内部属性，需要对泛型进行约束，只允许传入带该属性的参数。</p>
<pre><code class="language-ts">// function echoLength&lt;T&gt;(arg: T): number {
//     return arg.length        // 编译错误：arg 无法识别 length
// }

// 鸭子类型：叫起来像鸭子，你就是鸭子！嘻嘻
interface IWithLength {
  length: number
}

// extends 约束
function echoLength&lt;T extends IWithLength&gt;(arg: T): number {
  return arg.length // 编译错误：arg 无法识别 length
}

echoLength('hello world!')
echoLength([1, 2, 3])
echoLength({ length: 10, width: 20 })
</code></pre>
<h3 id="33-泛型应用于类"><a class="header" href="#33-泛型应用于类">3.3 泛型应用于类</a></h3>
<pre><code class="language-ts">class Queue {
  private data = []
  push(item) {
    return this.data.push(item)
  }
  pop() {
    return this.data.shift()
  }
}

const queue = new Queue()
queue.push(1)
queue.push('str')

console.log(queue.pop().toFixed())
console.log(queue.pop().toFixed())
</code></pre>
<p>上述示例会有编译错误，因为 'str' 没有 toFixed() 方法。一般情况下我们需要保证保证推入类型与推出类型一致，限制 item 类型即可，但是此方式又会连续导致其他类型难以使用。
此时可以使用泛型类：</p>
<pre><code class="language-ts">class Queue&lt;T&gt; {
  private data = []
  push(item: T) {
    return this.data.push(item)
  }
  pop(): T {
    return this.data.shift()
  }
}

const queue = new Queue&lt;number&gt;()
queue.push(1)
// queue.push('str')   // 此处报错

console.log(queue.pop().toFixed())
console.log(queue.pop().toFixed())
</code></pre>
<h3 id="34-keyof"><a class="header" href="#34-keyof">3.4 keyof</a></h3>
<pre><code class="language-ts">interface Person {
  name: string
  age: number
}

class Teacher {
  constructor(private info: Person) {}
  getInfo(key: string){
    // return this.info[key]
     // 上述写法有有语法错误提示，需要使用类型保护
    if(key==='name' } } key === 'age') {
      return this.info[key]
    }
  }
}
</code></pre>
<p>上述写法可以使用泛型来优雅的体现：</p>
<pre><code class="language-ts">interface Person {
  name: string
  age: number
}

class Teacher {
  constructor(private info: Person) {}
  getInfo&lt;T extends keyof Person&gt;(key: T): Person[T] {}
}
</code></pre>
<p><code>T extends name</code> 等价于 <code>type T = name</code></p>
<h3 id="35-泛型与接口"><a class="header" href="#35-泛型与接口">3.5 泛型与接口</a></h3>
<pre><code class="language-ts">interface KeyPair&lt;T, U&gt; {
  key: T
  value: U
}

let k1: KeyPair&lt;number, string&gt; = { key: 1, value: 'hello' }
</code></pre>
<h3 id="36-泛型默认类型"><a class="header" href="#36-泛型默认类型">3.6 泛型默认类型</a></h3>
<pre><code class="language-ts">type MyEvent&lt;T = HTMLElement&gt; = {
  target: T
  type: string
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="081-类型增强"><a class="header" href="#081-类型增强">08.1-类型增强</a></h1>
<h2 id="一-ts-内置映射类型"><a class="header" href="#一-ts-内置映射类型">一 TS 内置映射类型</a></h2>
<p>TS 内置了 Array、Map 等 ECMAScript 的标准，也内置了 DOM/BOM 等标准，可以直接使用。TS 也额外设置了一些 Utility Types，如：<code>Partial&lt;T&gt;</code>、<code>Readonly&lt;T&gt;</code>，示例如下：</p>
<pre><code class="language-ts">interface IPerson {
  name: string
  age: number
}

let p1: IPerson = { name: 'zs', age: 10 }

type AnyPerson = Partial&lt;IPerson&gt; // 其内部成员变为了可选的
let p2: AnyPerson = { name: 'ls' }
</code></pre>
<p>TS 内置的 Record 类型用于描述有映射关系的对象。用 Record 构建一个映射，从一周的每一天映射到次日：</p>
<pre><code class="language-ts">type WeekDay = 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri'
type Day = WeekDay | 'Sat' | 'Sun'

// 使用Record方式
let nextDay1: Record&lt;WeekDay, Day&gt; = {
  Mon: 'Tue',
  Tue: 'Wed',
  Wed: 'Thu',
  Thu: 'Fri',
  Fri: 'Sat',
}

// 使用映射方式:Record的实现本质
let nextDay2: { [K in WeekDay]: Day } = {
  Mon: 'Tue',
  Tue: 'Wed',
  Wed: 'Thu',
  Thu: 'Fri',
  Fri: 'Sat',
}
</code></pre>
<p>TS 的内置映射类型有：</p>
<ul>
<li><code>Record&lt;Keys, Values&gt;</code>：键的类型为 Keys，值的类型为 Values 的对象</li>
<li><code>Partial&lt;Object&gt;</code>：把 Object 中每个字段都标记为可选的</li>
<li><code>Required&lt;Object&gt;</code>：把 Object 中每个字段都标记为必须的</li>
<li><code>Readonly&lt;Object&gt;</code>：把 Object 中每个字段都标记为只读的</li>
<li><code>Pick&lt;Object, Keys&gt;</code>：返回 Object 的子类型，只含指定 Keys</li>
</ul>
<h2 id="二-条件类型"><a class="header" href="#二-条件类型">二 条件类型</a></h2>
<h3 id="21-条件类型的基本使用"><a class="header" href="#21-条件类型的基本使用">2.1 条件类型的基本使用</a></h3>
<pre><code class="language-ts">type IsString&lt;T&gt; = T extends string ? true : false

type A = IsString&lt;string&gt; // true
type B = IsString&lt;number&gt; // false
</code></pre>
<p>类似三元表达式的写法，条件判断可以用在类型别名、接口、类、参数、方法的泛型默认类型等。</p>
<h3 id="22-条件分配"><a class="header" href="#22-条件分配">2.2 条件分配</a></h3>
<p>下列的表达式是等效的：</p>
<pre><code class="language-ts">string extends T ? A:B              等价于 string extends T ? A:B
(string | number) extends T ? A:B   等价于 (string extends T ? A:B) |  (number extends T ? A:B)
</code></pre>
<p>假设有个函数接受 T 类型参数，把该参数提升为数组类型 T[]，则:</p>
<pre><code class="language-ts">type ToArray&lt;T&gt; = T[]

type A = ToArray&lt;number&gt; // number[]
type B = ToArray&lt;number | string&gt; // number[] | string[]
</code></pre>
<p>当使用条件类型时，会把并集类型分配到各个分支中：</p>
<pre><code class="language-ts">type ToArray&lt;T&gt; = T extends unknown ? T[] : T[]

type A = ToArray&lt;number&gt; // number[]
type B = ToArray&lt;number | string&gt; // number[] | string[]
</code></pre>
<p>示例：构建一个类型 Without，计算在 T 中而不在 U 中的类型：</p>
<pre><code class="language-txt">type Without&lt;T, U&gt; = T extends U ? never : T

// 用法示例
type A = Without&lt;boolean | number | string, boolean&gt; // number | string

// 分析其实现

// 第一步 把条件分配到并集中
type A = Without&lt;boolean, boolean&gt;
  | Without&lt;number, boolean&gt;
  | Without&lt;string, boolean&gt;

// 第二步：代入Without定义，替换T和U
type A = boolean extends boolean ? never : boolean
  | number extends boolean ? never : number
  | string extends boolean ? never : string

// 第三步：计算条件
type A = never | number | string

// 第四步：化简
type A = number | string
</code></pre>
<h3 id="23-infer-关键字"><a class="header" href="#23-infer-关键字">2.3 infer 关键字</a></h3>
<p>使用 infer 关键字可以在条件类型的条件中声明泛型：</p>
<pre><code class="language-ts">// 声明一个条件类型 ElementType，获取数组中的元素类型
type ElementType1&lt;T&gt; = T extends unknown[] ? T[number] : T
type A1 = ElementType1&lt;number[]&gt; // number

// 使用infer关键字
type ElementType2&lt;T&gt; = T extends (infer U)[] ? U : T
type A2 = ElementType2&lt;number[]&gt; // number
</code></pre>
<p>这里 ElementType1 和 ElementType2 是等价的，infer 子句声明了一个新的类型变量 U，TS 将根据传递给 ElementType2 的 T 推导出 U 的类型。</p>
<p>看一个更贴切的复杂示例：</p>
<pre><code class="language-ts">type SecondArg&lt;F&gt; = F extends (a: any, b: infer B) =&gt; any ? B : never
// 获取Array.slice类型
type F = typeof Array['prototype']['slice']
type A = SecondArg&lt;F&gt; // number | undefined
</code></pre>
<p>可以发现 <code>[].slice</code> 的第二个参数是 <code>number | undefined</code> 类型，在编译时就可以知晓，这是 Java 做不到的。</p>
<h3 id="24-内置的条件类型"><a class="header" href="#24-内置的条件类型">2.4 内置的条件类型</a></h3>
<p>利用条件类型可以在类型层面提供更强大的操作，所以 TS 提供了一些全局可用的条件类型：</p>
<pre><code class="language-ts">// Exclue&lt;T, U&gt; ： 与 Without类型，计算在T中而不在U中的类型
type A1 = number | string
type B1 = string
type C1 = Exclude&lt;A1, B1&gt; // number

// Extract&lt;T, U&gt; ： 计算T中可赋值给U的类型
type A2 = number | string
type B2 = string
type C2 = Extract&lt;A2, B2&gt; // string

// NonNullable&lt;T&gt; ： 从T中排除null和undefined
type A3 = { a?: number | null }
type B3 = NonNullable&lt;A['a']&gt; // number

// InstanceType&lt;C&gt;：计算类构造方法的实例类型
type A4 = { a: number }
type B4 = { new (): A4 }
type I = InstanceType&lt;B4&gt; // {a:number}

// ReturnType&lt;F&gt; ：计算函数的返回类型，不适用于泛型和重载函数
type F = (a: number) =&gt; string
type R = ReturnType&lt;F&gt; // strin
</code></pre>
<h2 id="三-类型断言"><a class="header" href="#三-类型断言">三 类型断言</a></h2>
<h3 id="31-类型判断-typeof-instanceof"><a class="header" href="#31-类型判断-typeof-instanceof">3.1 类型判断 typeof instanceof</a></h3>
<p>使用 <code>typeof</code> 、<code>instanceof</code> 可以判断类型：</p>
<pre><code class="language-ts">// 创建一个获取参数长度的函数，接收类型为数字或者字符串。
function getLength(num: number | string): number {
  // if (num.length) { } // num 是联合类型，不存在 length 属性

  if (typeof num === 'string') {
    // 断定其类型是 string，可以直接返回，省去类型转换步骤
    return num.length
  }

  return String(num).length
}

console.log(getLength(1))
</code></pre>
<p>用户也可以使用 <code>is</code> 自定义一些类型防护措施：</p>
<pre><code class="language-ts">function isString(a: unknown): a is string {
  return typeof a === 'string'
}
</code></pre>
<h3 id="32-类型断言"><a class="header" href="#32-类型断言">3.2 类型断言</a></h3>
<p>类型判断与类型断言（类型保护）并不是一回事，TS 提供了 <code>as</code> 关键字等两种方式进行断言：</p>
<pre><code class="language-ts">let num: unknown
num = 30 // 此时仍然是 unknown

// 类型判断
if (typeof num === 'number') {
  let result = num + 1 // 这里报错
}

// 类型断言：直接告知编译器 num 类型是 number
let result1 = (num as number) + 1 // 断言方式一
let result2 = &lt;number&gt;num + 1 // 断言方式二
</code></pre>
<p>3.1 的案例可以使用 TS 的类型断言，更加优雅：</p>
<pre><code class="language-ts">function getLength(num: number | string): number {
  if ((&lt;string&gt;num).length) {
    return (num as string).length
  }

  return String(num).length
}
</code></pre>
<p>当 2 个类型之间关系不明，无法断定具体类型时，直接断定为 any。所以类型断言并不安全，应该尽量避免使用，如下所示：</p>
<pre><code class="language-ts">function addToList(list: string[], item: string) {
  // ...
}

addToList('this is really,' as any, 'really unsafe')
</code></pre>
<h3 id="33-非空断言"><a class="header" href="#33-非空断言">3.3 非空断言</a></h3>
<p>针对 <code>T | null</code> 或者 <code>T | null | undefined</code> 等可为空的类型，TS 提供了专门的语法，用于断定类型为 T，而不是 null 或者 undefined。</p>
<pre><code class="language-ts">// 定义一个弹出层
type Dialog = {
  id?: string
}

// 定义关闭弹出层方法
function closeDialog(dialog: Dialog) {
  // 首先判断弹出层是否存在，不存在则返回
  if (!dialog.id) {
    return
  }

  //  错误一： string | undefined 类型不是 string类型，因箭头函数是一个新的作用域，第一步判断不起作用
  // 错误二：HTMLElement | null”的参数不能赋给类型“Element”的参数
  setTimeout(() =&gt; {
    removeDom(dialog, document.getElementById(dialog.id))
  })
}

function removeDom(dialog: Dialog, element: Element) {
  // Error: element.parentNode 可能为 “null”
  element.parentNode.removeChild(element)
  delete dialog.id
}
</code></pre>
<p>本示例需要使用大量的 <code>if(_ === null)</code> 进行判断，但是若确定不可能是空，则可以使用 TS 的特殊语法：</p>
<pre><code class="language-ts">// 定义一个弹出层
type Dialog = {
  id?: string
}

// 定义关闭弹出层方法
function closeDialog(dialog: Dialog) {
  if (!dialog.id) {
    return
  }

  setTimeout(() =&gt; {
    removeDom(dialog, document.getElementById(dialog.id!)!)
  })
}

function removeDom(dialog: Dialog, element: Element) {
  element.parentNode!.removeChild(element)
  delete dialog.id
}
</code></pre>
<p>非空断言运算符 <code>!</code> 告知了 TS 解析器，<code>dialog.id</code>、 <code>getElementById()</code> 、<code>parentNode</code> 的结果已经定义，不是空。</p>
<p>贴士：代码中如果大使用非空断言，则证明代码需要重构。</p>
<h3 id="34-明确赋值断言"><a class="header" href="#34-明确赋值断言">3.4 明确赋值断言</a></h3>
<p>下面的示例中会报错：</p>
<pre><code class="language-ts">let userId: string

// ... 其他操作

// Error: 在赋值前使用了变量“userId”
userId.toUpperCase()
</code></pre>
<p>这是 TS 提供的报错信息，如果其他操作后 <code>userId</code> 是明确可以知道的，则可以使用明确赋值断言：</p>
<pre><code class="language-ts">let userId!: string
</code></pre>
<p>贴士：代码中如果大使用明确赋值断言，则证明代码需要重构。</p>
<h2 id="四-模拟名义类型"><a class="header" href="#四-模拟名义类型">四 模拟名义类型</a></h2>
<p>TS 是典型的结构化类型系统，但是名义类型有时候也有用到的地方，如下所示：</p>
<pre><code class="language-ts">type OrderID = string
type UserID = string
type ID = OrderID | UserID

function queryUser(id: UserID) {}

// 由于OrderID和UserID只是类型别名，其本质仍然是string，则下面不会报错
let id: OrderID = '342de'
queryUser(id)
</code></pre>
<p>TS 可以使用类型烙印（type branding）方式模拟实现名义类型系统，用来保证上述示例的类型安全：</p>
<pre><code class="language-ts">// 这里使用的烙印方式是 unique symbol，因为他和 enum是TS仅有的2个名义类型
type OrderID = string &amp; { readonly brand: unique symbol }
type UserID = string &amp; { readonly brand: unique symbol }
type ID = OrderID | UserID

// 接着使用伴生对象方式创建 OrderID、UserID
function OrderID(id: string) {
  return id as OrderID
}

function UserID(id: string) {
  return id as UserID
}

// 回到示例
function queryUser(id: UserID) {}

let id: OrderID = OrderID('342de')
queryUser(id) // 这时候这里就出现错误提示了
</code></pre>
<p>烙印是一个典型的编译时结构，可以在大型项目中极大提升安全性！</p>
<h2 id="五-安全扩展原型"><a class="header" href="#五-安全扩展原型">五 安全扩展原型</a></h2>
<p>JS 允许在运行时修改内置方法，如： <code>[].push</code> 、 <code>'abc'.toUpperCase</code> 等，其每一个内置对象的原型都可以直接访问，包括 <code>Array.prototype</code> 、<code>Object.prototype</code> 等。</p>
<p>扩展 JS 的原型是不安全的，但是 TS 提供了静态类型系统，可以安全地对原型进行扩展：</p>
<pre><code class="language-ts">/**
 * 为 Array 原型新增 zip 方法
 */

// 让TS知道 zip方法的存在：利用接口合并增强全局Array接口
// 该文件没有显式导入导出，TS会合并同名接口
interface Array&lt;T&gt; {
  zip&lt;U&gt;(list: U[]): [T, U][]
}
// 如果实现zip需要导入其他代码，则需要把全局扩展放在 declare global 类型声明中：
// declare global {
//     interface Array&lt;T&gt; {
//         zip&lt;U&gt;(list: U[]): [T, U][]
//     }
// }

// 实现zip
Array.prototype.zip = function &lt;T, U&gt;(this: T[], list: U[]): [T, U][] {
  return this.map((v, k) =&gt; {
    return tuple(v, list[k])
  })
}

function tuple&lt;T extends unknown[]&gt;(...ts: T): T {
  return ts
}
</code></pre>
<p>TS 推导出的映射函数返回的类型是 <code>(T | U)[]</code>，因为 TS 意识不到这个元组的 0 索引始终是 T，1 索引始终是 U，所以使用 tuple 函数创建一个元组类型，而不使用类型断言。</p>
<p>注意：声明的 Array 接口是对全局命名空间 Array 的增强，即使没有导入 <code>zip.ts</code> 也会影响整个 TS 项目，<code>zip()</code> 方法已经被 TS 判定为可用。但是为了确保用到 <code>zip()</code> 方法文件都已经加载了 <code>zip.ts</code> 文件以让其生效，需要编辑 <code>tsconfig.json</code> 文件：</p>
<pre><code class="language-ts">{
  *exclude*: {
    &quot;./zip.ts&quot;
  }
}
</code></pre>
<p>现在可以随心使用 <code>zip()</code> 方法了，而且完全安全：</p>
<pre><code class="language-ts">import 'src/utils/zip'
;[1, 2, 3].map((n) =&gt; n * 2).zip(['a', 'b', 'c'])
// 得到结果 [[2, 'a'], [4, 'b'], [6, 'c']]
</code></pre>
<h2 id="六-类型的定义文件"><a class="header" href="#六-类型的定义文件">六 类型的定义文件</a></h2>
<h3 id="61-类型定义文件的使用"><a class="header" href="#61-类型定义文件的使用">6.1 类型定义文件的使用</a></h3>
<p>TS 中如果要使用 npm 上的一些 JS 包，需要声明类型的定义文件<code>.d.ts</code>。</p>
<p>比如现在使用第三方包：<code>jquery</code>，其语法是 JavaScript，在 HTML 文档或者使用 import 引入后，使用 <code>$</code> 等 jquery 的函数能够正常运行，但是编辑器中总是会包无法识别 $ 等错误。此时需要安装其翻译文件：</p>
<pre><code class="language-txt">npm i @types/jquery -D
</code></pre>
<p>翻译文件的源码中，核心文件是：<code>index.d.ts</code>，在该文件中补全了 JS 文件中的所有声明相关的定义。</p>
<h3 id="62-第三方库没有-types-文件"><a class="header" href="#62-第三方库没有-types-文件">6.2 第三方库没有 types 文件</a></h3>
<p>如果第三方库（比如 indexof 库）没有 types 文件，则可以在项目根目录下创建 <code>typings/indexof</code> 目录，注意这里子目录与第三方库目录名必须相同，接着在该子目录下创建 <code>index.d.ts</code>类型文件即可。</p>
<h3 id="63-类型定义文件的书写"><a class="header" href="#63-类型定义文件的书写">6.3 类型定义文件的书写</a></h3>
<p>如果要使用 1.2 节中的自定义类型文件，则可以参考下列<code>jquery.d.ts</code>：</p>
<pre><code class="language-ts">// 定义全局变量
declare var $: (param: () =&gt; void) =&gt; void

// 定义全局函数，支持函数重载
declare function $(param: () =&gt; void) =&gt; void

// 使用 interface 实现重载
interface Instance {
  html: (html: string)=&gt;Instance
}

interface jQuery {
  (readyFunc: ()= void): void
  (selector: string): Instance
}
declare var $:jQuery
</code></pre>
<p>注意：如果 jquery 是通过 import 方式引入，需要定义模块。</p>
<pre><code class="language-ts">declare module 'jquery' {
  // 书写所有定义 无需 declare
  var $: (param: () =&gt; void) =&gt; void
  function $(param: () =&gt; void) =&gt; void

  export = $
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="091-装饰器"><a class="header" href="#091-装饰器">09.1-装饰器</a></h1>
<h2 id="一-装饰器使用"><a class="header" href="#一-装饰器使用">一 装饰器使用</a></h2>
<p>装饰器用来修饰类，让类具备新的能力，其本质是一个函数。</p>
<p>由于装饰器是实验性方案，需要打开相关配置，以避免编辑器警告：</p>
<pre><code class="language-json"> /* Experimental Options */
    &quot;experimentalDecorators&quot;: true /* Enables experimental support for ES7 decorators. */,
    &quot;emitDecoratorMetadata&quot;: true /* Enables experimental support for emitting type metadata for decorators. */,
</code></pre>
<p>装饰器可以用来修饰类、方法、访问器等等。</p>
<h2 id="二-类装饰器"><a class="header" href="#二-类装饰器">二 类装饰器</a></h2>
<h3 id="20-类装饰器示例"><a class="header" href="#20-类装饰器示例">2.0 类装饰器示例</a></h3>
<p>类装饰器的参数是类的构造器，示例：</p>
<pre><code class="language-ts">// 定义一个函数，用来修饰类
function fn(constructor: any) {
  console.log('before....')
}

// 一个空的类
@fn
class Test {}
</code></pre>
<p>运行：</p>
<pre><code class="language-txt">ts-node ./src/demo1.ts
</code></pre>
<p>在运行时，即使没有对类进行实例化，也依然输出了装饰函数的内容，这是因为装饰器并不是类实例化时才会运行，而是在类被修饰会，就会运行！即：装饰器只是对类修改，而不是对类的实例修改。</p>
<p>装饰器支持使用多个，但是先收集到的装饰器后执行！</p>
<h3 id="21-添加原型方法"><a class="header" href="#21-添加原型方法">2.1 添加原型方法</a></h3>
<pre><code class="language-ts">// 定义一个函数，用来修饰类
function fn(constructor: any) {
  constructor.prototype.info = () =&gt; {
    console.log('hello...')
  }
}

// 一个空的类
@fn
class Test {}

let t = new Test()
;(t as any).info()
</code></pre>
<h3 id="22-使用工厂模式包装装饰器"><a class="header" href="#22-使用工厂模式包装装饰器">2.2 使用工厂模式包装装饰器</a></h3>
<pre><code class="language-ts">// 定义一个函数，用来修饰类
function fn(flag: boolean) {
  if (!flag) {
    return function (constructor: any) {}
  }

  return function (constructor: any) {
    constructor.prototype.info = () =&gt; {
      console.log('hello...')
    }
  }
}

// 一个空的类
@fn(true)
class Test {}

let t = new Test()
;(t as any).info()
</code></pre>
<p>此时，装饰器可以根据参数进行判断是否启用。</p>
<h3 id="23-装饰器中标准的构造函数扩展写法"><a class="header" href="#23-装饰器中标准的构造函数扩展写法">2.3 装饰器中标准的构造函数扩展写法</a></h3>
<pre><code class="language-ts">// 定义一个函数，用来修饰类
function fn() {
  return function &lt;T extends new (...args: any[]) =&gt; any&gt;(constructor: T) {
    return class extends constructor {
      name = 'zs'
      getName() {
        return this.name
      }
    }
  }
}

// 一个空的类
@fn()
class Person {
  name: string
  constructor(name: string) {
    this.name = name
  }
}

let p = new Person('lisi')
console.log(p.name) // zs
console.log((p as any).getName()) // zs
</code></pre>
<p>上述示例最后仍然需要将 p 转换为 any 才能识别 getName 方法，可以如下修改：</p>
<pre><code class="language-ts">const Test = fn()(
  class {
    name: string
    constructor(name: string) {
      this.name = name
    }
  }
)

let p = new Test('lisi')
console.log(p.name) // zs
console.log(p.getName()) // zs
</code></pre>
<h2 id="三-方法装饰器"><a class="header" href="#三-方法装饰器">三 方法装饰器</a></h2>
<p>方法构造器的参数如下所示：</p>
<pre><code class="language-ts">// target 在普通方法中是类的 prototype，在静态方法中是类的构造函数
// key 是方法名
// descriptor: PropertyDescriptor，这是第三个参数，是属性特征，descriptor.value 就是方法本身，可以进行函数重写！
function fn(target: any, key: string) {
  console.log(target, key)
}

class Test {
  name: string
  constructor(name: string) {
    this.name = name
  }
  @fn
  getName() {
    return this.name
  }
}
</code></pre>
<p>切记，装饰器不是在实例化的时候运行，而是在运行时，已经实现了装饰！，所以在编译上述代码时，会直接运行 fn 函数。</p>
<h2 id="四-访问器装饰器"><a class="header" href="#四-访问器装饰器">四 访问器装饰器</a></h2>
<p>访问器的装饰器与方法的装饰器参数是一致的。</p>
<pre><code class="language-ts">function fn(target: any, key: string, descriptor: PropertyDescriptor) {
  console.log(target, key)
}

class Test {
  private _name: string
  constructor(name: string) {
    this._name = name
  }

  get name() {
    return this._name
  }

  @fn
  set name(name: string) {
    this._name = name
  }
}
</code></pre>
<h2 id="五-属性装饰器"><a class="header" href="#五-属性装饰器">五 属性装饰器</a></h2>
<p>属性装饰器与方法装饰器类似，下面的示例中，替换了属性原本的特征：</p>
<pre><code class="language-ts">function fn(target: any, key: string): any {
  const descriptor: PropertyDescriptor = {
    writable: false,
  }
  return descriptor
}
</code></pre>
<h2 id="六-参数装饰器"><a class="header" href="#六-参数装饰器">六 参数装饰器</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-错误处理"><a class="header" href="#111-错误处理">11.1-错误处理</a></h1>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<p>TS 与 JS 处理异常方式类似，这里常见的处理方式有：</p>
<ul>
<li>返回 null</li>
<li>抛出异常</li>
<li>返回异常</li>
<li>Option 类型</li>
</ul>
<h2 id="一-返回-null-方式处理错误"><a class="header" href="#一-返回-null-方式处理错误">一 返回 null 方式处理错误</a></h2>
<p>返回 null 是一个很轻量的错误处理方式：</p>
<pre><code class="language-ts">function getDate(date: string): Date | null {
  let d = new Date(date)
  if (!Object.prototype.toString.call(date) === '[object Date]') {
    return null
  }

  return d
}

function test() {
  let date = getDate('ddd')
  if (!date) {
    console.log('date 获取时间错误')
  } else {
    console.log('date 为:', date)
  }
}

test()
</code></pre>
<p>使用 null 方式判断错误，每次操作都要检查值是否为 null，嵌套和串联操作过多情况下，显得代码繁冗，并且 null 方式下我们无法得知函数 <code>getDate()</code> 到底发生了什么错误(有些编程语言， 比如 Golang 支持多返回值则可以让开发者知晓错误)。</p>
<h2 id="二-抛出异常"><a class="header" href="#二-抛出异常">二 抛出异常</a></h2>
<p>抛出异常的方式可以让调用者获取到错误的元信息：</p>
<pre><code class="language-ts">function getDate(date: string): Date {
  let d = new Date(date)
  if (Object.prototype.toString.call(date) !== '[object Date]') {
    throw new Error('获取时间错误')
  }
  return d
}

function test() {
  try {
    let date = getDate('ddd')
    console.log('date 为:', date)
  } catch (e) {
    console.log('date 获取错误:', e)
  }
}

test()
</code></pre>
<p>这时候我们可以通过精细的对错误进行类型定义来更优雅的实现业务功能：</p>
<pre><code class="language-ts">class InvalidDateError extends RangeError {}
class OverTimeDateError extends RangeError {}

function getDate(date: string): Date {
  let d = new Date(date)
  if (Object.prototype.toString.call(date) !== '[object Date]') {
    throw new InvalidDateError('获取时间错误')
  }

  if (d.getTime() &gt; Date.now()) {
    throw new OverTimeDateError('时间超出错误')
  }
  return d
}

function test() {
  try {
    let date = getDate('ddd')
  } catch (e) {
    console.log(e instanceof InvalidDateError)

    if (e instanceof InvalidDateError) {
      console.log('11111')
      console.log(e.message)
    }

    if (e instanceof OverTimeDateError) {
      console.log('22222')
      console.log(e.message)
    }
  }
}

test()y bbbbbbbb
</code></pre>
<p>这里不仅表明了错误的位置，还能形容出错误的原因，以便更加方便的调试代码。但是在实际开发中，如果都按照抛出错误处理，那么 <code>try catch</code> 的地方就会很多，也会出现大量的嵌套情况。</p>
<h2 id="三-返回异常"><a class="header" href="#三-返回异常">三 返回异常</a></h2>
<p>使用并集方式返回异常：</p>
<pre><code class="language-ts">class InvalidDateError extends RangeError {}
class OverTimeDateError extends RangeError {}

function getDate(date: string): Date | InvalidDateError | OverTimeDateError {
  let d = new Date(date)
  if (Object.prototype.toString.call(date) !== '[object Date]') {
    return new InvalidDateError('获取时间错误')
  }

  if (d.getTime() &gt; Date.now()) {
    return new OverTimeDateError('时间超出错误')
  }
  return d
}

function test() {
  let res = getDate('dd')

  if (res instanceof InvalidDateError) {
    console.log('11111')
    console.log(res.message)
  } else if (res instanceof OverTimeDateError) {
    console.log('22222')
    console.log(res.message)
  } else {
    console.log(res)
  }
}

test()
</code></pre>
<p>上述方式很繁琐，但是保证了类型的安全。</p>
<p>嫌麻烦可以使用 <code>res instanceof Error</code>!</p>
<h2 id="四-option-类型"><a class="header" href="#四-option-类型">四 Option 类型</a></h2>
<h3 id="41-option-类型简介"><a class="header" href="#41-option-类型简介">4.1 Option 类型简介</a></h3>
<p>Option 类型原子类似 Haskell 等语言的概念，返回值不再是一个单纯的值，而是一个容器，容器内有一些方法，即使没有值夜能执行串联操作。</p>
<p>以下是使用数组作为返回容器的示例(在一些数据库的 orm 种经常见到该处理方式)：</p>
<pre><code class="language-ts">function getDate(date: string): Date[] {
  let d = new Date(date)
  if (Object.prototype.toString.call(date) !== '[object Date]') {
    return []
  }

  return [d]
}

function test() {
  let date = getDate('hh')

  date
    .map((item) =&gt; {
      item.toString()
    })
    .forEach((item) =&gt; {
      console.log('Date is: ', item)
    })
}

test()
</code></pre>
<p>Option 发挥作用的长处主要在一次执行多个操作，每个操作都有可能出错。</p>
<h3 id="42-option-使用示例"><a class="header" href="#42-option-使用示例">4.2 Option 使用示例</a></h3>
<p>Option 可以是一个接口，也可以是类型欧哲函数：</p>
<ul>
<li>作为接口：实现 2 个类：<code>Some&lt;T&gt;</code> 和 <code>None</code>，这是 2 种 Option，前者是一个包含一个 T 类型的值的 Option，后者 None 是没有值的 Option，表示失败</li>
<li>作为类型：是一个接口，表示 Some 和 None 类型的超类型</li>
<li>作为函数：是创建 Option 类型值的方式</li>
</ul>
<pre><code class="language-ts">// 接口Option
interface Option&lt;T&gt; {}

// 使用Some实现 Option接口
// 表示操作成功，得到一个值，类似之前安利的返回数组
class Some&lt;T&gt; implements Option&lt;T&gt; {
  constructor(private value: T) {}
}

// 使用None实现Option接口
// 表示操作失败，不包含值
class None implements Option&lt;never&gt; {}
</code></pre>
<p>如果改用数组的实现方式，则上述方案等价于：</p>
<pre><code class="language-ts">// Option
[T][]

// Some&lt;T&gt;
[T]

// None
[]
</code></pre>
<p>具体实现 Option 接口的类：</p>
<pre><code class="language-ts">interface Option&lt;T&gt; {
  // 接受一个函数f，f接口一个T类型的值（Option内的值的类型），返回一个内含U类型值的Option
  flatMap&lt;U&gt;(f: (value: T) =&gt; Option&lt;U&gt;): Option&lt;U&gt;
  // 接受一个默认值，其类型与Option中的值的类型相同，返回值为默认值或者Option中的值
  getOrElse(value: T): T
}

class Some&lt;T&gt; implements Option&lt;T&gt; {
  constructor(private value: T) {}

  // 调用flatMap，传入函数f，使用Some&lt;T&gt;中的值产生一个新类型Option
  flatMap&lt;U&gt;(f: (value: T) =&gt; Option&lt;U&gt;): Option&lt;U&gt; {
    return f(this.value)
  }

  getOrElse(value: T): T {
    throw new Error('Method not implemented.')
  }
}

class None implements Option&lt;never&gt; {
  // None 上调用flatMap始终返回一个None值
  flatMap&lt;U&gt;(): Option&lt;U&gt; {
    return this
  }

  // 始终返回传给getOrElse的值
  getOrElse&lt;U&gt;(value: U): U {
    return value
  }
}
</code></pre>
<p>可以通过重载给 flatMap 指定更具体的类型：</p>
<pre><code class="language-ts">interface Option&lt;T&gt; {
  flatMap&lt;U&gt;(f: (value: T) =&gt; None): None
  flatMap&lt;U&gt;(f: (value: T) =&gt; Option&lt;U&gt;): Option&lt;U&gt;
  getOrElse(value: T): T
}

class Some&lt;T&gt; implements Option&lt;T&gt; {
  constructor(private value: T) {}

  flatMap&lt;U&gt;(f: (value: T) =&gt; None): None
  flatMap&lt;U&gt;(f: (value: T) =&gt; Some&lt;U&gt;): Some&lt;U&gt;

  flatMap&lt;U&gt;(f: (value: T) =&gt; Option&lt;U&gt;): Option&lt;U&gt; {
    return f(this.value)
  }

  getOrElse(value: T): T {
    throw new Error('Method not implemented.')
  }
}

class None implements Option&lt;never&gt; {
  flatMap(): None {
    return this
  }

  getOrElse&lt;U&gt;(value: U): U {
    return value
  }
}
</code></pre>
<p>最后实现创建 Option 值的函数：</p>
<pre><code class="language-ts">function createOption&lt;T&gt;(value: null | undefined): None
function createOption&lt;T&gt;(value: T): Some&lt;T&gt;
function createOption&lt;T&gt;(value: T): Option&lt;T&gt; {
  if (value === null) {
    return new None()
  }
  return new Some(value)
}

let res = createOption(6) // Some&lt;number&gt;
  .flatMap((n) =&gt; createOption(n * 3)) // Some&lt;number&gt;
  .flatMap((n) =&gt; new None()) //None
  .getOrElse(7) // 7
</code></pre>
<p>这时候，执行一系列可能成功也可能失败的操作时，与返回值、错误并集等错误处理方式相比，Option 是一种强力的执行方式，不仅保证了类型安全性，还通过类型系统向使用方指出了某个操作可能失败。不过 Option 通过一个 None 值表示失败，没有失败的详细信息，也不知道失败的原因！！而且与不使用 Option 的代码无法互相操作（要自己手动包装这些 API，让他们返回 Option）。</p>
<p>贴士：多数语言无法实现上述重载，这是 TS 的简便之处。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="121-并发中的类型设计"><a class="header" href="#121-并发中的类型设计">12.1-并发中的类型设计</a></h1>
<h2 id="一-ts-与-promise"><a class="header" href="#一-ts-与-promise">一 TS 与 Promise</a></h2>
<p>在 ES6 中，Promise 用来解决 JS 异步回调地狱问题。在 TS 中，如果要实现 Promise，也需要为其添加类型设计。Promise 在 new 的时候接收的是一个执行器，执行器接收 resolve 和 reject 两个函数，在 TS 中可以这样定义：</p>
<pre><code class="language-ts">type Executor = {
  resolve: Function
  reject: Function
}

class Promise {
  constructor(f: Executor) {}
}
</code></pre>
<p>resolve 的参数取决于 API，而 reject 的参数始终是 Error 类型，所以可以细化为：</p>
<pre><code class="language-ts">type Executor&lt;T, E extends Error&gt; = {
  resolve: (result: T) =&gt; void

  reject: (error: E) =&gt; void
}

class Promise&lt;T, E extends Error&gt; {
  constructor(f: Executor&lt;T, E&gt;) {}
}
</code></pre>
<p>Promise 还需要提供 then 和 catch 方法，以实现串联、捕获异常：</p>
<pre><code class="language-ts">type Executor&lt;T, E extends Error&gt; = {
  resolve: (result: T) =&gt; void

  reject: (error: E) =&gt; void
}

class Promise&lt;T, E extends Error&gt; {
  constructor(f: Executor&lt;T, E&gt;) {}

  then&lt;U, F extends Error&gt;(g: (result: T) =&gt; Promise&lt;U, F&gt;) {
    return new Promise&lt;U, F&gt;((resolve, reject) =&gt; {})
  }

  catch&lt;U, F extends Error&gt;(g: (error: E) =&gt; Promise&lt;U, F&gt;) {
    return new Promise&lt;U, F&gt;((resolve, reject) =&gt; {})
  }
}
</code></pre>
<p>不过我们不能认定 throw 的就是 Error 对象，可以是函数、数组、字符串等，所以可以对其类型放宽要求：</p>
<pre><code class="language-ts">type Executor&lt;T, E extends Error&gt; = {
  resolve: (result: T) =&gt; void

  reject: (error: unknown) =&gt; void
}

class Promise&lt;T, E extends Error&gt; {
  constructor(f: Executor&lt;T, E&gt;) {}
  then&lt;U, F extends Error&gt;(g: (result: T) =&gt; Promise&lt;U, F&gt;) {
    return new Promise&lt;U, F&gt;((resolve, reject) =&gt; {})
  }
  catch&lt;U, F extends Error&gt;(g: (error: unknown) =&gt; Promise&lt;U, F&gt;) {
    return new Promise&lt;U, F&gt;((resolve, reject) =&gt; {})
  }
}
</code></pre>
<h2 id="二-ts-与异步流"><a class="header" href="#二-ts-与异步流">二 TS 与异步流</a></h2>
<h3 id="21-异步流概念"><a class="header" href="#21-异步流概念">2.1 异步流概念</a></h3>
<p>Promise 对象是便于排列、编排未来的值，但是如果有多个值在未来的不同时刻产出，则无法合理规划处理。比如：读取电脑中的大量文件、传送视频流等等，这些异步流都是在未来某个时刻发生的一系列事件。</p>
<p>常见的处理方案有：</p>
<ul>
<li>事件发射器：简单、轻量</li>
<li>响应式编程库，如 RxJS：复杂但是强大，可以编排事件流</li>
</ul>
<h3 id="22-事件发射器"><a class="header" href="#22-事件发射器">2.2 事件发射器</a></h3>
<p>事件发射器是 JavaScript 中的常见的设计模式，比如 DOM、Node 的 Eventmitter 模块都是基于此模式。在 TS 中可以这样定义：</p>
<pre><code class="language-ts">interface Emitter {
  // 发送事件
  emit(channel: string, value: unknown): void
  // 监听事件
  on(channel: string, f: (value: unknown) =&gt; void): void
}
</code></pre>
<p>如果我们要基于 TS 设计一个客户端软件，其事件绑定就可以这样设计：</p>
<pre><code class="language-ts">interface Emitter {
  // 发送事件
  emit(channel: string, value: unknown): void
  // 监听事件
  on(channel: string, f: (value: unknown) =&gt; void): void
}

type Events = {
  // 连接中
  connecting: { attempt: number; delay: number }
  ready: void
  error: Error
}

type Client = {
  on&lt;E extends keyof Events&gt;(event: E, f: (arg: Events[E]) =&gt; void): void

  emit&lt;E extends keyof Events&gt;(event: E, arg: Events[E]): void
}
</code></pre>
<h2 id="三-ts-与工作者"><a class="header" href="#三-ts-与工作者">三 TS 与工作者</a></h2>
<h3 id="31-开启工作者配置"><a class="header" href="#31-开启工作者配置">3.1 开启工作者配置</a></h3>
<p>tsconfig 中需要如下配置才可以开启工作者：</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;lib&quot;: [&quot;webworker&quot;, &quot;es2015&quot;]
  }
}
</code></pre>
<h3 id="32-添加-ts-类型"><a class="header" href="#32-添加-ts-类型">3.2 添加 TS 类型</a></h3>
<p>工作者示例代码如下（需要服务器环境启动）：</p>
<pre><code class="language-ts">// maint.ts
// 新建 一个工作者
let worker = new Worker('./worker.js', { type: 'module' })
// 传递消息给工作者
worker.postMessage('hello')
// 接收工作者消息
worker.onmessage = (e) =&gt; {
  console.log('来自工作者消息:', e.data)
}

// worker.ts
// 使用全局的 消息API 监听消息
onmessage = (e) =&gt; {
  console.log('来自主线程消息:', e.data)
  // 发送消息给主线程
  postMessage('world')
}
</code></pre>
<p>工作者的 API 其实就是一个事件发射器，这里加入 TS 类型后如下所示：</p>
<pre><code class="language-ts">/**
 * maint.ts
 * 主线程负责将Commands发送给Worker线程
 * Worker线程负责将Events发送给主线程
 */
type Message = string
type ThreadID = number
type UserID = number
type Participants = UserID[]

type Commands = {
  sendMessage: [ThreadID, Message]
  createThread: [Participants]
  addUserToThread: [ThreadID, UserID]
  removeUserFromThread: [ThreadID, UserID]
}

type Events = {
  receiveMessage: [ThreadID, UserID, Message]
  createdThread: [ThreadID, Participants]
  addedUserToThread: [ThreadID, UserID]
  removedUserFromThread: [ThreadID, UserID]
}

// 新建 一个工作者
let worker = new Worker('./worker.js', { type: 'module' })
// 传递消息给工作者
worker.postMessage('hello')

// 接收工作者消息
worker.onmessage = (e) =&gt; {
  console.log('来自工作者消息:', e.data)
}

/**
 * worker.ts
 */

// 使用并集囊括所有消息
type Command =
  | { type: 'sendMessage'; data: [ThreadID, Message] }
  | { type: 'createThread'; data: [Participants] }
  | { type: 'addUserToThread'; data: [ThreadID, UserID] }
  | { type: 'removeUserFromThread'; data: [ThreadID, UserID] }

// 使用全局的 消息API 监听消息
onmessage = (e) =&gt; {
  processCommandFromMainThread(e.data)
}

function processCommandFromMainThread(command: Command) {
  switch (command.type) {
    case 'sendMessage':
      // ...
      break
    case 'createThread':
      // ...
      break
    case 'addUserToThread':
      // ...
      break
    case 'removeUserFromThread':
      // ...
      break
  }
}
</code></pre>
<h3 id="33-使用类型安全的发射器包装"><a class="header" href="#33-使用类型安全的发射器包装">3.3 使用类型安全的发射器包装</a></h3>
<p>接着使用 Node 的 EventEmitter 或者 npm 包 events 进行类型安全包装，这个类并没有扩展能力，而是减少安全实现监听所需要的模板代码量：</p>
<pre><code class="language-ts">/**
 * SafeEmitter
 */

import { EventEmitter } from 'events'

// 声明一个泛型 Events，以及一个propertyKey（TS内置类型，表示对象的有效键：string,number,Symbol）到参数列表的Record映射
class SafeEmitter&lt;Events extends Record&lt;PropertyKey, unknown[]&gt;&gt; {
  private emitter: EventEmitter

  constructor() {
    this.emitter = new EventEmitter()
  }

  on&lt;K extends keyof Events&gt;(
    channel: K,
    listener: (...args: Events[K]) =&gt; void
  ) {
    return this.emitter.on(channel, listener)
  }

  emit&lt;K extends keyof Events&gt;(channel: K, ...data: Events[K]) {
    this.emitter.emit(channel, ...data)
  }
}
</code></pre>
<p>最终的使用：</p>
<pre><code class="language-ts">import { SafeEmitter } from './SafeEmitter'

/**
 * maint.ts
 * 主线程负责将Commands发送给Worker线程
 * Worker线程负责将Events发送给主线程
 */
type Message = string
type ThreadID = number
type UserID = number
type Participants = UserID[]

type Commands = {
  sendMessage: [ThreadID, Message]
  createThread: [Participants]
  addUserToThread: [ThreadID, UserID]
  removeUserFromThread: [ThreadID, UserID]
}

type Events = {
  receiveMessage: [ThreadID, UserID, Message]
  createdThread: [ThreadID, Participants]
  addedUserToThread: [ThreadID, UserID]
  removedUserFromThread: [ThreadID, UserID]
}

let commandEmitter = new SafeEmitter&lt;Commands&gt;()
let eventEmitter = new SafeEmitter&lt;Events&gt;()

let worker = new Worker('./worker.js')

// 监听工作者发来的事件，使用类型安全的事件发射器重新发射
worker.onmessage = (event) =&gt; {
  eventEmitter.emit(event.data.type, ...event.data.data)
}

// 监听该线程发出的命令，把命令发给工作者
commandEmitter.on('sendMessage', (data) =&gt; {
  worker.postMessage({ type: 'sendMessage', data })
})
commandEmitter.on('createThread', (data) =&gt; {
  worker.postMessage({ type: 'createThread', data })
})
// ...

// 工作贤臣穿件新线程处理的事情
eventEmitter.on('createdThread', (threadID, participants) =&gt; {
  console.log('threadID = ', threadID)
  console.log('participants = ', participants)
})

// 把命令发给工作者
commandEmitter.emit('createThread', [123, 456])

/**
 * worker.ts
 */

import { SafeEmitter } from './SafeEmitter.js'

// 使用并集囊括所有消息
type Commands = {
  sendMessage: [ThreadID, Message]
  createThread: [Participants]
  addUserToThread: [ThreadID, UserID]
  removeUserFromThread: [ThreadID, UserID]
}

type Events = {
  receiveMessage: [ThreadID, UserID, Message]
  createdThread: [ThreadID, Participants]
  addedUserToThread: [ThreadID, UserID]
  removedUserFromThread: [ThreadID, UserID]
}

// 监听主线程消息
let commandEmitter = new SafeEmitter&lt;Commands&gt;()

// 把事件发射回主线程
let eventEmitter = new SafeEmitter&lt;Events&gt;()

// 使用类型拿权的事件发射器包装主线程发来的命令
onmessage = (command) =&gt; {
  commandEmitter.emit(command.data.type, ...command.data.data)
}

// 监听工作者触发的事件，发给主线程
eventEmitter.on('receiveMessage', (data) =&gt; {
  postMessage({ type: 'receiveMessage', data })
})
eventEmitter.on('createdThread', (data) =&gt; {
  postMessage({ type: 'createdThread', data })
})

// 回应主线程发来的 sendMesageToThrread 命令
commandEmitter.on('sendMessage', (threadID, message) =&gt; {
  console.log('threadID = ', threadID)
})

// 把事件发回主线程
eventEmitter.emit('createdThread', 123, [456, 789])
</code></pre>
<h2 id="34-类型安全的协议"><a class="header" href="#34-类型安全的协议">3.4 类型安全的协议</a></h2>
<p>如果需要指明一个命令始终收到特定响应该如何处理？线程之间传递函数不好实现，不过可以在工作者中定义函数，把参数发给该函数，再把结果发送回来。</p>
<p>下面的示例中构建一个矩阵计算引擎，支持三种运算：求矩阵的行列式、计算两个矩阵的点积、求逆矩阵：</p>
<pre><code class="language-ts">/**
 * worker.ts
 */

// 运算交给工作者，对不安全的操作进行包装

// 定义一个多用途的代理类型，不限于只处理 MatrixProtocol
type Protocol = {
  [command: string]: {
    in: unknown[]
    out: unknown
  }
}

function createProtocol&lt;P extends Protocol&gt;(script: string) {
  return &lt;K extends keyof P&gt;(command: K) =&gt; {
    ;(...args: P[K]['in']) =&gt; {
      new Promise&lt;P[K]['out']&gt;((resolve, reject) =&gt; {
        let worker = new Worker(script)
        worker.onerror = reject
        worker.onmessage = (event) =&gt; resolve(event.data.data)
        worker.postMessage({ command, args })
      })
    }
  }
}
</code></pre>
<p>假定实现了如何计算行列式，得到一个函数，可在协议中运行特定命令：</p>
<pre><code class="language-ts">let runWithMatrixProtocol = createProtocol&lt;MatrixProtocol&gt;('matrixWorker.js')

let parallelDeterminant = runWithMatrixProtocol('determinant')

parallelDeterminant([
  [1, 2],
  [3, 4],
]).then(console.log) // -2
</code></pre>
<p>以上代码示例把不安全额操作（在线程之间传递无类型的消息）抽象成了对类型安全的请求-响应协议，协议支持的所有命令集中在一个地方 MatrixProtocol，而且核心逻辑 createProtocol 与协议的具体实现 runWithMatrixProtocol 是完全分开的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="131-ts-与-js-的互操作"><a class="header" href="#131-ts-与-js-的互操作">13.1-TS 与 JS 的互操作</a></h1>
<h2 id="一-类型声明"><a class="header" href="#一-类型声明">一 类型声明</a></h2>
<h3 id="11-类型声明的使用"><a class="header" href="#11-类型声明的使用">1.1 类型声明的使用</a></h3>
<p>当我们将一个 JS 项目迁移为 TS 项目时，或者 TS 项目中使用到了 JS 书写的第三方库时，为了类型安全，我们需要定义适配一些 TS 的类型，以让代码更加安全，这时候需要类型声明。</p>
<p>类型声明文件的扩展名是 <code>.d.ts</code>，配合 JSDoc 用来为无类型的 JavaScript 代码附加 TypeScript 类型。类型声明的规范：</p>
<ul>
<li>类型声明中只能包含类型，不能有参数，所以不能实现函数、类、对象或变量，参数也不能有默认值</li>
<li>使用关键字 <code>declare</code> 可以声明 JavaScript 代码中的定义过的某个值</li>
<li>类型声明只需要声明使用方可见的类型，不导出的代码、函数内的局部变量无需为其声明类型</li>
</ul>
<p>下面是一段原始的代码示例：</p>
<pre><code class="language-ts">export class Obeservable {
  _observers: any[]
  constructor() {
    this._observers = []
  }

  static create() {
    return new Obeservable()
  }

  subscribe(observer: any) {
    this._observers.push(observer)
  }

  unsubscribe(observer: any) {
    this._observers = this._observers.filter((obs) =&gt; obs !== observer)
  }

  notify(data: any) {
    this._observers.forEach((observer) =&gt; observer(data))
  }
}
</code></pre>
<p>当使用编译命令 <code>tsc -d Obeservable.ts</code> 后，除了得到编译后的 js 文件外，还有一个 <code>Obeservable.d.ts</code> 的类型声明文件：</p>
<pre><code class="language-ts">export declare class Obeservable {
  _observers: any[]
  constructor()
  static create(): Obeservable
  subscribe(observer: any): void
  unsubscribe(observer: any): void
  notify(data: any): void
}
</code></pre>
<p>这里新增了关键字 <code>declare</code>，这并不是真正的定义了一个 class 而是向编译器告知，会有一个类 <code>Obeservable</code> 存在。这个导出的类型声明文件对于当前项目来说没有太多意义，而是当项目作为第三方库被其他人使用时，API 调用者能够通过 TS 获取到更多的类型信息联想。</p>
<p>当 TS 项目启动时，会扫描读取所有的 <code>.d.ts</code> 文件，以为当前项目提供类型信息，并且无需编译 TS 书写的第三方库，能有效提升效率。</p>
<h3 id="12-外参变量声明"><a class="header" href="#12-外参变量声明">1.2 外参变量声明</a></h3>
<p>类型声明在自己的项目中也可以直接使用，比如 Node 项目需要使用 <code>process</code> 类的成员时，则可以声明一个全局的 <code>process</code> 类，这时候无需显式导入即可享受到类型提示。没有声明时，直接使用 <code>process</code> 则会报错：<code>找不到名称“process”</code>。</p>
<p>当我们自己定义一个 <code>process</code> 对象时，则会提示不能增强全局对象：</p>
<pre><code class="language-ts">process = {
  env: {
    NODE_ENV: 'dev',
  },
}
</code></pre>
<p>这里其实是 TS 防卫过当了，我们只需要新建一个 <code>polyfills.ts</code> 文件让 TS 项目自动扫描即可：</p>
<pre><code class="language-ts">declare let process: {
  env: {
    NODE_ENV: 'dev'
  }
}

process = {
  env: {
    NODE_ENV: 'dev',
  },
}
</code></pre>
<p>这里是向 TS 告知了有个全局对象 process，且有属性 env 等。</p>
<p>贴士：TS 自带了 Node 的一些类型，安装 <code>npm i --save-dev @types/node</code> 即可。</p>
<h3 id="13-外参模块声明"><a class="header" href="#13-外参模块声明">1.3 外参模块声明</a></h3>
<p>当我们需要给一些仓库提交类型声明时，可以把常规的类型声明放在 <code>declare module</code> 中：</p>
<pre><code class="language-ts">declare module 'module-name' {
  export type name = string
  let defaultName: name
  export default defaultName
}
</code></pre>
<p>在项目中则需要导入模块才能使用：</p>
<pre><code class="language-ts">// 使用方式一
import UtilModule from 'UtilModule'
const name: UtilModule.name = 'zs'

// 使用方式二
import { name } from 'UtilModule'
const name: name = 'zs'
</code></pre>
<p>模块的声明支持通配符，可以匹配指定模式的任何导入路径声明类型：</p>
<pre><code class="language-ts">// webpack中json-loader导入的json类型
declare module 'json!*' {}

// webpack 中 style-loaer 导入的css
declare module '*.css' {}
</code></pre>
<p>接着配置构建系统，允许加载 json 和 css 文件，就可以使用 json 和 css 文件了：</p>
<pre><code class="language-ts">import a from 'json!myFile'

import b from './widget.css'
</code></pre>
<h2 id="二-js-代码迁移到-ts-代码"><a class="header" href="#二-js-代码迁移到-ts-代码">二 JS 代码迁移到 TS 代码</a></h2>
<h3 id="20-迁移流程"><a class="header" href="#20-迁移流程">2.0 迁移流程</a></h3>
<p>如果我们要将 JS 项目迁移到 TS 项目，那么要做到的事代码都使用 TS 编写，类型做到全覆盖，依赖的第三方库也有严格的类型信息，以让 bug 在编译时捕获。</p>
<p>整体迁移流程可以概括为：</p>
<ul>
<li>1、添加并配置 TSC 文件</li>
<li>2、对 JS 代码做类型检查</li>
<li>3、将 JS 代码改写为 TS 代码，一次改一个文件</li>
<li>4、为了依赖安装类型声明</li>
<li>5、代码开启严格模式</li>
</ul>
<h3 id="21-添加并配置-tsc-文件"><a class="header" href="#21-添加并配置-tsc-文件">2.1 添加并配置 TSC 文件</a></h3>
<p>tsc 添加如下配置后即可让 TSC 编译 JS 文件了，此时 TSC 不会对 JS 文件做类型检查：</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;allowJs&quot;: true
  }
}
</code></pre>
<h3 id="22-对-js-代码做类型检查"><a class="header" href="#22-对-js-代码做类型检查">2.2 对 JS 代码做类型检查</a></h3>
<p>这一步是可选的，如果我们要求更加严格，JS 文件也要做类型检查，则可以修改配置为：</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;allowJs&quot;: true,
    &quot;checkJs&quot;: true
  }
}
</code></pre>
<p>此时 TS 编译 JS 文件时，会尽力推导类型，并做类型检查。如果代码量比较庞大，则很可能会出现错误，可以在出错的 JS 文件顶部加入以下注释禁用该功能：</p>
<pre><code class="language-txt">// @ts-check
</code></pre>
<p>如果一个文件抛出的类型错误问题较多，暂时不想修正，则可以保留 checkJs 设置，在该文件顶部加入注释：</p>
<pre><code class="language-txt">// ts-nocheck
</code></pre>
<p>TS 并不能推导出 JS 项目的全部类型信息，将会出现狠毒 any，如果启用了严格模式，迁移过程中可以临时允许隐式 any：</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;allowJs&quot;: true,
    &quot;checkJs&quot;: true,
    &quot;noImplicitAny&quot;: false
  }
}
</code></pre>
<p>贴士：TSC 推导 JS 代码，类型限定要宽容一点：</p>
<ul>
<li>所有的函数参数都是可选的</li>
<li>函数和类的属性无需事先声明，会根据场景推导</li>
<li>声明对象、类、函数后，可以再附加额外的属性。其背后原理是 TS 为各个类和函数声明生成了一个命名空间，为每个对象字面量自动添加一个索引签名</li>
</ul>
<h3 id="23-添加-jsdoc-注释"><a class="header" href="#23-添加-jsdoc-注释">2.3 添加 JSDoc 注释</a></h3>
<p>JSDoc 可以为某个 JS 函数添加类型注解，这在快速将一个 JS 文件转化为 TS 文件上有帮助，如下所示是一个 JS 文件，添加了 JSDoc 注释：</p>
<pre><code class="language-js">/**
 * @param name {string} The name of the person
 * @param age {number} The age of the person
 * @returns {void} The name of the person
 */
export function test(name: string, age: number): void {
  console.log('Hello, world!')
}
</code></pre>
<p>这个 test 函数的类型会推导为：
在没有 JSDoc 时，TSC 会将其类型推导为：</p>
<pre><code class="language-ts">// 没有JSDoc支持
(name:any, age:any)=&gt;void

// 有JSDoc支持
(name:string, age:number)=&gt;void
</code></pre>
<h3 id="24-修改文件后缀为-ts"><a class="header" href="#24-修改文件后缀为-ts">2.4 修改文件后缀为 ts</a></h3>
<p>修改文件后缀名为 ts 可能会带来大量的报错提示，这时候我们可以根据提示一一修改，以彻底改进项目的类型支持，如果比较耗时则可以偷懒，将严格模式 <code>use strict</code> 设置为 false，最后逐个开启严格模式，如：<code>noImplicitAny</code>，<code>noImplicitThis</code>，<code>strictNullChecks</code>等。</p>
<h3 id="25-启用严格类型检查策略"><a class="header" href="#25-启用严格类型检查策略">2.5 启用严格类型检查策略</a></h3>
<p>修改为 JS 切换 TS 带来的问题后，可以取消 JS 支持，开启严格 TS 检查：</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;allowJs&quot;: false,
    &quot;checkJs&quot;: false
  }
}
</code></pre>
<p>修正完此时出现的错误则 JS 项目成为了最终的优秀 TS 项目。</p>
<h2 id="三-ts-项目中使用-js-代码"><a class="header" href="#三-ts-项目中使用-js-代码">三 TS 项目中使用 JS 代码</a></h2>
<p>TS 查找 JS 代码类型类型信息的规律是：</p>
<ul>
<li>1、首先查找同一级目录中与 <code>.js</code> 文件同名的 <code>.d.ts</code> 文件，如果存在，则使用该文件作为 JS 文件的类型声明</li>
<li>2、如果不存在，且 tsc 配置中 allowJs 和 checkJs 的值为 true，推导 <code>.js</code> 推导 JS 的类型信息</li>
<li>3、如果无法推导，则整个模块都会被视为 any</li>
</ul>
<p>导入第三方库的时，查找的原则少有不同：</p>
<ul>
<li>1、在本地寻找模块的类型声明</li>
<li>2、本地未找到，则分析该第三方模块的 package.json 文件，这个文件中定义了 types 或 typings 的资源，则使用字段设置的 <code>.d.ts</code> 文件作为模块的类型声明</li>
<li>3、如果没有这些字段，则向上查找 node_modules/@types 文件夹，看看有没有类型声明</li>
<li>4、如果还没找到则，回到 TS 查找 JS 代码类型信息的规律中的 1、2、3 步骤。</li>
</ul>
<h2 id="四-使用第三方-js-库"><a class="header" href="#四-使用第三方-js-库">四 使用第三方 JS 库</a></h2>
<p>如果一个包自带了类型声明，且项目中设置了 <code>{&quot;noImplicitAny&quot;:true}</code>，则导入时不会有错误提示。</p>
<p>如果一个包没有类型声明，则可以前往 NPM 查看是否有该包的对应类型库，都位于 <code>@types</code> 作用域下，以 lodash 为例：</p>
<pre><code class="language-txt">// 安装lodash
npm i lodash -S

// 安装lodash声明
npm i @types/lodash -D
</code></pre>
<p>如果社区中也没有该包声明，则有以下几种办法：</p>
<ul>
<li>在导入的文件中加上 <code>// @ts-ignore</code> 注释，即将文件添加到白名单中，TS 这时候使用无类型信息的模块（其实是 any）</li>
<li>新建一个类型声明文件，欺骗 TSC 已经有可导入的模块，比如新建 <code>types.d.ts</code>，内容为 <code>declare module 'UtilModule'</code>，这时候类型都是 any，也可以在该文件内新增具体的类型，以外参模块形式增强类型</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-实用类型"><a class="header" href="#附录-实用类型">附录-实用类型</a></h1>
<pre><code class="language-txt">实用类型                   使用场景
ConstructorParameters     类构造方法类型      类构造方法参数类型组成的元组
InstanceType              类构造方法类型      使用new实例化得到的实例类型
Exclude                   并集类型           从类型中排除另一个类型
Extract                   并集类型           选择可赋值给某个类型的子类型
NonNullable               可为空的类型        从类型中排除null和undefined
Parameters                函数参数类型        函数的参数组成的元组
Partial                   对象类型            把对象的所有属性设为可选
Readonly                  数组、对象、元组     把对象的属性设为只读，或者数组/元组设为只读
ReadoblyArray             任何类型            把指定类型变成不可变数组
Record                    对象类型            键的类型到值的类型的映射
Required                  对象类型            把对象的所有属性设为必需
ReturnType                函数类型            函数的返回类型
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-react-简介"><a class="header" href="#011-react-简介">01.1-React 简介</a></h1>
<h2 id="一-开发思想"><a class="header" href="#一-开发思想">一 开发思想</a></h2>
<h3 id="11-mvc"><a class="header" href="#11-mvc">1.1 MVC</a></h3>
<p>在大型项目开发中，往往需要用业务逻辑、数据、界面显示分离的方法组织代码，以便在代码需要改进时能够做到最小化变更，便于扩展维护。</p>
<p>最经典的软件设计规范即 MVC（Model View Controller）：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/../images/mvvm/mvc01.svg" alt="mvc" /></p>
<ul>
<li>模型 model：对业务数据的抽象，如用户数据包括：uid、name、age 等，在模型层，将其抽象为 User 对象，包含上述字段，并附带基础的增删改查实例操作</li>
<li>视图 view：数据的可视化界面。更加面向普通用户，提供给了用户操作界面，即前端开发中最常见的网页</li>
<li>控制器 controller：数据流向的控制者，在数据发生变化时更新视图。控制层位于视图层与模型层中间，负责视图层数据的流转，即根据用户在视图层提交的数据，去模型层执行增删改查等操作</li>
</ul>
<h3 id="12-mvvm"><a class="header" href="#12-mvvm">1.2 MVVM</a></h3>
<p>MVC 思想在传统后端领域实现较多，但是在前端，开发者更多关注的是界面与数据。前端在行为交互上存在大量的相同代码，比如 tab 切换需要反复对几个 tab 元素进行循环遍历从而实现数据到界面，界面到数据的双向交互，MVC 思想在前端领域适应性较低。</p>
<p>MVVM 是前端视图层的分层开发思想，将前端视图的结构划分为 M（model）、V（view）、VM（view-model）三层：</p>
<ul>
<li>M：数据模型层，这里是接口请求到的数据结果集，封装于 data 对象中，专门用来保存每个页面里单独的数据。</li>
<li>V：视图层，vue 实例所控制的元素区域，即每个页面的 html 结构。</li>
<li>VM：VM 调度者，即 new 出来的 vue 实例对象，用来解耦视图层与数据模型层。视图层想要获取或保存数据的都需要由 vm 做中间处理。</li>
</ul>
<p>MVC 里的 C 是控制器，由不同的控制函数/对象，手动实现调度数据与视图转换。MVVM 的 VM 内部往往也存在一个虚拟 DOM，有了该调度者，开发者不再需要反复关注 DOM，只用与后台进行数据交互即可，数据模型的变更能够自动驱动视图的变更。</p>
<p>在前端中常见的具有 MVVM 思想的框架有：React、Vue。</p>
<p>在 MVVM 中：</p>
<ul>
<li>模型层数据发生变动，通过数据绑定形式驱动界面发生改变；</li>
<li>界面上的数据发生改变时，通过对 DOM 的监听驱动模型层数据发生改变！</li>
</ul>
<p>负责数据绑定、DOM 监听的就是 MVVM 编程的核心 VM 层，Vue/React 框架便是在其内部实现了这些机制。</p>
<h3 id="13-vue-与-react"><a class="header" href="#13-vue-与-react">1.3 Vue 与 React</a></h3>
<p>Vue 与 React 均是当前流行的框架，也都受到了 MVVM 编程思想的影响。二者的本质区别是：数据响应方式不同。React 侧重于用户手动 setState() 更新，Vue 中数据改动则界面自动更新。</p>
<p>二者没有绝对优劣，只是开发思维的不同。React 可以使用 mobx 实现类似 Vue 的响应编程，Vue 也可以把数据 freeze，不再具备响应式。</p>
<h3 id="14-单页面案弊端"><a class="header" href="#14-单页面案弊端">1.4 单页面案弊端</a></h3>
<p>使用 MVVM 思想可以让一个单页面就能实现一个完整的应用，虽然有一定的优点，但是在一个超大项目中，需要集成很多模块，造成其首次加载速度变慢，且一个局部异常容易造成整个 APP 无法使用。而多页面应用就不会有这两个缺点，笔者推荐使用的方式是：</p>
<p><strong>多页导航 + 单模块单页应用</strong>。</p>
<h2 id="二-react-框架"><a class="header" href="#二-react-框架">二 React 框架</a></h2>
<h3 id="21-框架简介"><a class="header" href="#21-框架简介">2.1 框架简介</a></h3>
<p>React 是 Facebook 2013 年开源的一款用于构建前端界面的 JS 库，其构想是将界面中的 UI 元素抽象为不同的组件，开发页面就像搭积木一样进行拼装。</p>
<p>React 与原生 JS 的对比：</p>
<ul>
<li>DOM 操作：原生 JS 如果要操作 UI，需要频繁操作 DOM，效率较低。（注意：jQuery 只是优化了 DOM 操作的代码写法而已，本质与原生 JS 一致）。React 框架内部实现了虚拟 DOM，在界面需要更新时，React 会在虚拟 DOM 中比较渲染前后的差异，决定最优更新哪些 DOM，由于虚拟 DOM 是内存数据，对实际 DOM 操作的仅仅是 Diff 部分，因而提高了性能。</li>
<li>组件化：原生 JS 组件化方案支持度不足，React 有完善的组件化支持（声明式）</li>
</ul>
<p>贴士：虚拟 DOM 上绑定的属性极少，更加轻量（因为只有框架自己使用）</p>
<h3 id="22-react-与-vue-对比"><a class="header" href="#22-react-与-vue-对比">2.2 React 与 Vue 对比</a></h3>
<p>React 与 Vue 共同点：</p>
<pre><code class="language-txt">都具备 MVVM 思想
内部都采用虚拟 DOM 方式进行视图更新
具备组件化开发理念
</code></pre>
<p>他们在组件化开发方式上：React 采用 JSX 来编写组件，而 Vue 使用单文件组件方式开发组件。</p>
<h2 id="二-react-helloworld"><a class="header" href="#二-react-helloworld">二 React HelloWorld</a></h2>
<h3 id="21-网页中直接使用-react"><a class="header" href="#21-网页中直接使用-react">2.1 网页中直接使用 React</a></h3>
<p>React 在设计之初就可以被渐进式适配，并且你可以根据需要选择性地使用 React。页面中可以直接使用 React，就可以实现 helloworld：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
&lt;!--React 核心库--&gt;
&lt;script
  src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;
  crossorigin
&gt;&lt;/script&gt;
&lt;!--React 支持 DOM 库--&gt;
&lt;script
  src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;
  crossorigin
&gt;&lt;/script&gt;
&lt;!--支持 JSX 语法--&gt;
&lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;
  const app = document.querySelector('#app')
  const vdom = &lt;h1&gt;Hello World&lt;/h1&gt; // 这里是 JSX 语法，不需要引号
  ReactDOM.render(vdom, app)
&lt;/script&gt;
</code></pre>
<p><code>ReactDOM.render</code> 用于将模板转为 HTML 语言，并插入指定的 DOM 节点。这个方法，必须而且只能返回一个有效的 React 元素对象。这意味着，如果你的组件是由多个元素构成的，那么你必须在外边包一个顶层 元素，然后返回这个顶层元素。</p>
<h3 id="22-react-脚手架"><a class="header" href="#22-react-脚手架">2.2 react 脚手架</a></h3>
<p>实际开发中，我们不可能直接在网页中引入 react 后进行开发，那样无法体现 react 在现代前端工程化体系下开发的便利，且上述案例在网页中运行 Babel，性能消耗极大。企业中一般使用 react 脚手架（模板）来初始化项目，脚手架能够提供规范的模板，也能更友好的使用各种 npm 包，并能直接提供的打包、编译后的源码给浏览器使用，是企业级 React 开发规范。</p>
<p>facebook 官方提供了多种脚手架工具，如 Next.js、Remix、create-react-app 等，见网页<a href="https://zh-hans.reactjs.org/learn/start-a-new-react-project">https://zh-hans.reactjs.org/learn/start-a-new-react-project</a>。</p>
<p>这里简单的以老牌的 create-react-app 为例：</p>
<pre><code class="language-txt">npx create-react-app my-app
cd my-app
npm start
</code></pre>
<p>项目源码中：</p>
<ul>
<li>index.js：全局入口文件</li>
<li>App.js：根组件</li>
</ul>
<p>注意：使用新版脚手架创建的 react 项目默认是不暴露 webpack 配置的，一旦使用其创建时提供的脚本 <code>yarn eject</code> 暴露了 webpack 就彻底无法返回。</p>
<p>这里不建议暴露，开发者可以通过其他方式自定义配置，如：</p>
<pre><code class="language-js">// 开发服务器代理可以在 package.json 中直接配置
proxy: 'http://192.168.1.1:5000'
</code></pre>
<p>复杂的代理配置可以直接在 src 目录的根目录中创建 <code>setupProxy.js</code> 文件，React 脚手架会自动编译。如下所示：</p>
<pre><code class="language-js">const proxy = require('http-proxy-middleware')

module.exports = function (app) {
  app.use(
    proxy('/api/v1', {
      target: 'http://192.168.1.1:5001', // 请求转发给谁
      changeOrigin: true, // 默认为 false，为 true 时服务器的 host 的端口值为 5001，而不是客户端 React 服务的端口
      pathRewrite: { '^/api/v1': '/api' }, // 将地址重写
    }),
    proxy('/api/v2', {
      target: 'http://192.168.1.1:5002',
      changeOrigin: true,
      pathRewrite: { '^/api/v2': '/api' },
    })
  )
}
</code></pre>
<p>如果需要配置的 webpack 功能过多，可以使用第三方修改工具：<a href="https://github.com/timarney/react-app-rewired">https://github.com/timarney/react-app-rewired</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-jsx-语法规范"><a class="header" href="#021-jsx-语法规范">02.1-JSX-语法规范</a></h1>
<h2 id="一-jsx-概念"><a class="header" href="#一-jsx-概念">一 JSX 概念</a></h2>
<p>HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，是一个 JavaScript 的语法扩展。JSX 看上去像模板语言，但它具有 JavaScript 的全部功能。</p>
<p>JSX 实质上这只是一个语法糖，每一个标签都会被 JSX 转换成纯 Javascript 代码，当然你想直接使用传统的 Javascript 代码写也是可以的，只是利用 JSX，组件的结构和组件之间的关系看上去更加清晰，组件写起来类似 HTML，极为简单。</p>
<p>JSX 优势示例：</p>
<pre><code class="language-js">// 传统书写方式
const vdom = React.createElement('h1', {id: 'title', React.createElement('span', {},'Hello World!')})

// jsx 书写方式
const vdom = &lt;h1 id=&quot;title&quot;&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;/h1&gt;
</code></pre>
<p>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据，所以 React 并没有采用将标记与逻辑分离到不同文件这种人为的分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。</p>
<h2 id="二-jsx-基础语法"><a class="header" href="#二-jsx-基础语法">二 JSX 基础语法</a></h2>
<h3 id="21-jsx-中标签写法"><a class="header" href="#21-jsx-中标签写法">2.1 JSX 中标签写法</a></h3>
<p>JSX 中只能书写一个根标签。</p>
<p>假如一个标签里面没有内容，你可以使用 <code>/&gt;</code> 来闭合标签，就像 XML 语法一样：</p>
<pre><code class="language-js">&lt;img src=&quot;1.png&quot; alt=&quot;&quot; /&gt;
</code></pre>
<h3 id="22-插值表达式"><a class="header" href="#22-插值表达式">2.2 插值表达式</a></h3>
<p>JSX 的大括号内可以放置有效的 JavaScript 表达式，如：<code>2+2</code>、<code>fn(user)</code>，如下所示：</p>
<pre><code class="language-js">function App() {
  let title = 'hello' // 在 JSX 中使用表达式

  const fn = function (obj) {
    console.log(obj.name)
  }

  const user = {
    age: 21,
    name: 'lisi',
  }

  // 多行标签外部需要使用 () 包裹
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;h2&gt;{title} world&lt;/h2&gt;
      &lt;div&gt;{fn(user)}&lt;/div&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>插值表达式只支持 JS 表达式，并不能直接书写 JS 语句，如 for 循环等，但是在 if、for 等代码块中，使用 JSX 是被允许的。</p>
<p>JS 表达式会产生一个值，可以放在任何需要该值的地方，常见的表达式有：</p>
<ul>
<li><code>num</code></li>
<li><code>num++</code></li>
<li><code>fn(num)</code>（这是函数表达式）</li>
<li><code>arr.map()</code></li>
</ul>
<h3 id="23-jsx-注释"><a class="header" href="#23-jsx-注释">2.3 JSX 注释</a></h3>
<p>JSX 的注释写法：</p>
<pre><code class="language-js">(
  &lt;h1&gt;{/* 注释 */}Hello World&lt;/h1&gt;

  &lt;h1&gt;
    {
      //注释
    }
    Hello World
  &lt;/h1&gt;
)
</code></pre>
<h3 id="24-jsx-中指定属性"><a class="header" href="#24-jsx-中指定属性">2.4 JSX 中指定属性</a></h3>
<p>通过使用引号或者大括号，可以将属性值指定为字符串字面量：</p>
<pre><code class="language-js">const config = {
  url: '1.png',
}
// return &lt;img src=&quot;config.url&quot; alt=&quot;&quot; /&gt;
return &lt;img src={config.url} alt=&quot;&quot; /&gt;
</code></pre>
<h3 id="25-遍历循环"><a class="header" href="#25-遍历循环">2.5 遍历循环</a></h3>
<p>在 JSX 中如果要渲染一个列表，需要生成一个数组数据，推荐使用 map 来遍历：</p>
<pre><code class="language-js">function App() {
  let myDom = [1, 2, 3].map((item, index) =&gt; {
    return &lt;p key={index}&gt;{item}&lt;/p&gt;
  })
  return &lt;div className=&quot;App&quot;&gt;{myDom}&lt;/div&gt;
}
</code></pre>
<p>注意一：如果要渲染的 dom 在 return 之后有换行需求，需要将 jsx 语句用小括号包裹。</p>
<p>注意二：React 要求遍历时，必须要有唯一的 key 属性值。</p>
<p>当然传统的循环方式也是可行的：</p>
<pre><code class="language-js">let myDom = []
for (let i in [1, 2, 3]) {
  myDom.push(&lt;p key={i}&gt;{[1, 2, 3][i]}&lt;/p&gt;)
}
</code></pre>
<h2 id="三-jsx-与-css"><a class="header" href="#三-jsx-与-css">三 JSX 与 CSS</a></h2>
<h3 id="31-class-类名与-for"><a class="header" href="#31-class-类名与-for">3.1 class 类名与 for</a></h3>
<p>JSX 中给组件添加类名，无需表达式，直接书写即可，但是由于 class 是 JS 的关键字，需要使用 className 代替：</p>
<pre><code class="language-js">const vdom = &lt;div className=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p>同理，CSS 中的 for 需要使用 htmlFor 代替。</p>
<h3 id="32-行内样式书写格式"><a class="header" href="#32-行内样式书写格式">3.2 行内样式书写格式</a></h3>
<p>行内样式不能像类名那样直接书写，需要使用 <code>style={ {key: value} }</code> 格式：</p>
<pre><code class="language-js">const vdom = &lt;div style={ { color: 'red', fontSize: '20px' } }&gt;&lt;/div&gt;
</code></pre>
<h3 id="33-css-属性"><a class="header" href="#33-css-属性">3.3 CSS 属性</a></h3>
<p>如果在 JSX 中使用的属性不存在于 HTML 的规范中，这个属性会被忽略。如果要使用自定义属性，可以用 data- 前缀。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="022-jsx-渲染-react-元素"><a class="header" href="#022-jsx-渲染-react-元素">02.2-JSX-渲染 React 元素</a></h1>
<h2 id="一-操作-react-元素"><a class="header" href="#一-操作-react-元素">一 操作 React 元素</a></h2>
<h3 id="11-创建-react-元素方法-createelement"><a class="header" href="#11-创建-react-元素方法-createelement">1.1 创建 React 元素方法 createElement()</a></h3>
<p>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。</p>
<p>以下两种示例代码完全等效：</p>
<pre><code class="language-js">// 方式一
const element = &lt;h1 className=&quot;greeting&quot;&gt;Hello, world!&lt;/h1&gt;

// 方式二
const element = React.createElement(
  'h1',
  { className: 'greeting' },
  'Hello, world!'
)
</code></pre>
<p>React.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个类似这样的结构：</p>
<pre><code class="language-js">const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!',
  },
}
</code></pre>
<p>这些对象被称为 “React 元素”。它们描述了你希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。</p>
<p>与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。</p>
<p>贴士：React 元素也可以自定义，这在组件化开发章节中介绍。</p>
<h3 id="12-react-元素渲染为-dom"><a class="header" href="#12-react-元素渲染为-dom">1.2 React 元素渲染为 DOM</a></h3>
<p>我们自己定义的 React 元素最终都会被添加进一个根节点，根节点内的所有内容都将由 React DOM 管理。仅使用 React 构建的应用通常只有单一的根 DOM 节点。如果你在将 React 集成进一个已有应用，那么你可以在应用中包含任意多的独立根 DOM 节点。</p>
<p>想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.createRoot()：</p>
<pre><code class="language-js">const root = ReactDOM.createRoot(document.getElementById('root'))

const element = &lt;h1&gt;Hello, world&lt;/h1&gt;
root.render(element)
</code></pre>
<h3 id="13-更新已渲染的元素"><a class="header" href="#13-更新已渲染的元素">1.3 更新已渲染的元素</a></h3>
<p>React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p>
<p>可以创建一个全新的元素，并将其传入 root.render()，来实现已渲染的元素的更新：</p>
<pre><code class="language-js">const root = ReactDOM.createRoot(document.getElementById('root'))

function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  )
  root.render(element)
}

setInterval(tick, 1000)
</code></pre>
<p>本定时器案例只是演示，在实践中，大多数 React 应用只会调用一次 root.render()，组件的更新应该利用 状态 state！</p>
<h3 id="14-react-只更新它需要更新的部分"><a class="header" href="#14-react-只更新它需要更新的部分">1.4 React 只更新它需要更新的部分</a></h3>
<p>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p>
<p>在 1.3 定时器示例中，尽管每一秒都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，也就是例子中的文本节点。</p>
<p>不过，在实际开发中应该专注于 UI 在任意给定时刻的状态，而不是一视同仁地随着时间修改整个界面。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-组件化开发-组件化思想"><a class="header" href="#031-组件化开发-组件化思想">03.1-组件化开发-组件化思想</a></h1>
<h2 id="一-react-组件创建化开发思想"><a class="header" href="#一-react-组件创建化开发思想">一 React 组件创建化开发思想</a></h2>
<h3 id="11-组件化思想"><a class="header" href="#11-组件化思想">1.1 组件化思想</a></h3>
<p>组件化是指从 UI 界面角度出发，合理重用 UI 组件。如果将一个页面中的业务逻辑放在一起，将会让项目变得难以维护、扩展，将页面拆分为一个个小的功能块，每个功能块具有完全独立的功能，不同功能块之间通过一些方法进行关联，这样更便于扩展、维护。</p>
<p>具体的实现细则：</p>
<pre><code class="language-txt">将一个完整的页面拆分为多个功能块组件，每个组件用于实现页面的一个功能块
每个组件内部可以进一步进行划分为更加细小的组件
</code></pre>
<p>组件化为页面的开发实现了更好的抽象，达到复用效果，任何应用都可以被抽象为一棵组件树：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/../images/mvvm/vue-02.png" alt="组价树" /></p>
<h3 id="12-react-中的组件化"><a class="header" href="#12-react-中的组件化">1.2 react 中的组件化</a></h3>
<p>组件都拥有自己独立的数据、行为，与其他组件之间互相独立，甚至相同组件的不同实例之间也是互相独立的。</p>
<p>react 中定义组件有两种方式：</p>
<ul>
<li>函数式组件：函数式组件只是一个返回 JSX 的简单函数，但是 React16 之前无法使用状态，只能用来作为基础模板使用，在 React16 hooks API 推出后，函数式组件成为主流组件创建方式</li>
<li>类组件：使用 class 语法定义的组件</li>
</ul>
<h3 id="13-创建一个组件"><a class="header" href="#13-创建一个组件">1.3 创建一个组件</a></h3>
<p>创建一个函数式组件：</p>
<pre><code class="language-js">// FuncComponent.js
function FuncComp() {
  return &lt;div&gt;函数组件&lt;/div&gt;
}

export default FuncComp
</code></pre>
<p>创建一个类组件：</p>
<pre><code class="language-js">// ClaComponent.js
import React from 'react'

class ClaComp extends React.Component {
  render() {
    return &lt;div&gt;类组件&lt;/div&gt;
  }
}

export default ClaComp
</code></pre>
<p>在页面中使用组件，下列示例在 App.js 根组件中使用：</p>
<pre><code class="language-js">import React from 'react'

import FuncComp from './components/FuncComp'
import ClaComp from './components/ClaComp'

function App() {
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;FuncComp&gt;&lt;/FuncComp&gt;
      &lt;ClaComp&gt;&lt;/ClaComp&gt;
    &lt;/div&gt;
  )
}

export default App
</code></pre>
<p>类似 <code>&lt;FuncComp&gt;&lt;/FuncComp&gt;</code> 这种自定义的组件也是 React 元素，最终也通过 createElement()方法创建元素。</p>
<p>贴士：</p>
<ul>
<li>组件名称必须以大写字母开头，因为<strong>React 会将以小写字母开头的组件视为原生 DOM 标签</strong>。</li>
<li>通常来说，每个新的 React 应用程序的顶层组件都是 App 组件。</li>
<li>一般推荐将抽取的组件放置在 cli 创建的 components 文件夹中。</li>
<li>组件文件的后缀名可以是 js、jsx、tsx（typescript 支持下的组件文件），一般推荐使用 jsx/tsx 后缀，以区分组件文件与普通 js/ts 文件。</li>
</ul>
<h3 id="14-hooksapi-概念"><a class="header" href="#14-hooksapi-概念">1.4 HooksAPI 概念</a></h3>
<p>在早期版本中，函数式组件无法使用 state，只能作为无状态组件使用，这是因为函数式组件最大的问题是没有 this，即实例对象，这就造成了类组件中很多实例方法无法在函数式组件中得到使用。</p>
<p>Hook 是 React16.8 新增的重要特性，其核心功能是让函数式组件能够使用状态、生命周期等特性，自此 React 的组件不再存在无状态属性这个概念。Hook 的本质其实是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。</p>
<h2 id="二-react-常见问题"><a class="header" href="#二-react-常见问题">二 React 常见问题</a></h2>
<h3 id="21-fragment"><a class="header" href="#21-fragment">2.1 Fragment</a></h3>
<p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点：</p>
<pre><code class="language-js">return (
  &lt;React.Fragment&gt;
    &lt;ChildA /&gt;
    &lt;ChildB /&gt;
    &lt;ChildC /&gt;
  &lt;/React.Fragment&gt;
)
</code></pre>
<p>也可以用更简短的语法来声明 Fragments：</p>
<pre><code class="language-js">return (
  &lt;&gt;
    &lt;ChildA /&gt;
    &lt;ChildB /&gt;
    &lt;ChildC /&gt;
  &lt;/&gt;
)
</code></pre>
<p>不过使用 Fragment 可以指定遍历时的唯一标识 key，而空标签不能书写任何属性：</p>
<pre><code class="language-js">function Glossary(props) {
  return (
    &lt;dl&gt;
      {props.items.map((item) =&gt; (
        // 没有`key`，React 会发出一个关键警告
        &lt;React.Fragment key={item.id}&gt;
          &lt;dt&gt;{item.term}&lt;/dt&gt;
          &lt;dd&gt;{item.description}&lt;/dd&gt;
        &lt;/React.Fragment&gt;
      ))}
    &lt;/dl&gt;
  )
}
</code></pre>
<h3 id="23-使用-css"><a class="header" href="#23-使用-css">2.3 使用 css</a></h3>
<p>推荐使用 <code>import comp1.css</code> 的方式引入 css。在 React 项目中，每个组件都有自己独立的文件夹，往往其自身的 CSS 文件也在其中，这时使用 import 方式引入 css，容易引起组件之间 CSS 冲突，这里 CSS 的引入也可以实现模块化。</p>
<p>实现方式一：如果脚手架目录并未显示 webpack 配置，可以直接在对 css 文件进行重命名为 <code>comp1.module.css</code>。使用方式：</p>
<pre><code class="language-js">import comp1 from './comp1.module.css'

export default class Comp1 extends Component {
  render() {
    return &lt;div className={comp1.box}&gt;hello&lt;/div&gt;
  }
}
</code></pre>
<p>方式二：在 webpack 中开启模块化，开启后使用方式与方式一相同。</p>
<pre><code class="language-json">    {test:/\.css$/, use:['style-loader','css-loader?modules']}
</code></pre>
<p>方式三：直接使用 less 等 css 库。</p>
<p>CSS 引入顺序注意事项：</p>
<ul>
<li>应该在样式导入之后引入组件，以避免样式覆盖问题</li>
<li>我们自己书写的全局样式应该在组件库样式后导入，才会生效、覆盖库里的样式</li>
</ul>
<h3 id="24-图片引入"><a class="header" href="#24-图片引入">2.4 图片引入</a></h3>
<p>若图片位于 public 目录，引入方式为：</p>
<pre><code class="language-html">&lt;img src=&quot;1.jpg&quot; /&gt;
</code></pre>
<p>若图片位于 src 下，如 assets 目录中，引入方式为：</p>
<pre><code class="language-js">import imgA from '../assets/1.jpg'
export default class Demo extends React.Component {
  render(){
    return (
      &lt;div&gt;
        &lt;img src={imgA}&gt;
        &lt;img src={require('../assets/1.jpg')}&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h3 id="25-严格模式"><a class="header" href="#25-严格模式">2.5 严格模式</a></h3>
<p>StrictMode 是一个用来突出显示应用程序中潜在问题的工具，你可以为应用程序的任何部分启用严格模式。一般推荐在根组件开启例如：</p>
<pre><code class="language-js">import React from 'react'

function ExampleApplication() {
  return (
    &lt;div&gt;
      &lt;Header /&gt;
      &lt;React.StrictMode&gt;
        &lt;div&gt;
          &lt;ComponentOne /&gt;
          &lt;ComponentTwo /&gt;
        &lt;/div&gt;
      &lt;/React.StrictMode&gt;
      &lt;Footer /&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。</p>
<p>StrictMode 目前有助于：</p>
<ul>
<li>识别不安全的生命周期</li>
<li>关于使用过时字符串 ref API 的警告</li>
<li>关于使用废弃的 findDOMNode 方法的警告</li>
<li>检测意外的副作用</li>
<li>检测过时的 context API</li>
<li>确保可复用的状态</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="032-组件化开发-state-组件状态"><a class="header" href="#032-组件化开发-state-组件状态">03.2-组件化开发-state 组件状态</a></h1>
<h2 id="一-组件状态-state-概念"><a class="header" href="#一-组件状态-state-概念">一 组件状态 state 概念</a></h2>
<p>在 React 组件<strong>实例</strong>上，挂载了三个重要属性：</p>
<ul>
<li><strong>state</strong>：组件的状态</li>
<li><strong>props</strong>：收集组件的外部数据</li>
<li><strong>refs</strong>：操作组件的 DOM</li>
</ul>
<p>组件的样式、行为等都会因为组件数据的改变而发生改变，维护组件这些数据的对象称为组件的状态（state）。</p>
<p>组件的内部数据称为状态（state），<strong>状态的更改能够驱动视图的变更</strong>。不过状态是无法直接更改的，需要借助 API：<code>setState()</code>。</p>
<h2 id="二-函数式组件的状态"><a class="header" href="#二-函数式组件的状态">二 函数式组件的状态</a></h2>
<h3 id="21-基本写法"><a class="header" href="#21-基本写法">2.1 基本写法</a></h3>
<p>函数式组件在 React16 之前无法使用状态，称为无状态组件，但是 HooksAPI 流行后，useState() 可以让函数式组件使用状态：</p>
<pre><code class="language-js">import React from 'react'

export default function Count(props) {
  // useState 返回是数组，数组的两个元素是：状态值、更新状态的方法
  let [count, setCount] = React.useState(0)

  function add() {
    // 函数式写法：
    // setCount(count =&gt; {
    //     return count + 1
    // })

    // 常规写法：是参数写法的语法糖
    setCount(count + 1)
  }

  return (
    &lt;div&gt;
      状态值：{count}
      &lt;button onClick={add}&gt;点我修改状态&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3 id="22-多个状态写法"><a class="header" href="#22-多个状态写法">2.2 多个状态写法</a></h3>
<pre><code class="language-js">import React from 'react'

export default function Count(props) {
  let [count, setCount] = React.useState(0)
  let [name, setName] = React.useState('Jack')

  function changeCount() {
    setCount(count + 1)
  }

  function changeName() {
    setName('Ross')
  }

  return (
    &lt;div&gt;
      count值：{count}
      &lt;button onClick={changeCount}&gt;点我修改 count&lt;/button&gt;
      &lt;hr /&gt;
      name 值：{name}
      &lt;button onClick={changeName}&gt;点我修改 name&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h2 id="三-类式组件使用状态"><a class="header" href="#三-类式组件使用状态">三 类式组件使用状态</a></h2>
<h3 id="31-类组件使用状态示例"><a class="header" href="#31-类组件使用状态示例">3.1 类组件使用状态示例</a></h3>
<pre><code class="language-js">class Comp extends React.Component {
  constructor(props) {
    super(props)
    // 初始化状态
    this.state = {
      name: 'lisi',
      age: 13,
    }
  }
  change = () =&gt; {
    let { age } = this.state
    age += 1
    // setState 会自动重新 render，而且是异步的！
    this.setState({ age: age })
  }
  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this.change}&gt;点击改变状态&lt;/button&gt;
        &lt;div&gt;组件 state 数据：{this.state.age}&lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>基于 ES6 类的语法，在构造器中书写状态可以如下简写：</p>
<pre><code class="language-js">class Comp extends React.Component {
  state = {
    name: 'lisi',
    age: 13,
  }

  constructor(props) {
    super(props)
  }

  // 其他代码...
}
</code></pre>
<p>贴士：</p>
<ul>
<li>构造函数是唯一可以给 this.state 赋值的地方。</li>
<li>不要在构造函数中调用 setState() 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 this.state 赋值初始 state。</li>
</ul>
<h2 id="四-状态使用细节"><a class="header" href="#四-状态使用细节">四 状态使用细节</a></h2>
<h3 id="41-更新-state-与组件重新渲染"><a class="header" href="#41-更新-state-与组件重新渲染">4.1 更新 state 与组件重新渲染</a></h3>
<p>直接修改 state 不会重新渲染组件，必须依赖对应的状态更新函数，比如类组件中的 <code>setState()</code>，或者函数式组件 HooksAPI useState 产出的 set 函数。</p>
<h3 id="42-state-更新可能是异步的"><a class="header" href="#42-state-更新可能是异步的">4.2 state 更新可能是异步的</a></h3>
<p>react 的状态是异步更新的，比如如下显示了类组件中 change()方法：</p>
<pre><code class="language-js">// state = {
//   name: 'lisi',
//   age: 13,
// }
change = () =&gt; {
  let { age } = this.state
  age += 1
  // setState 会自动重新 render，而且是异步的！
  this.setState({ age: age })
  console.log('count: ', this.state.age) // 不变
}
</code></pre>
<p>正确的写法是 setState 支持第二个参数，是一个 callback，代表状态改变之后执行的函数：</p>
<pre><code class="language-js">// state = {
//   name: 'lisi',
//   age: 13,
// }
change = () =&gt; {
  let { age } = this.state
  age += 1
  // setState 会自动重新 render，而且是异步的！
  this.setState({ age: age }, () =&gt; {
    console.log('count: ', this.state.age) // 不变
  })
}
</code></pre>
<p>callback 是在状态更新、render() 执行之后才执行！</p>
<h3 id="43-state-的更新会被合并"><a class="header" href="#43-state-的更新会被合并">4.3 state 的更新会被合并</a></h3>
<p>调用 setState() 时，React 会把你传入的对象合并到当前的 state。</p>
<pre><code class="language-js">// 初始state
state = {
  posts: [],
  comments: [],
}

// setState
this.setState({
  posts: { info: 'hi' },
})
this.setState({
  comments: [{}, {}],
})
</code></pre>
<p>这里的合并是浅合并，所以 this.setState({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。</p>
<h2 id="五-状态提升"><a class="header" href="#五-状态提升">五 状态提升</a></h2>
<p>通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去，这有利于传值操作。
见 组件传参-父子传值章节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="033-组件化开发-props-接受参数"><a class="header" href="#033-组件化开发-props-接受参数">03.3-组件化开发-props 接受参数</a></h1>
<h2 id="一-props-概念"><a class="header" href="#一-props-概念">一 props 概念</a></h2>
<p>props 属性用于接收外部传入组件的数据。当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。</p>
<p>示例如下：</p>
<pre><code class="language-js">&lt;HelloWorld msg={data}&gt;&lt;/HelloWorld&gt;
</code></pre>
<p>react 组件内可以引用其他组件，这就形成了组件树，下层组件可以利用 props 来使用上层组件传递过来的数据，所以 props 数据对当前组件来说是只读的，如果要修改 props 数据，只能由其父组件修改。</p>
<h2 id="二-props-使用示例"><a class="header" href="#二-props-使用示例">二 props 使用示例</a></h2>
<pre><code class="language-js">// 外部向组件内部传递数据示例
function App() {
  let data = 'lisi'
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;FuncComp name={data}&gt;&lt;/FuncComp&gt;
      &lt;ClasComp name={data}&gt;&lt;/ClasComp&gt;
    &lt;/div&gt;
  )
}

// 函数组件接收数据
function FuncComp(props) {
  return &lt;div&gt;传递过来的数据：{props.name}&lt;/div&gt;
}

// 类组件接收数据
class ClaComp extends React.Component {
  constructor(props) {
    super(props)
  }
  render() {
    return &lt;div&gt;组件 props 数据：{this.props.name}&lt;/div&gt;
  }
}
</code></pre>
<h2 id="三-props-使用注意事项"><a class="header" href="#三-props-使用注意事项">三 props 使用注意事项</a></h2>
<h3 id="31-props-默认值"><a class="header" href="#31-props-默认值">3.1 props 默认值</a></h3>
<p>类组件设定默认值：</p>
<pre><code class="language-js">// 方式一：浏览器编译以后才会生效
class ClaComp extends React.Component {
    static defaultProps = {
        name: 'ryj',
    }
    constructor(props) {
        super(props)
    }
    render() {
        return &lt;div&gt;组件 props 数据：{this.props.name}&lt;/div&gt;
    }
}

// 方式二：一直生效
ClaComp。defaultProps = {
    name: 'yy'
}
</code></pre>
<p>函数类型组件定默认值：</p>
<pre><code class="language-js">function FuncComp(props) {
  // 若参数 props 无 name 属性，则显示默认属性值
  return &lt;div&gt;默认数据：{props.name}&lt;/div&gt;
}

FuncComp.defaultProps = {
  name: 'zs',
}
</code></pre>
<p>贴士：在 React15 版本及其之前，默认参数使用 <code>||</code>方式，如下所示：</p>
<pre><code class="language-js">props.name = props.name || '默认值'
</code></pre>
<h3 id="32-批量传递标签属性-props"><a class="header" href="#32-批量传递标签属性-props">3.2 批量传递标签属性 props</a></h3>
<p>传递多个参数时可以使用 ES6 的扩展运算符：</p>
<pre><code class="language-js">// 传递 name、age
let data = {
  name: 'lisi',
  age: 30,
}

// 传递方式
;&lt;Comp {...data}&gt;&lt;/Comp&gt;
</code></pre>
<h3 id="33-props-验证"><a class="header" href="#33-props-验证">3.3 props 验证</a></h3>
<p>props 验证用来验证传递的数据类型是否符合要求。验证不会对运行产生影响，而是会在控制台打印错误信息，推荐在生产环境中取消 props 验证。</p>
<p>使用 props 验证需要先下载 prop-types 包：</p>
<pre><code class="language-txt">npm i prop-types -S
</code></pre>
<p>验证示例：</p>
<pre><code class="language-js">import PropTypes from 'prop-types'

// 类组件属性验证示例
class Comp extends React.Component {
  // 类型限制
  static propTypes = {
    name: PropTypes.string,
    age: PropTypes.number,
    info: PropTypes.func,
  }
}

// 函数组件属性验证示例
function FuncComp(props) {
  return &lt;div&gt;默认数据：{props.name}&lt;/div&gt;
}
FuncComp.propTypes = {
  name: PropTypes.string,
  age: PropTypes.number,
  info: PropTypes.func,
}
</code></pre>
<h3 id="34-构造器中的-props"><a class="header" href="#34-构造器中的-props">3.4 构造器中的 props</a></h3>
<p>构造器 props 的书写与否并不会影响组件的创建于使用，但是构造器只有接受了 props，且使用<code>super(props)</code>，组件的实例才能获取到 props，该用方法几乎用不到。</p>
<h2 id="四-传参特性"><a class="header" href="#四-传参特性">四 传参特性</a></h2>
<h2 id="41-纯函数与-props-只读性"><a class="header" href="#41-纯函数与-props-只读性">4.1 纯函数与 props 只读性</a></h2>
<p>下面的函数被称为“纯函数”，因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。</p>
<pre><code class="language-js">function sum(a, b) {
  return a + b
}
</code></pre>
<p>相反，下面这个函数则不是纯函数，因为它更改了自己的入参：</p>
<pre><code class="language-js">function withdraw(account, amount) {
  account.total -= amount
}
</code></pre>
<p>React 有个严格规则：<strong>组件不允许修改自己的接收的 props，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改</strong> 。</p>
<h2 id="42-数据是向下流动的"><a class="header" href="#42-数据是向下流动的">4.2 数据是向下流动的</a></h2>
<p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中：</p>
<pre><code class="language-js">&lt;FormattedDate date={this.state.date} /&gt;
</code></pre>
<p>FormattedDate 组件会在其 props 中接收参数 date，但是组件本身无法知道它是来自于 父组件 的 state，或是 父组件 的 props，还是手动输入的：</p>
<pre><code class="language-js">function FormattedDate(props) {
  return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;
}
</code></pre>
<p>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p>
<p>如果把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。</p>
<p>这样做用来保证：state 作为局部封装后，组件与组件之间完全独立。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="034-组件化开发-refs-获取原生-dom"><a class="header" href="#034-组件化开发-refs-获取原生-dom">03.4-组件化开发-refs 获取原生 DOM</a></h1>
<h2 id="一-refs-概念"><a class="header" href="#一-refs-概念">一 Refs 概念</a></h2>
<p>MVVM 框架推崇以数据来驱动界面更新，而不是直接操作 DOM，但是 React 官方还是提供了 refs 属性，用来直接操作 DOM。</p>
<p>在原生 JS 中，使用 id、class 等属性标识元素，即可操作该 DOM，在 React 中可以使用 <code>ref</code> 来标识 JSX 中的元素，组件会将标识了 ref 的元素收集到自身的 refs 属性中，开发者便可以操作对应 DOM 了，而且这里获取到的是真实 DOM！</p>
<p>不过官方仍然不推荐大量使用 ref，这会导致当前页面绑定的耦合度过高，不利于后期扩展，维护。</p>
<p>下面是几个适合使用 refs 的情况：</p>
<ul>
<li>管理焦点，文本选择或媒体播放。</li>
<li>触发强制动画。</li>
<li>集成第三方 DOM 库。</li>
<li>避免使用 refs 来做任何可以通过声明式实现来完成的事情。如：避免在 Dialog 组件里暴露 open() 和 close() 方法，最好传递 isOpen 属性。</li>
</ul>
<h2 id="二-refs-的使用"><a class="header" href="#二-refs-的使用">二 Refs 的使用</a></h2>
<h3 id="21-类组件使用-refs"><a class="header" href="#21-类组件使用-refs">2.1 类组件使用 Refs</a></h3>
<p>React16.3 提供了新的 refs 使用方式，即 React.createRef()，推荐使用该方式创建 refs：</p>
<pre><code class="language-js">class Comp extends React.Component {
  constructor(props) {
    super(props)
    this.myRef = React.createRef()
  }
  render() {
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; ref={this.myRef} /&gt;
        &lt;button
          onClick={() =&gt; {
            console.log(this.myRef.current.value)
            this.myRef.current.focus() // 可以用来获取焦点
          } }
        &gt;
          点击获取当前 input 数据
        &lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>在组件、DOM 节点上使用字符串直接标识元素，但是该方式已经不被 React 官方推荐：</p>
<pre><code class="language-js">class Comp extends React.Component {
  showRefs = () =&gt; {
    console.log(this.refs)
    console.log(this.refs.input1.value)
  }
  render() {
    return (
      &lt;div&gt;
        &lt;input ref=&quot;input1&quot; type=&quot;text&quot; /&gt;
        &lt;input ref=&quot;input2&quot; type=&quot;password&quot; /&gt;
        &lt;button onClick={this.showRefs}&gt;点击获取 refs&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>使用回调函数方式也可以替换字符串方式：</p>
<pre><code class="language-js">class Comp extends React.Component {
  cb = (c) =&gt; {
    console.log('被调用，c:', c) // c 为 input
    this.input1 = c
  }
  showRefs = () =&gt; {
    const { input1 } = this
    console.log(input1.value)
  }
  render() {
    return (
      &lt;div&gt;
        {/*&lt;input ref={c=&gt;this.input1 = c;console.log('被调用，c:',c)} type=&quot;text&quot; /&gt;*/}
        &lt;input ref={this.cb} type=&quot;text&quot; /&gt;
        &lt;button onClick={this.showRefs}&gt;点击获取 refs&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>上述的回调函数在页面被加载时，就会被调用一次，即输出：<code>被调用，c:</code>。</p>
<p>注意：如果 ref 是以内联函数形式存在，在以后组件<strong>再更新</strong>时会执行两次，第一次传入的是 null，第二次传入的是元素对象。因为每次渲染时会创建一个新的函数实例，所以 React 会清空旧的 ref 并且设置新的，上述直接书写的方式可以解决该问题。</p>
<h3 id="22-函数式组件使用-refs"><a class="header" href="#22-函数式组件使用-refs">2.2 函数式组件使用 Refs</a></h3>
<p>默认情况下，你不能在函数组件上使用 ref 属性，因为它们没有实例。如果要在函数组件中使用 ref，你可以使用 forwardRef（可与 useImperativeHandle 结合使用），或者可以将该组件转化为 class 组件。</p>
<p>如果 ref 属性指向一个 DOM 元素或 class 组件，则可以使用：</p>
<pre><code class="language-js">function CustomTextInput(props) {
  // 这里必须声明 textInput，这样 ref 才可以引用它
  const textInput = useRef(null)

  function handleClick() {
    textInput.current.focus()
  }

  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; ref={textInput} /&gt;
      &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={handleClick} /&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3 id="23-将-dom-refs-暴露给父组件"><a class="header" href="#23-将-dom-refs-暴露给父组件">2.3 将 DOM Refs 暴露给父组件</a></h3>
<p>在极少数情况下，可能希望在父组件中引用子节点的 DOM 节点。通常不建议这样做，因为它会打破组件的封装，但它偶尔可用于触发焦点或测量子 DOM 节点的大小或位置。虽然可以向子组件添加 ref，但这不是一个理想的解决方案，因为你只能获取组件实例而不是 DOM 节点。并且，它还在函数组件上无效。如果你使用 16.3 或更高版本的 React, 这种情况下我们推荐使用 ref 转发。Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref。如果你使用 16.2 或更低版本的 React，或者你需要比 ref 转发更高的灵活性，你可以使用这个替代方案将 ref 作为特殊名字的 prop 直接传递。可能的话，我们不建议暴露 DOM 节点，但有时候它会成为救命稻草。注意这个方案需要你在子组件中增加一些代码。如果你对子组件的实现没有控制权的话，你剩下的选择是使用 findDOMNode()，但在严格模式 下已被废弃且不推荐使用。</p>
<h2 id="三-refs-转发"><a class="header" href="#三-refs-转发">三 Refs 转发</a></h2>
<h3 id="31-refs-转发示例"><a class="header" href="#31-refs-转发示例">3.1 Refs 转发示例</a></h3>
<p>Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。</p>
<p>Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件。</p>
<pre><code class="language-js">const FancyButton = React.forwardRef((props, ref) =&gt; (
  &lt;button ref={ref}&gt;{props.children}&lt;/button&gt;
))

// 你可以直接获取 DOM button 的 ref：
function Demo() {
  const ref = React.createRef()
  return &lt;FancyButton ref={ref}&gt;Click me!&lt;/FancyButton&gt;
}
</code></pre>
<p>这样，使用 FancyButton 的组件可以获取底层 DOM 节点 button 的 ref ，并在必要时访问，就像其直接使用 DOM button 一样。</p>
<p>以下是对上述示例发生情况的逐步解释：</p>
<ul>
<li>通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。</li>
<li>通过指定 ref 为 JSX 属性，将其向下传递给 <code>&lt;FancyButton ref={ref}&gt;</code>。</li>
<li>React 传递 ref 给 forwardRef 内函数 (props, ref) =&gt; ...，作为其第二个参数。</li>
<li>向下转发该 ref 参数到 <code>&lt;button ref={ref}&gt;</code>，将其指定为 JSX 属性。</li>
<li>当 ref 挂载完成，ref.current 将指向 <code>&lt;button&gt;</code> DOM 节点。</li>
</ul>
<p>注意：第二个参数 ref 只在使用 React.forwardRef 定义组件时存在。常规函数和 class 组件不接收 ref 参数，且 props 中也不存在 ref。Ref 转发不仅限于 DOM 组件，你也可以转发 refs 到 class 组件实例中。</p>
<h3 id="32-组件库维护者的注意事项"><a class="header" href="#32-组件库维护者的注意事项">3.2 组件库维护者的注意事项</a></h3>
<p>当你开始在组件库中使用 forwardRef 时，你应当将其视为一个破坏性更改，并发布库的一个新的主版本。 这是因为你的库可能会有明显不同的行为（例如 refs 被分配给了谁，以及导出了什么类型），并且这样可能会导致依赖旧行为的应用和其他库崩溃。</p>
<p>出于同样的原因，当 React.forwardRef 存在时有条件地使用它也是不推荐的：它改变了你的库的行为，并在升级 React 自身时破坏用户的应用。</p>
<h3 id="33-在高阶组件中转发-refs"><a class="header" href="#33-在高阶组件中转发-refs">3.3 在高阶组件中转发 Refs</a></h3>
<p>在高阶组件中转发 refs 特别有用：</p>
<pre><code class="language-js">function logProps(WrappedComponent) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps)
      console.log('new props:', this.props)
    }

    render() {
      return &lt;WrappedComponent {...this.props} /&gt;
    }
  }

  return LogProps
}
</code></pre>
<p>“logProps” HOC 透传（pass through）所有 props 到其包裹的组件，所以渲染结果将是相同的。例如：我们可以使用该 HOC 记录所有传递到 “fancy button” 组件的 props：</p>
<pre><code class="language-js">class FancyButton extends React.Component {
  focus() {
    // ...
  }

  // ...
}

// 我们导出 LogProps，而不是 FancyButton。
// 虽然它也会渲染一个 FancyButton。
export default logProps(FancyButton)
</code></pre>
<p>下面的示例有一点需要注意：refs 将不会透传下去。这是因为 ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。</p>
<p>这意味着用于我们 FancyButton 组件的 refs 实际上将被挂载到 LogProps 组件：</p>
<pre><code class="language-js">import FancyButton from './FancyButton'

const ref = React.createRef()

// 我们导入的 FancyButton 组件是高阶组件（HOC）LogProps。
// 尽管渲染结果将是一样的，
// 但我们的 ref 将指向 LogProps 而不是内部的 FancyButton 组件！
// 这意味着我们不能调用例如 ref.current.focus() 这样的方法
;&lt;FancyButton label=&quot;Click Me&quot; handleClick={handleClick} ref={ref} /&gt;
</code></pre>
<p>幸运的是，我们可以使用 React.forwardRef API 明确地将 refs 转发到内部的 FancyButton 组件。React.forwardRef 接受一个渲染函数，其接收 props 和 ref 参数并返回一个 React 节点。例如：</p>
<pre><code class="language-js">function logProps(Component) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps)
      console.log('new props:', this.props)
    }

    render() {
      const { forwardedRef, ...rest } = this.props

      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref
      return &lt;Component ref={forwardedRef} {...rest} /&gt;
    }
  }

  // 注意 React.forwardRef 回调的第二个参数 “ref”。
  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”
  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。
  return React.forwardRef((props, ref) =&gt; {
    return &lt;LogProps {...props} forwardedRef={ref} /&gt;
  })
}
</code></pre>
<h3 id="34-在-devtools-中显示自定义名称"><a class="header" href="#34-在-devtools-中显示自定义名称">3.4 在 DevTools 中显示自定义名称</a></h3>
<p>React.forwardRef 接受一个渲染函数。React DevTools 使用该函数来决定为 ref 转发组件显示的内容。</p>
<p>例如，以下组件将在 DevTools 中显示为 “ForwardRef”：</p>
<pre><code class="language-js">const WrappedComponent = React.forwardRef((props, ref) =&gt; {
  return &lt;LogProps {...props} forwardedRef={ref} /&gt;
})
</code></pre>
<p>如果你命名了渲染函数，DevTools 也将包含其名称（例如 “ForwardRef(myFunction)”）：</p>
<pre><code class="language-js">const WrappedComponent = React.forwardRef(function myFunction(props, ref) {
  return &lt;LogProps {...props} forwardedRef={ref} /&gt;
})
</code></pre>
<p>你甚至可以设置函数的 displayName 属性来包含被包裹组件的名称：</p>
<pre><code class="language-js">function logProps(Component) {
  class LogProps extends React.Component {
    // ...
  }

  function forwardRef(props, ref) {
    return &lt;LogProps {...props} forwardedRef={ref} /&gt;
  }

  // 在 DevTools 中为该组件提供一个更有用的显示名。
  // 例如 “ForwardRef(logProps(MyComponent))”
  const name = Component.displayName || Component.name
  forwardRef.displayName = `logProps(${name})`

  return React.forwardRef(forwardRef)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-常见操作-事件处理"><a class="header" href="#041-常见操作-事件处理">04.1-常见操作-事件处理</a></h1>
<h2 id="一-基本事件操作"><a class="header" href="#一-基本事件操作">一 基本事件操作</a></h2>
<h3 id="11-绑定事件"><a class="header" href="#11-绑定事件">1.1 绑定事件</a></h3>
<p>React 推荐使用行内直接绑定的方式，其事件命采用小驼峰式（camelCase）：</p>
<pre><code class="language-js">function Demo() {
  const handleClick = (e) =&gt; {
    console.log('click--', e.target)
  }

  return &lt;div onClick={handleClick}&gt;demo&lt;/div&gt;
}
</code></pre>
<p>在类组件中，通常的做法是将事件处理函数声明为 class 中的方法：</p>
<pre><code class="language-js">class Demo extends React.Component {
  handleClick(e) {
    console.log('click--', e.target)
  }
  render() {
    return &lt;div onClick={this.handleClick}&gt;demo&lt;/div&gt;
  }
}
</code></pre>
<p>如果和原生绑定事件一致，行内也采用类似这样的写法： <code>onClick={handleClick()}</code>，那么就会出现 handleClick 被调用两次的现象，且绑定的事件变成 handleClick 的返回值，所以一般不这样做。</p>
<p>贴士：React 通过<code>onXX</code> 方式指定事件处理函数，React 事件与原生事件不完全相同，是 React 通过事件委托方式处理的（委托给最外层元素）。e 也是一个合成事件，不需要考虑兼容性，通过 <code>event.target</code> 可以得到事件的原生 DOM 元素。</p>
<h3 id="12-阻止默认行为"><a class="header" href="#12-阻止默认行为">1.2 阻止默认行为</a></h3>
<p>React 中阻止 DOM 默认行为需要通过事件对象提供的方法实现：</p>
<pre><code class="language-js">function Form() {
  function handleSubmit(e) {
    e.preventDefault()
    console.log('You clicked submit.')
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  )
}
</code></pre>
<h2 id="二-类组件事件的-this-指向问题"><a class="header" href="#二-类组件事件的-this-指向问题">二 类组件事件的 this 指向问题</a></h2>
<h3 id="21-事件函数中的-this-为-undefined"><a class="header" href="#21-事件函数中的-this-为-undefined">2.1 事件函数中的 this 为 undefined</a></h3>
<p>如下所示：handleClick() 中的 this 是 undefined。</p>
<pre><code class="language-js">class Demo extends React.Component {
  state = {
    num: 0,
  }
  handleClick() {
    let { num } = this.state
    num += 1
    this.setState({ num: num })
  }
  render() {
    return &lt;div onClick={this.handleClick}&gt;{this.state.num}&lt;/div&gt;
  }
}
</code></pre>
<p>如果我们在构造器、render() 内部的打印 this，发现 this 都是 Demo 对象的实例，但是在事件方法中打印 this 却是 undefined，这是因为，这些方法不是用实例调用的，调用者是 window。</p>
<p>在类 Title 中，构造器、render() 内部的 this 都是实例对象本身，但是在 test() 中却是 undefined 的！！这是因为前者都是通过实例调用的，而 test() 的调用者是 window！</p>
<p>其类似原理如下示例：</p>
<pre><code class="language-js">class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  info() {
    console.log(this)
  }
}

const p = new Person('Jack', 18)
p.info() // 正确输出 this 实例

const o = p.info
o() // undefined
</code></pre>
<p><code>info()</code> 方法是放置在 Person 的原型上的，Person 实例并没有 <code>info()</code>方法，使用实例调用<code>p.info()</code>是顺着原型链找到了原型上的方法进行调用的。而 <code>const o = p.info</code> 赋值语句中，<code>p.info</code>并没有调用 <code>info()</code>方法，而是简单赋值，故而是 undefined。</p>
<p>同理，组件中自定义方法默认并不是由组件实例调用，而是作为事件的回调在使用！！这就造成了自定义方法的 this 可能是全局的 window，但是组件中的方法也默认开启了局部的严格模式，所以下列示例函数<code>fn()</code>中的 this 默认是 undefined。</p>
<h3 id="22-解决方案一箭头函数"><a class="header" href="#22-解决方案一箭头函数">2.2 解决方案一：箭头函数</a></h3>
<p>由于箭头函数中的 this 是其定义的地方，所以可以修改事件函数为箭头函数方式：</p>
<pre><code class="language-js">handleClick = () =&gt; {
  let { num } = this.state
  num += 1
  this.setState({ num: num })
}
</code></pre>
<h3 id="23-解决方案二bind"><a class="header" href="#23-解决方案二bind">2.3 解决方案二：bind</a></h3>
<p>bind 可以绑定函数调用对象，所以事件方法调用时可以指定调用者：</p>
<pre><code class="language-js">render() {
    return &lt;div onClick={this.handleClick.bind(this)}&gt;{ this.state.num}&lt;/div&gt;
}
</code></pre>
<p>也可以在构造器中直接绑定：</p>
<pre><code class="language-js">constructor(props) {
  super(props)
  this.handleClick = this.handleClick.bind(this)
}
</code></pre>
<h2 id="三-向事件处理程序传递参数"><a class="header" href="#三-向事件处理程序传递参数">三 向事件处理程序传递参数</a></h2>
<p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 id 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：</p>
<pre><code class="language-js">&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;
&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;
</code></pre>
<p>上述两种方式是等价的，分别通过箭头函数和 Function.prototype.bind 来实现。</p>
<p>在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<h2 id="四-通过-portal-与事件冒泡"><a class="header" href="#四-通过-portal-与事件冒泡">四 通过 Portal 与事件冒泡</a></h2>
<h3 id="41-portal-用法"><a class="header" href="#41-portal-用法">4.1 Portal 用法</a></h3>
<p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案：</p>
<pre><code class="language-js">// 参数一：child，是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment。
// 参数二：container是一个 DOM 元素

ReactDOM.createPortal(child, container)
</code></pre>
<p>通常来说 render 方法返回一个元素时，该元素将被挂载到 DOM 节点中离其最近的父节点，但是有时候将也有需求需要将子元素插入到 DOM 节点中的不同位置：</p>
<pre><code class="language-js">render() {
  // React 并*没有*创建一个新的 div。它只是把子元素渲染到 `domNode` 中。
  // `domNode` 是一个可以在任何位置的有效 DOM 节点。
  return ReactDOM.createPortal(
    this.props.children,
    domNode
  );
}
</code></pre>
<p>portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。</p>
<h3 id="42-通过-portal-实现事件冒泡"><a class="header" href="#42-通过-portal-实现事件冒泡">4.2 通过 Portal 实现事件冒泡</a></h3>
<p>尽管 portal 可以被放置在 DOM 树中的任何地方，但在任何其他方面，其行为和普通的 React 子节点行为一致。由于 portal 仍存在于 React 树， 且与 DOM 树 中的位置无关，那么无论其子节点是否是 portal，像 context 这样的功能特性都是不变的。这包含事件冒泡。一个从 portal 内部触发的事件会一直冒泡至包含 React 树的祖先，即便这些元素并不是 DOM 树 中的祖先。假设存在如下 HTML 结构：</p>
<pre><code class="language-js">&lt;html&gt;
  &lt;body&gt;
    &lt;div id=&quot;app-root&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;modal-root&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在 #app-root 里的 Parent 组件能够捕获到未被捕获的从兄弟节点 #modal-root 冒泡上来的事件：</p>
<pre><code class="language-js">// 在 DOM 中有两个容器是兄弟级 （siblings）
const appRoot = document.getElementById('app-root')
const modalRoot = document.getElementById('modal-root')

class Modal extends React.Component {
  constructor(props) {
    super(props)
    this.el = document.createElement('div')
  }

  componentDidMount() {
    // 在 Modal 的所有子元素被挂载后，
    // 这个 portal 元素会被嵌入到 DOM 树中，
    // 这意味着子元素将被挂载到一个分离的 DOM 节点中。
    // 如果要求子组件在挂载时可以立刻接入 DOM 树，
    // 例如衡量一个 DOM 节点，
    // 或者在后代节点中使用 ‘autoFocus’，
    // 则需添加 state 到 Modal 中，
    // 仅当 Modal 被插入 DOM 树中才能渲染子元素。
    modalRoot.appendChild(this.el)
  }

  componentWillUnmount() {
    modalRoot.removeChild(this.el)
  }

  render() {
    return ReactDOM.createPortal(this.props.children, this.el)
  }
}

class Parent extends React.Component {
  constructor(props) {
    super(props)
    this.state = { clicks: 0 }
    this.handleClick = this.handleClick.bind(this)
  }

  handleClick() {
    // 当子元素里的按钮被点击时，
    // 这个将会被触发更新父元素的 state，
    // 即使这个按钮在 DOM 中不是直接关联的后代
    this.setState((state) =&gt; ({
      clicks: state.clicks + 1,
    }))
  }

  render() {
    return (
      &lt;div onClick={this.handleClick}&gt;
        &lt;p&gt;Number of clicks: {this.state.clicks}&lt;/p&gt;
        &lt;p&gt;
          Open up the browser DevTools to observe that the button is not a child
          of the div with the onClick handler.
        &lt;/p&gt;
        &lt;Modal&gt;
          &lt;Child /&gt;
        &lt;/Modal&gt;
      &lt;/div&gt;
    )
  }
}

function Child() {
  // 这个按钮的点击事件会冒泡到父元素
  // 因为这里没有定义 'onClick' 属性
  return (
    &lt;div className=&quot;modal&quot;&gt;
      &lt;button&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  )
}

const root = ReactDOM.createRoot(appRoot)
root.render(&lt;Parent /&gt;)
</code></pre>
<p>在父组件里捕获一个来自 portal 冒泡上来的事件，使之能够在开发时具有不完全依赖于 portal 的更为灵活的抽象。例如，如果你在渲染一个 <Modal /> 组件，无论其是否采用 portal 实现，父组件都能够捕获其事件。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="042-常见操作-条件渲染"><a class="header" href="#042-常见操作-条件渲染">04.2-常见操作-条件渲染</a></h2>
<h3 id="11-if-判断"><a class="header" href="#11-if-判断">1.1 if 判断</a></h3>
<p>使用条件判断，可以依据不同的数据或者状态，只渲染对应内容，而不是完整的渲染：</p>
<pre><code class="language-js">function UserGreeting(props) {
  return &lt;h1&gt;Welcome back!&lt;/h1&gt;
}

function GuestGreeting(props) {
  return &lt;h1&gt;Please sign up.&lt;/h1&gt;
}

function Greeting(props) {
  const isLogged = props.isLogged
  if (isLogged) {
    return &lt;UserGreeting /&gt;
  }
  return &lt;GuestGreeting /&gt;
}
</code></pre>
<p>如果需要阻止渲染还可以这样做：</p>
<pre><code class="language-js">function Greeting(props) {
  const isLogged = props.isLogged
  if (!isLogged) {
    return null
  }
  return &lt;UserGreeting /&gt;
}
</code></pre>
<h3 id="12-变量存储"><a class="header" href="#12-变量存储">1.2 变量存储</a></h3>
<p>还可以使用一个变量对元素进行存储，判断使用该变量：</p>
<pre><code class="language-js">function UserGreeting(props) {
  return &lt;h1&gt;Welcome back!&lt;/h1&gt;
}

function GuestGreeting(props) {
  return &lt;h1&gt;Please sign up.&lt;/h1&gt;
}

function Demo() {
  const [isLogged, setIsLogged] = useState(false)
  let greet
  if (isLogged) {
    greet = &lt;UserGreeting&gt;&lt;/UserGreeting&gt;
  } else {
    greet = &lt;GuestGreeting&gt;&lt;/GuestGreeting&gt;
  }

  return &lt;div&gt;{greet}&lt;/div&gt;
}
</code></pre>
<h3 id="13-与运算符"><a class="header" href="#13-与运算符">1.3 与运算符</a></h3>
<p>逻辑与 (&amp;&amp;) 运算符 可以在前者条件成立时，直接渲染后面的 jsx 语句：</p>
<pre><code class="language-js">function Demo(props) {
  const unreadMessages = ['React', 'Re: React', 'Re:Re: React']
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello!&lt;/h1&gt;
      {unreadMessages.length &gt; 0 &amp;&amp; (
        &lt;h2&gt;You have {unreadMessages.length} unread messages.&lt;/h2&gt;
      )}
    &lt;/div&gt;
  )
}
</code></pre>
<h3 id="14-三元运算符"><a class="header" href="#14-三元运算符">1.4 三元运算符</a></h3>
<p>示例：</p>
<pre><code class="language-js">render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    &lt;div&gt;
      The user is &lt;b&gt;{isLoggedIn ? 'currently' : 'not'}&lt;/b&gt; logged in.
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="二-阻止条件渲染"><a class="header" href="#二-阻止条件渲染">二 阻止条件渲染</a></h2>
<p>在极少数情况下，可能需要隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。</p>
<p>下面的示例中，<WarningBanner /> 会根据 prop 中 warn 的值来进行条件渲染。如果 warn 的值是 false，那么组件则不会渲染:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="043-常见操作-列表渲染"><a class="header" href="#043-常见操作-列表渲染">04.3-常见操作-列表渲染</a></h1>
<h2 id="一-数组数据到-dom-列表的转换"><a class="header" href="#一-数组数据到-dom-列表的转换">一 数组数据到 DOM 列表的转换</a></h2>
<p>使用 map()可以将数组的数据转换为一个新的列表：</p>
<pre><code class="language-js">const numbers = [1, 2, 3, 4, 5]
const doubled = numbers.map((number) =&gt; number * 2)
console.log(doubled) // [2, 4, 6, 8, 10]
</code></pre>
<p>在 React 中，也是通过类似过程实现的多组件渲染：</p>
<pre><code class="language-js">function NumberList() {
  const numbers = [1, 2, 3, 4, 5]
  // 生成 li 列表
  const lists = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;)

  // 将 li 列表加入ul中
  return &lt;ul&gt;{lists}&lt;/ul&gt;
}
</code></pre>
<p>此时会报出一个警告：a key should be provided for lists。解决办法就是加入一个特殊的 key，如下所示：</p>
<pre><code class="language-js">function NumberList() {
  const numbers = [1, 2, 3, 4, 5]
  // 生成 li 列表
  const lists = numbers.map((number) =&gt; (
    &lt;li key={number.toString()}&gt;{number}&lt;/li&gt;
  ))

  // 将 li 列表加入ul中
  return &lt;ul&gt;{lists}&lt;/ul&gt;
}
</code></pre>
<p>JSX 允许在大括号中嵌入任何表达式，所以我们可以内联 map() 返回的结果：</p>
<pre><code class="language-js">function ListItem(props) {
  return &lt;li&gt;{props.value}&lt;/li&gt;
}

function NumberList() {
  const numbers = [1, 2, 3, 4, 5]
  return (
    &lt;ul&gt;
      {numbers.map((number) =&gt; (
        &lt;ListItem key={number.toString()} value={number} /&gt;
      ))}
    &lt;/ul&gt;
  )
}
</code></pre>
<h2 id="二-key-的使用"><a class="header" href="#二-key-的使用">二 key 的使用</a></h2>
<h3 id="20-key-的作用"><a class="header" href="#20-key-的作用">2.0 key 的作用</a></h3>
<p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</p>
<h3 id="21-key-选择规范"><a class="header" href="#21-key-选择规范">2.1 key 选择规范</a></h3>
<p>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key。如果没有 id，也依然不推荐使用循环的索引 index，因为这会做会带来性能问题，以及组件状态问题。</p>
<h3 id="22-key-的就近使用"><a class="header" href="#22-key-的就近使用">2.2 key 的就近使用</a></h3>
<p>元素的 key 只有放在就近的数组上下文中才有意义，<strong>一般推荐在 map() 方法中的元素需要设置 key 属性</strong>。</p>
<p>下面是错误的示例：</p>
<pre><code class="language-js">function ListItem(props) {
  const value = props.value
  return (
    // 错误！你不需要在这里指定 key：
    &lt;li key={value.toString()}&gt;{value}&lt;/li&gt;
  )
}

function NumberList(props) {
  const numbers = props.numbers
  const listItems = numbers.map((number) =&gt; (
    // 错误！元素的 key 应该在这里指定：
    &lt;ListItem value={number} /&gt;
  ))
  return &lt;ul&gt;{listItems}&lt;/ul&gt;
}
</code></pre>
<p>这是正确的示例：</p>
<pre><code class="language-js">function ListItem(props) {
  // 正确！这里不需要指定 key：
  return &lt;li&gt;{props.value}&lt;/li&gt;
}

function NumberList(props) {
  const numbers = props.numbers
  const listItems = numbers.map((number) =&gt; (
    // 正确！key 应该在数组的上下文中被指定
    &lt;ListItem key={number.toString()} value={number} /&gt;
  ))
  return &lt;ul&gt;{listItems}&lt;/ul&gt;
}
</code></pre>
<h3 id="23-key-值在兄弟节点之间必须唯一"><a class="header" href="#23-key-值在兄弟节点之间必须唯一">2.3 key 值在兄弟节点之间必须唯一</a></h3>
<p>数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值：</p>
<pre><code class="language-js">function Blog() {
  const posts = [
    { id: 1, title: 'Hello World', content: 'Welcome to learning React!' },
    {
      id: 2,
      title: 'Installation',
      content: 'You can install React from npm.',
    },
  ]

  const sidebar = (
    &lt;ul&gt;
      {posts.map((post) =&gt; (
        &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  )
  const content = posts.map((post) =&gt; (
    &lt;div key={post.id}&gt;
      &lt;h3&gt;{post.title}&lt;/h3&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
    &lt;/div&gt;
  ))
  return (
    &lt;div&gt;
      {sidebar}
      &lt;hr /&gt;
      {content}
    &lt;/div&gt;
  )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="044-常见操作-表单与受控组件"><a class="header" href="#044-常见操作-表单与受控组件">04.4-常见操作-表单与受控组件</a></h1>
<h2 id="一-受控组件"><a class="header" href="#一-受控组件">一 受控组件</a></h2>
<p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p>
<p>在受控组件中，输入的值始终由 React 的 state 驱动，组件渲染出的状态与它的 value 或 checked prop 相对应。React 通过这种方式消除了组件的局部状态，使得应用的整个状态更加可控。例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：</p>
<pre><code class="language-js">function Demo() {
  const [value, setValue] = useState('')
  const handleChange = (e) =&gt; {
    setValue(e.target.value)
  }
  const handleSubmit = (e) =&gt; {
    console.log('提交的名字: ', value)
    e.preventDefault()
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label&gt;
        名字:
        &lt;input type=&quot;text&quot; value={value} onChange={handleChange} /&gt;
      &lt;/label&gt;
      &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
    &lt;/form&gt;
  )
}
</code></pre>
<p>总结下 React 受控组件更新 state 的流程：</p>
<ul>
<li>(1) 可以通过在初始 state 中设置表单的默认值。</li>
<li>(2) 每当表单的值发生变化时，调用 onChange 事件处理器。</li>
<li>(3) 事件处理器通过合成事件对象 e 拿到改变后的状态，并更新应用的 state。</li>
<li>(4) setState 触发视图的重新渲染，完成表单组件值的更新</li>
</ul>
<p>在 React 中，数据是单向流动的。一般通过 props 传递给组件的 state，现在又通过 onChange 事件处理器将新的表单数据写回到组件的 state，完成了双向数据绑定。</p>
<h2 id="二-常见表单元素操作"><a class="header" href="#二-常见表单元素操作">二 常见表单元素操作</a></h2>
<h3 id="21-textarea-标签"><a class="header" href="#21-textarea-标签">2.1 textarea 标签</a></h3>
<p>textarea 与 上述 input 案例 使用相似，也使用 value 属性代替，这里不做赘述。</p>
<h3 id="22-select-标签"><a class="header" href="#22-select-标签">2.2 select 标签</a></h3>
<p>React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这样这在受控组件中使用起来更方便：</p>
<pre><code class="language-html">&lt;select value=&quot;{value}&quot; onChange=&quot;{handleChange}&quot;&gt;
  &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt;
  &lt;option value=&quot;lime&quot;&gt;酸橙&lt;/option&gt;
  &lt;option value=&quot;coconut&quot;&gt;椰子&lt;/option&gt;
  &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<h3 id="23-处理多个-input-输入"><a class="header" href="#23-处理多个-input-输入">2.3 处理多个 input 输入</a></h3>
<p>当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。</p>
<pre><code class="language-js">function Demo() {
  const [value, setValue] = useState({
    sex: false,
    age: 0,
  })

  const handleChange = (e) =&gt; {
    const target = e.target
    const value = target.type === 'checkbox' ? target.checked : target.value
    const name = target.name

    console.log('change..')

    setValue({
      ...value,
      [name]: value,
    })
  }

  return (
    &lt;form&gt;
      &lt;label&gt;
        性别:
        &lt;input
          type=&quot;checkbox&quot;
          name=&quot;sex&quot;
          value={value.sex || false}
          onChange={handleChange}
        /&gt;
      &lt;/label&gt;
      &lt;br /&gt;
      &lt;label&gt;
        年龄:
        &lt;input
          type=&quot;text&quot;
          name=&quot;age&quot;
          value={value.age || 0}
          onChange={handleChange}
        /&gt;
      &lt;/label&gt;
    &lt;/form&gt;
  )
}
</code></pre>
<p>贴士：示例中，jsx 的输入框都给了默认的 value，<code>|| false</code> 、 <code>|| 0</code>，如果不这样做，由于默认初始值都是 undefined，输入框会被作为非受控组件处理。</p>
<h2 id="三-受控组件输入中文-bug"><a class="header" href="#三-受控组件输入中文-bug">三 受控组件输入中文 BUG</a></h2>
<p>受控组件使用 onChange 时，经常会出现中文未输入完就触发了 onChange 事件，这是因为 input 输入框其实还有三个事件未做处理：</p>
<pre><code class="language-js">class Demo extends React.Component {
  constructor(props) {
    super(props)
  }

  compositionstart(event) {
    console.log('开始输入', event.data)
  }

  compositionupdate(event) {
    document.getElementById('data').innerHTML = event.data
    console.log('正在输入的数据', event.data)
  }

  compositionend(event) {
    console.log('结束输入', event.data)
  }

  changeEvent() {
    console.log('改变')
  }

  render() {
    return (
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          id=&quot;test&quot;
          onChange={this.changeEvent.bind(this)}
          onCompositionStart={this.compositionstart.bind(this)}
          onCompositionUpdate={this.compositionupdate.bind(this)}
          onCompositionEnd={this.compositionend.bind(this)}
        /&gt;
        输入的数据为 &lt;span id=&quot;data&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>定义一个中间变量 isOncomposition，默认为 true，当触发 compositionend 事件时，我们把它赋为 false，这样 change 事件就会执行，但是在 Chrome 浏览器中，compositionend 事件是后于 change 事件触发的，所以还要考虑该情况：</p>
<pre><code class="language-js">let isOnComposition = false;
const isChrome = !!window.chrome &amp;&amp; !!window.chrome.webstore

class App extends React.Component {

	handleComposition(e) {
		if (e.type === 'compositionend') {
			// composition is end
			isOnComposition = false

			if (!isOnComposition &amp;&amp; isChrome) {
				// fire onChange
				this.changeEvent(e);
			}
		} else {
			// in composition
			isOnComposition = true
		}
	}

	changeEvent() {
		if (!isOnComposition) {
			console.log('改变');
		}
	}
  render() {
		return (
          &lt;div&gt;
              &lt;input type=&quot;text&quot; id=&quot;test&quot; onChange={this.changeEvent.bind(this)}
                     onCompositionStart={this.handleComposition.bind(this)}
                     onCompositionUpdate={this.handleComposition.bind(this)}
                     onCompositionEnd={this.handleComposition.bind(this)}/&gt;
          &lt;/div&gt;
		)
	}
</code></pre>
<h2 id="四-非受控组件"><a class="header" href="#四-非受控组件">四 非受控组件</a></h2>
<h3 id="41-非受控组件示例"><a class="header" href="#41-非受控组件示例">4.1 非受控组件示例</a></h3>
<p>在大多数情况下，我们推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。如果一个表单组件没有 value props（单选按钮和复选框对应的是 checked prop）时，就可以称为非受控组件。</p>
<pre><code class="language-js">class NameForm extends React.Component {
  constructor(props) {
    super(props)
    this.handleSubmit = this.handleSubmit.bind(this)
    this.input = React.createRef()
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.current.value)
    event.preventDefault()
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          Name:
          &lt;input type=&quot;text&quot; ref={this.input} /&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
<p>在 React 中，非受控组件是一种反模式，它的值不受组件自身的 state 或 props 控制。通常，需要通过为其添加 ref prop 来访问渲染后的底层 DOM 元素。</p>
<p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p>
<h3 id="42-默认值"><a class="header" href="#42-默认值">4.2 默认值</a></h3>
<p>在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值。在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 defaultValue 属性，而不是 value。在一个组件已经挂载之后去更新 defaultValue 属性的值，不会造成 DOM 上值的任何更新。</p>
<pre><code class="language-js">render() {
  return (
    &lt;form onSubmit={this.handleSubmit}&gt;
      &lt;label&gt;
        Name:
        &lt;input
          defaultValue=&quot;Bob&quot;
          type=&quot;text&quot;
          ref={this.input} /&gt;
      &lt;/label&gt;
      &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p>同样：</p>
<pre><code class="language-js">// 支持 defaultChecked
&lt;input type=&quot;checkbox&quot;&gt;
&lt;input type=&quot;radio&quot;&gt;

// 支持 defaultValue
&lt;select&gt;
&lt;textarea&gt;
</code></pre>
<h3 id="43-文件输入"><a class="header" href="#43-文件输入">4.3 文件输入</a></h3>
<p>当 <code>&lt;input type=&quot;file&quot;&gt;</code> 时，value 是只读的，此时是一个非受控组件，应该使用 File API 与文件进行交互。下面的例子显示了如何创建一个 DOM 节点的 ref 从而在提交表单时获取文件的信息。</p>
<pre><code class="language-js">class FileInput extends React.Component {
  constructor(props) {
    super(props)
    this.handleSubmit = this.handleSubmit.bind(this)
    this.fileInput = React.createRef()
  }
  handleSubmit(event) {
    event.preventDefault()
    alert(`Selected file - ${this.fileInput.current.files[0].name}`)
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          Upload file:
          &lt;input type=&quot;file&quot; ref={this.fileInput} /&gt;
        &lt;/label&gt;
        &lt;br /&gt;
        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
<h3 id="44-对比受控组件和非受控组件"><a class="header" href="#44-对比受控组件和非受控组件">4.4 对比受控组件和非受控组件</a></h3>
<p>我们刚才看到通过 defaultValue 或者 defaultChecked 来设置表单的默认值，它仅会被渲染
一次，在后续的渲染时并不起作用。下面对比以下两个示例。</p>
<pre><code class="language-js">// 将输入的字母转化为大写展示：
&lt;input
  value={this.state.value}
  onChange={e =&gt; {
  this.setState({ value: e.target.value.toUpperCase() })
} }
/&gt;
// 直接展示输入的字母：
&lt;input
  defaultValue={this.state.value}
  onChange={e =&gt; {
  this.setState({ value: e.target.value.toUpperCase() })
} }
/&gt;
</code></pre>
<p>在受控组件中，可以将用户输入的英文字母转化为大写后输出展示，而在非受控组件中则不会。而如果不对受控组件绑定 change 事件，我们在文本框中输入任何值都不会起作用。多数情况下，对于非受控组件，我们并不需要提供 change 事件。通过上面的示例可以看出，受控组件和非受控组件的最大区别是：非受控组件的状态并不会受应用状态的控制，应用中也多了局部组件状态，而受控组件的值来自于组件的 state。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="045-常见操作-组合模式"><a class="header" href="#045-常见操作-组合模式">04.5-常见操作-组合模式</a></h1>
<h2 id="一-组合模式实现代码重用"><a class="header" href="#一-组合模式实现代码重用">一 组合模式实现代码重用</a></h2>
<p>推荐使用组合而非继承来实现组件间的代码重用。</p>
<p>示例中我们要制作一个弹出信息框，可以利用 props.children 属性将子组件传递到渲染结果中：</p>
<pre><code class="language-js">// 负责具体显示的子组件
function FancyBorder(props) {
  return (
    &lt;&gt;
      &lt;div&gt;{props.color}&lt;/div&gt;
      &lt;div&gt;{props.children}&lt;/div&gt;
    &lt;/&gt;
  )
}

// 负责打开界面的父组件
function WelcomeDialog() {
  return (
    &lt;FancyBorder color=&quot;blue&quot;&gt;
      &lt;h1&gt;Welcome&lt;/h1&gt;
      &lt;p&gt;Thank you for visiting our spacecraft!&lt;/p&gt;
    &lt;/FancyBorder&gt;
  )
}
</code></pre>
<p><code>&lt;FancyBorder&gt;</code> JSX 标签中的所有内容都会作为一个 children prop 传递给 FancyBorder 组件。因为 FancyBorder 将 {props.children} 渲染在一个 <code>&lt;div&gt;</code> 中，被传递的这些子组件最终都会出现在输出结果中。</p>
<p>一些特殊场景中，需要为组件预留几个 “洞”，此时可以不使用 children 属性，可以自行约定：</p>
<pre><code class="language-js">function SplitPane(props) {
  return (
    &lt;div className=&quot;SplitPane&quot;&gt;
      &lt;div className=&quot;SplitPane-left&quot;&gt;{props.left}&lt;/div&gt;
      &lt;div className=&quot;SplitPane-right&quot;&gt;{props.right}&lt;/div&gt;
    &lt;/div&gt;
  )
}

function App() {
  return &lt;SplitPane left={&lt;Contacts /&gt;} right={&lt;Chat /&gt;} /&gt;
}
</code></pre>
<p>这种方法可类似别的库中“槽”（slot）的概念，但在 React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。</p>
<h2 id="二-特例关系"><a class="header" href="#二-特例关系">二 特例关系</a></h2>
<p>如果把一些组件看作是其他组件的特殊实例，比如 WelcomeDialog 可以说是 Dialog 的特殊实例，那么也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件：</p>
<pre><code class="language-js">function Dialog(props) {
  return (
    &lt;FancyBorder color=&quot;blue&quot;&gt;
      &lt;h1 className=&quot;Dialog-title&quot;&gt;{props.title}&lt;/h1&gt;
      &lt;p className=&quot;Dialog-message&quot;&gt;{props.message}&lt;/p&gt;
    &lt;/FancyBorder&gt;
  )
}

function WelcomeDialog() {
  return (
    &lt;Dialog title=&quot;Welcome&quot; message=&quot;Thank you for visiting our spacecraft!&quot; /&gt;
  )
}
</code></pre>
<h2 id="三-组合与类组件"><a class="header" href="#三-组合与类组件">三 组合与类组件</a></h2>
<p>组合也同样适用于以 class 形式定义的组件：</p>
<pre><code class="language-js">function Dialog(props) {
  return (
    &lt;FancyBorder color=&quot;blue&quot;&gt;
      &lt;h1 className=&quot;Dialog-title&quot;&gt;{props.title}&lt;/h1&gt;
      &lt;p className=&quot;Dialog-message&quot;&gt;{props.message}&lt;/p&gt;
      {props.children}
    &lt;/FancyBorder&gt;
  )
}

class SignUpDialog extends React.Component {
  constructor(props) {
    super(props)
    this.handleChange = this.handleChange.bind(this)
    this.handleSignUp = this.handleSignUp.bind(this)
    this.state = { login: '' }
  }

  render() {
    return (
      &lt;Dialog
        title=&quot;Mars Exploration Program&quot;
        message=&quot;How should we refer to you?&quot;
      &gt;
        &lt;input value={this.state.login} onChange={this.handleChange} /&gt;
        &lt;button onClick={this.handleSignUp}&gt;Sign Me Up!&lt;/button&gt;
      &lt;/Dialog&gt;
    )
  }

  handleChange(e) {
    this.setState({ login: e.target.value })
  }

  handleSignUp() {
    alert(`Welcome aboard, ${this.state.login}!`)
  }
}
</code></pre>
<h2 id="四-组合与继承推荐"><a class="header" href="#四-组合与继承推荐">四 组合与继承推荐</a></h2>
<p>如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-组件数据传递-父子传值"><a class="header" href="#051-组件数据传递-父子传值">05.1-组件数据传递-父子传值</a></h1>
<h2 id="一-父传子-props"><a class="header" href="#一-父传子-props">一 父传子 props</a></h2>
<p>父传子最简单的方式便是使用 props：</p>
<pre><code class="language-js">// 父组件传递数据
function Father() {
  return &lt;Son info=&quot;hi&quot; /&gt;
}

// 子组件接收数据
function Son(props) {
  return &lt;div&gt;{props.info}&lt;/div&gt;
}
</code></pre>
<h2 id="二-子传父"><a class="header" href="#二-子传父">二 子传父</a></h2>
<p>基于 props 属性，也可以实现子组件向父组件传递数据，我们可以父组件中的函数传递给子组件，由子组件调用该函数即可实现数据传递：</p>
<pre><code class="language-js">// 父组件
function Father() {
  const [num, setNum] = useState(0)
  const sendData = (data) =&gt; {
    console.log('收到子组件数据：', data)
    setNum(data)
  }

  return (
    &lt;div&gt;
      num: {num}
      &lt;Son sendData={sendData} /&gt;
    &lt;/div&gt;
  )
}

// 子组件
function Son(props) {
  const { sendData } = props

  const handleClick = () =&gt; {
    sendData(100)
  }

  return (
    &lt;div&gt;
      &lt;button onClick={handleClick}&gt;点我发送数据给父组件&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h2 id="三-其他传值方式"><a class="header" href="#三-其他传值方式">三 其他传值方式</a></h2>
<h3 id="31-状态提升"><a class="header" href="#31-状态提升">3.1 状态提升</a></h3>
<p>在树形组件结构中，a-&gt;b-&gt;c-&gt;d，四个组件，d 和 b 都用到了某个状态，那么状态应该存储在 a 组件中。</p>
<p>状态提升也有助于实现 props 改变触发组件更新，这也是推荐做法：</p>
<pre><code class="language-js">const Father = () =&gt; {
  // num 数据被提升到父级组件中
  const [num, setNum] = useState(0)

  return (
    &lt;div&gt;
      &lt;SonA num={num} setNum={setNum} /&gt;
      &lt;SonB num={num} setNum={setNum} /&gt;
    &lt;/div&gt;
  )
}

// SonA 组件显示一个原始数据 * 10
const SonA = (props) =&gt; {
  const { num, setNum } = props

  const changeData = (data) =&gt; {
    setNum(num + 1)
  }

  return (
    &lt;div&gt;
      num * 10 = {num * 10}
      &lt;button onClick={changeData}&gt;SonA组件执行原始数据+1&lt;/button&gt;
    &lt;/div&gt;
  )
}

// SonB 组件显示一个原始数据 + 10
const SonB = (props) =&gt; {
  const { num, setNum } = props

  const changeData = (data) =&gt; {
    setNum(num + 1)
  }

  return (
    &lt;div&gt;
      num + 10 = {num + 10}
      &lt;button onClick={changeData}&gt;SonB组件执行原始数据+1&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3 id="32-pubsub-js"><a class="header" href="#32-pubsub-js">3.2 pubsub-js</a></h3>
<p>第三方库 pubsub-js 利用发布订阅原理也能实现组件之间的消息通信。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="052-组件数据传递-context"><a class="header" href="#052-组件数据传递-context">05.2-组件数据传递-Context</a></h1>
<h2 id="一-context-作用示例"><a class="header" href="#一-context-作用示例">一 Context 作用示例</a></h2>
<p>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但此种用法对于某些类型的属性而言是极其繁琐的，比如用户的认证信息、网站的主题等等。</p>
<p>在 Context 支持下，无需为每层组件手动添加 props 就能再组件树间进行数据传递。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p>
<pre><code class="language-js">// 创建一个 Context 对象。
const AuthContext = createContext('auth')

function Father() {
  return (
    &lt;div&gt;
      &lt;Son /&gt;
    &lt;/div&gt;
  )
}

function Son() {
  const auth = useContext(AuthContext)
  return &lt;div&gt;auth = {auth}&lt;/div&gt;
}

function App() {
  return (
    // Provider React 组件允许消费组件订阅 context 的变化
    &lt;AuthContext.Provider value=&quot;admin&quot;&gt;
      &lt;Father /&gt;
    &lt;/AuthContext.Provider&gt;
  )
}
</code></pre>
<p>当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。</p>
<p>只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。</p>
<p>贴士：一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。从 Provider 到其内部 consumer 组件（包括 .contextType 和 useContext）的传播不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件跳过更新的情况下也能更新。</p>
<p>React 通过新旧值检测来确定变化，使用了与 Object.is 相同的算法。</p>
<h2 id="二-类组件中使用-context"><a class="header" href="#二-类组件中使用-context">二 类组件中使用 context</a></h2>
<p>类组件上的 contextType 属性可以赋值为由 React.createContext() 创建的 Context 对象。此属性可以让你使用 this.context 来获取最近 Context 上的值。你可以在任何生命周期中访问到它，包括 render 函数中。</p>
<pre><code class="language-js">// 创建一个 Context 对象。
const AuthContext = createContext('auth')

function Father() {
  return (
    &lt;div&gt;
      &lt;Son /&gt;
    &lt;/div&gt;
  )
}

class Son extends React.Component {
  static contextType = AuthContext
  render() {
    return &lt;div&gt;auth = {this.context}&lt;/div&gt;
  }
}
// Son.contextType = AuthContext    // 这里由static简洁书写了

function App() {
  return (
    &lt;AuthContext.Provider value=&quot;admin&quot;&gt;
      &lt;Father /&gt;
    &lt;/AuthContext.Provider&gt;
  )
}
</code></pre>
<h2 id="三-context-的-api"><a class="header" href="#三-context-的-api">三 Context 的 API</a></h2>
<h3 id="31-contextconsumer"><a class="header" href="#31-contextconsumer">3.1 Context.Consumer</a></h3>
<p>一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。</p>
<p>这种方法需要一个函数作为子元素（function as a child）。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。</p>
<pre><code class="language-js">&lt;MyContext.Consumer&gt;
  {value =&gt; /* 基于 context 值进行渲染*/}
&lt;/MyContext.Consumer&gt;
</code></pre>
<h3 id="32-contextdisplayname"><a class="header" href="#32-contextdisplayname">3.2 Context.displayName</a></h3>
<p>context 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。</p>
<p>示例，下述组件在 DevTools 中将显示为 MyDisplayName：</p>
<pre><code class="language-js">const MyContext = React.createContext(/* some value */);
MyContext.displayName = 'MyDisplayName';

&lt;MyContext.Provider&gt; // &quot;MyDisplayName.Provider&quot; 在 DevTools 中
&lt;MyContext.Consumer&gt; // &quot;MyDisplayName.Consumer&quot; 在 DevTools 中
</code></pre>
<h2 id="四-使用技巧"><a class="header" href="#四-使用技巧">四 使用技巧</a></h2>
<h3 id="41-在嵌套组件中更新-context"><a class="header" href="#41-在嵌套组件中更新-context">4.1 在嵌套组件中更新 Context</a></h3>
<p>从一个在组件树中嵌套很深的组件中更新 context 是很有必要的。在这种场景下，你可以通过 context 传递一个函数，使得 consumers 组件更新 context。</p>
<p>theme-context.js：</p>
<pre><code class="language-js">// 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！
export const ThemeContext = React.createContext({
  theme: themes.dark,
  toggleTheme: () =&gt; {},
})
</code></pre>
<p>theme-toggler-button.js：</p>
<pre><code class="language-js">import { ThemeContext } from './theme-context'

function ThemeTogglerButton() {
  // Theme Toggler 按钮不仅仅只获取 theme 值，
  // 它也从 context 中获取到一个 toggleTheme 函数
  return (
    &lt;ThemeContext.Consumer&gt;
      {({ theme, toggleTheme }) =&gt; (
        &lt;button
          onClick={toggleTheme}
          style={ { backgroundColor: theme.background } }
        &gt;
          Toggle Theme
        &lt;/button&gt;
      )}
    &lt;/ThemeContext.Consumer&gt;
  )
}

export default ThemeTogglerButton
</code></pre>
<p>app.js：</p>
<pre><code class="language-js">import { ThemeContext, themes } from './theme-context'
import ThemeTogglerButton from './theme-toggler-button'

class App extends React.Component {
  constructor(props) {
    super(props)

    this.toggleTheme = () =&gt; {
      this.setState((state) =&gt; ({
        theme: state.theme === themes.dark ? themes.light : themes.dark,
      }))
    }

    // State 也包含了更新函数，因此它会被传递进 context provider。
    this.state = {
      theme: themes.light,
      toggleTheme: this.toggleTheme,
    }
  }
  render() {
    // 整个 state 都被传递进 provider
    return (
      &lt;ThemeContext.Provider value={this.state}&gt;
        &lt;Content /&gt;
      &lt;/ThemeContext.Provider&gt;
    )
  }
}

function Content() {
  return (
    &lt;div&gt;
      &lt;ThemeTogglerButton /&gt;
    &lt;/div&gt;
  )
}

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(&lt;App /&gt;)
</code></pre>
<h3 id="42-消费多个-context"><a class="header" href="#42-消费多个-context">4.2 消费多个 Context</a></h3>
<p>为了确保 context 快速进行重渲染，React 需要使每一个 consumers 组件的 context 在组件树中成为一个单独的节点。</p>
<pre><code class="language-js">// Theme context，默认的 theme 是 “light” 值
const ThemeContext = React.createContext('light')

// 用户登录 context
const UserContext = React.createContext({
  name: 'Guest',
})

class App extends React.Component {
  render() {
    const { signedInUser, theme } = this.props

    // 提供初始 context 值的 App 组件
    return (
      &lt;ThemeContext.Provider value={theme}&gt;
        &lt;UserContext.Provider value={signedInUser}&gt;
          &lt;Layout /&gt;
        &lt;/UserContext.Provider&gt;
      &lt;/ThemeContext.Provider&gt;
    )
  }
}
function Layout() {
  return (
    &lt;div&gt;
      &lt;Sidebar /&gt;
      &lt;Content /&gt;
    &lt;/div&gt;
  )
}

// 一个组件可能会消费多个 context
function Content() {
  return (
    &lt;ThemeContext.Consumer&gt;
      {(theme) =&gt; (
        &lt;UserContext.Consumer&gt;
          {(user) =&gt; &lt;ProfilePage user={user} theme={theme} /&gt;}
        &lt;/UserContext.Consumer&gt;
      )}
    &lt;/ThemeContext.Consumer&gt;
  )
}
</code></pre>
<p>如果两个或者更多的 context 值经常被一起使用，那你可能要考虑一下另外创建你自己的渲染组件，以提供这些值。</p>
<h2 id="五-注意事项"><a class="header" href="#五-注意事项">五 注意事项</a></h2>
<p>因为 context 会根据引用标识来决定何时进行渲染（本质上是 value 属性值的浅比较），所以这里可能存在一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，由于 value 属性总是被赋值为新的对象，以下的代码会重新渲染下面所有的 consumers 组件：</p>
<pre><code class="language-js">class App extends React.Component {
  render() {
    return (
      &lt;MyContext.Provider value={ { something: 'something' } }&gt;
        &lt;Toolbar /&gt;
      &lt;/MyContext.Provider&gt;
    )
  }
}
</code></pre>
<p>为了防止这种情况，将 value 状态提升到父节点的 state 里：</p>
<pre><code class="language-js">class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      value: { something: 'something' },
    }
  }

  render() {
    return (
      &lt;MyContext.Provider value={this.state.value}&gt;
        &lt;Toolbar /&gt;
      &lt;/MyContext.Provider&gt;
    )
  }
}
</code></pre>
<h2 id="六-何时使用-context"><a class="header" href="#六-何时使用-context">六 何时使用 Context</a></h2>
<p>Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据，使用不当则会导致组件复用性变差。如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。</p>
<p>比如，考虑这样一个 Page 组件，它层层向下传递 user 和 avatarSize 属性，从而让深度嵌套的 Link 和 Avatar 组件可以读取到这些属性：</p>
<pre><code class="language-js">&lt;Page user={user} avatarSize={avatarSize} /&gt;
// ... 渲染出 ...
&lt;PageLayout user={user} avatarSize={avatarSize} /&gt;
// ... 渲染出 ...
&lt;NavigationBar user={user} avatarSize={avatarSize} /&gt;
// ... 渲染出 ...
&lt;Link href={user.permalink}&gt;
  &lt;Avatar user={user} size={avatarSize} /&gt;
&lt;/Link&gt;
</code></pre>
<p>如果在最后只有 Avatar 组件真的需要 user 和 avatarSize，那么层层传递这两个 props 就显得非常冗余。而且一旦 Avatar 组件需要更多从来自顶层组件的 props，你还得在中间层级一个一个加上去，这将会变得非常麻烦。</p>
<p>一种无需 context 的解决方案是将 Avatar 组件自身传递下去，因为中间组件无需知道 user 或者 avatarSize 等 props：</p>
<pre><code class="language-js">function Page(props) {
  const user = props.user;
  const userLink = (
    &lt;Link href={user.permalink}&gt;
      &lt;Avatar user={user} size={props.avatarSize} /&gt;
    &lt;/Link&gt;
  );
  return &lt;PageLayout userLink={userLink} /&gt;;
}

// 现在，我们有这样的组件：
&lt;Page user={user} avatarSize={avatarSize} /&gt;
// ... 渲染出 ...
&lt;PageLayout userLink={...} /&gt;
// ... 渲染出 ...
&lt;NavigationBar userLink={...} /&gt;
// ... 渲染出 ...
{props.userLink}
</code></pre>
<p>这种变化下，只有最顶部的 Page 组件需要知道 Link 和 Avatar 组件是如何使用 user 和 avatarSize 的。</p>
<p>这种对组件的控制反转减少了在你的应用中要传递的 props 数量，这在很多场景下会使得你的代码更加干净，使你对根组件有更多的把控。但是，这并不适用于每一个场景：这种将逻辑提升到组件树的更高层次来处理，会使得这些高层组件变得更复杂，并且会强行将低层组件适应这样的形式，这可能不会是你想要的。</p>
<p>而且你的组件并不限制于接收单个子组件。你可能会传递多个子组件，甚至会为这些子组件（children）封装多个单独的“接口（slots）”，</p>
<pre><code class="language-js">function Page(props) {
  const user = props.user
  const content = &lt;Feed user={user} /&gt;
  const topBar = (
    &lt;NavigationBar&gt;
      &lt;Link href={user.permalink}&gt;
        &lt;Avatar user={user} size={props.avatarSize} /&gt;
      &lt;/Link&gt;
    &lt;/NavigationBar&gt;
  )
  return &lt;PageLayout topBar={topBar} content={content} /&gt;
}
</code></pre>
<p>这种模式足够覆盖很多场景了，在这些场景下你需要将子组件和直接关联的父组件解耦。如果子组件需要在渲染前和父组件进行一些交流，你可以进一步使用 render props。</p>
<p>但是，有的时候在组件树中很多不同层级的组件需要访问同样的一批数据。Context 能让你将这些数据向组件树下所有的组件进行“广播”，所有的组件都能访问到这些数据，也能访问到后续的数据更新。使用 context 的通用的场景包括管理当前的 locale，theme，或者一些缓存数据，这比替代方案要简单的多。</p>
<h2 id="七-过时的-api"><a class="header" href="#七-过时的-api">七 过时的 API</a></h2>
<p>推荐使用 16.3 版本中引入的 新的 context API， 过时的 API 将会继续在所有 16.x 版本中工作，但是会在未来的主要版本中被移除。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-react-路由-基础使用"><a class="header" href="#061-react-路由-基础使用">06.1-React 路由-基础使用</a></h1>
<h2 id="一-前端路由"><a class="header" href="#一-前端路由">一 前端路由</a></h2>
<h3 id="11-前端路由概念"><a class="header" href="#11-前端路由概念">1.1 前端路由概念</a></h3>
<p>在后端中，路由的概念是：一个路由对应着一个接口，根据路由的不同，返回不同的响应数据。</p>
<p>前端路由的概念是依据 url 的不同，分配不同的界面组件，其本质是用户事件与事件处理函数之间的对应关系！</p>
<h3 id="12-前端路由原理"><a class="header" href="#12-前端路由原理">1.2 前端路由原理</a></h3>
<p>前端路由分为：历史路由、哈希路由两种。二者都不会产生页面刷新，但是表现形式与本质原理都不一致。</p>
<pre><code class="language-js">// 哈希路由表现：localhost:3000/#/news/1001
// 哈希路由实现原理：使用的是 URL 的哈希值
location.hash = 'about' // 地址为： /#/about
location.hash = 'news' // 地址为： /#/news

// 历史路由表现：localhost:3000/news/1001
// 历史路由原理 (栈结构)：使用的浏览器的 history API，不兼容 IE9
location.pushState({}, '', 'about') // 地址为： /about
location.pushState({}, '', 'news') // 地址为： /news
</code></pre>
<p>使用上，二者也有不同影响：</p>
<pre><code class="language-txt">哈希路由：刷新会不会向服务端请求资源，但会导致路由传递的 state 参数丢失，因为其没有 history 的 API，无法在内存中保存 state 数据
历史路由：刷新会向服务端请求资源，但不会导致路由传递的 state 参数丢失。所以历史路由在路径 404 页面上需要服务端额外支持。
</code></pre>
<h2 id="二-react-router-dom-基础使用"><a class="header" href="#二-react-router-dom-基础使用">二 react-router-dom 基础使用</a></h2>
<p>React 中实现前端路由的库是：react-router-dom，通过管理 url，实现组件与 url 的对应，通过 url 进行组件之间的切换。</p>
<p>贴士：react-router 是 react 中路由的核心 api，但是没有提供 dom 操作进行路由跳转的 api，react-router-dom 在使用上更加便利。</p>
<p>使用示例：</p>
<pre><code class="language-js">// npm i react-router-dom -S
import React from 'react'
import ReactDOM from 'react-dom'
import { Link, BrowserRouter, Route } from 'react-router-dom'
import Home from './component/Home'
import About from './component/About'

export default class App extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;BrowserRouter&gt;
                    &lt;div&gt;导航区：&lt;/div&gt;
                    &lt;Link to=&quot;/home&quot;&gt;home&lt;/Link&gt;
                    &lt;Link to=&quot;/about&quot;&gt;about&lt;/Link&gt;
                    &lt;hr&gt;
                    &lt;div&gt;内容展示区：&lt;/div&gt;
                    &lt;Route path=&quot;/home&quot; component={Home} /&gt;
                    &lt;Route path=&quot;/about&quot; component={About} /&gt;
                &lt;/BrowserRouter&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>
<p>贴士：BrowserRouter 是 React router 的路由器之一，<strong>一个项目必须交给一个路由器管理，所以可以在 <code>&lt;App&gt;</code> 组件最外侧包裹路由标签即可</strong>。</p>
<h2 id="三-react-router-dom-核心使用"><a class="header" href="#三-react-router-dom-核心使用">三 react-router-dom 核心使用</a></h2>
<h3 id="31-基础概念"><a class="header" href="#31-基础概念">3.1 基础概念</a></h3>
<p>react-router-dom 内置组件：</p>
<ul>
<li>BrowserRouter、HashRouter：路由的根容器，分别代表历史路由（<code>history.createBrowserRouter</code>）、哈希路由（<code>history.createHashRouter</code>）。所有路由相关的内容都要包裹在该标签中。</li>
<li>Route：表示一个路由映射规则，用于注册路由。在 Route 上，有两个比较重要的属性：path、component，分别代表有对应关系的路由与组件。</li>
<li>Link：表示路由的连接，其本质是被 React 阻止默认行为，添加监听的 a 连接。</li>
<li>NavLink：</li>
<li>Redirect：</li>
<li>Switch：</li>
</ul>
<h3 id="32-路由组件与一般组件"><a class="header" href="#32-路由组件与一般组件">3.2 路由组件与一般组件</a></h3>
<p>规范：</p>
<ul>
<li>一般组件：被类似 <code>&lt;About /&gt;</code> 的方式直接使用的组件，一般放置在 components 文件夹中。</li>
<li>路由组件：被使用在 Route 标签的 <code>component</code> 属性中的组件，一般放置在 pages 文件夹中。</li>
</ul>
<p>二者核心区别：<strong>路由组件接收的 props 为三个固定属性</strong>：</p>
<ul>
<li>history：包含 go、goBack、push、replace（替换栈顶）、location 等常用的 historyAPI</li>
<li>location：与前者 history.location 一致，包含：pathname（路由地址）、search（参数）、state（状态）</li>
<li>match：包含：isExact（默认为 true，精准匹配）、params、path、url</li>
</ul>
<h3 id="33-路由匹配-exact"><a class="header" href="#33-路由匹配-exact">3.3 路由匹配 exact</a></h3>
<p><code>to=&quot;/a/home/b&quot;</code> 这样的路由只会对 <code>/a</code> 进行匹配，如果要只匹配到<code>/a/home/b</code>，需要使用 exact 开启精准匹配：</p>
<pre><code class="language-js">&lt;Route exact path=&quot;/a/home/b&quot; componet={Home} /&gt;
</code></pre>
<h3 id="34-push-与-replace-路由方式"><a class="header" href="#34-push-与-replace-路由方式">3.4 push 与 replace 路由方式</a></h3>
<p>路由的历史记录默认使用 push 方式，先进后出，会留下历史记录。</p>
<p>修改为替换模式不会留下历史记录，即执行的不是入栈操作，而是替换栈顶的操作：</p>
<pre><code class="language-js">&lt;Link replace to=&quot;&quot;&gt;&lt;/Link&gt;
&lt;Link replace={true} to=&quot;&quot;&gt;&lt;/Link&gt;
</code></pre>
<p>使用替换方式，当浏览器回退时，就可以回退到更远的历史记录中，适用的一些场景有：选项卡页面的整体回退。</p>
<h2 id="四-navlinkredirectswith-的使用"><a class="header" href="#四-navlinkredirectswith-的使用">四 NavLink、Redirect、Swith 的使用</a></h2>
<h3 id="41-navlink-自动添加-active-样式"><a class="header" href="#41-navlink-自动添加-active-样式">4.1 NavLink 自动添加 active 样式</a></h3>
<p>NavLink 的特殊功能：一旦被点击就会添加一个 css 类名 <code>active</code>，也可以修改该样式名。</p>
<p>当然，我们一般使用 NavLink 来封装一个导航组件，如下所示：</p>
<pre><code class="language-js">import React. {Component} from 'react'
import { NavLink } from 'react-router-dom'

export default class MyNavLink extends Component {
  render(){
    return (
      &lt;NavLink activeClassName=&quot;isActive&quot; {...this.props}/&gt;
    )
  }
}
</code></pre>
<p><code>...this.props</code> 展开的传入属性中也包括了标签体内容（标签内的文本 Home、About），获取方式为 <code>this.props.children</code>，所以在使用该自定义导航组件可以直接如下使用：</p>
<pre><code class="language-js">&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;
&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;
</code></pre>
<h3 id="42-switch-规则筛选"><a class="header" href="#42-switch-规则筛选">4.2 Switch 规则筛选</a></h3>
<p>如果有多个相同的路由规则，但是对应组件不同，则匹配到该路由后，将会显示所有对应组件。如下所示当遇到 <code>/home</code> 路由时，不会停止，而是继续查询后续是否仍然有 home 路由：</p>
<pre><code class="language-js">  &lt;Route path=&quot;/home&quot; component={Home}&gt;&lt;/Route&gt;
  &lt;Route path=&quot;/about&quot; component={About}&gt;&lt;/Route&gt;
  &lt;Route path=&quot;/home&quot; component={Other}&gt;&lt;/Route&gt;
</code></pre>
<p>这种情况在开发中不常见，多个相同路由也会有性能问题。Switch 组件可以解决该问题，匹配到一个组件后，就不会继续往下查找。下列示例中只会显示 Home 组件内容：</p>
<pre><code class="language-js">&lt;Switch&gt;
  &lt;Route path=&quot;/home&quot; component={Home}&gt;&lt;/Route&gt;
  &lt;Route path=&quot;/about&quot; component={About}&gt;&lt;/Route&gt;
  &lt;Route path=&quot;/home&quot; component={Other}&gt;&lt;/Route&gt;
&lt;/Switch&gt;
</code></pre>
<h3 id="43-redirect-重定向"><a class="header" href="#43-redirect-重定向">4.3 Redirect 重定向</a></h3>
<p>下列示例中，路由没有匹配到，则会进入 Redirect 中设定的路由：</p>
<pre><code class="language-js">&lt;Switch&gt;
  &lt;Route path=&quot;/home&quot; component={Home}&gt;&lt;/Route&gt;
  &lt;Route path=&quot;/about&quot; component={About}&gt;&lt;/Route&gt;
  &lt;Redirect to=&quot;/home&quot;&gt;&lt;/Redirect&gt;
&lt;/Switch&gt;
</code></pre>
<h2 id="五-路由参数传递"><a class="header" href="#五-路由参数传递">五 路由参数传递</a></h2>
<h3 id="51-search-参数方式传递"><a class="header" href="#51-search-参数方式传递">5.1 search 参数方式传递</a></h3>
<p>向路由组件传递 search 参数：</p>
<pre><code class="language-js">&lt;Link to={`/news/detail/?id=${id}&amp;flag=${flag}`}&gt;&lt;Link&gt;
</code></pre>
<p>组件接收参数，search 是 ?id=1&amp;flag=0：</p>
<pre><code class="language-js">import qs from 'querystring'
const { search } = this.props.search
const { id, flag } = qs.parse(search.slice(1))
</code></pre>
<h3 id="52-params-参数方式传递"><a class="header" href="#52-params-参数方式传递">5.2 params 参数方式传递</a></h3>
<p>向路由组件传递 params 参数：</p>
<pre><code class="language-js">&lt;Link to={`/news/detail/${id}/${flag}`}&gt;&lt;Link&gt;

{/* 声明接收 params 参数，不声明会产生模糊匹配 */}
&lt;Route to={`/news/detail/:id/:flag`}&gt;&lt;Route&gt;
</code></pre>
<p>组件接收参数：</p>
<pre><code class="language-js">const { id, flag } = this.props.match.params
</code></pre>
<h3 id="53-state-方式传递"><a class="header" href="#53-state-方式传递">5.3 state 方式传递</a></h3>
<p>state 方式传递不会将参数暴露在网址中：</p>
<pre><code class="language-js">&lt;Link to={`/news/detail/`, state: {id:id, flag: flag} }&gt;&lt;Link&gt;
</code></pre>
<p>接收方式：</p>
<pre><code class="language-js">const { id, flag } = this.props.location.state || {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="062-react-路由-路由嵌套懒加载与编程式导航"><a class="header" href="#062-react-路由-路由嵌套懒加载与编程式导航">06.2-React 路由-路由嵌套懒加载与编程式导航</a></h1>
<h2 id="一-嵌套路由"><a class="header" href="#一-嵌套路由">一 嵌套路由</a></h2>
<p>实际项目中嵌套路由很常见，如下所示：</p>
<pre><code class="language-js">// 主界面
export default class App extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;BrowserRouter&gt;
                    &lt;Link to=&quot;/home&quot;&gt;home&lt;/Link&gt;
                    &lt;Route path=&quot;/home&quot; component={Home} /&gt;
                    &lt;Route path=&quot;/404&quot; component={NotFind}&gt;&lt;/Route&gt;
                    &lt;Redirect to=&quot;/404&quot;&gt;&lt;/Redirect&gt;
                &lt;/BrowserRouter&gt;
            &lt;/div&gt;
        )
    }
}

// home 内部
class Home extends React.Component {
    render() {
        return (
            &lt;div&gt;
                    &lt;div&gt;导航区：&lt;/div&gt;
                    &lt;Link to=&quot;/home/news&quot;&gt;News&lt;/Link&gt;
                    &lt;Link to=&quot;/home/images&quot;&gt;Images&lt;/Link&gt;
                    &lt;hr&gt;
                    &lt;div&gt;内容展示区：&lt;/div&gt;
                    &lt;Switch&gt;
                      &lt;Route path=&quot;/home/news&quot; component={News} /&gt;
                      &lt;Route path=&quot;/home/images&quot; component={Images} /&gt;
                     &lt;Redirect to=&quot;/home/news&quot;&gt;&lt;/Redirect&gt;
                    &lt;/Switch&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>
<p>注意：这里如果 <code>&lt;Route exact path=&quot;/home&quot; component={Home} /&gt;</code> 开启了严格匹配，当用户点击 news 按钮，即路由为 <code>/home/news</code>的时候，是不会展示出来的！所以严格匹配在一些场景中会导致二级路由出现问题。</p>
<h2 id="二-路由懒加载"><a class="header" href="#二-路由懒加载">二 路由懒加载</a></h2>
<p>路由组件可以通过懒加载提升性能。</p>
<p>组件引入方式：</p>
<pre><code class="language-js">import React, { Component, lazy, Suspense } from 'react'

// import Home from './components/Home'
const Home = lazy(() =&gt; {
  import './components/Home'
})
</code></pre>
<p>组件使用方式：</p>
<pre><code class="language-js">&lt;div&gt;
  &lt;Suspense fallback={&lt;h3&gt;loading...&lt;h3&gt;}&gt;
    &lt;Route path=&quot;/home&quot; component={Home} /&gt;
  &lt;/Suspense&gt;
&lt;/div&gt;
</code></pre>
<h2 id="三-编程式导航"><a class="header" href="#三-编程式导航">三 编程式导航</a></h2>
<p>编程式导航常用场景：页面在延迟一定时间后跳转到另外一个页面。显然 <code>&lt;Link&gt;</code> 这样需要主动点击的标签就无法实现了。</p>
<p>编程式导航示例：</p>
<pre><code class="language-js">// 以 replace 方式跳转：替换栈顶
this.props.history.replace(`/home`)

// 以 push 方式跳转：压栈
this.props.history.push(`/home`)
</code></pre>
<p>常见的编程式导航 API：</p>
<pre><code class="language-js">this.props.history.push()
this.props.history.replace()
this.props.history.go()
this.props.history.goback()
this.props.history.goForward()
</code></pre>
<p><strong>注意：一般组件上是不存在 history 这些属性的，如果要让一般组件在点击时可以实现跳转，需要借助 withRouter，此时一般组件内部就可以使用路由相关的 API 了：</strong></p>
<pre><code class="language-js">import { withRouter } from 'react-router-dom'

class MyBox extends Component {}

export default withRouter(MyBox)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="071-react-生命周期-钩子方法"><a class="header" href="#071-react-生命周期-钩子方法">07.1-React 生命周期-钩子方法</a></h1>
<h2 id="一-生命周期概念"><a class="header" href="#一-生命周期概念">一 生命周期概念</a></h2>
<p>组件的创建、更新、销毁等过程，总是伴随着各种各样的事件，这些特定的时期，以及触发的事件，被称为生命周期。</p>
<p>组件的生命周期分为三部分：</p>
<ul>
<li>挂载：当组件实例被创建并插入 DOM 中时，生命周期方法按顺序有（只会执行一次）：
<ul>
<li><code>constructor()</code></li>
<li><code>static getDerivedStateFromProps()</code>：这是新增的 2 个钩子之一</li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ul>
</li>
<li>更新：当组件的 state 和 props 的改变时，有选择的触发一些函数，运行的生命周期方法按顺序有：
<ul>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><code>render()</code></li>
<li><code>getSnapshotBeforeUpdate()</code>：：这是新增的 2 个钩子之一</li>
<li><code>componentDidUpdate()</code></li>
</ul>
</li>
<li>销毁：当组件从 DOM 中移除时，生命周期方法按顺序有（只会执行一次）：
<ul>
<li><code>componentWillUnmount()</code></li>
</ul>
</li>
</ul>
<p>React 16.4 及以上生命周期钩子函数如图所示：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/../images/mvvm/react-04.svg" alt="16.4 钩子函数" /></p>
<h2 id="二-react-164-生命周期"><a class="header" href="#二-react-164-生命周期">二 React 16.4 生命周期</a></h2>
<h3 id="21-挂载阶段"><a class="header" href="#21-挂载阶段">2.1 挂载阶段</a></h3>
<blockquote>
<p><strong>static getDeriveStateFromProps(nextProps, prevState)</strong>：</p>
</blockquote>
<p>作用：可以用来更新状态，若组件的状态依赖于 props 可以使用该钩子，即该方法能够通过 props 派生并返回状态对象。但该钩子函数会造成代码冗余。</p>
<p>场景：</p>
<ul>
<li>根据 props 更新内部 state（只要有传入 props 值，就更新 state）</li>
<li>props 值和 state 值不同时需要更新 state</li>
</ul>
<p>getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p>
<p>此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。例如，实现 <code>&lt;Transition&gt;</code> 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。</p>
<p>派生状态会导致代码冗余，并使组件难以维护。 确保你已熟悉这些简单的替代方案：</p>
<ul>
<li>如果你需要执行副作用（例如，数据提取或动画）以响应 props 中的更改，请改用 componentDidUpdate。</li>
<li>如果只想在 prop 更改时重新计算某些数据，请使用 memoization helper 代替。</li>
<li>如果你想在 prop 更改时“重置”某些 state，请考虑使组件完全受控或使用 key 使组件完全不受控 代替。</li>
<li>此方法无权访问组件实例。如果你需要，可以通过提取组件 props 的纯函数及 class 之外的状态，在 getDerivedStateFromProps()和其他 class 方法之间重用代码。</li>
</ul>
<p>请注意，不管原因是什么，都会在每次渲染前触发此方法。这与 UNSAFE_componentWillReceiveProps 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 setState 时。</p>
<p>在 16.4 版本之前，<code>getDeriveStateFromProps()</code> 是不可以在 <code>setState()</code>、<code>forceUpdate()</code> 时触发的，如下所示：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/../images/mvvm/react-04-2.svg" alt="16.3 钩子函数" /></p>
<blockquote>
<p><strong>componentDidMount()</strong>：</p>
</blockquote>
<p>作用：组件挂载后（插入 DOM 树中）立即调用。</p>
<p>场景：</p>
<ul>
<li>依赖于 DOM 节点的初始化应该放在这里</li>
<li>通过网络请求应该在此处执行</li>
<li>可以在此添加订阅，不过还需要在 componentWillUnmount() 里取消订阅</li>
</ul>
<p>你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理。</p>
<h3 id="23-更新阶段"><a class="header" href="#23-更新阶段">2.3 更新阶段</a></h3>
<blockquote>
<p><strong>static getDeriveStateFromProps(nextProps, prevState)</strong></p>
</blockquote>
<p>在挂载阶段介绍过了。</p>
<blockquote>
<p><strong>shouldComponentUpdate()</strong></p>
</blockquote>
<p>作用：根据其返回值判断 React 组件的输出是否受当前 state 或 props 更改的影响。</p>
<p>shouldComponentUpdate()的默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。</p>
<p>当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。</p>
<p>此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p>
<p>如果你一定要手动编写此函数，可以将 this.props 与 nextProps 以及 this.state 与 nextState 进行比较，并返回 false 以告知 React 可以跳过更新。请注意，返回 false 并不会阻止子组件在 state 更改时重新渲染。</p>
<p>我们不建议在 shouldComponentUpdate() 中进行深层比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能。</p>
<p>目前，如果 shouldComponentUpdate() 返回 false，则不会调用 UNSAFE_componentWillUpdate()，render() 和 componentDidUpdate()。后续版本，React 可能会将 shouldComponentUpdate 视为提示而不是严格的指令，并且，当返回 false 时，仍可能导致组件重新渲染。</p>
<blockquote>
<p><strong>getSnapshotBeforeUpdate()</strong></p>
</blockquote>
<p>作用：可以在更新发生前捕获一些信息（快照），其返回值将作为参数传递给下游钩子 <code>componentDidUpdate()</code>。</p>
<p>场景：</p>
<ul>
<li>获取滚动位置</li>
</ul>
<p>该方法应返回 snapshot 的值（或 null）：</p>
<pre><code class="language-js">class ScrollingList extends React.Component {
  constructor(props) {
    super(props)
    this.listRef = React.createRef()
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 我们是否在 list 中添加新的 items ？
    // 捕获滚动​​位置以便我们稍后调整滚动位置。
    if (prevProps.list.length &lt; this.props.list.length) {
      const list = this.listRef.current
      return list.scrollHeight - list.scrollTop
    }
    return null
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，
    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。
    //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）
    if (snapshot !== null) {
      const list = this.listRef.current
      list.scrollTop = list.scrollHeight - snapshot
    }
  }
  render() {
    return &lt;div ref={this.listRef}&gt;{/* ...contents... */}&lt;/div&gt;
  }
}
</code></pre>
<p>在上述示例中，重点是从 getSnapshotBeforeUpdate 读取 scrollHeight 属性，因为 “render” 阶段生命周期（如 render）和 “commit” 阶段生命周期（如 getSnapshotBeforeUpdate 和 componentDidUpdate）之间可能存在延迟。</p>
<blockquote>
<p><strong>componentDidUpdate()</strong></p>
</blockquote>
<p>作用：会在更新后会被立即调用。首次渲染不会执行此方法。</p>
<p>当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。</p>
<pre><code class="language-js">componentDidUpdate(prevProps) {
  // 典型用法（不要忘记比较 props）：
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}
</code></pre>
<p>你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。</p>
<h3 id="24-销毁阶段"><a class="header" href="#24-销毁阶段">2.4 销毁阶段</a></h3>
<blockquote>
<p><strong>componentWillUnmount()</strong></p>
</blockquote>
<p>作用： 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。</p>
<p>componentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>
<h3 id="23-过时的生命周期钩子"><a class="header" href="#23-过时的生命周期钩子">2.3 过时的生命周期钩子</a></h3>
<p>从 16.3+开始，有三个旧钩子不再被推荐使用，在这三个钩子函数原名基础上添加 <code>UNSAFE_</code> 前缀：</p>
<ul>
<li>挂载阶段：<code>UNSAFE_componentWillMount()</code></li>
<li>更新阶段：<code>UNSAFE_componentWillUpdate()</code>、<code>UNSAFE_componentWillReceiveProps()</code></li>
</ul>
<p>到了 17 版本开始，只能使用 <code>UNSAFE_</code>开头的钩子，或者新版钩子，因为 React 官方认为这三个函数经常被滥用，且在异步渲染中更容易出现错误，到了 18 则不再允许使用该废弃 API。</p>
<blockquote>
<p><strong>componentWillMount()</strong></p>
</blockquote>
<p>在挂载之前被调用。它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染。通常，我们建议使用 constructor() 来初始化 state。</p>
<p>避免在此方法中引入任何副作用或订阅。如遇此种情况，请改用 componentDidMount()。</p>
<p>此方法是服务端渲染唯一会调用的生命周期函数。</p>
<blockquote>
<p><strong>componentWillReceiveProps()</strong></p>
</blockquote>
<p>componentWillReceiveProps()通常会出现 bug 和不一致性：</p>
<ul>
<li>如果你需要执行副作用（例如，数据提取或动画）以响应 props 中的更改，请改用 componentDidUpdate 生命周期。</li>
<li>如果你使用 componentWillReceiveProps 仅在 prop 更改时重新计算某些数据，请使用 memoization helper 代替。</li>
<li>如果你使用 componentWillReceiveProps 是为了在 prop 更改时“重置”某些 state，请考虑使组件完全受控或使用 key 使组件完全不受控 代替。</li>
</ul>
<p>UNSAFE_componentWillReceiveProps() 会在已挂载的组件接收新的 props 之前被调用。如果你需要更新状态以响应 prop 更改（例如，重置它），你可以比较 this.props 和 nextProps 并在此方法中使用 this.setState() 执行 state 转换。</p>
<p>请注意，如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。</p>
<p>在挂载过程中，React 不会针对初始 props 调用 UNSAFE_componentWillReceiveProps()。组件只会在组件的 props 更新时调用此方法。调用 this.setState() 通常不会触发 UNSAFE_componentWillReceiveProps()。</p>
<blockquote>
<p><strong>componentWillUpdate()</strong></p>
</blockquote>
<p>当组件收到新的 props 或 state 时，会在渲染之前调用 UNSAFE_componentWillUpdate()。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。</p>
<p>注意，你不能此方法中调用 this.setState()；在 UNSAFE_componentWillUpdate() 返回之前，你也不应该执行任何其他操作（例如，dispatch Redux 的 action）触发对 React 组件的更新</p>
<p>通常，此方法可以替换为 componentDidUpdate()。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 getSnapshotBeforeUpdate() 中。</p>
<p>注意：如果 shouldComponentUpdate() 返回 false，则不会调用 UNSAFE_componentWillUpdate()。</p>
<h2 id="三-useeffect"><a class="header" href="#三-useeffect">三 useEffect()</a></h2>
<p>函数组件没有生命周期函数，hoos 提供了 useEffect() 可以在函数式组件中执行副作用操作（即监控组件状态的变更，模拟生命周期）。</p>
<p>贴士：副作用操作有在 React 中发送 ajax、手动更改真实 DOM、启动定时器等。</p>
<p>添加 useEffect Hook，示例将会在初次加载、任意状态改变时执行：</p>
<pre><code class="language-js">let [count, setCount] = React.useState('Jack')
let [name, setName] = React.useState('Jack')

React.useEffect(() =&gt; {
  console.log('useEffect...')
}, [count, name])
</code></pre>
<p>第二个数组参数是可选的，意思是：监控该函数式组件内哪些状态。</p>
<ul>
<li>空数组，则不会监控，只会在组件初次加载时执行 useEffect()。</li>
<li>数组参数不写，则监控所有状态。</li>
</ul>
<p>useEffect 的第一个函数参数内部也可以返回一个函数，这个返回的函数会在组件卸载时触发，推荐在 return 中书写清理定时器等方法：</p>
<pre><code class="language-js">React.useEffect(() =&gt; {
  console.log('useEffect...')
  return () =&gt; {
    console.log('component will unmount...')
  }
})
</code></pre>
<h2 id="四-旧版生命周期"><a class="header" href="#四-旧版生命周期">四 旧版生命周期</a></h2>
<h3 id="41-旧版生命周期钩子函数"><a class="header" href="#41-旧版生命周期钩子函数">4.1 旧版生命周期钩子函数</a></h3>
<p>不同的生命周期内都对应了一些钩子函数，如图所示：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/../images/mvvm/react-03.png" alt="钩子函数" /></p>
<h3 id="42-旧版生命周期---组件创建阶段"><a class="header" href="#42-旧版生命周期---组件创建阶段">4.2 旧版生命周期 - 组件创建阶段</a></h3>
<p>创建阶段是组件的第一次渲染，由 <code>ReactDOM.render()</code> 触发，包含四步：</p>
<pre><code class="language-js">class Comp extends React.Component {
    // 设置原始的私有数据
    constructor() {
        super()
        console.log('0-初始化')
        this.state = {}
        static defaultProps = {}
    }

    // 组件即将被挂载，虚拟 DOM 元素尚未创建完毕，该生命周期未来会废弃
    componentWillMount() {
        console.log('1-将要挂载')
    }

    // render() 方法运行完毕后，虚拟 DOM 也创建完毕，但是并未真正挂载到真实的页面上
    render() {
        console.log('2-渲染函数')
        return &lt;div&gt;comp&lt;/div&gt;
    }

    // state 上的数据、内存中的虚拟 DOM、浏览器的页面都已经保持了一致，组件进入到了运行阶段。
    componentDidMount() {
        console.log('3-已经挂载')
    }
}
</code></pre>
<p>componentWillMount() 较为常用，由于此阶段组件已经真实渲染，可以在钩子内开启定时器、发送网络请求、订阅消息等。</p>
<h3 id="43-旧版生命周期---组件运行阶段"><a class="header" href="#43-旧版生命周期---组件运行阶段">4.3 旧版生命周期 - 组件运行阶段</a></h3>
<p>运行阶段，属性 props 的改变，状态 state 的改变都可以触发组件的更新。</p>
<p>由 <code>setState()</code> 、<code>父组件.render()</code> 触发更新：</p>
<pre><code class="language-js">class Comp extends React.Component {
  // 组件接收到新的 props 时执行，该生命周期未来会废弃
  componentWillReceiveProps(nextProps) {
    console.log('0-接收新参数')
  }

  // 该钩子函数是能否能改状态的阀门，该函数返回 true 才能执行更新
  shouldComponentUpdate(nextProps, nextState) {
    console.log('1-是否可以执行更新')
    return true
  }

  // 组件将要更新此时内存中的虚拟 DOM 树还是旧的，该生命周期未来会废弃
  componentWillUpdate() {
    console.log('2-即将更新')
  }

  // 渲染
  render() {
    console.log('3-渲染函数')
    return &lt;div&gt;comp&lt;/div&gt;
  }

  // 重新渲染：新的 state、虚拟 DOM 与页面都保持了同步
  componentDidUpdate() {
    console.log('3-已经更新')
  }
}
</code></pre>
<p>注意：父组件在再次渲染（第二次 render）的时候，会额外触发钩子：<code>componentWillReceiveProps()</code>用来证明父组件给当前子组件传递了新的属性值。</p>
<p>贴士：通过强制更新（forceUpdate）绕过阀门控制，不更改状态也更新组件。</p>
<p>贴士：<code>React.Component</code> 是最基础的 React 组件类，而 <code>React.PueComponent</code> 则内部默认为开发者定义好了 <code>shouldComponentUpdate</code> 生命周期，开发者无需考虑该函数。</p>
<h3 id="44-旧版生命周期---组件销毁阶段"><a class="header" href="#44-旧版生命周期---组件销毁阶段">4.4 旧版生命周期 - 组件销毁阶段</a></h3>
<p>组件销毁即组件卸载。</p>
<p>由 <code>ReactDOM.unmountComponentAtNode()</code> 触发：</p>
<pre><code class="language-js">class Comp extends React.Component {
  // 其他生命周期

  // 此时组件还能正常使用，一般用于做收尾的事情，如：关闭定时器、取消订阅
  componentWillUnmount() {
    console.log('1-将要卸载')
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="072-react-生命周期-常用操作"><a class="header" href="#072-react-生命周期-常用操作">07.2-React 生命周期-常用操作</a></h1>
<h2 id="一-setstate"><a class="header" href="#一-setstate">一 setState()</a></h2>
<pre><code class="language-js">setState(updater[, callback])
</code></pre>
<p>setState() 将对组件 state 的更改排入队列，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组件。这是用于更新用户界面以响应事件处理器和处理服务器数据的主要方式</p>
<p>将 setState() 视为请求而不是立即更新组件的命令。为了更好的感知性能，React 会延迟调用它，然后通过一次传递更新多个组件。在罕见的情况下，你需要强制 DOM 更新同步应用，你可以使用 flushSync 来包装它，但这可能会损害性能。</p>
<p>setState() 并不总是立即更新组件。它会批量推迟更新。这使得在调用 setState() 后立即读取 this.state 成为了隐患。为了消除隐患，请使用 componentDidUpdate 或者 setState 的回调函数（setState(updater, callback)），这两种方式都可以保证在应用更新后触发。如需基于之前的 state 来设置当前的 state，请阅读下述关于参数 updater 的内容。</p>
<p>除非 shouldComponentUpdate() 返回 false，否则 setState() 将始终执行重新渲染操作。如果可变对象被使用，且无法在 shouldComponentUpdate() 中实现条件渲染，那么仅在新旧状态不一时调用 setState()可以避免不必要的重新渲染</p>
<p>参数一为带有形式参数的 updater 函数：</p>
<pre><code class="language-js">;(state, props) =&gt; stateChange
</code></pre>
<p>state 是对应用变化时组件状态的引用。当然，它不应直接被修改。你应该使用基于 state 和 props 构建的新对象来表示变化。例如，假设我们想根据 props.step 来增加 state：</p>
<pre><code class="language-js">this.setState((state, props) =&gt; {
  return { counter: state.counter + props.step }
})
</code></pre>
<p>updater 函数中接收的 state 和 props 都保证为最新。updater 的返回值会与 state 进行浅合并。</p>
<p>setState() 的第二个参数为可选的回调函数，它将在 setState 完成合并并重新渲染组件后执行。通常，我们建议使用 componentDidUpdate() 来代替此方式。</p>
<p>setState() 的第一个参数除了接受函数外，还可以接受对象类型：</p>
<pre><code class="language-js">setState(stateChange[, callback])
</code></pre>
<p>stateChange 会将传入的对象浅层合并到新的 state 中，例如，调整购物车商品数：</p>
<pre><code class="language-js">this.setState({ quantity: 2 })
</code></pre>
<p>这种形式的 setState() 也是异步的，并且在同一周期内会对多个 setState 进行批处理。例如，如果在同一周期内多次设置商品数量增加，则相当于：</p>
<pre><code class="language-js">Object.assign(
  previousState,
  {quantity: state.quantity + 1},
  {quantity: state.quantity + 1},
  ...
)
</code></pre>
<p>后调用的 setState() 将覆盖同一周期内先调用 setState 的值，因此商品数仅增加一次。如果后续状态取决于当前状态，我们建议使用 updater 函数的形式代替：</p>
<pre><code class="language-js">this.setState((state) =&gt; {
  return { quantity: state.quantity + 1 }
})
</code></pre>
<h2 id="二-forceupdate"><a class="header" href="#二-forceupdate">二 forceUpdate()</a></h2>
<pre><code class="language-js">component.forceUpdate(callback)
</code></pre>
<p>默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。如果 render() 方法依赖于其他数据，则可以调用 forceUpdate() 强制让组件重新渲染。</p>
<p>调用 forceUpdate() 将致使组件调用 render() 方法，此操作会跳过该组件的 shouldComponentUpdate()。但其子组件会触发正常的生命周期方法，包括 shouldComponentUpdate() 方法。如果标记发生变化，React 仍将只更新 DOM。</p>
<p>通常你应该避免使用 forceUpdate()，尽量在 render() 中使用 this.props 和 this.state。</p>
<h2 id="三-错误边界"><a class="header" href="#三-错误边界">三 错误边界</a></h2>
<p>错误边界（Error Boundaries）：部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。</p>
<p>错误边界是一种 React 组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。</p>
<p>如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。</p>
<p>componentDidCatch() 会在“提交”阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况：</p>
<pre><code class="language-js">class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染能够显示降级后的 UI
    return { hasError: true }
  }

  componentDidCatch(error, errorInfo) {
    // 你同样可以将错误日志上报给服务器
    logErrorToMyService(error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      // 你可以自定义降级后的 UI 并渲染
      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;
    }

    return this.props.children
  }
}
</code></pre>
<p>然后你可以将它作为一个常规组件去使用：</p>
<pre><code class="language-js">&lt;ErrorBoundary&gt;
  &lt;MyWidget /&gt;
&lt;/ErrorBoundary&gt;
</code></pre>
<p>React 的开发和生产构建版本在 componentDidCatch() 的方式上有轻微差别。</p>
<p>在开发模式下，错误会冒泡至 window，这意味着任何 window.onerror 或 window.addEventListener('error', callback) 会中断这些已经被 componentDidCatch() 捕获的错误。</p>
<p>相反，在生产模式下，错误不会冒泡，这意味着任何根错误处理器只会接受那些没有显式地被 componentDidCatch() 捕获的错误。</p>
<p>错误边界的工作方式类似于 JavaScript 的 catch {}，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为错误边界组件。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。</p>
<p>注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 catch {} 的工作机制。</p>
<p>自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。</p>
<p>在开发环境下，React 16 会把渲染期间发生的所有错误打印到控制台，即使该应用意外的将这些错误掩盖。除了错误信息和 JavaScript 栈外，React 16 还提供了组件栈追踪。现在你可以准确地查看发生在组件树内的错误信息。</p>
<p>如果你没有使用 Create React App，可以手动将该插件添加到你的 Babel 配置中。注意它仅用于开发环境，在生产环境必须将其禁用 。</p>
<p>误边界无法捕获事件处理器内部的错误。React 不需要错误边界来捕获事件处理器中的错误。与 render 方法和生命周期方法不同，事件处理器不会在渲染期间触发。因此，如果它们抛出异常，React 仍然能够知道需要在屏幕上显示什么。如果你需要在事件处理器内部捕获错误，使用普通的 JavaScript try / catch 语句</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="081-深入-hooksapi-使用规范"><a class="header" href="#081-深入-hooksapi-使用规范">08.1-深入 HooksAPI-使用规范</a></h1>
<h2 id="一-关于-hooksapi"><a class="header" href="#一-关于-hooksapi">一 关于 HooksAPI</a></h2>
<p>拥有了 HooksAPI 后的的函数式组件对比类组件：</p>
<ul>
<li>代码可读性更强了：类组件的业务逻辑被分布在了不同的生命周期函数中，不利于维护，Hooks 可以将业务代码聚合</li>
<li>组件层级更浅：类组件需要使用 HOC/render props 等方式复用组件状态，增强功能，会增加组件的层级，Hooks 可以通过自定义 Hooks 实现。</li>
</ul>
<p>贴士：Hook 是 100%向后兼容的，没有破坏性改动，反而是提供了更简明、直接的 API，如：props、state、context、refs、lifecircle。</p>
<p>HooksAPI 也并非万金油，同样拥有不足之处。比如 useEffect 在依赖太多时，很容易导致代码臃肿，需要合理拆分。</p>
<h2 id="二-开发建议"><a class="header" href="#二-开发建议">二 开发建议</a></h2>
<h3 id="21-只在最顶层使用-hook"><a class="header" href="#21-只在最顶层使用-hook">2.1 只在最顶层使用 Hook</a></h3>
<p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p>
<ul>
<li>只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。</li>
<li>只能在 React 的函数组件、自定义 Hook 中调用 Hook，不要在其他 JavaScript 函数中调用。</li>
</ul>
<p>在函数最外层调用 Hook，才能确保 Hook 在每一次渲染中都按照同样的顺序被调用，即让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。</p>
<p>例如下列的写法就是不规范的：</p>
<pre><code class="language-js">if (flag) {
  useEffect()
}
</code></pre>
<h3 id="22-hooks-顺序"><a class="header" href="#22-hooks-顺序">2.2 hooks 顺序</a></h3>
<p>我们可以在单个组件中使用多个 State Hook 或 Effect Hook：</p>
<pre><code class="language-js">function Form() {
  // 1. Use the name state variable
  const [name, setName] = useState('Mary')

  // 2. Use an effect for persisting the form
  useEffect(function persistForm() {
    localStorage.setItem('formData', name)
  })

  // 3. Use the surname state variable
  const [surname, setSurname] = useState('Poppins')

  // 4. Use an effect for updating the title
  useEffect(function updateTitle() {
    document.title = name + ' ' + surname
  })

  // ...
}
</code></pre>
<p>那么 React 怎么知道哪个 state 对应哪个 useState？答案是 React 靠的是 Hook 调用的顺序。因为我们的示例中，Hook 的调用顺序在每次渲染中都是相同的，所以它能够正常工作：</p>
<pre><code class="language-js">// ------------
// 首次渲染
// ------------
useState('Mary') // 1. 使用 'Mary' 初始化变量名为 name 的 state
useEffect(persistForm) // 2. 添加 effect 以保存 form 操作
useState('Poppins') // 3. 使用 'Poppins' 初始化变量名为 surname 的 state
useEffect(updateTitle) // 4. 添加 effect 以更新标题

// -------------
// 二次渲染
// -------------
useState('Mary') // 1. 读取变量名为 name 的 state（参数被忽略）
useEffect(persistForm) // 2. 替换保存 form 的 effect
useState('Poppins') // 3. 读取变量名为 surname 的 state（参数被忽略）
useEffect(updateTitle) // 4. 替换更新标题的 effect

// ...
</code></pre>
<p>只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联。但如果我们将一个 Hook (例如 persistForm effect) 调用放到一个条件语句中会发生什么呢？</p>
<pre><code class="language-js">// 🔴 在条件语句中使用 Hook 违反第一条规则
if (name !== '') {
  useEffect(function persistForm() {
    localStorage.setItem('formData', name)
  })
}
</code></pre>
<p>在第一次渲染中 name !== '' 这个条件值为 true，所以我们会执行这个 Hook。但是下一次渲染时我们可能清空了表单，表达式值变为 false。此时的渲染会跳过该 Hook，Hook 的调用顺序发生了改变：</p>
<pre><code class="language-js">useState('Mary') // 1. 读取变量名为 name 的 state（参数被忽略）
// useEffect(persistForm)  // 此 Hook 被忽略！
useState('Poppins') // 2 （之前为 3）。读取变量名为 surname 的 state 失败
useEffect(updateTitle) // 3 （之前为 4）。替换更新标题的 effect 失败
</code></pre>
<p>React 不知道第二个 useState 的 Hook 应该返回什么。React 会以为在该组件中第二个 Hook 的调用像上次的渲染一样，对应的是 persistForm 的 effect，但并非如此。从这里开始，后面的 Hook 调用都被提前执行，导致 bug 的产生。</p>
<p>这就是为什么 Hook 需要在我们组件的最顶层调用。如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的内部：</p>
<pre><code class="language-js">useEffect(function persistForm() {
  // 👍 将条件判断放置在 effect 中
  if (name !== '') {
    localStorage.setItem('formData', name)
  }
})
</code></pre>
<p>贴士：如果使用了提供的 eslint-plugin-react-hooks 插件，就无需担心此问题， Create React App 在后续版本默认集成。</p>
<h2 id="三-在组件之间复用状态逻辑很难"><a class="header" href="#三-在组件之间复用状态逻辑很难">三 在组件之间复用状态逻辑很难</a></h2>
<p>React 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）。如果你使用过 React 一段时间，你也许会熟悉一些解决此类问题的方案，比如 render props 和 高阶组件。但是这类方案需要重新组织你的组件结构，这可能会很麻烦，使你的代码难以理解。如果你在 React DevTools 中观察过 React 应用，你会发现由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管我们可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。</p>
<p>你可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。</p>
<h2 id="四-复杂组件变得难以理解"><a class="header" href="#四-复杂组件变得难以理解">四 复杂组件变得难以理解</a></h2>
<p>我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。</p>
<p>在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。</p>
<p>为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。</p>
<p>我们将在使用 Effect Hook 中对此展开更多讨论。</p>
<h2 id="五-难以理解的-class"><a class="header" href="#五-难以理解的-class">五 难以理解的 class</a></h2>
<p>除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 React 的一大屏障。你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。如果不使用 ES2022 public class fields，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。</p>
<p>另外，React 已经发布五年了，我们希望它能在下一个五年也与时俱进。就像 Svelte，Angular，Glimmer 等其它的库展示的那样，组件预编译会带来巨大的潜力。尤其是在它不局限于模板的时候。最近，我们一直在使用 Prepack 来试验 component folding，也取得了初步成效。但是我们发现使用 class 组件会无意中鼓励开发者使用一些让优化措施无效的方案。class 也给目前的工具带来了一些问题。例如，class 不能很好的压缩，并且会使热重载出现不稳定的情况。因此，我们想提供一个使代码更易于优化的 API。</p>
<p>为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。</p>
<h2 id="六-渐进策略"><a class="header" href="#六-渐进策略">六 渐进策略</a></h2>
<p>没有计划从 React 中移除 class。</p>
<p>大部分 React 开发者会专注于开发产品，而没时间关注每一个新 API 的发布。Hook 还很新，也许等到有更多示例和教程后，再考虑学习或使用它们也不迟。</p>
<p>我们也明白向 React 添加新的原生概念的门槛非常高。我们为好奇的读者准备了详细的征求意见文档，在文档中用更多细节深入讨论了我们推进这件事的动机，也在具体设计决策和相关先进技术上提供了额外的视角。</p>
<p>最重要的是，Hook 和现有代码可以同时工作，你可以渐进式地使用他们。 不用急着迁移到 Hook。我们建议避免任何“大规模重写”，尤其是对于现有的、复杂的 class 组件。开始“用 Hook 的方式思考”前，需要做一些思维上的转变。按照我们的经验，最好先在新的不复杂的组件中尝试使用 Hook，并确保团队中的每一位成员都能适应。在你尝试使用 Hook 后，欢迎给我们提供反馈，无论好坏。</p>
<p>我们准备让 Hook 覆盖所有 class 组件的使用场景，但是我们将继续为 class 组件提供支持。在 Facebook，我们有成千上万的组件用 class 书写，我们完全没有重写它们的计划。相反，我们开始在新的代码中同时使用 Hook 和 class。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="082-深入-hooksapi-自定义-hook"><a class="header" href="#082-深入-hooksapi-自定义-hook">08.2-深入 HooksAPI-自定义 Hook</a></h1>
<h2 id="一-自定义-hook-作用示例"><a class="header" href="#一-自定义-hook-作用示例">一 自定义 Hook 作用示例</a></h2>
<p>假设现在有一个聊天程序中的组件，该组件用于显示好友的在线状态：</p>
<pre><code class="language-js">import React, { useState, useEffect } from 'react'

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null)
  useEffect(() =&gt; {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline)
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)
    }
  })

  if (isOnline === null) {
    return 'Loading...'
  }
  return isOnline ? 'Online' : 'Offline'
}
</code></pre>
<p>现在我们假设聊天应用中有一个联系人列表，当用户在线时需要把名字设置为绿色。我们可以把上面类似的逻辑复制并粘贴到 FriendListItem 组件中来，但这并不是理想的解决方案：</p>
<pre><code class="language-js">import React, { useState, useEffect } from 'react'

function FriendListItem(props) {
  const [isOnline, setIsOnline] = useState(null)
  useEffect(() =&gt; {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline)
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)
    }
  })

  return (
    &lt;li style={ { color: isOnline ? 'green' : 'black' } }&gt;{props.friend.name}&lt;/li&gt;
  )
}
</code></pre>
<p>相反，我们希望在 FriendStatus 和 FriendListItem 之间共享逻辑。</p>
<p>目前为止，在 React 中有两种流行的方式来共享组件之间的状态逻辑: render props 和高阶组件，而自定义 Hook 可以在不增加组件的情况下解决相同问题。</p>
<p>我们一开始的目标是在 FriendStatus 和 FriendListItem 组件中去除重复的逻辑，即：这两个组件都想知道好友是否在线。现在我们已经把这个逻辑提取到 useFriendStatus 的自定义 Hook 中，然后就可以使用它了：</p>
<pre><code class="language-js">function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id)

  if (isOnline === null) {
    return 'Loading...'
  }
  return isOnline ? 'Online' : 'Offline'
}

function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id)

  return (
    &lt;li style={ { color: isOnline ? 'green' : 'black' } }&gt;{props.friend.name}&lt;/li&gt;
  )
}
</code></pre>
<p>这段代码等价于原来的示例代码，它的工作方式完全一样。如果你仔细观察，你会发现我们没有对其行为做任何的改变，我们只是将两个函数之间一些共同的代码提取到单独的函数中。自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。</p>
<p>自定义 Hook 必须以 “use” 开头吗？必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用。</p>
<p>在两个组件中使用相同的 Hook 不会共享 state ，自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。</p>
<p>自定义 Hook 每次调用 Hook，它都会获取独立的 state。由于我们直接调用了 useFriendStatus，从 React 的角度来看，我们的组件只是调用了 useState 和 useEffect。 正如我们在之前章节中了解到的一样，我们可以在一个组件中多次调用 useState 和 useEffect，它们是完全独立的。</p>
<h2 id="二-在多个-hook-之间传递信息"><a class="header" href="#二-在多个-hook-之间传递信息">二 在多个 Hook 之间传递信息</a></h2>
<p>由于 Hook 本身就是函数，因此我们可以在它们之间传递信息。</p>
<p>我们将使用聊天程序中的另一个组件来说明这一点。这是一个聊天消息接收者的选择器，它会显示当前选定的好友是否在线:</p>
<pre><code class="language-js">const friendList = [
  { id: 1, name: 'Phoebe' },
  { id: 2, name: 'Rachel' },
  { id: 3, name: 'Ross' },
]

function ChatRecipientPicker() {
  const [recipientID, setRecipientID] = useState(1)
  const isRecipientOnline = useFriendStatus(recipientID)

  return (
    &lt;&gt;
      &lt;Circle color={isRecipientOnline ? 'green' : 'red'} /&gt;
      &lt;select
        value={recipientID}
        onChange={(e) =&gt; setRecipientID(Number(e.target.value))}
      &gt;
        {friendList.map((friend) =&gt; (
          &lt;option key={friend.id} value={friend.id}&gt;
            {friend.name}
          &lt;/option&gt;
        ))}
      &lt;/select&gt;
    &lt;/&gt;
  )
}
</code></pre>
<p>我们将当前选择的好友 ID 保存在 recipientID 状态变量中，并在用户从<code>&lt;select&gt;</code> 中选择其他好友时更新这个 state。</p>
<p>由于 useState 为我们提供了 recipientID 状态变量的最新值，因此我们可以将它作为参数传递给自定义的 useFriendStatus Hook：</p>
<pre><code class="language-js">const [recipientID, setRecipientID] = useState(1)
const isRecipientOnline = useFriendStatus(recipientID)
</code></pre>
<p>如此可以让我们知道当前选中的好友是否在线。当我们选择不同的好友并更新 recipientID 状态变量时，useFriendStatus Hook 将会取消订阅之前选中的好友，并订阅新选中的好友状态。</p>
<h2 id="三-useyourimagination"><a class="header" href="#三-useyourimagination">三 useYourImagination()</a></h2>
<p>自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题。你可以创建涵盖各种场景的自定义 Hook，如表单处理、动画、订阅声明、计时器，甚至可能还有其他我们没想到的场景。更重要的是，创建自定义 Hook 就像使用 React 内置的功能一样简单。</p>
<p>尽量避免过早地增加抽象逻辑。既然函数组件能够做的更多，那么代码库中函数组件的代码行数可能会剧增。这属于正常现象 —— 不必立即将它们拆分为 Hook。但我们仍鼓励你能通过自定义 Hook 寻找可能，以达到简化代码逻辑，解决组件杂乱无章的目的。</p>
<p>例如，有个复杂的组件，其中包含了大量以特殊的方式来管理的内部状态。useState 并不会使得集中更新逻辑变得容易，因此你可能更愿意使用 redux 中的 reducer 来编写。</p>
<pre><code class="language-js">function todosReducer(state, action) {
  switch (action.type) {
    case 'add':
      return [
        ...state,
        {
          text: action.text,
          completed: false,
        },
      ]
    // ... other actions ...
    default:
      return state
  }
}
</code></pre>
<p>Reducers 非常便于单独测试，且易于扩展，以表达复杂的更新逻辑。如有必要，您可以将它们分成更小的 reducer。但是，你可能还享受着 React 内部 state 带来的好处，或者可能根本不想安装其他库。</p>
<p>那么，为什么我们不编写一个 useReducer 的 Hook，使用 reducer 的方式来管理组件的内部 state 呢？其简化版本可能如下所示：</p>
<pre><code class="language-js">function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState)

  function dispatch(action) {
    const nextState = reducer(state, action)
    setState(nextState)
  }

  return [state, dispatch]
}
</code></pre>
<p>在组件中使用它，让 reducer 驱动它管理 state：</p>
<pre><code class="language-js">function Todos() {
  const [todos, dispatch] = useReducer(todosReducer, [])

  function handleAddClick(text) {
    dispatch({ type: 'add', text })
  }

  // ...
}
</code></pre>
<p>在复杂组件中使用 reducer 管理内部 state 的需求很常见，我们已经将 useReducer 的 Hook 内置到 React 中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="083-深入-hooksapi-其他常用-hooks"><a class="header" href="#083-深入-hooksapi-其他常用-hooks">08.3-深入 HooksAPI-其他常用 Hooks</a></h1>
<h2 id="一-usereducer"><a class="header" href="#一-usereducer">一 useReducer()</a></h2>
<p>useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）</p>
<p>在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。</p>
<p>useRedcuer() 的使用方式类似 redux：</p>
<pre><code class="language-js">function Demo() {
  const [count, dispatch] = React.useReducer((state, action) =&gt; {
    switch (action) {
      case 'add':
        return state + 1
      case 'sub':
        return state - 1
      default:
        return state
    }
  }, 0)
  return (
    &lt;div&gt;
      &lt;h3&gt;count: {count}&lt;/h3&gt;
      &lt;button
        onClick={() =&gt; {
          dispatch('add')
        } }
      &gt;
        增加
      &lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>useReducer 和 useContext 其实可以模拟出 Redux 效果：</p>
<ul>
<li>useContext：可以访问全局状态，避免一层层传递，可以实现 Redux 状态全局化统一管理。</li>
<li>useReducer：可以实现类似 Redux 的 Reducer 部分</li>
</ul>
<p>所以创建一个共享数据的组件：</p>
<pre><code class="language-js">export const ctx = React.createContext()

export const UPDATE_NUM = 'UPDATE_NUM'

const reducer = (state, action)=&gt;{
    switch (action.type) {
      case 'add':
        return state + 1
      case 'sub':
        return state - 1
      default:
        return state
    }
}

export function DemoRedux = props =&gt; {
  const [data, dispatch] = React.useReducer(reducer, 100)
  return (
    &lt;div&gt;
      &lt;ctx.Provider value={ {data, dispatch} }&gt;
        {props.children}
      &lt;/ctx.Provider&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>其他组件使用共享数据：</p>
<pre><code class="language-js">&lt;DemoRedux&gt;
  &lt;MyComp1 /&gt;
  &lt;MyComp2 /&gt;
&lt;/DemoRedux&gt;
</code></pre>
<p>MyComp1 中动态接收数据：</p>
<pre><code class="language-js">function MyComp1() {
  const { data } = React.useContext(DemoRedux)

  return (
    &lt;div&gt;
      DemoRedux:{data}
      &lt;button
        onClick={() =&gt; {
          dispatcj((type: 'add'), (data: 20))
        } }
      &gt;
        点击
      &lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h2 id="二-记忆函数-usecallbackusememo"><a class="header" href="#二-记忆函数-usecallbackusememo">二 记忆函数 useCallback()、useMemo()</a></h2>
<h3 id="40-组件更新问题"><a class="header" href="#40-组件更新问题">4.0 组件更新问题</a></h3>
<p>如下所示类组件的 React 代码：</p>
<pre><code class="language-js">class Demo {
  render() {
    return (
      &lt;div&gt;
        &lt;Comp
          style={ { fontSize: 14 } }
          handler={() =&gt; {
            console.log('run....')
          } }
        /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>在 React 中，父组件如果重新 render()，则其内部子组件的 render() 也都会被相应调用。一旦 Demo 的 props、state 发生改变，触发 Demo 的 render() 函数后，其子组件 Comp 的 style、handler 属性的值是一个新生成的引用，这时候会导致 Comp 重新渲染。如果该组件是一个大型组件树，则会造成性能损失，解决办法是将参数抽离为变量：</p>
<pre><code class="language-js">const fontSizeStyle = { fontSize: 14 }
class Demo {
  handler = () =&gt; {
    console.log('run....')
  }
  render() {
    return (
      &lt;div&gt;
        &lt;Comp style={ontSizeStyle} handler={this.handler} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>在函数式组件中，没有 this 保存函数，所以函数式组件在每次渲染时，如果有传递函数的话都会重新渲染子组件：</p>
<pre><code class="language-js">const fontSizeStyle = { fontSize: 14 }

function Demo() {
  const handler = () =&gt; {
    console.log('run....')
  }

  return (
    &lt;div&gt;
      &lt;Comp style={ontSizeStyle} handler={handler} /&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>贴士：一般可以将函数式组件理解为类组件中 render 函数的语法糖，所以每次渲染时，哈术士组件内部所有代码都会重新执行一遍，对应到上述代码，每次 render，handler 都是一个新的引用，即其绑定的事件函数仍然一直在随着 render 发生变化！</p>
<h3 id="41-记忆函数-usecallback"><a class="header" href="#41-记忆函数-usecallback">4.1 记忆函数 useCallback()</a></h3>
<p>useCallback() 可以获得一个记忆函数：</p>
<pre><code class="language-js">const fontSizeStyle = { fontSize: 14 }

// 这里要对子组件做高阶组件化处理才能行得通
const MemComp = memo(Comp)

function Demo() {
  const handler = useCallback(() =&gt; {
    console.log('run....')
  }, []) // 空数组表示无论什么情况该函数都不会发生改变

  return (
    &lt;div&gt;
      &lt;MemComp style={ontSizeStyle} handler={handler} /&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>useCallback() 第二个参数数组中每一项发生改变，或者引用发生改变，useCallback() 返回一个新的记忆函数提供给后面进行渲染。</p>
<p>memo() 的第二个参数是一个回调函数，如果返回 true，则表示组件内的函数被永远缓存了下来：</p>
<pre><code class="language-js">const MemComp = memo(Comp, () =&gt; {
  return true
})
</code></pre>
<h3 id="42-记忆函数-usememo"><a class="header" href="#42-记忆函数-usememo">4.2 记忆函数 useMemo()</a></h3>
<p>useMemo() 可以完全取代 useCallback：</p>
<pre><code class="language-js">useMemo(() =&gt; {}, [])
</code></pre>
<p>二者的区别是：useCallback() 不会执行第一个参数函数，而是直接返回给你，useMemo() 则会执行该函数，并将函数结果返回给你。</p>
<p>一般情况下：useCallback() 用于事件的响应函数，useMemo() 用于组件的缓存。</p>
<h3 id="43-memoize-one"><a class="header" href="#43-memoize-one">4.3 memoize-one</a></h3>
<p>在未进行任何处理的情况下，父组件 render，总会导致子组件 render，即使子组件的 state/props 并未发生变化。在大列表筛选时，筛选逻辑复杂，这将是一个很重要的优化点。memoize-one 可以帮助：</p>
<p><a href="https://github.com/alexreardon/memoize-one">https://github.com/alexreardon/memoize-one</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="091-状态管理-redux"><a class="header" href="#091-状态管理-redux">09.1-状态管理 Redux</a></h1>
<h2 id="一-redux-概念"><a class="header" href="#一-redux-概念">一 Redux 概念</a></h2>
<p>Redux 是一款集中状态管理库，适用于 React、Angular、Vue 等库，但经常与 React 配合使用。</p>
<p>redux 使用场景：</p>
<ul>
<li>
<p>多个组件的状态需要其他组件随时使用（共享）</p>
</li>
<li>
<p>存在很多组件之间更改对方状态（通信）场景</p>
</li>
</ul>
<p>redux 工作如图：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/../images/mvvm/redux-01.png" alt="redux" /></p>
<p><strong>store</strong>：store 用于维护 state，可以将 action 与 reducer 联系到一起，是整个 redux 的核心部分。</p>
<p><strong>action</strong>：是负责将数据从应用传递到 store 的对象。触发 action 是唯一可以改变 state 的方法。给 store 发送 aciton 方式：<code>store.dispatch()</code>。</p>
<p><strong>reducer</strong>：reducer 只是一些纯函数，接收到数据更改要求（action），返回新的 state 给 store。reducer 可以实现复用、顺序控制等。</p>
<p>应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。state 中的数据是只读的，惟一改变 state 的办法是使用 dispatch 派发 action，具体的更新方式位于对应的 reducer（返回一个新的 state）。</p>
<p>Redux 的设计原则：</p>
<ul>
<li>单一数据源：与 MVC 不同（Model 之间互相监听、触发），Redux 认为一个应用只需要一个唯一数据源，这会导致产生一个极大的 JS 对象，Redux 通过 combineReducers() 解决</li>
<li>状态只读：redux 没有真正意义上的 store，即无法用代码定义，reducer 也只是返回一个全新的状态</li>
<li>状态修改由纯函数完成：每个 reducer 都是纯函数，没有副作用，使得 redux 变得容易测试。</li>
</ul>
<h2 id="二-redux-简单示例"><a class="header" href="#二-redux-简单示例">二 redux 简单示例</a></h2>
<h3 id="21-redux-基础使用"><a class="header" href="#21-redux-基础使用">2.1 Redux 基础使用</a></h3>
<p>安装 redux 相关库：</p>
<pre><code class="language-txt">npm i -S redux
</code></pre>
<p>代码示例：</p>
<pre><code class="language-js">import { createStore } from 'redux'

// reducer
const initCount = {
  count: 0,
}
function counterReducer(state = initCount, action) {
  switch (action.type) {
    case 'INCREMENT':
      return {
        ...state,
        count: state.count + action.payload.num,
      }
    case 'DECREMENT':
      return {
        ...state,
        count: state.count - action.payload.num,
      }
    default:
      console.log('未执行操作')
      return state
  }
}

// 创建 Store
const store = createStore(
  counterReducer,
  // 支持 redux-devtools 谷歌插件
  window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()
)

// 创建第一个 Action：对 count+1
function countAddAction() {
  return {
    type: 'INCREMENT',
    payload: {
      num: 1,
    },
  }
}

// 创建第二个 Action：对 count-2
function countMinusAction() {
  return {
    type: 'DECREMENT',
    payload: {
      num: 2,
    },
  }
}

// 执行 action，改变数据
store.dispatch(countAddAction())
store.dispatch(countMinusAction())

// 获取数据
console.log(store.getState()) // {count: -1}
</code></pre>
<h3 id="22-combine-合并多个-reducer"><a class="header" href="#22-combine-合并多个-reducer">2.2 combine 合并多个 reducer</a></h3>
<p>store 在创建时，可以支持多个 reducer，使用 combine 合并：</p>
<pre><code class="language-js">import { createStore, combineReducers } from 'redux'

const rootReducers = combineReducers({
  counter: counterReducer,
  other: otherRerucer,
})

// 创建 Store
const store = createStore(
  rootReducers,
  window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()
)
</code></pre>
<p><strong>注意：合并时 reducer 的名字会将状态数据分组，会决定 state 中的属性的获取方式，比如合并前在组件中获取属性为：state.count，合并的名字为 counter，则获取方式为：state.counter.count</strong>。</p>
<h2 id="三-redux-中间件"><a class="header" href="#三-redux-中间件">三 Redux 中间件</a></h2>
<h3 id="31-redux-中间件基础示例"><a class="header" href="#31-redux-中间件基础示例">3.1 redux 中间件基础示例</a></h3>
<p>在 redux 中可以使用一些中间件，多个中间件也可以组合使用，中间件会在发出 action，reducer 执行数据维护之前执行一些操作，如下所示：</p>
<pre><code class="language-js">import { createStore, applyMiddleware } from 'redux'
import thunk from 'redux-thunk' // 异步请求中间件
import { createLogger } from 'redux-logger' // 日志中间件

// 环境
let isDev = true

// logger 中间件
const logger = createLogger({
  predicate: isDev,
  collapsed: true,
})

// 集成中间件:apply 函数用于加载中间件
let appliedMiddlewares = applyMiddleware(...[thunk, logger])
if (isDev) {
  const { composeWithDevTools } = require('redux-devtools-extension')
  appliedMiddlewares = composeWithDevTools(appliedMiddlewares)
}

// 创建 Store
const store = createStore(rootReducers, appliedMiddlewares)
</code></pre>
<p>贴士：这里 redux-devtool 使用了扩展，依赖于 react-redux，所以需要这样安装： <code>npm install -S redux react-redux</code>。</p>
<h3 id="32-redux-中间件原理"><a class="header" href="#32-redux-中间件原理">3.2 Redux 中间件原理</a></h3>
<p>redux 中间件工作图：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/../images/mvvm/redux-01.png" alt="redux middleware" /></p>
<p>点击 button1 触发一个同步数据流场景，在回调中分发一个 action，reducer 收到该 action 后更新 state，触发 view 重新渲染。如果此时我们需要一个日志功能：打印每个 action 信息进行调试，就需要修改 dispatch/reducer 的实现。如果还需要在点击 button 后，先异步获取数据，数据返回后才能重新渲染 view，即希望 dispatch/reducer 具备异步请求功能等等。一旦业务场景多样化后，单纯修改 dispatch 或 reducer 的代码显然不具有普适性。这时候就需要一个可以组合的、自由插拔的插件机制。</p>
<p>middleware 原理：</p>
<pre><code class="language-js">// 柯里化思想
export default function applyMiddleware(...middlewares) {
  return (next) =&gt; (reducer, initialState) =&gt; {
    let store = next(reducer, initialState)
    let dispatch = store.dispatch
    let chain = []
    var middlewareAPI = {
      getState: store.getState,
      dispatch: (action) =&gt; dispatch(action),
    }
    chain = middlewares.map((middleware) =&gt; middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)
    return {
      ...store,
      dispatch,
    }
  }
}
</code></pre>
<p>用户开发的 logger 中间件示例：</p>
<pre><code class="language-js">export default (store) =&gt; (next) =&gt; (action) =&gt; {
  console.log('dispatch:', action)
  next(action)
  console.log('finish:', action)
}
</code></pre>
<h3 id="33-redux-异步流"><a class="header" href="#33-redux-异步流">3.3 redux 异步流</a></h3>
<p>请求发送的最好的地方是：action creator。redux 中可以使用 redux-thunk 中间件实现异步流。</p>
<p>thunk 函数是针对多参数函数的柯里化，以实现函数的惰性求值。任何函数，只要参数有回调函数，都可以写成 thunk 函数形式：</p>
<pre><code class="language-js">// 将 node 的  fs.readFile(filename, callback) thunk 化
const Thunk = function (filename) {
  return function (callback) {
    return fs.readFile(filename, callback)
  }
}

// 使用该 thunk
const readFileChunk = Thunk(filename)
readFieChunk(callback)
</code></pre>
<p>redux-thunk 源码：</p>
<pre><code class="language-js">function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) =&gt;
    (next) =&gt;
    (action) =&gt; {
      if (typeof action === 'function') {
        return action(dispatch, getState, extraArgument)
      }
      return next(action)
    }
}
</code></pre>
<p>当 action 为函数的时候，我们并没有调用 next 或 dispatch 方法，而是返回 action 的调用。这里的 action 即为一个 Thunk 函数，以达到将 dispatch 和 getState 参数传递到函数内的作用。</p>
<p>异步请求示例 (把同步 action 变成了异步 action)：</p>
<pre><code class="language-js">function getProducts(url, params) {
  return (dispatch, getState) =&gt; {
    fetch(url, params)
      .then((result) =&gt; {
        dispatch({
          type: 'GET_PRODUCTS_SUCCESS',
          payload: result,
        })
      })
      .catch((err) =&gt; {
        dispatch({
          type: 'GET_PRODUCTS_ERROR',
          error: err,
        })
      })
  }
}
</code></pre>
<p>使用 async/await 语法简化：</p>
<pre><code class="language-js">const fetchData = (url, params) =&gt; fetch(url, params)
async function getProducts(url, params) {
  const result = await fetchData(url, params)
  if (result.error) {
    return {
      type: 'GET_PRODUCTS_ERROR',
      error: result.error,
    }
  }
  return {
    type: 'GET_PRODUCTS_SUCCESS',
    payload: result,
  }
}
</code></pre>
<p>多异步串联可以通过 promise 传递，将同步、异步都进行统一封装：</p>
<pre><code class="language-js">const sequenceMiddleware =
  ({ dispatch, getState }) =&gt;
  (next) =&gt;
  (action) =&gt; {
    if (!Array.isArray(action)) {
      return next(action)
    }
    return action.reduce((result, currAction) =&gt; {
      return result.then(() =&gt; {
        return Array.isArray(currAction)
          ? Promise.all(currAction.map((item) =&gt; dispatch(item)))
          : dispatch(currAction)
      })
    }, Promise.resolve())
  }
</code></pre>
<p>上述示例中使用 Promise.resolve() 来初始化 action.reduce 方法，然后始终使用 Promise.then() 方法串联起数组，达到了串联步骤的目的。</p>
<p>实践示例，先获取商品分类再获取商品：</p>
<pre><code class="language-js">function getCurrentCategory() {
  return {
    url: '',
    params: {},
    types: [null, 'GET_Category_SUCCESS', null],
  }
}
function getProducts(cid) {
  return {
    url: '',
    params: { cityId },
    types: [null, 'GET_Products_SUCCESS', null],
  }
}
function loadInitData(ip) {
  return [
    getCurrentCategory(ip),
    (dispatch, state) =&gt; {
      dispatch(getProducts(state))
    },
  ]
}
</code></pre>
<h2 id="四-react-redux-综合示例"><a class="header" href="#四-react-redux-综合示例">四 react-redux 综合示例</a></h2>
<h3 id="41-示例目录"><a class="header" href="#41-示例目录">4.1 示例目录</a></h3>
<p>react-redux 是 redux 针对 react 推出的库，提供了 connect、Provider 等配合 redux 能够更好的在组件中传递状态。</p>
<p>所有文件目录：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/../images/mvvm/redux-03.png" alt="redux 项目" /></p>
<p>demmo 示例：
<img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/../images/mvvm/redux-04.png" alt="redux 项目" /></p>
<h3 id="42-入口传递-store"><a class="header" href="#42-入口传递-store">4.2 入口传递 store</a></h3>
<p>入口通过 Provider 挂载传递 store，在根组件中使用后才能在其他组件中任意使用对应状态、函数：</p>
<pre><code class="language-js">import { Provider } from 'react-redux'

import Store from './store'

import CompA from './components/CompA'
import CompB from './components/CompB'

function App() {
  return (
    &lt;Provider store={Store}&gt;
      &lt;div className=&quot;App&quot;&gt;
        &lt;CompA /&gt;
        &lt;CompB /&gt;
      &lt;/div&gt;
    &lt;/Provider&gt;
  )
}

export default App
</code></pre>
<h3 id="43-store"><a class="header" href="#43-store">4.3 store</a></h3>
<p>store 文件专门用于暴露一个 store 对象，整个应用只有一个 store 对象，其内容与 2.3 中间件小节中所示无异：</p>
<pre><code class="language-js">import { createStore, applyMiddleware } from 'redux'
import thunk from 'redux-thunk' // 异步请求中间件
import { createLogger } from 'redux-logger' // 日志中间件

import { reducer } from './reducers/countReducer'

// 环境
let isDev = true
const logger = createLogger({
  predicate: isDev,
  collapsed: true,
})

// 集成中间件
let appliedMiddlewares = applyMiddleware(...[thunk, logger])
if (isDev) {
  const { composeWithDevTools } = require('redux-devtools-extension')
  appliedMiddlewares = composeWithDevTools(appliedMiddlewares)
}

const store = createStore(reducer, appliedMiddlewares)

export default store
</code></pre>
<h3 id="44-constantsjs"><a class="header" href="#44-constantsjs">4.4 constants.js</a></h3>
<p>该模块是用于定义 action 对象中 type 类型的常量值，目的只有一个：便于管理的同时防止程序员单词写错。</p>
<pre><code class="language-js">const ActionTypes = {
  counter: {
    INCREMENT: 'INCREMENT',
    DECREMENT: 'DECREMENT',
  },
  user: {
    GET_USER: 'GET_USER',
    GET_USER_LOADING: 'GET_USER_LOADING', // 正在请求中
    GET_USER_SUCCESS: 'GET_USER_SUCCESS',
    GET_USER_FAIL: 'GET_USER_FAIL',
  },
}

export default ActionTypes
</code></pre>
<h3 id="45-actions"><a class="header" href="#45-actions">4.5 actions</a></h3>
<p>actions 文件夹内全部是视图组件对应的各自 action 对象，以 count 组件对应的 acount_action.js 文件为例：</p>
<p>countActions：</p>
<pre><code class="language-js">import ActionTypes from '../contants'

export function addAction() {
  return {
    type: ActionTypes.counter.INCREMENT,
    payload: {},
  }
}

export function subAction() {
  return {
    type: ActionTypes.counter.DECREMENT,
    payload: {
      num: 1,
    },
  }
}

export function addActionAsync() {
  return (dispatch) =&gt; {
    setTimeout(() =&gt; {
      dispatch({
        type: ActionTypes.counter.INCREMENT,
        payload: {},
      })
    }, 1500)
  }
}

export function subActionAsync() {
  return (dispatch) =&gt; {
    setTimeout(() =&gt; {
      dispatch({
        type: ActionTypes.counter.DECREMENT,
        payload: {
          num: 1,
        },
      })
    }, 1000)
  }
}
</code></pre>
<p>userAtions，包含异步请求：</p>
<pre><code class="language-js">import ActionTypes from '../contants'

export const getUserLoadingAction = () =&gt; {
  return {
    type: ActionTypes.user.GET_USER_LOADING,
  }
}

export const getUserSuccessAction = (data) =&gt; {
  return {
    type: ActionTypes.user.GET_USER_SUCCESS,
    payload: {
      data: data,
    },
  }
}

export const getUserFailAction = (error) =&gt; {
  return {
    type: ActionTypes.user.GET_USER_FAIL,
    payload: {
      error: error,
    },
  }
}

export const fetchUser = (params) =&gt; {
  const { isUpdate } = params

  return (dispatch) =&gt; {
    // 状态一：加载中状态
    dispatch(getUserLoadingAction())

    // 开始请求
    fetch(`http://localhost:3100/user?isUpdate=${isUpdate}`)
      .then((res) =&gt; {
        return res.json()
      })
      .then((data) =&gt; {
        console.log('fetch data:', data)
        // 状态二：请求成功状态
        dispatch(getUserSuccessAction(data))
      })
      .catch((err) =&gt; {
        // 状态三：请求失败状态
        dispatch(getUserFailAction(err))
      })
  }
}
</code></pre>
<h3 id="46-reducers"><a class="header" href="#46-reducers">4.6 reducers</a></h3>
<p>reducers 文件夹内全部是 actions 对应的 reducer，以 count 组件为例，acount_reducer.js 是 count_actions 对应的所有 reducer：</p>
<pre><code class="language-js">import ActionTypes from '../contants'

const initialState = {
  count: 0,
}

const countReducer = (state = initialState, action) =&gt; {
  const cur = state.count
  switch (action.type) {
    case ActionTypes.counter.INCREMENT:
      return {
        ...state,
        count: cur + 1,
      }
    case ActionTypes.counter.DECREMENT:
      return {
        ...state,
        count: cur - action.payload.num,
      }
    default:
      return state
  }
}

export default countReducer
</code></pre>
<p>userReducers:</p>
<pre><code class="language-js">const initialState = {
  data: [{ name: '', age: 0 }], // 请求的数据结果
  loading: false, // 正在请求中
  error: null, // 请求发生错误
}

const userReducer = (state = initialState, action) =&gt; {
  switch (action.type) {
    case 'GET_USER_LOADING':
      return { data: [{ name: '', age: 0 }], loading: true, error: null }
    case 'GET_USER_SUCCESS':
      return { data: action.payload.data, loading: false, error: null }
    case 'GET_USER_FAIL':
      return {
        data: [{ name: '', age: 0 }],
        loading: false,
        error: action.payload.error,
      }
    default:
      return state
  }
}

export default userReducer
</code></pre>
<p>rootReducer:</p>
<pre><code class="language-js">import { combineReducers } from 'redux'

import countReducer from './countReducer'
import userReducer from './userReducer'

const rootReducer = combineReducers({
  counter: countReducer,
  user: userReducer,
})

export default rootReducer
</code></pre>
<h3 id="47-组件中使用"><a class="header" href="#47-组件中使用">4.7 组件中使用</a></h3>
<p>CompA：mapDispatch</p>
<pre><code class="language-js">import React from 'react'
import { connect } from 'react-redux'
// import { addAction, subAction, addActionAsync, subActionAsync } from '../../store/actions/countActions'

import * as countActions from '../../store/actions/countActions'
import { bindActionCreators } from 'redux'

class CompA extends React.Component {
  handleAdd = () =&gt; {
    // this.props.addAction()
    this.props.countActions.addAction()
  }
  handleSub = () =&gt; {
    // this.props.subAction()
    this.props.countActions.subAction()
  }
  handleAddAsync = () =&gt; {
    // this.props.addActionAsync()
    this.props.countActions.addActionAsync()
  }
  handleSubAsync = () =&gt; {
    // this.props.subActionAsync()
    this.props.countActions.subActionAsync()
  }
  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this.handleAdd}&gt; count + &lt;/button&gt;
        &lt;button onClick={this.handleSub}&gt; count - &lt;/button&gt;
        &lt;button onClick={this.handleAddAsync}&gt; 异步 count + &lt;/button&gt;
        &lt;button onClick={this.handleSubAsync}&gt; 异步 count - &lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

const mapDispatchToProps = (dispatch) =&gt; {
  // return {
  //     addAction: ()=&gt;{ dispatch(addAction()) },
  //     subAction: ()=&gt;{ dispatch(subAction()) },
  //     addActionAsync: ()=&gt;{ dispatch(addActionAsync())},
  //     subActionAsync: ()=&gt;{ dispatch(subActionAsync())}
  // }
  return {
    countActions: bindActionCreators(countActions, dispatch),
  }
}

export default connect(null, mapDispatchToProps)(CompA)
</code></pre>
<p>CompB：mapState</p>
<pre><code class="language-js">import React from 'react'
import { connect } from 'react-redux'

class CompB extends React.Component {
  render() {
    return &lt;div&gt;count:{this.props.counter.count}&lt;/div&gt;
  }
}

const mapStateToProps = (state) =&gt; {
  return {
    counter: state.counter, // state 内部 counter 的产生是因为 combineReducers 包裹 reducer 操作
  }
}

export default connect(mapStateToProps)(CompB)
</code></pre>
<p>User：异步请求</p>
<pre><code class="language-js">import React from 'react'
import { connect } from 'react-redux'

import * as userActions from '../../store/actions/userActions'
import { bindActionCreators } from 'redux'

class User extends React.Component {
  componentDidMount() {
    this.props.userActions.fetchUser({ isUpdate: 0 })
  }

  handlUpdateUser = () =&gt; {
    this.props.userActions.fetchUser({ isUpdate: 1 })
  }

  render() {
    console.log('CompUser props:', this.props.user.data[0].name)
    return (
      &lt;div&gt;
        &lt;button onClick={this.handlUpdateUser}&gt;点击更新用户信息&lt;/button&gt;
        &lt;div&gt;用户信息：{this.props.user.data[0].name}&lt;/div&gt;
      &lt;/div&gt;
    )
  }
}

const mapStateToProps = (state) =&gt; {
  console.log('map User:', state)
  return {
    user: state.user,
  }
}

const mapDispatchToProps = (dispatch) =&gt; {
  return {
    userActions: bindActionCreators(userActions, dispatch),
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(User)
</code></pre>
<h2 id="五-高阶-reducer"><a class="header" href="#五-高阶-reducer">五 高阶 reducer</a></h2>
<h3 id="51-reduce-复用"><a class="header" href="#51-reduce-复用">5.1 reduce 复用</a></h3>
<p>在 Redux 架构中，reducer 是一个纯函数，它的职责是根据 previousState 和 action 计算出新的 state。在复杂应用中，Redux 提供的 combineReducers 让我们可以把顶层的 reducer 拆分成多个小的 reducer，分别独立地操作 state 树的不同部分。而在一个应用中，很多小粒度的 reducer 往
往有很多重复的逻辑，使用高阶 reducer 可以抽取公用逻辑，减少代码冗余。</p>
<p>高阶 reducer 就是指将 reducer 作为参数或者返回值的函数。combineReducers 其实就是一个高阶 reducer，combineReducers 将一个 reducer 对象作为参数，最后返回顶层的 reducer。</p>
<p>我们将顶层的 reducer 拆分成多个小的 reducer，肯定会碰到 reducer 的复用问题。例如有 A 和 B 两个模块，它们的 UI 部分相似，此时可以通过配置不同的 props 来区别它们。那么这种情况下，A 和 B 模块能不能共用一个 reducer 呢？答案是否定的。我们先来看一个简单的 reducer：</p>
<pre><code class="language-js">const LOAD_DATA = 'LOAD_DATA'
const initialState = {}

function loadData() {
  return {
    type: LOAD_DATA,
  }
}

function reducer(state = initialState, action) {
  switch (action.type) {
    case LOAD_DATA:
      return {
        ...state,
        data: action.payload,
      }
    default:
      return state
  }
}
</code></pre>
<p>loadData 来分发相应的 action 时，A 和 B 的 reducer 都会处理这个 action，然后 A 和 B 的内容就完全一致了。这里我们需要意识到，在一个应用中，不同模块间的 actionType 必须是全局唯一的。因此，要解决 actionType 唯一的问题，有一个方法就是通过添加前缀的方式来做到：</p>
<pre><code class="language-js">function generateReducer(prefix, state) {
  const LOAD_DATA = prefix + 'LOAD_DATA'
  const initialState = { ...state }

  return function reducer(state = initialState, action) {
    switch (action.type) {
      case LOAD_DATA:
        return {
          ...state,
          data: action.payload,
        }
      default:
        return state
    }
  }
}
</code></pre>
<p>这样只要 A 模块和 B 模块分别调用 generateReducer 来生成相应的 reducer，就能解决 reducer 复用的问题了。而对于 prefix，我们可以根据自己的项目结构来决定，例如 <code>${页面名称}_${模块名称}</code>。只要能够保证全局唯一性，就可以写成一种前缀。</p>
<h3 id="52-reducer-增强"><a class="header" href="#52-reducer-增强">5.2 reducer 增强</a></h3>
<p>高阶 reducer 的另一个重要作用就是对原始的 reducer 进行增强。
redux-undo 就是典型的利用高阶 reducer 来增强 reducer 的例子，它的主要作用是使任意 reducer 变
成可以执行撤销和重做的全新 reducer。我们来看看它的核心代码实现：</p>
<pre><code class="language-js">function undoable(reducer) {
  const initialState = {
    // 记录过去的 state
    past: [],
    // 以一个空的 action 调用 reducer 来产生当前值的初始值
    present: reducer(undefined, {}),
    // 记录后续的 state
    future: [],
  }
  return function (state = initialState, action) {
    const { past, present, future } = state
    switch (action.type) {
      case '@@redux-undo/UNDO':
        const previous = past[past.length - 1]
        const newPast = past.slice(0, past.length - 1)
        return {
          past: newPast,
          present: previous,
          future: [present, ...future],
        }
      case '@@redux-undo/REDO':
        const next = future[0]
        const newFuture = future.slice(1)
        return {
          past: [...past, present],
          present: next,
          future: newFuture,
        }
      default:
        // 将其他 action 委托给原始的 reducer 处理
        const newPresent = reducer(present, action)
        if (present === newPresent) {
          return state
        }
        return {
          past: [...past, present],
          present: newPresent,
          future: [],
        }
    }
  }
}
</code></pre>
<p>有了这个高阶 reducer，就可以对任意一个 reducer 进行封装：</p>
<pre><code class="language-js">import { createStore } from 'redux'
function todos(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
    // ...
  }
}
const undoableTodos = undoable(todos)
const store = createStore(undoableTodos)
store.dispatch({
  type: 'ADD_TODO',
  text: 'Use Redux',
})
store.dispatch({
  type: 'ADD_TODO',
  text: 'Implement Undo',
})
store.dispatch({
  type: '@@redux-undo/UNDO',
})
</code></pre>
<p>高阶 reducer 主要通过下面 3 点来增强 reducer：</p>
<ul>
<li>能够处理额外的 action；</li>
<li>能够维护更多的 state；</li>
<li>将不能处理的 action 委托给原始 reducer 处理。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1101-react-进阶-高阶组件"><a class="header" href="#1101-react-进阶-高阶组件">110.1-React 进阶-高阶组件</a></h1>
<h2 id="一-高阶组件hoc概念"><a class="header" href="#一-高阶组件hoc概念">一 高阶组件（HOC）概念</a></h2>
<p>高阶组件（HOC）的本质是一个参数为组件，返回值为新组件的函数，负责讲一个组件转换为另外一个组件：</p>
<pre><code class="language-js">const EnhancedComponent = higherOrderComponent(WrappedComponent)
</code></pre>
<p>高阶组件自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式，是 React 中用于复用组件逻辑的一种高级技巧。相对于 mixins 来说，更加方便优雅，不会产生新的问题。</p>
<p>HOC 在 React 的第三方库中很常见，例如 Redux 的 connect 和 Relay 的 createFragmentContainer。</p>
<h2 id="二-高阶组件示例"><a class="header" href="#二-高阶组件示例">二 高阶组件示例</a></h2>
<p>假设现在有两个相似的组件：</p>
<pre><code class="language-js">// CommonList 组件 订阅了外部的数据源，用来渲染评论列表
class CommentList extends React.Component {
  constructor(props) {
    super(props)
    this.handleChange = this.handleChange.bind(this)
    this.state = {
      // 假设 &quot;DataSource&quot; 是个全局范围内的数据源变量
      comments: DataSource.getComments(),
    }
  }

  componentDidMount() {
    // 订阅更改
    DataSource.addChangeListener(this.handleChange)
  }
  componentWillUnmount() {
    // 清除订阅
    DataSource.removeChangeListener(this.handleChange)
  }

  handleChange() {
    // 当数据源更新时，更新组件状态
    this.setState({
      comments: DataSource.getComments(),
    })
  }

  render() {
    return (
      &lt;div&gt;
        {this.state.comments.map((comment) =&gt; (
          &lt;Comment comment={comment} key={comment.id} /&gt;
        ))}
      &lt;/div&gt;
    )
  }
}

// BlogPost 组件订阅单个博客帖子
class BlogPost extends React.Component {
  constructor(props) {
    super(props)
    this.handleChange = this.handleChange.bind(this)
    this.state = {
      blogPost: DataSource.getBlogPost(props.id),
    }
  }

  componentDidMount() {
    DataSource.addChangeListener(this.handleChange)
  }

  componentWillUnmount() {
    DataSource.removeChangeListener(this.handleChange)
  }

  handleChange() {
    this.setState({
      blogPost: DataSource.getBlogPost(this.props.id),
    })
  }
  render() {
    return &lt;TextBlock text={this.state.blogPost} /&gt;
  }
}
</code></pre>
<p>CommentList 和 BlogPost 不同 - 它们在 DataSource 上调用不同的方法，且渲染不同的结果。但它们的大部分实现都是一样的：</p>
<ul>
<li>在挂载时，向 DataSource 添加一个更改侦听器。</li>
<li>在侦听器内部，当数据源发生变化时，调用 setState。</li>
<li>在卸载时，删除侦听器。</li>
</ul>
<p>在一个大型应用程序中，这种订阅 DataSource 和调用 setState 的模式将一次又一次地发生。我们需要一个抽象，允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。这正是高阶组件擅长的地方。</p>
<p>对于订阅了 DataSource 的组件，比如 CommentList 和 BlogPost，我们可以编写一个创建组件函数。该函数将接受一个子组件作为它的其中一个参数，该子组件将订阅数据作为 prop。让我们调用函数 withSubscription：</p>
<pre><code class="language-js">function withSubscription(WrappedComponent, selectData) {
  return class extends React.Component {
    constructor(props) {
      super(props)
      this.handleChange = this.handleChange.bind(this)
      this.state = {
        data: selectData(DataSource, props),
      }
    }

    componentDidMount() {
      // ...负责订阅相关的操作...
      DataSource.addChangeListener(this.handleChange)
    }

    componentWillUnmount() {
      DataSource.removeChangeListener(this.handleChange)
    }
    handleChange() {
      this.setState({
        data: selectData(DataSource, this.props),
      })
    }

    render() {
      // ... 使用新数据渲染被包装的组件
      return &lt;WrappedComponent data={this.state.data} {...this.props} /&gt;
    }
  }
}

const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) =&gt; DataSource.getComments()
)

const BlogPostWithSubscription = withSubscription(
  BlogPost,
  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)
)
</code></pre>
<h2 id="三-hoc-使用注意事项"><a class="header" href="#三-hoc-使用注意事项">三 HOC 使用注意事项</a></h2>
<h3 id="31-hoc-函数是个纯函数"><a class="header" href="#31-hoc-函数是个纯函数">3.1 HOC 函数是个纯函数</a></h3>
<p>HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。</p>
<p>不要试图在 HOC 中修改组件原型（或以其他方式改变它），而是尽量采用组合。</p>
<p>这是一个错误示范：</p>
<pre><code class="language-js">function logProps(InputComponent) {
  InputComponent.prototype.componentDidUpdate = function (prevProps) {
    console.log('Current props: ', this.props)
    console.log('Previous props: ', prevProps)
  }
  // 返回原始的 input 组件，暗示它已经被修改。
  return InputComponent
}

// 每次调用 logProps 时，增强组件都会有 log 输出。
const EnhancedComponent = logProps(InputComponent)
</code></pre>
<p>这样做会产生一些不良后果。其一是输入组件再也无法像 HOC 增强之前那样使用了。更严重的是，如果你再用另一个同样会修改 componentDidUpdate 的 HOC 增强它，那么前面的 HOC 就会失效！同时，这个 HOC 也无法应用于没有生命周期的函数组件。</p>
<p>修改传入组件的 HOC 是一种糟糕的抽象方式。调用者必须知道他们是如何实现的，以避免与其他 HOC 发生冲突。</p>
<p>HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：</p>
<pre><code class="language-js">function logProps(WrappedComponent) {
  return class extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('Current props: ', this.props)
      console.log('Previous props: ', prevProps)
    }
    render() {
      // 将 input 组件包装在容器中，而不对其进行修改。Good!
      return &lt;WrappedComponent {...this.props} /&gt;
    }
  }
}
</code></pre>
<p>该 HOC 与上文中修改传入组件的 HOC 功能相同，同时避免了出现冲突的情况。它同样适用于 class 组件和函数组件。而且因为它是一个纯函数，它可以与其他 HOC 组合，甚至可以与其自身组合。</p>
<p>您可能已经注意到 HOC 与容器组件模式之间有相似之处。容器组件担任将高级和低级关注点分离的责任，由容器管理订阅和状态，并将 prop 传递给处理 UI 的组件。HOC 使用容器作为其实现的一部分，你可以将 HOC 视为参数化容器组件。</p>
<h3 id="32-将不相关的-props-传递给被包裹的组件"><a class="header" href="#32-将不相关的-props-传递给被包裹的组件">3.2 将不相关的 props 传递给被包裹的组件</a></h3>
<p>HOC 应该透传与自身无关的 props。大多数 HOC 都应该包含一个类似于下面的 render 方法，以保证 HOC 的灵活性以及可复用性：</p>
<pre><code class="language-js">render() {
  // 过滤掉非此 HOC 额外的 props，且不要进行透传
  const { extraProp, ...passThroughProps } = this.props;

  // 将 props 注入到被包装的组件中。
  // 通常为 state 的值或者实例方法。
  const injectedProp = someStateOrInstanceMethod;

  // 将 props 传递给被包装组件
  return (
    &lt;WrappedComponent
      injectedProp={injectedProp}
      {...passThroughProps}
    /&gt;
  );
}
</code></pre>
<h3 id="33-包装显示名称以便轻松调试"><a class="header" href="#33-包装显示名称以便轻松调试">3.3 包装显示名称以便轻松调试</a></h3>
<p>HOC 创建的容器组件会与任何其他组件一样，会显示在 React Developer Tools 中。为了方便调试，请选择一个显示名称，以表明它是 HOC 的产物。</p>
<p>最常见的方式是用 HOC 包住被包装组件的显示名称。比如高阶组件名为 withSubscription，并且被包装组件的显示名称为 CommentList，显示名称应该为 WithSubscription(CommentList)：</p>
<pre><code class="language-js">function withSubscription(WrappedComponent) {
  class WithSubscription extends React.Component {
    /* ... */
  }
  WithSubscription.displayName = `WithSubscription(${getDisplayName(
    WrappedComponent
  )})`
  return WithSubscription
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component'
}
</code></pre>
<h3 id="34-不要在-render-方法中使用-hoc"><a class="header" href="#34-不要在-render-方法中使用-hoc">3.4 不要在 render 方法中使用 HOC</a></h3>
<p>React 的 diff 算法（称为协调）使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 render 返回的组件与前一个渲染中的组件相同（===），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。</p>
<p>通常，你不需要考虑这点。但对 HOC 来说这一点很重要，因为这代表着你不应在组件的 render 方法中对一个组件应用 HOC：</p>
<pre><code class="language-js">render() {
  // 每次调用 render 函数都会创建一个新的 EnhancedComponent
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！
  return &lt;EnhancedComponent /&gt;;
}
</code></pre>
<p>这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。</p>
<p>如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。一般来说，这跟你的预期表现是一致的。</p>
<p>在极少数情况下，你需要动态调用 HOC。你可以在组件的生命周期方法或其构造函数中进行调用。</p>
<h3 id="35-务必复制静态方法"><a class="header" href="#35-务必复制静态方法">3.5 务必复制静态方法</a></h3>
<p>有时在 React 组件上定义静态方法很有用。例如，Relay 容器暴露了一个静态方法 getFragment 以方便组合 GraphQL 片段。</p>
<p>但是，当你将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。</p>
<pre><code class="language-js">// 定义静态函数
WrappedComponent.staticMethod = function () {
  /*...*/
}
// 现在使用 HOC
const EnhancedComponent = enhance(WrappedComponent)

// 增强组件没有 staticMethod
typeof EnhancedComponent.staticMethod === 'undefined' // true
</code></pre>
<p>为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：</p>
<pre><code class="language-js">function enhance(WrappedComponent) {
  class Enhance extends React.Component {
    /*...*/
  }
  // 必须准确知道应该拷贝哪些方法 :(
  Enhance.staticMethod = WrappedComponent.staticMethod
  return Enhance
}
</code></pre>
<p>但要这样做，你需要知道哪些方法应该被拷贝。你可以使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法:</p>
<pre><code class="language-js">import hoistNonReactStatic from 'hoist-non-react-statics'
function enhance(WrappedComponent) {
  class Enhance extends React.Component {
    /*...*/
  }
  hoistNonReactStatic(Enhance, WrappedComponent)
  return Enhance
}
</code></pre>
<p>除了导出组件，另一个可行的方案是再额外导出这个静态方法。</p>
<pre><code class="language-js">// 使用这种方式代替...
MyComponent.someFunction = someFunction
export default MyComponent

// ...单独导出该方法...
export { someFunction }

// ...并在要使用的组件中，import 它们
import MyComponent, { someFunction } from './MyComponent.js'
</code></pre>
<h3 id="36-refs-不会被传递"><a class="header" href="#36-refs-不会被传递">3.6 Refs 不会被传递</a></h3>
<p>虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 ref 实际上并不是一个 prop - 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p>
<p>这个问题的解决方案是通过使用 React.forwardRef API（React 16.3 中引入）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="102-react-进阶-renderprops"><a class="header" href="#102-react-进阶-renderprops">10.2-React 进阶-RenderProps</a></h1>
<h2 id="一-render-props-概念"><a class="header" href="#一-render-props-概念">一 Render Props 概念</a></h2>
<p>“render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p>
<pre><code class="language-js">&lt;DataProvider render={(data) =&gt; &lt;h1&gt;Hello {data.target}&lt;/h1&gt;} /&gt;
</code></pre>
<p>使用 render prop 的库有 React Router、Downshift 以及 Formik。</p>
<h2 id="二-使用-render-props-来解决横切关注点cross-cutting-concerns"><a class="header" href="#二-使用-render-props-来解决横切关注点cross-cutting-concerns">二 使用 Render Props 来解决横切关注点（Cross-Cutting Concerns）</a></h2>
<p>组件复用是很常见的设计，但是如果要将组件封装的状态、行为共享给其他需要相同状态的组件，则需要一定的技巧。下列示例中，当光标在屏幕上移动时，会显示其（x，y）坐标，如果需要另外一个组件也能实时获取到这个状态，就需要该组件的状态能共享出去，比如另外一个组件需要再界面上根据鼠标位置显示一个方格：</p>
<pre><code class="language-js">function Rect(props) {
  const mouse = props.mouse
  return (
    &lt;div
      style={ {
        position: 'absolute',
        width: '10px',
        height: '10px',
        left: mouse.x,
        top: mouse.y,
        backgroundColor: 'red',
      } }
    /&gt;
  )
}

function Mouse() {
  const [pos, setPos] = useState({ x: 0, y: 0 })

  const handleMouseMove = (event) =&gt; {
    setPos({
      x: event.clientX,
      y: event.clientY,
    })
  }

  return (
    &lt;div style={ { height: '100vh' } } onMouseMove={handleMouseMove}&gt;
      当前鼠标位置： ({pos.x}, {pos.y})
    &lt;/div&gt;
  )
}
</code></pre>
<p>此时我们只要将 Mouse 内 return 的 jsx 修改一下，让其渲染 Cat 即可实现需求：</p>
<pre><code class="language-js">return (
  &lt;div style={ { height: '100vh' } } onMouseMove={handleMouseMove}&gt;
    当前鼠标位置： ({pos.x}, {pos.y})
    &lt;Rect mouse={pos} /&gt;
  &lt;/div&gt;
)
</code></pre>
<p>但是这样做并未达到复用的效果，这也是 render prop 的来历：相比于直接将 <code>&lt;Rect&gt;</code> 写死在 <code>&lt;Mouse&gt;</code> 组件中，我们可以为 <code>&lt;Mouse&gt;</code> 提供一个函数 prop 来动态的确定要渲染什么，这就是 render props：</p>
<pre><code class="language-js">function Rect(props) {
  const mouse = props.mouse
  return (
    &lt;div
      style={ {
        position: 'absolute',
        width: '10px',
        height: '10px',
        left: mouse.x,
        top: mouse.y,
        backgroundColor: 'red',
      } }
    /&gt;
  )
}

function Mouse(props) {
  const [pos, setPos] = useState({ x: 0, y: 0 })

  const handleMouseMove = (event) =&gt; {
    setPos({
      x: event.clientX,
      y: event.clientY,
    })
  }

  // 修改要渲染的结果为外部传入的结果
  return (
    &lt;div style={ { height: '100vh' } } onMouseMove={handleMouseMove}&gt;
      {props.render(pos)}
    &lt;/div&gt;
  )
}

// 新增一个 trakcer 组件
function MouseTracker() {
  return &lt;Mouse render={(mouse) =&gt; &lt;Rect mouse={mouse} /&gt;} /&gt;
}
</code></pre>
<p>综上看出：render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</p>
<p>这项技术使我们共享行为非常容易。要获得这个行为，只要渲染一个带有 render prop 的 <code>&lt;Mouse&gt;</code> 组件就能够告诉它当前鼠标坐标 (x, y) 要渲染什么。</p>
<p>贴士：render prop 是因为模式才被称为 render prop ，不一定要用名为 render 的 prop 来使用这种模，任何被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”。</p>
<h2 id="三-render-props-使用注意事项"><a class="header" href="#三-render-props-使用注意事项">三 Render Props 使用注意事项</a></h2>
<h3 id="31-render-props-与-reactpurecomponent-一起使用"><a class="header" href="#31-render-props-与-reactpurecomponent-一起使用">3.1 Render Props 与 React.PureComponent 一起使用</a></h3>
<p>如果你在 render 方法里创建函数，那么使用 render prop 会抵消使用 React.PureComponent 带来的优势。因为浅比较 props 的时候总会得到 false，并且在这种情况下每一个 render 对于 render prop 将会生成一个新的值。</p>
<p>例如，继续我们之前使用的 <code>&lt;Mouse&gt;</code> 组件，如果 Mouse 继承自 React.PureComponent 而不是 React.Component，我们的例子看起来就像这样：</p>
<pre><code class="language-js">class Mouse extends React.PureComponent {
  // 与上面相同的代码......
}

class MouseTracker extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Move the mouse around!&lt;/h1&gt;

        {/*
          这是不好的！
          每个渲染的 `render` prop的值将会是不同的。
        */}
        &lt;Mouse render={(mouse) =&gt; &lt;Rect mouse={mouse} /&gt;} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>在这样例子中，每次 <code>&lt;MouseTracker&gt;</code> 渲染，它会生成一个新的函数作为 <code>&lt;Mouse render&gt;</code> 的 prop，因而在同时也抵消了继承自 React.PureComponent 的 <code>&lt;Mouse&gt;</code> 组件的效果！</p>
<p>为了绕过这一问题，有时你可以定义一个 prop 作为实例方法，类似这样：</p>
<pre><code class="language-js">class MouseTracker extends React.Component {
  // 定义为实例方法，`this.renderTheCat`始终
  // 当我们在渲染中使用它时，它指的是相同的函数
  renderTheCat(mouse) {
    return &lt;Rect mouse={mouse} /&gt;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Move the mouse around!&lt;/h1&gt;
        &lt;Mouse render={this.renderTheCat} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>如果你无法静态定义 prop（例如，因为你需要控制组件 props 和/或 state 的暴露程度），则 <code>&lt;Mouse&gt;</code> 应该继承自 React.Component。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="103-react-进阶-diffing-算法"><a class="header" href="#103-react-进阶-diffing-算法">10.3-React 进阶-Diffing 算法</a></h1>
<h2 id="一-diffing-算法出现原因"><a class="header" href="#一-diffing-算法出现原因">一 Diffing 算法出现原因</a></h2>
<p>在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。</p>
<p>此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用 <a href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf">最优的算法</a>，该算法的复杂程度仍为 $O(n^3 )$，其中 n 是树中元素的数量。</p>
<p>如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法：</p>
<ul>
<li>两个不同类型的元素会产生出不同的树；</li>
<li>开发者可以使用 key 属性标识哪些子元素在不同的渲染中可能是不变的。</li>
</ul>
<h2 id="二-diffing-算法细节"><a class="header" href="#二-diffing-算法细节">二 Diffing 算法细节</a></h2>
<h3 id="21-对比不同类型的元素"><a class="header" href="#21-对比不同类型的元素">2.1 对比不同类型的元素</a></h3>
<p>当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。举个例子，当一个元素从 <code>&lt;a&gt;</code> 变成 <code>&lt;img&gt;</code>，从 <code>&lt;Article&gt;</code> 变成 <code>&lt;Comment&gt;</code>，或从 <code>&lt;Button&gt;</code> 变成 <code>&lt;div&gt;</code> 都会触发一个完整的重建流程。</p>
<p>当卸载一棵树时，组件实例将执行 componentWillUnmount() 方法，对应的 DOM 节点也会被销毁。</p>
<p>当建立一棵新的树时，组件实例将执行 UNSAFE_componentWillMount() 方法，紧接着 componentDidMount() 方法，对应的 DOM 节点会被创建以及插入到 DOM 中。</p>
<h3 id="22-对比同一类型的元素"><a class="header" href="#22-对比同一类型的元素">2.2 对比同一类型的元素</a></h3>
<p>当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。比如：</p>
<pre><code class="language-js">// 对比这2个元素时，只需要修改 DOM 元素上的 className 属性
&lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&gt;
&lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&gt;
</code></pre>
<p>更新 style 属性时，也仅仅更新所变更的属性：</p>
<pre><code class="language-js">// 只修改color
&lt;div style={ {color: 'red', fontWeight: 'bold'} } &gt;&lt;/div&gt;
&lt;div style={ {color: 'green', fontWeight: 'bold'} }&gt;&lt;/div&gt;
</code></pre>
<h3 id="23-对比同类型的组件元素"><a class="header" href="#23-对比同类型的组件元素">2.3 对比同类型的组件元素</a></h3>
<p>当一个组件更新时，组件实例会保持不变，因此可以在不同的渲染时保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致，并且调用该实例的 UNSAFE_componentWillReceiveProps()、UNSAFE_componentWillUpdate() 以及 componentDidUpdate() 方法。</p>
<p>下一步，调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归。</p>
<h3 id="24-对子节点进行递归"><a class="header" href="#24-对子节点进行递归">2.4 对子节点进行递归</a></h3>
<p>默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。</p>
<p>在子元素列表末尾新增元素时，更新开销比较小。比如：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
  &lt;li&gt;third&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>React 会先匹配两个 <code>&lt;li&gt;first&lt;/li&gt; </code>对应的树，然后匹配第二个元素 <code>&lt;li&gt;second&lt;/li&gt;</code> 对应的树，最后插入第三个元素的 <code>&lt;li&gt;third&lt;/li&gt;</code> 树。</p>
<p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：</p>
<pre><code class="language-js">&lt;ul&gt;
  &lt;li&gt;Duke&lt;/li&gt;
  &lt;li&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li&gt;Connecticut&lt;/li&gt;
  &lt;li&gt;Duke&lt;/li&gt;
  &lt;li&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>React 并不会意识到应该保留 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code>，而是会重建每一个子元素。这种情况会带来性能问题。</p>
<h3 id="25-keys"><a class="header" href="#25-keys">2.5 Keys</a></h3>
<p>为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt;
  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>现在 React 知道只有带着 '2014' key 的元素是新元素，带着 '2015' 以及 '2016' key 的元素仅仅移动了。</p>
<p>实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取</p>
<pre><code class="language-js">&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;
</code></pre>
<p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。</p>
<p>最后，你也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢。</p>
<p>当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动。</p>
<h2 id="三-diffing-算法的权衡"><a class="header" href="#三-diffing-算法的权衡">三 Diffing 算法的权衡</a></h2>
<p>由于 React 依赖启发式算法，因此当以下假设没有得到满足，性能会有所损耗。</p>
<p>该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。在实践中，我们没有遇到这类问题。
Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="104-react-进阶-性能优化"><a class="header" href="#104-react-进阶-性能优化">10.4-React 进阶-性能优化</a></h1>
<h2 id="一-组件性能优化"><a class="header" href="#一-组件性能优化">一 组件性能优化</a></h2>
<h3 id="11-性能优化经验"><a class="header" href="#11-性能优化经验">1.1 性能优化经验</a></h3>
<p>Web 中，浏览器的重绘、重排是对性能影响的最大因素，React 的虚拟 DOM 就是尽可能的减少重绘、重排。为了防止不必要的渲染 React 还提供了便捷的方法：PureRender。</p>
<p>这里涉及纯函数的概念：</p>
<ul>
<li>给定相同的输入，总是返回相同的输出：给定相加的函数 f(2,5)，无论任何时间、执行多少次，都只有一个结果 7。而<code>Math.random()``new Date()</code> <code>slice()</code>则不是纯函数。</li>
<li>过程没有副作用（side effect）：函数不会改变外部状态。比如方法的参数是对象、数组等，执行时就有可能改变外部的该对象、数组。</li>
<li>没有额外的状态依赖：指方法内的状态都只在方法的生命周期内存活，这意味着我们不能在方法内使用共享变量，因为这会给方法带来不可知因素。</li>
</ul>
<p>React 在设计时带有函数式编程的基因，因为 React 组件本身就是纯函数。React 的 createElement 方法保证了组件是纯净的，即传入指定 props 得到一定的 Virtual DOM，整个过程都是可预测的。</p>
<p>我们可以通过拆分组件为子组件，进而对组件做更细粒度的控制。这也是函数式编程的魅力之一，保持纯净状态，可以让方法或组件更加专注（focused），体积更小（small），更独立（independent），更具有复用性（reusability）和可测试性（testability）</p>
<h3 id="12-component-类的问题"><a class="header" href="#12-component-类的问题">1.2 Component 类的问题</a></h3>
<p>使用 Component 实现的组件，在状态更新后会有以下问题：</p>
<ul>
<li>只要执行了 setState()，即使该函数内没做任何事情，组件依然会重新 render</li>
<li>父组件 render 之后，子组件即使没有用到父组件数据也会 render！</li>
</ul>
<p>Component 组件只有在组件的 state 或者 props 真正发生改变触发 render 时，效率才会变高。</p>
<p>render 一直被触发的原因是：shouldComponentUpdate() 这个阀门总是返回 true。所以我们可以在该生命周期内手动进行原状态、修改状态的对比，决定是否返回 true：</p>
<pre><code class="language-js">class CounterButton extends React.Component {
  constructor(props) {
    super(props)
    this.state = { count: 1 }
  }

  shouldComponentUpdate(nextProps, nextState) {
    if (this.props.color !== nextProps.color) {
      return true
    }
    if (this.state.count !== nextState.count) {
      return true
    }
    return false
  }

  render() {
    return (
      &lt;button
        color={this.props.color}
        onClick={() =&gt; this.setState((state) =&gt; ({ count: state.count + 1 }))}
      &gt;
        Count: {this.state.count}
      &lt;/button&gt;
    )
  }
}
</code></pre>
<p>React 已经提供了一位好帮手来帮你实现这种常见的模式 - 你只要继承 React.PureComponent 就行了。所以这段代码可以改成以下这种更简洁的形式：</p>
<pre><code class="language-js">class CounterButton extends React.PureComponent {
  constructor(props) {
    super(props)
    this.state = { count: 1 }
  }

  render() {
    return (
      &lt;button
        color={this.props.color}
        onClick={() =&gt; this.setState((state) =&gt; ({ count: state.count + 1 }))}
      &gt;
        Count: {this.state.count}
      &lt;/button&gt;
    )
  }
}
</code></pre>
<p>大部分情况下，你可以使用 React.PureComponent 来代替手写 shouldComponentUpdate。但它只进行浅比较，所以当 props 或者 state 某种程度是可变的话，浅比较会有遗漏，那你就不能使用它了。当数据结构很复杂时，情况会变得麻烦。例如，你想要一个 ListOfWords 组件来渲染一组用逗号分开的单词。它有一个叫做 WordAdder 的父组件，该组件允许你点击一个按钮来添加一个单词到列表中。以下代码并不正确：</p>
<pre><code class="language-js">class ListOfWords extends React.PureComponent {
  render() {
    return &lt;div&gt;{this.props.words.join(',')}&lt;/div&gt;
  }
}

class WordAdder extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      words: ['marklar'],
    }
    this.handleClick = this.handleClick.bind(this)
  }

  handleClick() {
    // 这部分代码很糟，而且还有 bug
    const words = this.state.words
    words.push('marklar')
    this.setState({ words: words })
  }
  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this.handleClick} /&gt;
        &lt;ListOfWords words={this.state.words} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>问题在于 PureComponent 仅仅会对新老 this.props.words 的值进行简单的对比。由于代码中 WordAdder 的 handleClick 方法改变了同一个 words 数组，使得新老 this.props.words 比较的其实还是同一个数组。即便实际上数组中的单词已经变了，但是比较结果是相同的。可以看到，即便多了新的单词需要被渲染， ListOfWords 却并没有被更新。</p>
<h3 id="13-不可变数据-immutable"><a class="header" href="#13-不可变数据-immutable">1.3 不可变数据 Immutable</a></h3>
<p>Immutable Data 就是一旦创建，就不能再更改的数据。对 Immutable 对象进行修改、添加或删除操作，都会返回一个新的 Immutable 对象。Immutable 实现的原理是持久化的数据结构（persistent data structure），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免深拷贝把所有节点都复制一遍带来的性能损耗，Immutable 使用了结构共享（structuralsharing），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。</p>
<p>Immutable.js 库也是 Facebook 出品的，内部实现一套完整的持久化数据结构，还有很多易用的数据类型，比如 Collection、List、Map、Set、Record、Seq。有非常全面的 map、filter、groupBy、reduce、find 等函数式操作方法。同时，API 也尽量与 JavaScript 的 Object 或 Array 类似。</p>
<p>Immutable 的优点：</p>
<ul>
<li>降低了“可变”带来的复杂度。可变数据耦合了 time 和 value 的概念，造成了数据很难被回溯。</li>
<li>节省内存。Immutable 使用结构共享尽量复用内存。没有被引用的对象会被垃圾回收</li>
<li>撤销/重做，复制/粘贴，甚至时间旅行这些功能做起来都是小菜一碟。因为每次数据都是不一样的，那么只要把这些数据放到一个数组里存储起来，想回退到哪里，就拿出对应的数据，这很容易开发出撤销及重做这两种功能。</li>
<li>并发安全。传统的并发非常难做，因为要处理各种数据不一致的问题，所以“聪明人”发明了各种锁来解决。但使用了 Immutable 之后，数据天生是不可变的，并发锁就不再需要了。然而现在并没有用，因为 JavaScript 还是单线程运行的。</li>
<li>拥抱函数式编程。Immutable 本身就是函数式编程中的概念。只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。</li>
</ul>
<p>节省内存示例：</p>
<pre><code class="language-js">//  a 和 b 共享了没有变化的 filter 节点
import { Map } from 'immutable'
let a = Map({
  select: 'users',
  filter: Map({ name: 'Cam' }),
})
let b = a.set('select', 'people')
a === b // =&gt; false
a.get('filter') === b.get('filter') // =&gt; true
</code></pre>
<p>Immutable 的缺点：容易与原生对象混淆。</p>
<p>注意：两个 Immutable 对象可以使用 === 来比较，这样是直接比较内存地址，其性能最好。但是即使两个对象的值是一样的，也会返回 false：</p>
<pre><code class="language-js">let map1 = Immutable.Map({ a: 1, b: 1, c: 1 })
let map2 = Immutable.Map({ a: 1, b: 1, c: 1 })
map1 === map2 // =&gt; false
// 为了直接比较对象的值，Immutable 提供了 Immutable.is 来作“值比较”：
Immutable.is(map1, map2) // =&gt; true
</code></pre>
<h3 id="13-虚拟化长列表"><a class="header" href="#13-虚拟化长列表">1.3 虚拟化长列表</a></h3>
<p>如果你的应用渲染了长列表（上百甚至上千的数据），我们推荐使用“虚拟滚动”技术。这项技术会在有限的时间内仅渲染有限的内容，并奇迹般地降低重新渲染组件消耗的时间，以及创建 DOM 节点的数量。</p>
<p>react-window 和 react-virtualized 是热门的虚拟滚动库。 它们提供了多种可复用的组件，用于展示列表、网格和表格数据。</p>
<h3 id="14-reactmemo"><a class="header" href="#14-reactmemo">1.4 React.memo</a></h3>
<p>React.memo 为高阶组件。</p>
<p>如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p>
<p>React.memo 仅检查 props 变更。如果函数组件被 React.memo 包裹，且其实现中拥有 useState，useReducer 或 useContext 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。</p>
<p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p>
<pre><code class="language-js">function MyComponent(props) {
  /* 使用 props 渲染 */
}
function areEqual(prevProps, nextProps) {
  /*
  如果把 nextProps 传入 render 方法的返回结果与
  将 prevProps 传入 render 方法的返回结果一致则返回 true，
  否则返回 false
  */
}
export default React.memo(MyComponent, areEqual)
</code></pre>
<p>此方法仅作为性能优化的方式而存在。但请不要依赖它来“阻止”渲染，因为这会产生 bug。与 class 组件中 shouldComponentUpdate() 方法不同的是，如果 props 相等，areEqual 会返回 true；如果 props 不相等，则返回 false。这与 shouldComponentUpdate 方法的返回值相反。</p>
<h2 id="二-打包"><a class="header" href="#二-打包">二 打包</a></h2>
<p>开发环境下的打包项目会在浏览器的 React 开发工具中报红，用来提示需要生产环境打包。</p>
<p>如果你的项目是通过 Create React App 构建的，生产环境下可以运行：<code>npm run build</code> 即可。</p>
<p>如果项目是通过 Rollup 打包，则需要安装插件：</p>
<pre><code class="language-txt"># 如果你使用 npm
npm install --save-dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-terser

# 如果你使用 Yarn
yarn add --dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-terser
</code></pre>
<p>接着打包配置为：</p>
<pre><code class="language-js">plugins: [
  // ...
  require('rollup-plugin-replace')({
    'process.env.NODE_ENV': JSON.stringify('production'),
  }),
  require('rollup-plugin-commonjs')(),
  require('rollup-plugin-terser')(),
  // ...
]
</code></pre>
<h2 id="三-profiler-api"><a class="header" href="#三-profiler-api">三 Profiler API</a></h2>
<h3 id="31-profiler-api-的使用"><a class="header" href="#31-profiler-api-的使用">3.1 Profiler API 的使用</a></h3>
<p>Profiler 用来测量 React 多久渲染一次，以及渲染一次的性能消耗，因此可以识别出应用中渲染较慢的部分，或是可以使用类似 memoization 优化的部分。</p>
<p>不过由于 Profiling 增加了额外的开支，所以它在生产构建中会被禁用。为了将 profiling 功能加入生产环境中，React 提供了 react-profiling 可用于特殊的生产构建环境。</p>
<p>Profiler 能添加在 React 树中的任何地方来测量树中这部分渲染所带来的开销，它需要两个 prop 参数 ：</p>
<ul>
<li>id(string)</li>
<li>onRender(function)：当组件树中的组件“提交”更新的时候被 React 调用的回调函数</li>
</ul>
<p>例如，为了分析 Navigation 组件和它的子代：</p>
<pre><code class="language-js">render(
  &lt;App&gt;
    &lt;Profiler id=&quot;Navigation&quot; onRender={callback}&gt;
      &lt;Navigation {...props} /&gt;
    &lt;/Profiler&gt;
    &lt;Main {...props} /&gt;
  &lt;/App&gt;
)
</code></pre>
<p>多个 Profiler 组件能测量应用中的不同部分：</p>
<pre><code class="language-js">render(
  &lt;App&gt;
    &lt;Profiler id=&quot;Navigation&quot; onRender={callback}&gt;
      &lt;Navigation {...props} /&gt;
    &lt;/Profiler&gt;
    &lt;Profiler id=&quot;Main&quot; onRender={callback}&gt;
      &lt;Main {...props} /&gt;
    &lt;/Profiler&gt;
  &lt;/App&gt;
)
</code></pre>
<p>嵌套使用 Profiler 组件来测量相同一个子树下的不同组件：</p>
<pre><code class="language-js">render(
  &lt;App&gt;
    &lt;Profiler id=&quot;Panel&quot; onRender={callback}&gt;
      &lt;Panel {...props}&gt;
        &lt;Profiler id=&quot;Content&quot; onRender={callback}&gt;
          &lt;Content {...props} /&gt;
        &lt;/Profiler&gt;
        &lt;Profiler id=&quot;PreviewPane&quot; onRender={callback}&gt;
          &lt;PreviewPane {...props} /&gt;
        &lt;/Profiler&gt;
      &lt;/Panel&gt;
    &lt;/Profiler&gt;
  &lt;/App&gt;
)
</code></pre>
<h3 id="32-onrender-回调"><a class="header" href="#32-onrender-回调">3.2 onRender 回调</a></h3>
<p>Profiler 需要一个 onRender 函数作为参数。 React 会在 profile 包含的组件树中任何组件 “提交” 一个更新的时候调用这个函数。 它的参数描述了渲染了什么和花费了多久。</p>
<pre><code class="language-js">function onRenderCallback(
  id, // 发生提交的 Profiler 树的 “id”
  phase, // &quot;mount&quot; （如果组件树刚加载） 或者 &quot;update&quot; （如果它重渲染了）之一
  actualDuration, // 本次更新 committed 花费的渲染时间
  baseDuration, // 估计不使用 memoization 的情况下渲染整棵子树需要的时间
  startTime, // 本次更新中 React 开始渲染的时间
  commitTime, // 本次更新中 React committed 的时间
  interactions // 属于本次更新的 interactions 的集合
) {
  // 合计或记录渲染时间。。。
}
</code></pre>
<ul>
<li>id: string - 发生提交的 Profiler 树的 id。 如果有多个 profiler，它能用来分辨树的哪一部分发生了“提交”。</li>
<li>phase: &quot;mount&quot; | &quot;update&quot; - 判断是组件树的第一次装载引起的重渲染，还是由 props、state 或是 hooks 改变引起的重渲染。</li>
<li>actualDuration: number - 本次更新在渲染 Profiler 和它的子代上花费的时间。 这个数值表明使用 memoization 之后能表现得多好。（例如 React.memo，useMemo，shouldComponentUpdate）。 理想情况下，由于子代只会因特定的 prop 改变而重渲染，因此这个值应该在第一次装载之后显著下降。</li>
<li>baseDuration: number - 在 Profiler 树中最近一次每一个组件 render 的持续时间。 这个值估计了最差的渲染时间。（例如当它是第一次加载或者组件树没有使用 memoization）。</li>
<li>startTime: number - 本次更新中 React 开始渲染的时间戳。</li>
<li>commitTime: number - 本次更新中 React commit 阶段结束的时间戳。 在一次 commit 中这个值在所有的 profiler 之间是共享的，可以将它们按需分组。</li>
<li>interactions: Set - 当更新被制定时，“interactions” 的集合会被追踪。（例如当 render 或者 setState 被调用时）。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="105-react-进阶-派生-state"><a class="header" href="#105-react-进阶-派生-state">10.5-React 进阶-派生 state</a></h1>
<h2 id="一-派生-state-的问题"><a class="header" href="#一-派生-state-的问题">一 派生 state 的问题</a></h2>
<h3 id="11-使用派生-state-的时机"><a class="header" href="#11-使用派生-state-的时机">1.1 使用派生 state 的时机</a></h3>
<p>在 16.3 之前，生命周期函数 componentWillReceiveProps 是响应 Props 变化之后进行更新的唯一方式，目前新增的钩子函数 getDerivedStateFromProps 目的与之相同。而这两个方法在使用上容易出现细微混乱的错误，16.4 修复了这个 bug，让派生更加可控。</p>
<p>getDerivedStateFromProps 的存在只有一个目的：让组件在 props 变化时更新 state，但是该派生 state 方式应该尽量保守使用。派生 state 容易产生的问题的原因是：</p>
<ul>
<li>1，直接复制 props 到 state 上；</li>
<li>2，如果 props 和 state 不一致就更新 state。下面的示例包含了这两种情况。</li>
</ul>
<p>如果你只是为了缓存（memoize）基于当前 props 计算后的结果的话，你就没必要使用派生 state。尝试一下 memoization。</p>
<p>如果只是用来保存 props 或者和当前 state 比较之后不一致后更新 state，那你的组件应该是太频繁的更新了 state。</p>
<h3 id="12-派生-state-的常见-bug"><a class="header" href="#12-派生-state-的常见-bug">1.2 派生 state 的常见 bug</a></h3>
<p>名词“受控”和“非受控”通常用来指代表单的 inputs，但是也可以用来描述数据频繁更新的组件。用 props 传入数据的话，组件可以被认为是受控（因为组件被父级传入的 props 控制）。数据只保存在组件内部的 state 的话，是非受控组件（因为外部没办法直接控制 state）。</p>
<p>常见的错误就是把两者混为一谈。当一个派生 state 值也被 setState 方法更新时，这个值就不是一个单一来源的值了。加载外部数据示例描述的行为和这个类似，但是有很重要的区别。在加载外部数据示例中，数据 source 和 loading 都有非常清晰并且唯一的数据来源。当 prop 改变时，loading 的状态一定会改变。相反，state 只有在 prop 改变时才会改变，除非组件内部还有其他行为改变这个状态。</p>
<p>上述条件如果有一个不满足，就会导致问题，最常见的就是在两个表单里修改数据。</p>
<h3 id="13-错误行为复制-props-到-state-上"><a class="header" href="#13-错误行为复制-props-到-state-上">1.3 错误行为：复制 props 到 state 上</a></h3>
<p>最常见的误解就是 getDerivedStateFromProps 和 componentWillReceiveProps 只会在 props “改变”时才会调用。实际上只要父级重新渲染时，这两个生命周期函数就会重新调用，不管 props 有没有“变化”。所以，在这两个方法内直接复制（unconditionally）props 到 state 是不安全的。这样做会导致 state 后没有正确渲染。</p>
<p>重现一下这个问题。这个 EmailInput 组件复制 props 到 state：</p>
<pre><code class="language-js">class EmailInput extends Component {
  state = { email: this.props.email }

  render() {
    return &lt;input onChange={this.handleChange} value={this.state.email} /&gt;
  }

  handleChange = (event) =&gt; {
    this.setState({ email: event.target.value })
  }

  componentWillReceiveProps(nextProps) {
    // 这会覆盖所有组件内的 state 更新！
    // 不要这样做。
    this.setState({ email: nextProps.email })
  }
}
</code></pre>
<p>乍看之下还可以。 state 的初始值是 props 传来的，当在 <code>&lt;input&gt;</code> 里输入时，修改 state。但是如果父组件重新渲染，我们输入的所有东西都会丢失！(查看这个示例)，即使在重置 state 前比较 nextProps.email !== this.state.email 仍然会导致更新。</p>
<p>这个小例子中，使用 shouldComponentUpdate ，比较 props 的 email 是不是修改再决定要不要重新渲染。但是在实践中，一个组件会接收多个 prop，任何一个 prop 的改变都会导致重新渲染和不正确的状态重置。加上行内函数和对象 prop，创建一个完全可靠的 shouldComponentUpdate 会变得越来越难。这个示例展示了这个情况。而且 shouldComponentUpdate 的最佳实践是用于性能提升，而不是改正不合适的派生 state。</p>
<h3 id="14-错误行为在-props-变化后修改-state"><a class="header" href="#14-错误行为在-props-变化后修改-state">1.4 错误行为：在 props 变化后修改 state</a></h3>
<p>继续上面的示例，我们可以只使用 props.email 来更新组件，这样能防止修改 state 导致的 bug：</p>
<pre><code class="language-js">class EmailInput extends Component {
  state = {
    email: this.props.email,
  }

  // 使用 getDerivedStateFromProps 也是一样的
  componentWillReceiveProps(nextProps) {
    // 只要 props.email 改变，就改变 state
    if (nextProps.email !== this.props.email) {
      this.setState({
        email: nextProps.email,
      })
    }
  }

  // ...
}
</code></pre>
<p>现在组件只会在 prop 改变时才会改变。但是仍然有个问题。想象一下，如果这是一个密码输入组件，拥有同样 email 的两个账户进行切换时，这个输入框不会重置（用来让用户重新登录）。因为父组件传来的 prop 值没有变化！这会让用户非常惊讶，因为这看起来像是帮助一个用户分享了另外一个用户的密码，(查看这个示例)。</p>
<p>虽然这个设计就有问题，但是这样的错误很常见，(我就犯过这样的错误)。幸运的是，有两个方案能解决这些问题。这两者的关键在于，任何数据，都要保证只有一个数据来源，而且避免直接复制它。我们来看看这两个方案。</p>
<h2 id="二-建议的方式"><a class="header" href="#二-建议的方式">二 建议的方式</a></h2>
<h3 id="21-完全可控的组件"><a class="header" href="#21-完全可控的组件">2.1 完全可控的组件</a></h3>
<p>阻止上述问题发生的一个方法是，从组件里删除 state。如果 prop 里包含了 email，我们就没必要担心它和 state 冲突。我们甚至可以把 EmailInput 转换成一个轻量的函数组件：</p>
<pre><code class="language-js">function EmailInput(props) {
  return &lt;input onChange={props.onChange} value={props.email} /&gt;
}
</code></pre>
<p>这样能用最简单的方式完成我们需要的组件。但是如果我们仍然想要保存临时的值，则需要父组件手动执行保存这个动作。</p>
<h3 id="22-有-key-的非可控组件"><a class="header" href="#22-有-key-的非可控组件">2.2 有 key 的非可控组件</a></h3>
<p>另外一个选择是让组件自己存储临时的 email state。在这种情况下，组件仍然可以从 prop 接收“初始值”，但是更改之后的值就和 prop 没关系了：</p>
<pre><code class="language-js">class EmailInput extends Component {
  state = { email: this.props.defaultEmail }

  handleChange = (event) =&gt; {
    this.setState({ email: event.target.value })
  }

  render() {
    return &lt;input onChange={this.handleChange} value={this.state.email} /&gt;
  }
}
</code></pre>
<p>在这密码管理器的例子中，为了在不同的页面切换不同的值，我们可以使用 key 这个特殊的 React 属性。当 key 变化时， React 会创建一个新的而不是更新一个既有的组件。 Keys 一般用来渲染动态列表，但是这里也可以使用。在这个示例里，当用户输入时，我们使用 user ID 当作 key 重新创建一个新的 email input 组件：</p>
<p><EmailInput
  defaultEmail={this.props.user.email}
  key={this.props.user.id}
/>
每次 ID 更改，都会重新创建 EmailInput ，并将其状态重置为最新的 defaultEmail 值， 使用此方法，不用为每次输入都添加 key，在整个表单上添加 key 更有位合理。每次 key 变化，表单里的所有组件都会用新的初始值重新创建。</p>
<p>大部分情况下，这是处理重置 state 的最好的办法。这听起来很慢，但是这点的性能是可以忽略的。如果在组件树的更新上有很重的逻辑，这样反而会更快，因为省略了子组件 diff。</p>
<p>方式一：用 prop 的 ID 重置非受控组件。</p>
<p>如果某些情况下 key 不起作用（可能是组件初始化的开销太大），一个麻烦但是可行的方案是在 getDerivedStateFromProps 观察 userID 的变化：</p>
<pre><code class="language-js">class EmailInput extends Component {
  state = {
    email: this.props.defaultEmail,
    prevPropsUserID: this.props.userID,
  }

  // componentWillReceiveProps 也一样。
  static getDerivedStateFromProps(props, state) {
    // 只要当前 user 变化，
    // 重置所有跟 user 相关的状态。
    // 这个例子中，只有 email 和 user 相关。
    if (props.userID !== state.prevPropsUserID) {
      return {
        prevPropsUserID: props.userID,
        email: props.defaultEmail,
      }
    }
    return null
  }

  // ...
}
</code></pre>
<p>方式二：使用实例方法重置非受控组件。</p>
<p>更少见的情况是，即使没有合适的 key，我们也想重新创建组件。一种解决方案是给一个随机值或者递增的值当作 key，另外一种是用实例方法强制重置内部状态：</p>
<pre><code class="language-js">class EmailInput extends Component {
  state = {
    email: this.props.defaultEmail,
  }

  resetEmailForNewUser(newEmail) {
    this.setState({ email: newEmail })
  }

  // ...
}
</code></pre>
<p>然后父级组件可以使用 ref 调用这个方法。(点击查看这个模式的演示)。</p>
<p>refs 在某些情况下很有用，比如这个。但通常我们建议谨慎使用。即使是做一个演示，这个命令式的方法也是非理想的，因为这会导致两次而不是一次渲染。</p>
<h3 id="23-总结"><a class="header" href="#23-总结">2.3 总结</a></h3>
<p>设计组件时，重要的是确定组件是受控组件还是非受控组件。</p>
<p>不要直接复制（mirror） props 的值到 state 中，而是去实现一个受控的组件，然后在父组件里合并两个值。比如，不要在子组件里被动的接受 props.value 并跟踪一个临时的 state.value，而要在父组件里管理 state.draftValue 和 state.committedValue，直接控制子组件里的值。这样数据才更加明确可预测。</p>
<p>对于不受控的组件，当你想在 prop 变化（通常是 ID ）时重置 state 的话，可以选择以下几种方式：</p>
<p>建议: 重置内部所有的初始 state，使用 key 属性。</p>
<ul>
<li>选项一：仅更改某些字段，观察特殊属性的变化（比如 props.userID）。</li>
<li>选项二：使用 ref 调用实例方法。</li>
</ul>
<h2 id="三-其他方案"><a class="header" href="#三-其他方案">三 其他方案</a></h2>
<h3 id="31-memoization"><a class="header" href="#31-memoization">3.1 memoization</a></h3>
<p>把派生 state 用作 memoization 并不是什么坏事情，但是这并不是好的方法。管理派生 state 本来就很复杂，而且这种复杂度是随着需要管理的属性变得越来越庞大。比如，如果我们想在组件 state 里添加第二个派生 state，那就需要写两份跟踪变化的逻辑。</p>
<p>这里有个示例，组件使用一个 prop ————一个列表————并在用户输入查询条件时显示匹配的项，我们可以使用派生 state 存储过滤后的列表：</p>
<pre><code class="language-js">class Example extends Component {
  state = {
    filterText: '',
  }

  // *******************************************************
  // 注意：这个例子不是建议的方法。
  // 下面的例子才是建议的方法。
  // *******************************************************

  static getDerivedStateFromProps(props, state) {
    // 列表变化或者过滤文本变化时都重新过滤。
    // 注意我们要存储 prevFilterText 和 prevPropsList 来检测变化。
    if (
      props.list !== state.prevPropsList ||
      state.prevFilterText !== state.filterText
    ) {
      return {
        prevPropsList: props.list,
        prevFilterText: state.filterText,
        filteredList: props.list.filter((item) =&gt;
          item.text.includes(state.filterText)
        ),
      }
    }
    return null
  }
  handleChange = (event) =&gt; {
    this.setState({ filterText: event.target.value })
  }

  render() {
    return (
      &lt;Fragment&gt;
        &lt;input onChange={this.handleChange} value={this.state.filterText} /&gt;
        &lt;ul&gt;
          {this.state.filteredList.map((item) =&gt; (
            &lt;li key={item.id}&gt;{item.text}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/Fragment&gt;
    )
  }
}
</code></pre>
<p>这个实现避免了重复计算 filteredList，但是过于复杂。因为它必须单独追踪并检测 prop 和 state 的变化，才能及时的更新过滤后的 list。我们可以使用 PureComponent，把过滤操作放到 render 方法里来简化这个组件：</p>
<pre><code class="language-js">// PureComponents 只会在 state 或者 prop 的值修改时才会再次渲染。
// 通过对 state 和 prop 的 key 做浅比较（ shallow comparison ）来确定有没有变化。
class Example extends PureComponent {
  // state 只需要保存 filter 的值：
  state = {
    filterText: '',
  }

  handleChange = (event) =&gt; {
    this.setState({ filterText: event.target.value })
  }

  render() {
    // PureComponent 的 render 只有
    // 在 props.list 或 state.filterText 变化时才会调用
    const filteredList = this.props.list.filter((item) =&gt;
      item.text.includes(this.state.filterText)
    )

    return (
      &lt;Fragment&gt;
        &lt;input onChange={this.handleChange} value={this.state.filterText} /&gt;
        &lt;ul&gt;
          {filteredList.map((item) =&gt; (
            &lt;li key={item.id}&gt;{item.text}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/Fragment&gt;
    )
  }
}
</code></pre>
<p>上面的方法比派生 state 版本更加清晰明了。只有在过滤很大的列表时，这样做的效率不是很好。当有 prop 改变时 PureComponent 不会阻止再次渲染。为了解决这两个问题，我们可以添加 memoization 帮助函数来阻止非必要的过滤：</p>
<pre><code class="language-js">import memoize from 'memoize-one'

class Example extends Component {
  // state 只需要保存当前的 filter 值：
  state = { filterText: '' }

  // 在 list 或者 filterText 变化时，重新运行 filter：
  filter = memoize((list, filterText) =&gt;
    list.filter((item) =&gt; item.text.includes(filterText))
  )

  handleChange = (event) =&gt; {
    this.setState({ filterText: event.target.value })
  }

  render() {
    // 计算最新的过滤后的 list。
    // 如果和上次 render 参数一样，`memoize-one` 会重复使用上一次的值。
    const filteredList = this.filter(this.props.list, this.state.filterText)

    return (
      &lt;Fragment&gt;
        &lt;input onChange={this.handleChange} value={this.state.filterText} /&gt;
        &lt;ul&gt;
          {filteredList.map((item) =&gt; (
            &lt;li key={item.id}&gt;{item.text}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/Fragment&gt;
    )
  }
}
</code></pre>
<p>这样更简单，而且和派生 state 版本一样好！在使用 memoization 时，请记住这些约束：</p>
<ul>
<li>大部分情况下， 每个组件内部都要引入 memoized 方法，已免实例之间相互影响。</li>
<li>一般情况下，我们会限制 memoization 帮助函数的缓存空间，以免内存泄漏。（上面的例子中，使用 memoize-one 只缓存最后一次的参数和结果）。</li>
<li>如果每次父组件都传入新的 props.list ，那本文提到的问题都不会遇到。在大多数情况下，这种方式是可取的</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="106-react-进阶-代码分割与-suspense"><a class="header" href="#106-react-进阶-代码分割与-suspense">10.6-React 进阶-代码分割与 Suspense</a></h1>
<h2 id="一-代码分割"><a class="header" href="#一-代码分割">一 代码分割</a></h2>
<h3 id="11-代码分割的作用"><a class="header" href="#11-代码分割的作用">1.1 代码分割的作用</a></h3>
<p>对你的应用进行代码分割能够帮助你“懒加载”当前用户所需要的内容，能够显著地提高你的应用性能。尽管并没有减少应用整体的代码体积，但你可以避免加载用户永远不需要的代码，并在初始加载的时候减少所需加载的代码量。</p>
<h3 id="12-import"><a class="header" href="#12-import">1.2 import()</a></h3>
<p>在你的应用中引入代码分割的最佳方式是通过动态 import() 语法：</p>
<pre><code class="language-js">// 使用 import() 语法之前
import { add } from './math'
console.log(add(16, 26))

// 使用 import() 语法之后
import('./math').then((math) =&gt; {
  console.log(math.add(16, 26))
})
</code></pre>
<p>当 Webpack 解析到该语法时，会自动进行代码分割。如果项目采用 Create React App 构建，则该功能已开箱即用。</p>
<h3 id="13-reactlazy"><a class="header" href="#13-reactlazy">1.3 React.lazy</a></h3>
<p>React.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）：</p>
<pre><code class="language-js">// 使用之前：
import OtherComponent from './OtherComponent'

// 使用之后：
const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'))
</code></pre>
<p>代码将会在组件首次渲染时，自动导入包含 OtherComponent 组件的包。</p>
<p>React.lazy 目前只支持默认导出（default exports）。如果你想被引入的模块使用命名导出（named exports），你可以创建一个中间模块，来重新导出为默认模块。这能保证 tree shaking 不会出错，并且不必引入不需要的组件。</p>
<pre><code class="language-js">// ManyComponents.js
export const MyComponent = /* ... */;
export const MyUnusedComponent = /* ... */;

// MyComponent.js
export { MyComponent as default } from &quot;./ManyComponents.js&quot;;

// MyApp.js
import React, { lazy } from 'react';
const MyComponent = lazy(() =&gt; import(&quot;./MyComponent.js&quot;));
</code></pre>
<h2 id="二-suspense-组件应用"><a class="header" href="#二-suspense-组件应用">二 Suspense 组件应用</a></h2>
<h3 id="21-suspense-与-reactlazy-结合"><a class="header" href="#21-suspense-与-reactlazy-结合">2.1 Suspense 与 React.lazy 结合</a></h3>
<p>应该在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。</p>
<pre><code class="language-js">import React, { Suspense } from 'react'

const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'))

function MyComponent() {
  return (
    &lt;div&gt;
      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;OtherComponent /&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>fallback 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 Suspense 组件置于懒加载组件之上的任何位置。你甚至可以用一个 Suspense 组件包裹多个懒加载组件。</p>
<pre><code class="language-js">import React, { Suspense } from 'react'

const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'))
const AnotherComponent = React.lazy(() =&gt; import('./AnotherComponent'))

function MyComponent() {
  return (
    &lt;div&gt;
      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;section&gt;
          &lt;OtherComponent /&gt;
          &lt;AnotherComponent /&gt;
        &lt;/section&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<h3 id="22-避免兜底"><a class="header" href="#22-避免兜底">2.2 避免兜底</a></h3>
<p>任何组件都可能因渲染而暂停，甚至是已经展示给用户的组件。为了使屏幕内容始终一致，如果一个已经显示的组件暂停，React 必须隐藏它的树，直到最近的 <Suspense> 边界。然而，从用户的角度来看，这可能会使人很困惑。</p>
<p>参考这个标签切换的示例：</p>
<pre><code class="language-js">import React, { Suspense } from 'react'
import Tabs from './Tabs'
import Glimmer from './Glimmer'

const Comments = React.lazy(() =&gt; import('./Comments'))
const Photos = React.lazy(() =&gt; import('./Photos'))

function MyComponent() {
  const [tab, setTab] = React.useState('photos')

  function handleTabSelect(tab) {
    setTab(tab)
  }

  return (
    &lt;div&gt;
      &lt;Tabs onTabSelect={handleTabSelect} /&gt;
      &lt;Suspense fallback={&lt;Glimmer /&gt;}&gt;
        {tab === 'photos' ? &lt;Photos /&gt; : &lt;Comments /&gt;}
      &lt;/Suspense&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>在这个示例中，如果标签从 'photos' 切换为 'comments'，但 Comments 会暂停，用户会看到屏幕闪烁。这符合常理，因为用户不想看到 'photos'，而 Comments 组件还没有准备好渲染其内容，而 React 为了保证用户体验的一致性，只能显示上面的 Glimmer，别无选择。</p>
<p>然而，有时这种用户体验并不可取。特别是在准备新 UI 时，展示 “旧” 的 UI 会体验更好。你可以尝试使用新的 startTransition API 来让 React 实现这一点：</p>
<pre><code class="language-js">function handleTabSelect(tab) {
  startTransition(() =&gt; {
    setTab(tab)
  })
}
</code></pre>
<p>此处代码会告知 React，将标签切换为 'comments' 不会标记为紧急更新，而是标记为需要一些准备时间的 transition。然后 React 会保留旧的 UI 并进行交互，当它准备好时，会切换为 <code>&lt;Comments /&gt;</code>。</p>
<h3 id="23-异常捕获边界error-boundaries"><a class="header" href="#23-异常捕获边界error-boundaries">2.3 异常捕获边界（Error boundaries）</a></h3>
<p>如果模块加载失败（如网络问题），它会触发一个错误。你可以通过异常捕获边界（Error boundaries）技术来处理这些情况，以显示良好的用户体验并管理恢复事宜。</p>
<pre><code class="language-js">import React, { Suspense } from 'react'
import MyErrorBoundary from './MyErrorBoundary'

const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'))
const AnotherComponent = React.lazy(() =&gt; import('./AnotherComponent'))

const MyComponent = () =&gt; (
  &lt;div&gt;
    &lt;MyErrorBoundary&gt;
      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;section&gt;
          &lt;OtherComponent /&gt;
          &lt;AnotherComponent /&gt;
        &lt;/section&gt;
      &lt;/Suspense&gt;
    &lt;/MyErrorBoundary&gt;
  &lt;/div&gt;
)
</code></pre>
<h2 id="三-基于路由的代码分割"><a class="header" href="#三-基于路由的代码分割">三 基于路由的代码分割</a></h2>
<p>决定在哪引入代码分割需要一些技巧，因为需要确保选择的位置能够均匀地分割代码包而不会影响用户体验。</p>
<p>一个不错的选择是从路由开始。大多数网络用户习惯于页面之间能有个加载切换过程。你也可以选择重新渲染整个页面，这样您的用户就不必在渲染的同时再和页面上的其他元素进行交互。</p>
<p>以下示例展示了如何在你的应用中使用 React.lazy 和 React Router 这类的第三方库，来配置基于路由的代码分割：</p>
<pre><code class="language-js">import React, { Suspense, lazy } from 'react'
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'

const Home = lazy(() =&gt; import('./routes/Home'))
const About = lazy(() =&gt; import('./routes/About'))

const App = () =&gt; (
  &lt;Router&gt;
    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;/about&quot; element={&lt;About /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/Suspense&gt;
  &lt;/Router&gt;
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="121-react-项目测试"><a class="header" href="#121-react-项目测试">12.1-React 项目测试</a></h1>
<h2 id="一-测试技巧"><a class="header" href="#一-测试技巧">一 测试技巧</a></h2>
<h3 id="11-创建清理"><a class="header" href="#11-创建清理">1.1 创建/清理</a></h3>
<p>对于每个测试，我们通常希望将 React 树渲染给附加到 document 的 DOM 元素。这点很重要，以便它可以接收 DOM 事件。当测试结束时，我们需要“清理”并从 document 中卸载树。</p>
<p>常见的方法是使用一对 beforeEach 和 afterEach 块，以便它们一直运行，并隔离测试本身造成的影响：</p>
<pre><code class="language-js">import { unmountComponentAtNode } from 'react-dom'

let container = null
beforeEach(() =&gt; {
  // 创建一个 DOM 元素作为渲染目标
  container = document.createElement('div')
  document.body.appendChild(container)
})

afterEach(() =&gt; {
  // 退出时进行清理
  unmountComponentAtNode(container)
  container.remove()
  container = null
})
</code></pre>
<p>你可以使用不同的测试模式，但请注意，即使测试失败，也需要执行清理。否则，测试可能会导致“泄漏”，并且一个测试可能会影响另一个测试的行为。这使得其难以调试。</p>
<h3 id="12-act"><a class="header" href="#12-act">1.2 act()</a></h3>
<p>在编写 UI 测试时，可以将渲染、用户事件或数据获取等任务视为与用户界面交互的“单元”。react-dom/test-utils 提供了一个名为 act() 的 helper，它确保在进行任何断言之前，与这些“单元”相关的所有更新都已处理并应用于 DOM：</p>
<pre><code class="language-js">// act 名称来自 Arrange-Act-Assert 模式
act(() =&gt; {
  // 渲染组件
})
// 进行断言
</code></pre>
<p>这有助于使测试运行更接近真实用户在使用应用程序时的体验。这些示例的其余部分使用 act() 来作出这些保证。</p>
<p>你可能会发现直接使用 act() 有点过于冗长。为了避免一些样板代码，你可以使用 React 测试库，这些 helper 是使用 act() 函数进行封装的。</p>
<h3 id="13-渲染"><a class="header" href="#13-渲染">1.3 渲染</a></h3>
<p>通常，你可能希望测试组件对于给定的 prop 渲染是否正确。此时应考虑实现基于 prop 渲染消息的简单组件：</p>
<pre><code class="language-js">// hello.js

import React from 'react'

export default function Hello(props) {
  if (props.name) {
    return &lt;h1&gt;你好，{props.name}！&lt;/h1&gt;
  } else {
    return &lt;span&gt;嘿，陌生人&lt;/span&gt;
  }
}
</code></pre>
<p>我们可以为这个组件编写测试：</p>
<pre><code class="language-js">// hello.test.js

import React from 'react'
import { render, unmountComponentAtNode } from 'react-dom'
import { act } from 'react-dom/test-utils'

import Hello from './hello'

let container = null
beforeEach(() =&gt; {
  // 创建一个 DOM 元素作为渲染目标
  container = document.createElement('div')
  document.body.appendChild(container)
})
afterEach(() =&gt; {
  // 退出时进行清理
  unmountComponentAtNode(container)
  container.remove()
  container = null
})

it('渲染有或无名称', () =&gt; {
  act(() =&gt; {
    render(&lt;Hello /&gt;, container)
  })
  expect(container.textContent).toBe('嘿，陌生人')

  act(() =&gt; {
    render(&lt;Hello name=&quot;Jenny&quot; /&gt;, container)
  })
  expect(container.textContent).toBe('你好，Jenny！')

  act(() =&gt; {
    render(&lt;Hello name=&quot;Margaret&quot; /&gt;, container)
  })
  expect(container.textContent).toBe('你好，Margaret！')
})
</code></pre>
<h3 id="14-数据获取"><a class="header" href="#14-数据获取">1.4 数据获取</a></h3>
<p>你可以使用假数据来 mock 请求，而不是在所有测试中调用真正的 API。使用“假”数据 mock 数据获取可以防止由于后端不可用而导致的测试不稳定，并使它们运行得更快。注意：你可能仍然希望使用一个“端到端”的框架来运行测试子集，该框架可显示整个应用程序是否一起工作。</p>
<pre><code class="language-js">// user.js

import React, { useState, useEffect } from 'react'

export default function User(props) {
  const [user, setUser] = useState(null)

  async function fetchUserData(id) {
    const response = await fetch('/' + id)
    setUser(await response.json())
  }

  useEffect(() =&gt; {
    fetchUserData(props.id)
  }, [props.id])

  if (!user) {
    return '加载中...'
  }

  return (
    &lt;details&gt;
      &lt;summary&gt;{user.name}&lt;/summary&gt;
      &lt;strong&gt;{user.age}&lt;/strong&gt; 岁
      &lt;br /&gt;
      住在 {user.address}
    &lt;/details&gt;
  )
}
</code></pre>
<p>我们可以为它编写测试：</p>
<pre><code class="language-js">// user.test.js

import React from 'react'
import { render, unmountComponentAtNode } from 'react-dom'
import { act } from 'react-dom/test-utils'
import User from './user'

let container = null
beforeEach(() =&gt; {
  // 创建一个 DOM 元素作为渲染目标
  container = document.createElement('div')
  document.body.appendChild(container)
})

afterEach(() =&gt; {
  // 退出时进行清理
  unmountComponentAtNode(container)
  container.remove()
  container = null
})

it('渲染用户数据', async () =&gt; {
  const fakeUser = {
    name: 'Joni Baez',
    age: '32',
    address: '123, Charming Avenue',
  }
  jest.spyOn(global, 'fetch').mockImplementation(() =&gt;
    Promise.resolve({
      json: () =&gt; Promise.resolve(fakeUser),
    })
  )

  // 使用异步的 act 应用执行成功的 promise
  await act(async () =&gt; {
    render(&lt;User id=&quot;123&quot; /&gt;, container)
  })

  expect(container.querySelector('summary').textContent).toBe(fakeUser.name)
  expect(container.querySelector('strong').textContent).toBe(fakeUser.age)
  expect(container.textContent).toContain(fakeUser.address)

  // 清理 mock 以确保测试完全隔离
  global.fetch.mockRestore()
})
</code></pre>
<h3 id="15-mock-模块"><a class="header" href="#15-mock-模块">1.5 mock 模块</a></h3>
<p>有些模块可能在测试环境中不能很好地工作，或者对测试本身不是很重要。使用虚拟数据来 mock 这些模块可以使你为代码编写测试变得更容易。</p>
<p>考虑一个嵌入第三方 GoogleMap 组件的 Contact 组件：</p>
<pre><code class="language-js">// map.js
import React from 'react'

import { LoadScript, GoogleMap } from 'react-google-maps'
export default function Map(props) {
  return (
    &lt;LoadScript id=&quot;script-loader&quot; googleMapsApiKey=&quot;YOUR_API_KEY&quot;&gt;
      &lt;GoogleMap id=&quot;example-map&quot; center={props.center} /&gt;
    &lt;/LoadScript&gt;
  )
}

// contact.js
import React from &quot;react&quot;;
import Map from &quot;./map&quot;;

export default function Contact(props) {
  return (
    &lt;div&gt;
      &lt;address&gt;
        联系 {props.name}，通过{&quot; &quot;}
        &lt;a data-testid=&quot;email&quot; href={&quot;mailto:&quot; + props.email}&gt;
          email
        &lt;/a&gt;
        或者他们的 &lt;a data-testid=&quot;site&quot; href={props.site}&gt;
          网站
        &lt;/a&gt;。
      &lt;/address&gt;
      &lt;Map center={props.center} /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>如果不想在测试中加载这个组件，我们可以将依赖 mock 到一个虚拟组件，然后运行我们的测试：</p>
<pre><code class="language-js">// contact.test.js

import React from 'react'
import { render, unmountComponentAtNode } from 'react-dom'
import { act } from 'react-dom/test-utils'

import Contact from './contact'
import MockedMap from './map'

jest.mock('./map', () =&gt; {
  return function DummyMap(props) {
    return (
      &lt;div data-testid=&quot;map&quot;&gt;
        {props.center.lat}:{props.center.long}
      &lt;/div&gt;
    )
  }
})
let container = null
beforeEach(() =&gt; {
  // 创建一个 DOM 元素作为渲染目标
  container = document.createElement('div')
  document.body.appendChild(container)
})

afterEach(() =&gt; {
  // 退出时进行清理
  unmountComponentAtNode(container)
  container.remove()
  container = null
})

it('应渲染联系信息', () =&gt; {
  const center = { lat: 0, long: 0 }
  act(() =&gt; {
    render(
      &lt;Contact
        name=&quot;Joni Baez&quot;
        email=&quot;test@example.com&quot;
        site=&quot;http://test.com&quot;
        center={center}
      /&gt;,
      container
    )
  })
  expect(
    container.querySelector(&quot;[data-testid='email']&quot;).getAttribute('href')
  ).toEqual('mailto:test@example.com')

  expect(
    container.querySelector('[data-testid=&quot;site&quot;]').getAttribute('href')
  ).toEqual('http://test.com')

  expect(container.querySelector('[data-testid=&quot;map&quot;]').textContent).toEqual(
    '0:0'
  )
})
</code></pre>
<h3 id="16-events"><a class="header" href="#16-events">1.6 Events</a></h3>
<p>我们建议在 DOM 元素上触发真正的 DOM 事件，然后对结果进行断言。考虑一个 Toggle 组件：</p>
<pre><code class="language-js">// toggle.js

import React, { useState } from 'react'

export default function Toggle(props) {
  const [state, setState] = useState(false)
  return (
    &lt;button
      onClick={() =&gt; {
        setState((previousState) =&gt; !previousState)
        props.onChange(!state)
      } }
      data-testid=&quot;toggle&quot;
    &gt;
      {state === true ? 'Turn off' : 'Turn on'}
    &lt;/button&gt;
  )
}
</code></pre>
<p>我们可以为它编写测试：</p>
<pre><code class="language-js">// toggle.test.js

import React from 'react'
import { render, unmountComponentAtNode } from 'react-dom'
import { act } from 'react-dom/test-utils'

import Toggle from './toggle'

let container = null
beforeEach(() =&gt; {
  // 创建一个 DOM 元素作为渲染目标
  container = document.createElement('div')
  document.body.appendChild(container)
})
afterEach(() =&gt; {
  // 退出时进行清理
  unmountComponentAtNode(container)
  container.remove()
  container = null
})

it('点击时更新值', () =&gt; {
  const onChange = jest.fn()
  act(() =&gt; {
    render(&lt;Toggle onChange={onChange} /&gt;, container)
  })

  // 获取按钮元素，并触发点击事件
  const button = document.querySelector('[data-testid=toggle]')
  expect(button.innerHTML).toBe('Turn on')

  act(() =&gt; {
    button.dispatchEvent(new MouseEvent('click', { bubbles: true }))
  })

  expect(onChange).toHaveBeenCalledTimes(1)
  expect(button.innerHTML).toBe('Turn off')
  act(() =&gt; {
    for (let i = 0; i &lt; 5; i++) {
      button.dispatchEvent(new MouseEvent('click', { bubbles: true }))
    }
  })

  expect(onChange).toHaveBeenCalledTimes(6)
  expect(button.innerHTML).toBe('Turn on')
})
</code></pre>
<h3 id="17-计时器"><a class="header" href="#17-计时器">1.7 计时器</a></h3>
<p>你的代码可能会使用基于计时器的函数（如 setTimeout）来安排将来更多的工作。在这个例子中，多项选择面板等待选择并前进，如果在 5 秒内没有做出选择，则超时：</p>
<pre><code class="language-js">// card.js

import React, { useEffect } from 'react'

export default function Card(props) {
  useEffect(() =&gt; {
    const timeoutID = setTimeout(() =&gt; {
      props.onSelect(null)
    }, 5000)
    return () =&gt; {
      clearTimeout(timeoutID)
    }
  }, [props.onSelect])

  return [1, 2, 3, 4].map((choice) =&gt; (
    &lt;button
      key={choice}
      data-testid={choice}
      onClick={() =&gt; props.onSelect(choice)}
    &gt;
      {choice}
    &lt;/button&gt;
  ))
}
</code></pre>
<p>我们可以利用 Jest 的计时器 mock 为这个组件编写测试，并测试它可能处于的不同状态。</p>
<pre><code class="language-js">// card.test.js

import React from 'react'
import { render, unmountComponentAtNode } from 'react-dom'
import { act } from 'react-dom/test-utils'

import Card from './card'

let container = null
beforeEach(() =&gt; {
  // 创建一个 DOM 元素作为渲染目标
  container = document.createElement('div')
  document.body.appendChild(container)
  jest.useFakeTimers()
})

afterEach(() =&gt; {
  // 退出时进行清理
  unmountComponentAtNode(container)
  container.remove()
  container = null
  jest.useRealTimers()
})

it('超时后应选择 null', () =&gt; {
  const onSelect = jest.fn()
  act(() =&gt; {
    render(&lt;Card onSelect={onSelect} /&gt;, container)
  })

  // 提前 100 毫秒执行
  act(() =&gt; {
    jest.advanceTimersByTime(100)
  })
  expect(onSelect).not.toHaveBeenCalled()

  // 然后提前 5 秒执行
  act(() =&gt; {
    jest.advanceTimersByTime(5000)
  })
  expect(onSelect).toHaveBeenCalledWith(null)
})

it('移除时应进行清理', () =&gt; {
  const onSelect = jest.fn()
  act(() =&gt; {
    render(&lt;Card onSelect={onSelect} /&gt;, container)
  })
  act(() =&gt; {
    jest.advanceTimersByTime(100)
  })
  expect(onSelect).not.toHaveBeenCalled()

  // 卸载应用程序
  act(() =&gt; {
    render(null, container)
  })
  act(() =&gt; {
    jest.advanceTimersByTime(5000)
  })
  expect(onSelect).not.toHaveBeenCalled()
})

it('应接受选择', () =&gt; {
  const onSelect = jest.fn()
  act(() =&gt; {
    render(&lt;Card onSelect={onSelect} /&gt;, container)
  })

  act(() =&gt; {
    container
      .querySelector(&quot;[data-testid='2']&quot;)
      .dispatchEvent(new MouseEvent('click', { bubbles: true }))
  })

  expect(onSelect).toHaveBeenCalledWith(2)
})
</code></pre>
<p>你只能在某些测试中使用假计时器。在上面，我们通过调用 jest.useFakeTimers() 来启用它们。它们提供的主要优势是，你的测试实际上不需要等待 5 秒来执行，而且你也不需要为了测试而使组件代码更加复杂。</p>
<h3 id="18-快照测试"><a class="header" href="#18-快照测试">1.8 快照测试</a></h3>
<p>像 Jest 这样的框架还允许你使用 toMatchSnapshot / toMatchInlineSnapshot 保存数据的“快照”。有了这些，我们可以“保存”渲染的组件输出，并确保对它的更新作为对快照的更新显式提交。</p>
<p>在这个示例中，我们渲染一个组件并使用 pretty 包对渲染的 HTML 进行格式化，然后将其保存为内联快照：</p>
<pre><code class="language-js">// hello.test.js, again

import React from 'react'
import { render, unmountComponentAtNode } from 'react-dom'
import { act } from 'react-dom/test-utils'
import pretty from 'pretty'

import Hello from './hello'

let container = null
beforeEach(() =&gt; {
  // 创建一个 DOM 元素作为渲染目标
  container = document.createElement('div')
  document.body.appendChild(container)
})

afterEach(() =&gt; {
  // 退出时进行清理
  unmountComponentAtNode(container)
  container.remove()
  container = null
})

it('应渲染问候语', () =&gt; {
  act(() =&gt; {
    render(&lt;Hello /&gt;, container)
  })

  expect(
    pretty(container.innerHTML)
  ).toMatchInlineSnapshot() /* ... 由 jest 自动填充 ... */

  act(() =&gt; {
    render(&lt;Hello name=&quot;Jenny&quot; /&gt;, container)
  })

  expect(
    pretty(container.innerHTML)
  ).toMatchInlineSnapshot() /* ... 由 jest 自动填充 ... */

  act(() =&gt; {
    render(&lt;Hello name=&quot;Margaret&quot; /&gt;, container)
  })

  expect(
    pretty(container.innerHTML)
  ).toMatchInlineSnapshot() /* ... 由 jest 自动填充 ... */
})
</code></pre>
<p>通常，进行具体的断言比使用快照更好。这类测试包括实现细节，因此很容易中断，并且团队可能对快照中断不敏感。选择性地 mock 一些子组件可以帮助减小快照的大小，并使它们在代码评审中保持可读性。</p>
<h3 id="19-多渲染器"><a class="header" href="#19-多渲染器">1.9 多渲染器</a></h3>
<p>在极少数情况下，你可能正在使用多个渲染器的组件上运行测试。例如，你可能正在使用 react-test-renderer 组件上运行快照测试，该组件内部使用 react-dom 的 render 来渲染子组件的一些内容。在这个场景中，你可以使用与它们的渲染器相对应的 act() 来包装更新。</p>
<pre><code class="language-js">import { act as domAct } from 'react-dom/test-utils'
import { act as testAct, create } from 'react-test-renderer'
// ...
let root
domAct(() =&gt; {
  testAct(() =&gt; {
    root = create(&lt;App /&gt;)
  })
})
expect(root).toMatchSnapshot()
</code></pre>
<h2 id="二-测试环境"><a class="header" href="#二-测试环境">二 测试环境</a></h2>
<h3 id="21-测试运行器"><a class="header" href="#21-测试运行器">2.1 测试运行器</a></h3>
<p>使用 Jest，mocha，ava 等测试运行器能像编写 JavaScript 一样编写测试套件，并将其作为开发过程的环节运行。此外，测试套件也将作为持续集成的环节运行。</p>
<ul>
<li>Jest 与 React 项目广泛兼容，支持诸如模拟 模块、计时器 和 jsdom 等特性。如果你使用 Create React App，Jest 已经能够开箱即用且包含许多实用的默认配置。</li>
<li>像 mocha 这样的库在真实浏览器环境下运行良好，并且可以为明确需要它的测试提供帮助。</li>
<li>端对端测试用于测试跨多个页面的长流程，并且需要不同的设置。</li>
</ul>
<h3 id="22-模拟渲染表面"><a class="header" href="#22-模拟渲染表面">2.2 模拟渲染表面</a></h3>
<p>测试通常在无法访问真实渲染表面（如浏览器）的环境中运行。对于这些环境，我们建议使用 jsdom 来模拟浏览器，这是一个在 Node.js 内运行的轻量级浏览器实现。</p>
<p>在大多数情况下，jsdom 的行为类似于常规浏览器，但不具备如布局和导航的功能。这对于大多数基于 Web 的组件测试仍然有用，因为它的运行比为每个测试启动浏览器的方式效率更高。并且由于它与你编写的测试运行在同一个进程中，所以你能够编写代码来检查和断言渲染的 DOM。</p>
<p>就像在真实的浏览器中一样，jsdom 让我们模拟用户交互；测试可以在 DOM 节点上派发事件，然后观察并断言这些操作的副作用(例子)。</p>
<p>可以使用上述设置编写大部分 UI 测试：使用 Jest 作为测试运行器，渲染到 jsdom，使用 act() 辅助函数(例子)提供的能力通过一系列的浏览器事件来模拟用户交互行为。例如，大量 React 自己的测试都是用这种组合编写的。</p>
<p>如果您正在编写一个主要测试浏览器特定行为的库，并且需要布局或真实输入等原生浏览器行为，那么你可以使用像 mocha 这样的框架。</p>
<p>在你 无法 模拟 DOM 环境（例如，在 Node.js 上测试 React Native 组件）的情况下，可以使用 事件模拟辅助函数 来模拟与元素的交互。或者，你也可以使用 @testing-library/react-native 中的 fireEvent 辅助函数。</p>
<p>诸如 Cypress，puppeteer 和 webdriver 等框架对于运行端对端测试 都非常有用。</p>
<h3 id="23-模拟功能"><a class="header" href="#23-模拟功能">2.3 模拟功能</a></h3>
<p>在编写测试的时候，我们希望模拟代码在测试环境较真实环境中缺失的等效部分（例如，在 Node.js 中检查 navigator.onLine 的状态）。测试还可以监视某些功能，并观察测试的其他部分如何与它们进行交互。有选择的将这些功能模拟为测试友好的版本是很有用的。</p>
<p>这对于数据获取尤其有用。通常最好使用“假”数据进行测试，以避免从实际 API 端获取数据可能导致的缓慢和不稳定（例子）。这样做有助于让测试变得可预测。像 Jest 与 sinon 这样的类库，支持模拟功能。对于端对端测试，虽然模拟网络可能更加困难，但你可能还想对真实的 API 端进行测试。</p>
<h3 id="24-模拟模块"><a class="header" href="#24-模拟模块">2.4 模拟模块</a></h3>
<p>一些组件可能会依赖在测试环境中无法正常运行的模块，或者说这些模块对于我们的测试并不必要。那么，通过选择性地模拟来替换这些模块是很有用的（例子）。</p>
<p>在 Node.js 中，测试运行器如 Jest 支持模拟模块。你也可以使用像 mock-require 这样的类库。</p>
<h3 id="25-模拟计时器"><a class="header" href="#25-模拟计时器">2.5 模拟计时器</a></h3>
<p>组件可能会使用基于时间的函数如 setTimeout、setInterval 和 Date.now 等。在测试环境中，使用可以手动“推进”时间的替代物来模拟这些功能会很有帮助。它会确保你的测试快速运行！依赖于计时器的测试仍将按照顺序解析，但会更快（例子）。大部分测试框架，包括 Jest、sinon 和 lolex 都允许你在测试中模拟计时器。</p>
<p>有些时候可能你不想要模拟计时器。例如，在你测试动画时，或是交互端对时间较为敏感的情况下（如 API 访问速率限制器）。具有计时器模拟的库允许你在每个测试/套件上启用或禁用这个功能，因此你可以明确地选择这些测试的运行方式。</p>
<h3 id="26-端对端测试"><a class="header" href="#26-端对端测试">2.6 端对端测试</a></h3>
<p>端对端测试对于测试更长的工作流程非常有用，特别是当它们对于你的业务（例如付款或注册）特别重要时。对于这些测试，你可能会希望测试真实浏览器如何渲染整个应用、从真实的 API 端获取数据、使用 session 和 cookies 以及在不同的链接间导航等功能。你可能还希望不仅在 DOM 状态上进行断言，而同时也在后端数据上进行校验（例如，验证更新是否已经在数据库中持久化）。</p>
<p>在这种场景下，你可以使用像 Cypress，Playwright 等类似框架或者使用 Puppeteer 这样的库，这样你就可以在多个路由之间导航切换，并且不仅能够在浏览器中对副作用进行断言也能够在后端这么做。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-vue-简介"><a class="header" href="#011-vue-简介">01.1-Vue 简介</a></h1>
<h2 id="一-开发思想-概念"><a class="header" href="#一-开发思想-概念">一 开发思想 概念</a></h2>
<h3 id="11-mvc-1"><a class="header" href="#11-mvc-1">1.1 MVC</a></h3>
<p>在大型项目开发中，往往需要用业务逻辑、数据、界面显示分离的方法组织代码，以便在代码需要改进时能够做到最小化变更，便于扩展维护。</p>
<p>最经典的软件设计规范即 MVC（Model View Controller）：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/mvvm/mvc01.svg" alt="mvc" /></p>
<ul>
<li>模型 model：对业务数据的抽象，如用户数据包括：uid、name、age 等，在模型层，将其抽象为 User 对象，包含上述字段，并附带基础的增删改查实例操作</li>
<li>视图 view：数据的可视化界面。更加面向普通用户，提供给了用户操作界面，即前端开发中最常见的网页</li>
<li>控制器 controller：数据流向的控制者，在数据发生变化时更新视图。控制层位于视图层与模型层中间，负责视图层数据的流转，即根据用户在视图层提交的数据，去模型层执行增删改查等操作</li>
</ul>
<h3 id="12-mvvm-1"><a class="header" href="#12-mvvm-1">1.2 MVVM</a></h3>
<p>MVC 思想在传统后端领域实现较多，但是在前端，开发者更多关注的是界面与数据。前端在行为交互上存在大量的相同代码，比如 tab 切换需要反复对几个 tab 元素进行循环遍历从而实现数据到界面，界面到数据的双向交互，MVC 思想在前端领域适应性较低。</p>
<p>MVVM 是前端视图层的分层开发思想，将前端视图的结构划分为 M（model）、V（view）、VM（view-model）三层：</p>
<ul>
<li>M：数据模型层，这里是接口请求到的数据结果集，封装于 data 对象中，专门用来保存每个页面里单独的数据。</li>
<li>V：视图层，vue 实例所控制的元素区域，即每个页面的 html 结构。</li>
<li>VM：VM 调度者，即 new 出来的 vue 实例对象，用来解耦视图层与数据模型层。视图层想要获取或保存数据的都需要由 vm 做中间处理。</li>
</ul>
<p>MVC 里的 C 是控制器，由不同的控制函数/对象，手动实现调度数据与视图转换。MVVM 的 VM 内部往往也存在一个虚拟 DOM，有了该调度者，开发者不再需要反复关注 DOM，只用与后台进行数据交互即可，数据模型的变更能够自动驱动视图的变更。</p>
<p>在前端中常见的具有 MVVM 思想的框架有：React、Vue。</p>
<p>在 MVVM 中：</p>
<ul>
<li>模型层数据发生变动，通过数据绑定形式驱动界面发生改变；</li>
<li>界面上的数据发生改变时，通过对 DOM 的监听驱动模型层数据发生改变！</li>
</ul>
<p>负责数据绑定、DOM 监听的就是 MVVM 编程的核心 VM 层，Vue/React 框架便是在其内部实现了这些机制。</p>
<h3 id="13-vue-与-react-1"><a class="header" href="#13-vue-与-react-1">1.3 Vue 与 React</a></h3>
<p>Vue 与 React 均是当前流行的框架，也都受到了 MVVM 编程思想的影响。二者的本质区别是：数据响应方式不同。React 侧重于用户手动 setState() 更新，Vue 中数据改动则界面自动更新。</p>
<p>二者没有绝对优劣，只是开发思维的不同。React 可以使用 mobx 实现类似 Vue 的响应编程，Vue 也可以把数据 freeze，不再具备响应式。</p>
<h3 id="14-单页面应用弊端"><a class="header" href="#14-单页面应用弊端">1.4 单页面应用弊端</a></h3>
<p>使用 MVVM 思想可以让一个单页面就能实现一个完整的应用，虽然有一定的优点，但是在一个超大项目中，需要集成很多模块，造成其首次加载速度变慢，且一个局部异常容易造成整个 APP 无法使用。而多页面应用就不会有这两个缺点，笔者推荐使用的方式是：</p>
<p><strong>多页导航 + 单模块单页应用</strong>。</p>
<h2 id="二-vue-框架"><a class="header" href="#二-vue-框架">二 Vue 框架</a></h2>
<h3 id="21-vue-简介"><a class="header" href="#21-vue-简介">2.1 Vue 简介</a></h3>
<p>Vue 是一个渐进式 MVVM 框架，只关注视图层（view），用来构建 Web 应用界面。所谓渐进式，即我们需要哪些功能就使用框架的哪些模块即可，vue 这样处理使其减少侵入性。</p>
<p>Vue 提供的主要功能：</p>
<ul>
<li>声明式渲染：Vue 的核心库提供了数据渲染功能（vue 模板引擎），实现视图与数据解耦。</li>
<li>组件系统：对界面进行组件化</li>
<li>前端路由：可以用来制作移动端单页面应用</li>
<li>状态管理：对共享数据进行管理</li>
</ul>
<p>Vue 与 原生 JS 对比：</p>
<ul>
<li>DOM 操作：原生 JS 如果要操作 UI，需要频繁操作 DOM，效率较低。（注意：jQuery 只是优化了 DOM 操作的代码写法而已，本质与原生 JS 一致）。React 框架内部实现了虚拟 DOM，在界面需要更新时，React 会在虚拟 DOM 中比较渲染前后的差异，决定最优更新哪些 DOM，由于虚拟 DOM 是内存数据，对实际 DOM 操作的仅仅是 Diff 部分，因而提高了性能。</li>
<li>组件化：原生 JS 组件化方案支持度不足，React 有完善的组件化支持（声明式）</li>
</ul>
<p>贴士：在操作大量 DOM 时，js 的运行速度会被严重拖累。时常在更新数据后需要重新渲染页面，这样会造成一个困扰：数据未发生改变的地方也要被重新渲染一遍，资源严重浪费，虚拟 DOM 很好的解决了该问题。</p>
<p>贴士：虚拟 DOM 上绑定的属性极少，更加轻量（因为只有框架自己使用）</p>
<h3 id="22-react-与-vue-对比-1"><a class="header" href="#22-react-与-vue-对比-1">2.2 React 与 Vue 对比</a></h3>
<p>React 与 Vue 共同点：</p>
<pre><code class="language-txt">都具备 MVVM 思想
内部都采用虚拟 DOM 方式进行视图更新
具备组件化开发理念，且采用声明式编码，可以让编码人员无需直接操作 DOM，提高开发效率。
</code></pre>
<p>声明式编码：
<img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/mvvm/statement.png" alt="声明式编码" /></p>
<p>他们在组件化开发方式上：React 采用 JSX 来编写组件，而 Vue 使用单文件组件方式开发组件。</p>
<h3 id="23-vue-的-mvvm-原理"><a class="header" href="#23-vue-的-mvvm-原理">2.3 Vue 的 MVVM 原理</a></h3>
<p>Vue 的 MVVM 的原理图：
<img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/mvvm/vue-01.png" alt="MVVVM 原理" /></p>
<h2 id="三-helloworld"><a class="header" href="#三-helloworld">三 HelloWorld</a></h2>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;div&gt;{ {msg} }&lt;/div&gt;
  &lt;!-- 获取数据 --&gt;
  &lt;button v-on:click=&quot;change&quot;&gt;点击弹出数据&lt;/button&gt;
  &lt;!-- 绑定事件 --&gt;
&lt;/div&gt;

&lt;!-- 当导入 vue 之后，在浏览器的内存中就多了一个 vue 构造函数 --&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // Vue 实例
  new Vue({
    el: '#app', // 挂载元素
    // 数据源
    data: {
      msg: 'hello world',
    },
    methods: {
      change() {
        alert(this.msg)
      },
    },
  })
&lt;/script&gt;
</code></pre>
<p>上面的示例展示了 Vue 的两个核心功能：</p>
<ul>
<li><strong>声明式渲染</strong>：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。</li>
<li><strong>响应性</strong>：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。</li>
</ul>
<h2 id="四-脚手架-vue-cli"><a class="header" href="#四-脚手架-vue-cli">四 脚手架 vue-cli</a></h2>
<h3 id="41-脚手架创建项目"><a class="header" href="#41-脚手架创建项目">4.1 脚手架创建项目</a></h3>
<p>Vue 官方也提供了完整的脚手架 vue-cli，利用该脚手架可以简单实现构建项目、打包编译上述文件：</p>
<pre><code class="language-txt"># 安装脚手架
npm install -g @vue/cli

# 查看是否安装成功
vue

# 生成基础项目 根据项目需求选择模板，这里推荐使用 3.x 版本
vue create myapp

# 运行项目
cd myapp
npm run serve
</code></pre>
<p>项目生成后，vue-cli 默认提供了三个运行脚本：</p>
<ul>
<li><code>npm run serve</code>：开发环境构建</li>
<li><code>npm run build</code>：生产环境构建</li>
<li><code>npm run lint</code>：格式化编码格式</li>
</ul>
<p>贴士：vue-cli 也提供了可视化的操作，在命令行中输入<code>vue ui</code>，则会启动一个本地服务，打开<a href="http://localhost:8000">http://localhost:8000</a>即可。</p>
<h3 id="42-初始化项目文件分析"><a class="header" href="#42-初始化项目文件分析">4.2 初始化项目文件分析</a></h3>
<p>使用 vue-cli 创建的是单页面应用，也就是说拥有一个 html 页面，在该页面中从根元素开始进行页面渲染。该文件位于 <code>public/index.html</code>：</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;noscript&gt;
    &lt;strong&gt;
      We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work
      properly without JavaScript enabled. Please enable it to continue.
    &lt;/strong&gt;
  &lt;/noscript&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;!-- built files will be auto injected --&gt;
&lt;/body&gt;
</code></pre>
<p>这里只有根组件 <code>id=&quot;app&quot;</code>，并没有引入其他文件、代码，是因为 vue-cli 默认使用了打包工具，在 build 阶段，会自动将项目代码生成到该根组件中！</p>
<h3 id="43-反向代理解决跨域问题"><a class="header" href="#43-反向代理解决跨域问题">4.3 反向代理解决跨域问题</a></h3>
<p>单页面应用在开发时往往面临着跨域问题，而服务端与服务端进行通信时，是没有跨域问题的。在开发时，vue 已经提供了一个 Node 服务器，并实现了静态文件管理等功能，此时只需要该服务器代理 vue 的请求即可。</p>
<p>在项目根目录创建 <code>vue.config.js</code> 文件：</p>
<pre><code class="language-js">module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: '&lt;url&gt;',
        ws: true,
        changeOrigin: true,
      },
      '/about': {
        target: '&lt;url&gt;',
        ws: true,
        changeOrigin: true,
      },
    },
  },
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-模板语法-常用指令"><a class="header" href="#021-模板语法-常用指令">02.1-模板语法-常用指令</a></h1>
<h2 id="一-vue-模板语法与插值"><a class="header" href="#一-vue-模板语法与插值">一 Vue 模板语法与插值</a></h2>
<p>Vue 使用了一种基于 HTML 的模板语法，能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。这些模板语法会被 Vue 编译为 JavaScript 代码，并渲染为 DOM。</p>
<p>在 Vue 模板中，使用双大括号文本插值可以替换组件实例中的 data 数据。下面是脚手架创建的 3.x 版本项目中的 HelloWorld 组件，该组件了接收外部参数 msg 后，将 msg 的值通过插值渲染在组件中：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    { { msg } }
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'HelloWorld',
  props: {
    msg: String,
  },
})
&lt;/script&gt;
</code></pre>
<h2 id="二-常见模板指令"><a class="header" href="#二-常见模板指令">二 常见模板指令</a></h2>
<h3 id="20-指令概念"><a class="header" href="#20-指令概念">2.0 指令概念</a></h3>
<p>指令是带有 <code>v-</code> 前缀的特殊属性，除了 v-for、v-on 和 v-slot 外， 指令属性一般一个 JavaScript 表达式。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 v-if 为例：</p>
<pre><code class="language-js">&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;
</code></pre>
<h3 id="21-v-text-v-html-v-pre-数据绑定"><a class="header" href="#21-v-text-v-html-v-pre-数据绑定">2.1 v-text v-html v-pre 数据绑定</a></h3>
<p><code>v-text</code>，<code>v-html</code>，<code>v-pre</code>的作用与<code>{ {} }</code>作用一样，都可以用来插入数据：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot; v-text=&quot;msg&quot;&gt;&lt;/div&gt;
</code></pre>
<p>注意：</p>
<ul>
<li><code>v-text</code>：填充普通文本，不会出现闪烁问题</li>
<li><code>v-html</code>：填充 html 文本，能够额外将数据中的标签文本解析出来，所以很容易引起安全问题（XSS 攻击）。</li>
<li><code>v-pre</code>：直接填充原始数据，作用是跳过编译，直接显示原始文本。比如要在界面中显示 <code>{ {} }</code> 这 2 个括号，就需要该指令</li>
</ul>
<h3 id="22-v-bind-绑定属性-与动态参数"><a class="header" href="#22-v-bind-绑定属性-与动态参数">2.2 v-bind 绑定属性 与动态参数</a></h3>
<p>v-bind 用于绑定属性：</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; v-bind:title=&quot;myTitle&quot; /&gt;

&lt;script&gt;
  export default {
    name: 'HelloWorld',
    props: {
      msg: String,
    },
    data() {
      return {
        myTitle: '自定义 title',
      }
    },
  }
&lt;/script&gt;
</code></pre>
<p>注意：</p>
<ul>
<li>v-bind 可以省略，直接写冒号即可 <code>:title=&quot;myTitle&quot;</code></li>
<li>v-bind 中可以使用表达式： <code>:title=&quot;myTitle + '123'&quot;</code></li>
</ul>
<p>动态参数表达式使用注意事项：</p>
<ul>
<li>表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。</li>
<li>动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。</li>
</ul>
<p>如果你需要传入一个复杂的动态参数，我们推荐使用计算属性替换复杂的表达式。</p>
<h3 id="23-v-if-与-v-show-条件渲染"><a class="header" href="#23-v-if-与-v-show-条件渲染">2.3 v-if 与 v-show 条件渲染</a></h3>
<p>v-if 和 v-show 都可以用于条件性地渲染一块内容，但是 v-if 每次都会重新创建或移除元素，切换性能消耗高，而 v-show 只是切换 display:none 的样式，初始渲染消耗高：</p>
<pre><code class="language-html">&lt;!-- 每次都会重新创建或移除元素，切换性能消耗高 --&gt;
&lt;h2 v-if=&quot;flag&quot;&gt;test1&lt;/h2&gt;

&lt;!-- 只是切换 display:none 的样式，初始渲染消耗高  --&gt;
&lt;h2 v-show=&quot;flag&quot;&gt;test1&lt;/h2&gt;

&lt;button @click=&quot;flag=!flag&quot;&gt;点击&lt;/button&gt;
</code></pre>
<p>v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。同时 v-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。</p>
<p><strong>总结：如果元素涉及到频繁的切换推荐使用 v-show，如果元素可能永远也不会被显示出来被用户看到推荐使用 v-if。</strong></p>
<p>也可以使用 v-else 为 v-if 添加一个“else 区块”：</p>
<pre><code class="language-html">&lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt;

&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;
&lt;h1 v-else&gt;Oh no&lt;/h1&gt;
</code></pre>
<p>v-else-if 提供的是相应于 v-if 的“else if 区块”。它可以连续多次重复使用：</p>
<pre><code class="language-html">&lt;div v-if=&quot;type === 'A'&quot;&gt;A&lt;/div&gt;
&lt;div v-else-if=&quot;type === 'B'&quot;&gt;B&lt;/div&gt;
&lt;div v-else-if=&quot;type === 'C'&quot;&gt;C&lt;/div&gt;
&lt;div v-else&gt;Not A/B/C&lt;/div&gt;
</code></pre>
<h3 id="24-v-cloak-解决闪烁问题"><a class="header" href="#24-v-cloak-解决闪烁问题">2.4 v-cloak 解决闪烁问题</a></h3>
<p>插值表达式具有闪烁问题：当网速较慢时，<code>{ {} }</code>的花括号会被显示在浏览器上，过一段很小的时间后才会被替换为真实的 data 内的数据。</p>
<p><code>v-cloak</code>指令可以解决上述问题：</p>
<pre><code class="language-html">&lt;style&gt;
  [v-cloak] {
    display: none;
  }
&lt;/style&gt;

&lt;div v-cloak&gt;{ {msg} }&lt;/div&gt;
</code></pre>
<p>由于设置了元素隐藏，所以插值表达式就不会再显示，但是当 vue 得到数据后，会将该 class 抹除，插值表达式就会显示。</p>
<h2 id="三-v-on-事件绑定指令"><a class="header" href="#三-v-on-事件绑定指令">三 v-on 事件绑定指令</a></h2>
<p>该指令见 事件章节。</p>
<h2 id="四-v-for-列表渲染"><a class="header" href="#四-v-for-列表渲染">四 v-for 列表渲染</a></h2>
<p>该指令剑 列表渲染章节</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="022-模板语法-双向绑定与自定义指令"><a class="header" href="#022-模板语法-双向绑定与自定义指令">02.2-模板语法-双向绑定与自定义指令</a></h1>
<h2 id="一-v-model-指令"><a class="header" href="#一-v-model-指令">一 v-model 指令</a></h2>
<h3 id="11-v-model基础使用"><a class="header" href="#11-v-model基础使用">1.1 <code>v-model</code>基础使用</a></h3>
<p>插值、绑定属性、<code>v-text</code>等显示数据的方式是单向绑定的，其作用仅仅是将数据填充到标签上，即 vue 实例中的数据模型发生变化，则界面发生改变。</p>
<p>在表单中，常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦：</p>
<pre><code class="language-js">&lt;input
  :value=&quot;text&quot;
  @input=&quot;event =&gt; text = event.target.value&quot;&gt;
</code></pre>
<p>v-model 可以简化上述步骤：</p>
<pre><code class="language-html">&lt;div id=&quot;div&quot;&gt;
  &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt;
  插值数据：{ {msg} }
&lt;/div&gt;

&lt;script&gt;
  export default {
    name: 'HelloWorld',
    data() {
      return {
        msg: 1,
      }
    },
  }
&lt;/script&gt;
</code></pre>
<p>v-model 还可以用于各种不同类型的输入，<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 元素。它会根据所使用的元素自动使用对应的 DOM 属性和事件组合：</p>
<p>文本类型的 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素会绑定 value property 并侦听 input 事件；
<code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;&gt;</code> 会绑定 checked property 并侦听 change 事件；
<code>&lt;select&gt;</code> 会绑定 value property 并侦听 change 事件。</p>
<h3 id="12-radio-中使用-v-model"><a class="header" href="#12-radio-中使用-v-model">1.2 radio 中使用 v-model</a></h3>
<p>在 radio 中使用 v-model：</p>
<pre><code class="language-html">&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;first&quot; /&gt;
&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;second&quot; /&gt;
</code></pre>
<p>pick 会在第一个按钮选中时被设为 first，在第二个按钮选中时被设为 second</p>
<h3 id="13-select-中使用-v-model"><a class="header" href="#13-select-中使用-v-model">1.3 select 中使用 v-model</a></h3>
<p>在 select 中使用 v-model：</p>
<pre><code class="language-html">&lt;select v-model=&quot;fruit&quot;&gt;
  &lt;option&gt;苹果&lt;/option&gt;
  &lt;option&gt;香蕉&lt;/option&gt;
  &lt;option&gt;葡萄&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>v-model 同样也支持非字符串类型的值绑定，即会被设置为字面量值。</p>
<h3 id="14-复选框"><a class="header" href="#14-复选框">1.4 复选框</a></h3>
<pre><code class="language-js">&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot; /&gt;
</code></pre>
<p>true-value 和 false-value 是 Vue 特有的 attributes，仅支持和 v-model 配套使用。这里 toggle 属性的值会在选中时被设为 'yes'，取消选择时设为 'no'。你同样可以通过 v-bind 将其绑定为其他动态值：</p>
<pre><code class="language-js">&lt;input
  type=&quot;checkbox&quot;
  v-model=&quot;toggle&quot;
  :true-value=&quot;dynamicTrueValue&quot;
  :false-value=&quot;dynamicFalseValue&quot; /&gt;
</code></pre>
<p>true-value 和 false-value attributes 不会影响 value attribute，因为浏览器在表单提交时，并不会包含未选择的复选框。为了保证这两个值 (例如：“yes”和“no”) 的其中之一被表单提交，请使用单选按钮作为替代。</p>
<h2 id="二-表单处理"><a class="header" href="#二-表单处理">二 表单处理</a></h2>
<h3 id="21-表单修饰符"><a class="header" href="#21-表单修饰符">2.1 表单修饰符</a></h3>
<p>表单中的数据往往需要做一些特殊处理，如年龄强制转换为数值类型，电话号码需要去掉开始结尾空格，input 事件需要切换为 change 事件 (失去焦点才触发) 等等。</p>
<p>vue 提供了简便的方式，即表单修饰符：</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; v-model.number=&quot;age&quot; /&gt;
&lt;input type=&quot;text&quot; v-model.lazy=&quot;msg&quot; /&gt;
</code></pre>
<p>.lazy：默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)，添加 lazy 修饰符来改为在每次 change 事件后更新数据。</p>
<p>.number：用户输入自动转换为数字，如果该值无法被 parseFloat() 处理，那么将返回原始值。number 修饰符会在输入框有 type=&quot;number&quot; 时自动启用。</p>
<p>.trim：自动去除用户输入内容中两端的空格。</p>
<h3 id="22-v-once"><a class="header" href="#22-v-once">2.2 <code>v-once</code></a></h3>
<p><code>v-once</code>：用于显示内容后不再具有数据响应功能，其目的是提高性能，原理是只编译一次，比如可以用于显示初始化的 vue 的 data 数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="023-模板语法-自定义指令"><a class="header" href="#023-模板语法-自定义指令">02.3-模板语法-自定义指令</a></h1>
<h2 id="一-自定义指令"><a class="header" href="#一-自定义指令">一 自定义指令</a></h2>
<p>一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数。下面是一个自定义指令的例子，当一个 input 元素被 Vue 插入到 DOM 中后，它会被自动聚焦：</p>
<pre><code class="language-vue">&lt;script setup&gt;
// 在模板中启用 v-focus
const vFocus = {
  mounted: (el) =&gt; el.focus(),
}
&lt;/script&gt;

&lt;template&gt;
  &lt;input v-focus /&gt;
&lt;/template&gt;
</code></pre>
<p>假设你还未点击页面中的其他地方，那么上面这个 input 元素应该会被自动聚焦。该指令比 autofocus attribute 更有用，因为它不仅仅可以在页面加载完成后生效，还可以在 Vue 动态插入元素后生效。</p>
<p>在 <code>&lt;script setup&gt;</code> 中，任何以 v 开头的驼峰式命名的变量都可以被用作一个自定义指令。在上面的例子中，vFocus 即可以在模板中以 v-focus 的形式使用。</p>
<p>在没有使用 <code>&lt;script setup&gt;</code> 的情况下，自定义指令需要通过 directives 选项注册：</p>
<pre><code class="language-js">export default {
  setup() {
    /*...*/
  },
  directives: {
    // 在模板中启用 v-focus
    focus: {
      /* ... */
    },
  },
}
</code></pre>
<p>将一个自定义指令全局注册到应用层级也是一种常见的做法：</p>
<pre><code class="language-js">const app = createApp({})

// 使 v-focus 在所有组件中都可用
app.directive('focus', {
  /* ... */
})
</code></pre>
<h2 id="二-指令钩子"><a class="header" href="#二-指令钩子">二 指令钩子</a></h2>
<p>一个指令的定义对象可以提供几种钩子函数 (都是可选的)：</p>
<pre><code class="language-js">const myDirective = {
  // 在绑定元素的 attribute 前
  // 或事件监听器应用前调用
  created(el, binding, vnode, prevVnode) {
    // 下面会介绍各个参数的细节
  },
  // 在元素被插入到 DOM 前调用
  beforeMount(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都挂载完成后调用
  mounted(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件更新前调用
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都更新后调用
  updated(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载后调用
  unmounted(el, binding, vnode, prevVnode) {},
}
</code></pre>
<p>指令的钩子会传递以下几种参数：</p>
<ul>
<li>el：指令绑定到的元素。这可以用于直接操作 DOM。</li>
<li>binding：一个对象，包含以下属性。</li>
<li>value：传递给指令的值。例如在 v-my-directive=&quot;1 + 1&quot; 中，值是 2。</li>
<li>oldValue：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。</li>
<li>arg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 &quot;foo&quot;。</li>
<li>modifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 { foo: true, bar: true }。</li>
<li>instance：使用该指令的组件实例。</li>
<li>dir：指令的定义对象。</li>
<li>vnode：代表绑定元素的底层 VNode。</li>
<li>prevNode：之前的渲染中代表指令所绑定元素的 VNode。仅在 beforeUpdate 和 updated 钩子中可用。</li>
</ul>
<p>举例来说，像下面这样使用指令：</p>
<pre><code class="language-vue">&lt;div v-example:foo.bar=&quot;baz&quot; /&gt;
</code></pre>
<p>binding 参数会是一个这样的对象：</p>
<pre><code class="language-js">{
arg: 'foo',
modifiers: { bar: true },
value: /_ `baz` 的值 _/,
oldValue: /_ 上一次更新时 `baz` 的值 _/
}
</code></pre>
<p>和内置指令类似，自定义指令的参数也可以是动态的。举例来说：</p>
<pre><code class="language-vue">&lt;div v-example:[arg]=&quot;value&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这里指令的参数会基于组件的 arg 数据属性响应式地更新。 Note 除了 el 外，其他参数都是只读的，不要更改它们。若你需要在不同的钩子间共享信息，推荐通过元素的 dataset attribute 实现。</p>
<h2 id="三-简化形式"><a class="header" href="#三-简化形式">三 简化形式</a></h2>
<p>对于自定义指令来说，一个很常见的情况是仅仅需要在 mounted 和 updated 上实现相同的行为，除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令，如下所示：</p>
<pre><code class="language-vue">&lt;div v-color=&quot;color&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">app.directive('color', (el, binding) =&gt; {
  // 这会在 `mounted` 和 `updated` 时都调用
  el.style.color = binding.value
})
</code></pre>
<h2 id="四-对象字面量"><a class="header" href="#四-对象字面量">四 对象字面量</a></h2>
<p>如果你的指令需要多个值，你可以向它传递一个 JavaScript 对象字面量。别忘了，指令也可以接收任何合法的 JavaScript 表达式。</p>
<pre><code class="language-js">&lt;div v-demo=&quot;{ color: 'white', text: 'hello!' }&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">app.directive('demo', (el, binding) =&gt; {
  console.log(binding.value.color) // =&gt; &quot;white&quot;
  console.log(binding.value.text) // =&gt; &quot;hello!&quot;
})
</code></pre>
<h2 id="五-在组件上使用"><a class="header" href="#五-在组件上使用">五 在组件上使用</a></h2>
<p>当在组件上使用自定义指令时，它会始终应用于组件的根节点，和透传 attributes 类似。</p>
<pre><code class="language-js">&lt;MyComponent v-demo=&quot;test&quot; /&gt;
</code></pre>
<pre><code class="language-js">&lt;!-- MyComponent 的模板 --&gt;

&lt;div&gt; &lt;!-- v-demo 指令会被应用在此处 --&gt;
  &lt;span&gt;My component content&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>需要注意的是组件可能含有多个根节点。当应用到一个多根组件时，指令将会被忽略且抛出一个警告。和 attribute 不同，指令不能通过 v-bind=&quot;$attrs&quot; 来传递给一个不同的元素。总的来说，不推荐在组件上使用自定义指令。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-组件基础-组件注册"><a class="header" href="#031-组件基础-组件注册">03.1-组件基础-组件注册</a></h1>
<h2 id="一-vue-组件创建化开发思想"><a class="header" href="#一-vue-组件创建化开发思想">一 Vue 组件创建化开发思想</a></h2>
<h3 id="11-组件化思想-1"><a class="header" href="#11-组件化思想-1">1.1 组件化思想</a></h3>
<p>组件化是指从 UI 界面角度出发，合理重用 UI 组件。如果将一个页面中的业务逻辑放在一起，将会让项目变得难以维护、扩展，将页面拆分为一个个小的功能块，每个功能块具有完全独立的功能，不同功能块之间通过一些方法进行关联，这样更便于扩展、维护。</p>
<p>具体的实现细则：</p>
<pre><code class="language-txt">将一个完整的页面拆分为多个功能块组件，每个组件用于实现页面的一个功能块
每个组件内部可以进一步进行划分为更加细小的组件
</code></pre>
<p>组件化为页面的开发实现了更好的抽象，达到复用效果，任何应用都可以被抽象为一棵组件树：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/mvvm/vue-02.png" alt="组价树" /></p>
<h3 id="12-单文件组件"><a class="header" href="#12-单文件组件">1.2 单文件组件</a></h3>
<p>在代码中直接使用方法等方式定义组件并不适合大型项目，且 ES6 的语法在很多浏览器中不被支持。在企业级开发中，Vue 推荐使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 ( Single-File Components，缩写为 SFC)。即：Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里，这些组件化文件以 <code>.vue</code> 后缀为结尾，并通过编译、打包工具来进行线上环境部署。</p>
<p>如下所示一个完整的组件示例：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h1&gt;{ { msg } }&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name: 'HelloWorld',
  }
&lt;/script&gt;

&lt;style scoped lang=&quot;scss&quot;&gt;
  h1 {
    margin: 40px 0 0;
  }
&lt;/style&gt;
</code></pre>
<p>该 vue 文件可以被导出，多次重复利用，也可以在引入使用后绑定事件等等。Vue SFC 是一个框架指定的文件格式，因此必须交由 @vue/compiler-sfc 编译为标准的 JavaScript 和 CSS，一个编译后的 SFC 是一个标准的 JavaScript(ES) 模块，这也意味着在构建配置正确的前提下，你可以像导入其他 ES 模块一样导入 SFC：</p>
<pre><code class="language-js">import MyComponent from './MyComponent.vue'

export default {
  components: {
    MyComponent,
  },
}
</code></pre>
<p>SFC 中的 <code>&lt;style&gt;</code> 标签一般会在开发时注入成原生的 <code>&lt;style&gt;</code> 标签以支持热更新，而生产环境下它们会被抽取、合并成单独的 CSS 文件。在实际项目中，我们一般会使用集成了 SFC 编译器的构建工具，比如 Vite 或者 Vue CLI (基于 webpack)。</p>
<p><strong>Volar VSCode</strong> 插件为 Vue SFC 提供了开箱即用的格式化功能。除此之外，Prettier 也提供了内置的 Vue SFC 格式化支持。</p>
<p>基于此，一些有着传统 Web 开发背景的用户可能会因为 SFC 将不同的关注点集合在一处而有所顾虑，觉得 HTML/CSS/JS 应当是分离开的！</p>
<p>要回答这个问题，我们必须对这一点达成共识：前端开发的关注点不是完全基于文件类型分离的。前端工程化的最终目的都是为了能够更好地维护代码。关注点分离不应该是教条式地将其视为文件类型的区别和分离，仅仅这样并不够帮我们在日益复杂的前端应用的背景下提高开发效率。</p>
<p>在现代的 UI 开发中，我们发现与其将代码库划分为三个巨大的层，相互交织在一起，不如将它们划分为松散耦合的组件，再按需组合起来。在一个组件中，其模板、逻辑和样式本就是有内在联系的、是耦合的，将它们放在一起，实际上使组件更有内聚性和可维护性。</p>
<p>即使你不喜欢单文件组件这样的形式而仍然选择拆分单独的 JavaScript 和 CSS 文件，也没关系，你还是可以通过资源导入功能获得热更新和预编译等功能的支持。</p>
<h2 id="二-注册组件"><a class="header" href="#二-注册组件">二 注册组件</a></h2>
<h3 id="20-组件注册概念"><a class="header" href="#20-组件注册概念">2.0 组件注册概念</a></h3>
<p>一个 .vue 后缀的单文件组件在引入后，不能直接被使用，使用前需要先被 ”注册“，这样 Vue 才能在渲染模板时找到其对应的实现。</p>
<p>组件注册有两种方式：全局注册和局部注册。局部注册使用较多。</p>
<h3 id="21-局部注册"><a class="header" href="#21-局部注册">2.1 局部注册</a></h3>
<p>局部组件是挂载在了 Vue 的实例上，而且只能在注册他的父组件中使用！</p>
<pre><code class="language-js">import ComponentA from './ComponentA.js'

export default {
  components: {
    ComponentA,
  },
  setup() {
    // ...
  },
}
</code></pre>
<p>对于每个 components 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：</p>
<pre><code class="language-js">export default {
  components: {
    ComponentA: ComponentA,
  },
  // ...
}
</code></pre>
<p>注意：<strong>在使用 <code>&lt;script setup&gt;</code> 的单文件组件中，导入的组件可以直接在模板中使用，无需注册</strong>。</p>
<h3 id="22-全局注册"><a class="header" href="#22-全局注册">2.2 全局注册</a></h3>
<p>全局注册的组件可以在此应用的任意组件的模板中使用。使用 Vue 应用实例的 app.component() 方法，让组件在当前 Vue 应用中全局可用：</p>
<pre><code class="language-js">const app = createApp({})

app.component(
  // 注册的名字
  'MyComponent',
  // 组件的实现
  {
    /* ... */
  }
)
</code></pre>
<p>如果是单文件组件，可以注册被导入的 .vue 文件：</p>
<pre><code class="language-js">import MyComponent from './App.vue'

app.component('MyComponent', MyComponent)
</code></pre>
<h3 id="23-全局注册于局部注册对比"><a class="header" href="#23-全局注册于局部注册对比">2.3 全局注册于局部注册对比</a></h3>
<p>全局注册虽然很方便，但有以下几个问题：</p>
<ul>
<li>全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。</li>
<li>全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。</li>
</ul>
<p>相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。</p>
<h2 id="三-组件注册的注意事项"><a class="header" href="#三-组件注册的注意事项">三 组件注册的注意事项</a></h2>
<h3 id="31-常见重要注意点"><a class="header" href="#31-常见重要注意点">3.1 常见重要注意点</a></h3>
<p>Vue2.x 中组件的根元素只能有一个，Vue3 则无需注意。</p>
<h3 id="32-组件命名格式"><a class="header" href="#32-组件命名格式">3.2 组件命名格式</a></h3>
<p>组件命名时：若没有使用驼峰式命名，则该名称可以直接使用；若使用了驼峰命名，在引用组件的时候，需要把大写的驼峰改为小写的字母，同时两个单词之间使用 <code>-</code> 连接。</p>
<h3 id="33-组件的-data-属性"><a class="header" href="#33-组件的-data-属性">3.3 组件的 data 属性</a></h3>
<p>组件是一个单独的功能模块的封装，所以不能直接访问 Vue 实例的数据对象 data，组件自己的数据应该由自己存储，即组件自身的 data 函数。</p>
<p><strong>组件的 data 属性必须是一个函数，且返回一个对象。</strong></p>
<p>因为：函数能够形成独立的作用域环境，避免污染。如：某个组件在界面中使用了多次，这些组件之间内部的数据是不应该共用一个 data 对象的，而是每次在界面中使用了该组件，就应该创建一个全新的数据对象，所以只能是函数形式，在函数内部返回一个数据对象。</p>
<h3 id="34-引用-template"><a class="header" href="#34-引用-template">3.4 引用 template</a></h3>
<p>template 属性也可以直接引用其他已经定义好的 template。</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;my-com3&gt;&lt;/my-com3&gt;
&lt;/div&gt;

&lt;template id=&quot;tmp1&quot;&gt;
  &lt;h3&gt;组件&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
  Vue.component('myCom3', {
    template: '#tmp1',
  })

  new Vue({
    el: '#app',
  })
&lt;/script&gt;
</code></pre>
<h2 id="四-动态组件"><a class="header" href="#四-动态组件">四 动态组件</a></h2>
<h3 id="41-动态组件实现组件切换"><a class="header" href="#41-动态组件实现组件切换">4.1 动态组件实现组件切换</a></h3>
<p>除了可以使用自定义 true/false 方式来切换组件外，vue 本身也提供了组件切换机制：在 component 里展示对应名称的组件</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;span @click=&quot;who='com1'&quot;&gt;显示组件 1&lt;/span&gt;
  &lt;span @click=&quot;who='com2'&quot;&gt;显示组件 2&lt;/span&gt;
  &lt;component :is=&quot;who&quot;&gt;&lt;/component&gt;
&lt;/div&gt;

&lt;script&gt;
  Vue.component('com1', {
    template: '&lt;h3&gt;111&lt;/h3&gt;',
  })

  Vue.component('com2', {
    template: '&lt;h3&gt;222&lt;/h3&gt;',
  })

  let vm = new Vue({
    el: '#app',
    data: {
      who: 'com1',
    },
  })
&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="032-组件基础-vue-实例"><a class="header" href="#032-组件基础-vue-实例">03.2-组件基础-Vue 实例</a></h1>
<h2 id="一-vue-应用创建函数相关"><a class="header" href="#一-vue-应用创建函数相关">一 Vue 应用创建函数相关</a></h2>
<h3 id="11-createapp"><a class="header" href="#11-createapp">1.1 createApp()</a></h3>
<p>每个 Vue 应用都是通过 createApp 函数创建一个新的 应用实例：</p>
<pre><code class="language-js">import { createApp } from 'vue'

const app = createApp({
  /* 根组件选项 */
})
</code></pre>
<p>我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件：</p>
<pre><code class="language-js">import { createApp } from 'vue'
// 从一个单文件组件中导入根组件
import App from './App.vue'

const app = createApp(App)
</code></pre>
<h3 id="12-挂载应用"><a class="header" href="#12-挂载应用">1.2 挂载应用</a></h3>
<p>应用实例必须在调用了 .mount() 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  app.mount('#app')
&lt;/script&gt;
</code></pre>
<p>应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。</p>
<p>.mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。</p>
<h2 id="二-vue-实例"><a class="header" href="#二-vue-实例">二 Vue 实例</a></h2>
<h3 id="21-vue-实例选项对象"><a class="header" href="#21-vue-实例选项对象">2.1 Vue 实例选项对象</a></h3>
<p>每一个应用都是通过 Vue 这个构造函数来创建根实例来启动的：</p>
<pre><code class="language-js">    const app = new Vue({
        选项对象1,
        选项对象2,
        ...
    })
</code></pre>
<p>传入的选项对象包含：挂载元素、数据、模板、方法等，如下所示最常见的三个选项对象：</p>
<ul>
<li>el：挂载点，可以是元素，也可以是 CSS 选择器，支持原生 JS 写法</li>
<li>data：代理数据</li>
<li>methods：定义方法</li>
</ul>
<h3 id="22-vue-实例属性"><a class="header" href="#22-vue-实例属性">2.2 Vue 实例属性</a></h3>
<p>每个 Vue 实例都会代理其对应 data 对象中的所有属性：</p>
<pre><code class="language-html">&lt;div class=&quot;div&quot;&gt;渲染数据为：{ {a} }&lt;/div&gt;

&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  const result = {
    a: 1,
  }

  let app = new Vue({
    el: '.div',
    data: {
      a: result.a,
    },
  })

  // 获取代理中的数据
  console.log('app.a = ', app.a) // 1

  // 修改原始数据，代理数据会被改变
  result.a = 3
  console.log('修改原始数据为 3，代理数据为：', app.a) // 2

  // 修改代理数据，不会更改原始数据
  app.a = 2
  console.log('修改代理数据为 2，原始数据值为：', result.a) // 1
&lt;/script&gt;
</code></pre>
<p>注意：视图上显示的是代理数据的值，所以修改 vue 实例上的选项对象、修改原始值都会造成视图更新！</p>
<p>贴士：在 Vue 的实例上，我们不但可以看到绑定的 a 的值，也看到了一个 <code>_data</code> 的属性，该属性内也有 a 的值，这是 vue 对数据的劫持，内部为 data 数据都包装了 getter/setter 方法，用于实现数据在界面的响应式（自动更新）。</p>
<h3 id="23-选项式-api-与组合式-api"><a class="header" href="#23-选项式-api-与组合式-api">2.3 选项式 API 与组合式 API</a></h3>
<p>Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API。</p>
<p>使用选项式 API (Options API)，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例：</p>
<pre><code class="language-vue">&lt;script&gt;
export default {
  // data() 返回的属性将会成为响应式的状态
  // 并且暴露在 `this` 上
  data() {
    return {
      count: 0,
    }
  },

  // methods 是一些用来更改状态与触发更新的函数
  // 它们可以在模板中作为事件监听器绑定
  methods: {
    increment() {
      this.count++
    },
  },

  // 生命周期钩子会在组件生命周期的各个不同阶段被调用
  // 例如这个函数就会在组件挂载完成后被调用
  mounted() {
    console.log(`The initial count is ${this.count}.`)
  },
}
&lt;/script&gt;

&lt;template&gt;
  &lt;button @click=&quot;increment&quot;&gt;Count is: { { count } }&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>通过组合式 API (Composition API)，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 <code>&lt;script setup&gt;</code> 搭配使用。这个 setup attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，<code>&lt;script setup&gt;</code> 中的导入和顶层变量/函数都能够在模板中直接使用。</p>
<p>下面是使用了组合式 API 与 <code>&lt;script setup&gt;</code> 改造后和上面的模板完全一样的组件：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, onMounted } from 'vue'

// 响应式状态
const count = ref(0)

// 用来修改状态、触发更新的函数
function increment() {
  count.value++
}

// 生命周期钩子
onMounted(() =&gt; {
  console.log(`The initial count is ${count.value}.`)
})
&lt;/script&gt;

&lt;template&gt;
  &lt;button @click=&quot;increment&quot;&gt;Count is: { { count } }&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="033-组件基础-响应式基础"><a class="header" href="#033-组件基础-响应式基础">03.3-组件基础-响应式基础</a></h1>
<h2 id="一-组合式-api-声明响应式状态"><a class="header" href="#一-组合式-api-声明响应式状态">一 组合式 API 声明响应式状态</a></h2>
<h3 id="11-使用-reactive-函数声明响应式状态"><a class="header" href="#11-使用-reactive-函数声明响应式状态">1.1 使用 reactive() 函数声明响应式状态</a></h3>
<p>使用 reactive() 函数可以创建一个响应式对象或数组：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    { { state.count } }
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { reactive } from 'vue'
export default {
  // `setup` 是一个专门用于组合式 API 的特殊钩子函数
  setup() {
    const state = reactive({ count: 0 })

    // 暴露 state 到模板
    return {
      state,
    }
  },
}
&lt;/script&gt;
</code></pre>
<p>也可以在同一个作用域下定义更新响应式状态的函数，并将他们作为方法与状态一起暴露出去：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div @click=&quot;increment&quot;&gt;
    { { state.count } }
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { reactive } from 'vue'

export default {
  setup() {
    const state = reactive({ count: 0 })

    const increment = () =&gt; {
      state.count++
    }

    // 不要忘记同时暴露 increment 函数
    return {
      state,
      increment,
    }
  },
}
&lt;/script&gt;
</code></pre>
<h3 id="12-setup-语法糖"><a class="header" href="#12-setup-语法糖">1.2 setup 语法糖</a></h3>
<p>在 setup() 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。当使用单文件组件（SFC）时，我们可以使用 <code>&lt;script setup&gt;</code> 来大幅度地简化代码。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div @click=&quot;increment&quot;&gt;
    { { state.count } }
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { reactive } from 'vue'

const state = reactive({ count: 0 })

const increment = () =&gt; {
  state.count++
}
&lt;/script&gt;
</code></pre>
<h3 id="13-reactive-的局限性"><a class="header" href="#13-reactive-的局限性">1.3 reactive() 的局限性</a></h3>
<p>reactive() API 有两条限制：</p>
<ul>
<li>仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。</li>
<li>因为 Vue 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失。</li>
</ul>
<pre><code class="language-js">let state = reactive({ count: 0 })

// 上面的引用 ({ count: 0 }) 将不再被追踪（响应性连接已丢失！）
state = reactive({ count: 1 })
</code></pre>
<p>同时这也意味着当我们将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数时，我们会失去响应性：</p>
<pre><code class="language-js">const state = reactive({ count: 0 })

// n 是一个局部变量，同 state.count
let n = state.count // 失去响应性连接
n++ // n 值变化不影响原始的 state

// 解构后的count 也和 state.count 失去了响应性连接
let { count } = state
count++ // count 值变化不会影响原始的 state

// 该函数只是接收一个普通数字，无法跟踪 state.count 的变化
callSomeFunction(state.count)
</code></pre>
<h3 id="14-使用-ref-函数声明响应式状态"><a class="header" href="#14-使用-ref-函数声明响应式状态">1.4 使用 ref() 函数声明响应式状态</a></h3>
<p>reactive() 的种种限制归根结底是因为 JavaScript 没有可以作用于所有值类型的 “引用” 机制。为此，Vue 提供了一个 ref() 方法来允许我们创建可以使用任何值类型的响应式 ref：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div @click=&quot;increment&quot;&gt;
    { { count } }
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'
const count = ref(0)

const increment = () =&gt; {
  count.value++
}
&lt;/script&gt;
</code></pre>
<p>ref 的 <code>.value</code> 属性也是响应式的，当值为对象类型时，会用 reactive() 自动转换它的 <code>.value</code>。</p>
<p>贴士：当 ref 在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用 <code>.value</code>。</p>
<p>一个包含对象类型值的 ref 可以响应式地替换整个对象：</p>
<pre><code class="language-js">const objectRef = ref({ count: 0 })

// 这是响应式的替换
objectRef.value = { count: 1 }
</code></pre>
<p>ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性：</p>
<pre><code class="language-js">const obj = {
  foo: ref(1),
  bar: ref(2),
}

// 该函数接收一个 ref，需要通过 .value 取值，但它会保持响应性
callSomeFunction(obj.foo)

// 仍然是响应式的
const { foo, bar } = obj
</code></pre>
<h3 id="15-ref-在响应式对象中的解包"><a class="header" href="#15-ref-在响应式对象中的解包">1.5 ref 在响应式对象中的解包</a></h3>
<p>当一个 ref 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现得和一般的属性一样：</p>
<pre><code class="language-js">const count = ref(0)
const state = reactive({
  count,
})

console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1
</code></pre>
<p>如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：</p>
<pre><code class="language-js">const otherCount = ref(2)

state.count = otherCount
console.log(state.count) // 2
// 原始 ref 现在已经和 state.count 失去联系
console.log(count.value) // 1
</code></pre>
<p>只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为浅层响应式对象的属性被访问时不会解包。</p>
<h3 id="16-数组和集合类型的-ref-解包"><a class="header" href="#16-数组和集合类型的-ref-解包">1.6 数组和集合类型的 ref 解包</a></h3>
<p>跟响应式对象不同，当 ref 作为响应式数组或像 Map 这种原生集合类型的元素被访问时，不会进行解包。</p>
<pre><code class="language-js">const books = reactive([ref('Vue 3 Guide')])
// 这里需要 .value
console.log(books[0].value)

const map = reactive(new Map([['count', ref(0)]]))
// 这里需要 .value
console.log(map.get('count').value)
</code></pre>
<h2 id="二-响应式使用细节"><a class="header" href="#二-响应式使用细节">二 响应式使用细节</a></h2>
<h3 id="21-dom-更新时机"><a class="header" href="#21-dom-更新时机">2.1 DOM 更新时机</a></h3>
<p>当你更改响应式状态后，DOM 会自动更新。然而，你得注意 DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次状态更改，每个组件都只更新一次。</p>
<p>若要等待一个状态改变后的 DOM 更新完成，你可以使用 nextTick() 这个全局 API：</p>
<pre><code class="language-js">import { nextTick } from 'vue'

function increment() {
  state.count++
  nextTick(() =&gt; {
    // 访问更新后的 DOM
  })
}
</code></pre>
<h3 id="22-深层响应性"><a class="header" href="#22-深层响应性">2.2 深层响应性</a></h3>
<p>在 Vue 中，状态都是默认深层响应式的。这意味着即使在更改深层次的对象或数组，你的改动也能被检测到。</p>
<pre><code class="language-js">import { reactive } from 'vue'

const obj = reactive({
  nested: { count: 0 },
  arr: ['foo', 'bar'],
})

function mutateDeeply() {
  // 以下都会按照期望工作
  obj.nested.count++
  obj.arr.push('baz')
}
</code></pre>
<p>你也可以直接创建一个浅层响应式对象。它们仅在顶层具有响应性，一般仅在某些特殊场景中需要。</p>
<h4 id="15-响应式代理-vs-原始对象"><a class="header" href="#15-响应式代理-vs-原始对象">1.5 响应式代理 vs. 原始对象</a></h4>
<p>值得注意的是，reactive() 返回的是一个原始对象的 Proxy，它和原始对象是不相等的：</p>
<pre><code class="language-js">const raw = {}
const proxy = reactive(raw)

// 代理对象和原始对象不是全等的
console.log(proxy === raw) // false
</code></pre>
<p>只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的最佳实践是 仅使用你声明对象的代理版本。</p>
<p>为保证访问代理的一致性，对同一个原始对象调用 reactive() 会总是返回同样的代理对象，而对一个已存在的代理对象调用 reactive() 会返回其本身：</p>
<pre><code class="language-js">// 在同一个对象上调用 reactive() 会返回相同的代理
console.log(reactive(raw) === proxy) // true

// 在一个代理上调用 reactive() 会返回它自己
console.log(reactive(proxy) === proxy) // true
</code></pre>
<p>这个规则对嵌套对象也适用。依靠深层响应性，响应式对象内的嵌套对象依然是代理：</p>
<pre><code class="language-js">const proxy = reactive({})

const raw = {}
proxy.nested = raw

console.log(proxy.nested === raw) // false
</code></pre>
<h2 id="三-选项式-api-声明响应式状态"><a class="header" href="#三-选项式-api-声明响应式状态">三 选项式 API 声明响应式状态</a></h2>
<h3 id="31-data-选项"><a class="header" href="#31-data-选项">3.1 data() 选项</a></h3>
<p>选用选项式 API 时，会用 data 选项来声明组件的响应式状态。此选项的值应为返回一个对象的函数，Vue 将在创建新组件实例的时候调用此函数，并将函数返回的对象用响应式系统进行包装。此对象的所有顶层属性都会被代理到组件实例 (即方法和生命周期钩子中的 this) 上：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;{ { count } }&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      count: 1,
    }
  },

  // `mounted` 是生命周期钩子
  mounted() {
    // `this` 指向当前组件实例
    console.log(this.count) // =&gt; 1

    // 数据属性也可以被更改
    this.count = 2
  },
}
&lt;/script&gt;
</code></pre>
<p>贴士：若响应式数据所需的值还未准备好，在必要时也可以使用 null、undefined 或者其他一些值占位。虽然也可以不在 data 上定义，直接向组件实例添加新属性，但这个属性将无法触发响应式更新。</p>
<p>Vue 在组件实例上暴露的内置 API 使用 <code>$</code> 作为前缀。它同时也为内部属性保留 <code>_</code> 前缀。因此，你应该避免在顶层 data 上使用任何以这些字符作前缀的属性。</p>
<h3 id="32-methods绑定事件函数"><a class="header" href="#32-methods绑定事件函数">3.2 methods()绑定事件函数</a></h3>
<p>要为组件添加方法，我们需要用到 methods 选项。它应该是一个包含所有方法的对象：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div @click=&quot;increment&quot;&gt;{ { count } }&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      count: 1,
    }
  },
  methods: {
    increment() {
      this.count++
    },
  },
  mounted() {
    // 在其他方法或是生命周期中也可以调用方法
    this.increment()
  },
}
&lt;/script&gt;
</code></pre>
<p>Vue 自动为 methods 中的方法绑定了永远指向组件实例的 this。这确保了方法在作为事件监听器或回调函数时始终保持正确的 this，所以 methods 中不应该使用箭头函数，因为箭头函数没有自己的 this 上下文。</p>
<h3 id="33-响应式代理-vs-原始值"><a class="header" href="#33-响应式代理-vs-原始值">3.3 响应式代理 vs. 原始值</a></h3>
<p>在 Vue 3 中，数据是基于 JavaScript Proxy（代理） 实现响应式的。使用过 Vue 2 的用户可能需要注意下面这样的边界情况：</p>
<pre><code class="language-js">export default {
  data() {
    return {
      someObject: {},
    }
  },
  mounted() {
    const newObject = {}
    this.someObject = newObject

    console.log(newObject === this.someObject) // false
  },
}
</code></pre>
<p>当你在赋值后再访问 this.someObject，此值已经是原来的 newObject 的一个响应式代理。与 Vue 2 不同的是，这里原始的 newObject 不会变为响应式：请确保始终通过 this 来访问响应式状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="034-组件基础-组件参数-props"><a class="header" href="#034-组件基础-组件参数-props">03.4-组件基础-组件参数 Props</a></h1>
<h2 id="一-props-声明"><a class="header" href="#一-props-声明">一 Props 声明</a></h2>
<h3 id="11-props-使用示例"><a class="header" href="#11-props-使用示例">1.1 props 使用示例</a></h3>
<p>props 用来接收父组件传递过来的数据。一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute</p>
<pre><code class="language-js">export default {
  props: ['foo'],
  setup(props) {
    // setup() 接收 props 作为第一个参数
    console.log(props.foo)
  },
}
</code></pre>
<p>如果在 <code>&lt;script setup&gt;</code> 的单文件组件中，props 可以使用 defineProps() 宏来声明：</p>
<pre><code class="language-vue">&lt;script setup&gt;
// defineProps 是一个仅 &lt;script setup&gt; 中可用的编译宏命令，并不需要显式地导入。
const props = defineProps(['foo'])

console.log(props.foo)
&lt;/script&gt;
</code></pre>
<h3 id="12-props-的对象形式"><a class="header" href="#12-props-的对象形式">1.2 props 的对象形式</a></h3>
<p>除了使用字符串数组来声明 prop 外，还可以使用对象的形式：</p>
<pre><code class="language-js">// 使用 &lt;script setup&gt;
defineProps({
  title: String,
  likes: Number,
})

// 非 &lt;script setup&gt;
export default {
  props: {
    title: String,
    likes: Number,
  },
}
</code></pre>
<p>对于以对象形式声明中的每个属性，key 是 prop 的名称，而值则是该 prop 预期类型的构造函数。比如，如果要求一个 prop 的值是 number 类型，则可使用 Number 构造函数作为其声明的值。</p>
<h3 id="13-动态-props"><a class="header" href="#13-动态-props">1.3 动态 props</a></h3>
<p>使用 v-bind 可以绑定动态 props：</p>
<pre><code class="language-vue">&lt;!--静态props--&gt;
&lt;BlogPost title=&quot;My journey with Vue&quot; /&gt;

&lt;!-- 根据一个变量的值动态传入 --&gt;
&lt;BlogPost :title=&quot;post.title&quot; /&gt;

&lt;!-- 根据一个更复杂表达式的值动态传入 --&gt;
&lt;BlogPost :title=&quot;post.title + ' by ' + post.author.name&quot; /&gt;
</code></pre>
<h2 id="二-单向数据流"><a class="header" href="#二-单向数据流">二 单向数据流</a></h2>
<p>所有的 props 都遵循着单向绑定原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p>
<p>另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你不应该在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：</p>
<pre><code class="language-js">const props = defineProps(['foo'])

// ❌ 警告！prop 是只读的！
props.foo = 'bar'
</code></pre>
<p>导致你想要更改一个 prop 的需求通常来源于以下两种场景：</p>
<p>1 prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。在这种情况下，最好是新定义一个局部数据属性，从 props 上获取初始值即可：</p>
<pre><code class="language-js">const props = defineProps(['initialCounter'])

// 计数器只是将 props.initialCounter 作为初始值
// 像下面这样做就使 prop 和后续更新无关了
const counter = ref(props.initialCounter)
</code></pre>
<p>2 需要对传入的 prop 值做进一步的转换。在这种情况中，最好是基于该 prop 值定义一个计算属性：</p>
<pre><code class="language-js">const props = defineProps(['size'])

// 该 prop 变更时计算属性也会自动更新
const normalizedSize = computed(() =&gt; props.size.trim().toLowerCase())
</code></pre>
<p>更改对象 / 数组类型的 props</p>
<p>当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然可以更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，而对 Vue 来说，禁止这样的改动，虽然可能生效，但有很大的性能损耗，比较得不偿失。</p>
<p>这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该抛出一个事件来通知父组件做出改变。</p>
<h2 id="三-prop-校验"><a class="header" href="#三-prop-校验">三 Prop 校验</a></h2>
<p>要声明对 props 的校验，你可以向 defineProps() 宏提供一个带有 props 校验选项的对象，例如：</p>
<pre><code class="language-js">defineProps({
  // 基础类型检查
  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）
  propA: Number,
  // 多种可能的类型
  propB: [String, Number],
  // 必传，且为 String 类型
  propC: {
    type: String,
    required: true,
  },
  // Number 类型的默认值
  propD: {
    type: Number,
    default: 100,
  },
  // 对象类型的默认值
  propE: {
    type: Object,
    // 对象或数组的默认值
    // 必须从一个工厂函数返回。
    // 该函数接收组件所接收到的原始 prop 作为参数。
    default(rawProps) {
      return { message: 'hello' }
    },
  },
  // 自定义类型校验函数
  propF: {
    validator(value) {
      // The value must match one of these strings
      return ['success', 'warning', 'danger'].includes(value)
    },
  },
  // 函数类型的默认值
  propG: {
    type: Function,
    // 不像对象或数组的默认，这不是一个工厂函数。这会是一个用来作为默认值的函数
    default() {
      return 'Default function'
    },
  },
})
</code></pre>
<p>一些补充细节：</p>
<ul>
<li>所有 prop 默认都是可选的，除非声明了 required: true。</li>
<li>除 Boolean 外的未传递的可选 prop 将会有一个默认值 undefined。</li>
<li>Boolean 类型的未传递 prop 将被转换为 false。这可以通过为它设置 default 来更改——例如：设置为 default: undefined 将与非布尔类型的 prop 的行为保持一致。</li>
<li>如果声明了 default 值，那么在 prop 的值被解析为 undefined 时，无论 prop 是未被传递还是显式指明的 undefined，都会改为 default 值。</li>
<li>当 prop 的校验失败后，Vue 会抛出一个控制台警告 (在开发模式下)。</li>
<li>如果使用了基于类型的 prop 声明 ，Vue 会尽最大努力在运行时按照 prop 的类型标注进行编译。举例来说，<code>defineProps&lt;{ msg: string }&gt;</code> 会被编译为 <code>{ msg: { type: String, required: true } }</code>。</li>
</ul>
<p>校验选项中的 type 可以是下列这些原生构造函数，也可以是自定义的类或构造函数，Vue 将会通过 instanceof 来检查类型是否匹配。例如下面这个类：</p>
<pre><code class="language-js">class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
  }
}

defineProps({
  author: Person,
})
</code></pre>
<p>为了更贴近原生 boolean attributes 的行为，声明为 Boolean 类型的 props 有特别的类型转换规则。以带有如下声明的 <MyComponent> 组件为例：</p>
<pre><code class="language-js">defineProps({
  disabled: Boolean,
})
</code></pre>
<p>该组件可以被这样使用：</p>
<pre><code class="language-vue">&lt;!-- 等同于传入 :disabled=&quot;true&quot; --&gt;
&lt;MyComponent disabled /&gt;

&lt;!-- 等同于传入 :disabled=&quot;false&quot; --&gt;
&lt;MyComponent /&gt;
</code></pre>
<p>当一个 prop 被声明为允许多种类型时，例如：</p>
<pre><code class="language-js">defineProps({
  disabled: [Boolean, Number],
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="035-组件基础-模板引用-ref"><a class="header" href="#035-组件基础-模板引用-ref">03.5-组件基础-模板引用 ref</a></h1>
<h2 id="一-模板引用示例"><a class="header" href="#一-模板引用示例">一 模板引用示例</a></h2>
<h3 id="11-字符串-ref"><a class="header" href="#11-字符串-ref">1.1 字符串 ref</a></h3>
<p>Vue 抽象了大部分 DOM 操作，如果我们想要直接访问 DOM 元素，使用 ref 属性即可：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, onMounted } from 'vue'

// 声明一个 ref 来存放该元素的引用
// 必须和模板里的 ref 同名
const input = ref(null)

onMounted(() =&gt; {
  input.value.focus()
})
&lt;/script&gt;

&lt;template&gt;
  &lt;input ref=&quot;input&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>贴士：如果不使用 <code>&lt;script setup&gt;</code>，需确保从 setup() 返回 ref 的引用。</p>
<p>如果是选项式 API，则书写方式如下：</p>
<pre><code class="language-vue">&lt;script&gt;
export default {
  mounted() {
    this.$refs.input.focus()
  },
}
&lt;/script&gt;

&lt;template&gt;
  &lt;input ref=&quot;input&quot; /&gt;
&lt;/template&gt;
</code></pre>
<h3 id="12-函数-ref"><a class="header" href="#12-函数-ref">1.2 函数 ref</a></h3>
<p>除了使用字符串值作名字，ref attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：</p>
<pre><code class="language-js">&lt;input :ref=&quot;(el) =&gt; { /* 将 el 赋值给一个数据属性或 ref 变量 */ }&quot;&gt;
</code></pre>
<p>注意我们这里需要使用动态的 :ref 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 el 参数会是 null。你当然也可以绑定一个组件方法而不是内联函数。</p>
<h3 id="13-ref-使用注意"><a class="header" href="#13-ref-使用注意">1.3 ref 使用注意</a></h3>
<p>ref 允许在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。其常见使用场景有：如在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库，挂载结束后引用都会被暴露在 this.$refs 之上。</p>
<p>模板引用只可以在组件挂载后才能被访问。如果你想在模板中的表达式上访问 input，在初次渲染时会是 null。这是因为在初次渲染前这个元素还不存在。所以侦听一个模板引用 ref 的变化，要考虑到其值为 null 的情况：</p>
<pre><code class="language-js">watchEffect(() =&gt; {
  if (input.value) {
    input.value.focus()
  } else {
    // 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制）
  }
})
</code></pre>
<p>注意：ref 数组并不保证与源数组相同的顺序。</p>
<h3 id="14-组件上的-ref"><a class="header" href="#14-组件上的-ref">1.4 组件上的 ref</a></h3>
<p>模板引用也可以被用在一个子组件上。这种情况下引用中获得的值是组件实例：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, onMounted } from 'vue'
import Child from './Child.vue'

const child = ref(null)

onMounted(() =&gt; {
  // child.value 是 &lt;Child /&gt; 组件的实例
})
&lt;/script&gt;

&lt;template&gt;
  &lt;Child ref=&quot;child&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>如果一个子组件使用的是选项式 API 或没有使用 <code>&lt;script setup&gt;</code>，被引用的组件实例和该子组件的 this 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。</p>
<p>有一个例外的情况，使用了 <code>&lt;script setup&gt;</code> 的组件是默认私有的：一个父组件无法访问到一个使用了 <code>&lt;script setup&gt;</code> 的子组件中的任何东西，除非子组件在其中通过 defineExpose 宏显式暴露：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref } from 'vue'

const a = 1
const b = ref(2)

// 像 defineExpose 这样的编译器宏不需要导入
defineExpose({
  a,
  b,
})
&lt;/script&gt;
</code></pre>
<p>当父组件通过模板引用获取到了该组件的实例时，得到的实例类型为 { a: number, b: number } (ref 都会自动解包，和一般的实例一样)。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="036-组件基础-计算属性"><a class="header" href="#036-组件基础-计算属性">03.6-组件基础-计算属性</a></h1>
<h2 id="一-计算属性在组合式-api-中的示例"><a class="header" href="#一-计算属性在组合式-api-中的示例">一 计算属性在组合式 API 中的示例</a></h2>
<p>模板中的表达式只能做简单的操作，表达式逻辑复杂将会难以维护，比如下面的一个数据：</p>
<pre><code class="language-js">const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery',
  ],
})
</code></pre>
<p>根据 author 是否已有一些书籍来展示不同的信息：</p>
<pre><code class="language-html">&lt;p&gt;Has published books:&lt;/p&gt;
&lt;span&gt;{ { author.books.length &gt; 0 ? 'Yes' : 'No' } }&lt;/span&gt;
</code></pre>
<p>表达式的计算逻辑依赖于 author.books，该成员有可能在很多地方会被使用，也就是说会被计算多次，这里就推荐使用计算属性来实现：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { reactive, computed } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery',
  ],
})

// 一个计算属性 ref
const publishedBooksMessage = computed(() =&gt; {
  return author.books.length &gt; 0 ? 'Yes' : 'No'
})
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;Has published books:&lt;/p&gt;
  &lt;span&gt;{ { publishedBooksMessage } }&lt;/span&gt;
&lt;/template&gt;
</code></pre>
<p>computed() 方法期望接收一个 getter 函数，返回值为一个计算属性 ref。和其他一般的 ref 类似，你可以通过 publishedBooksMessage.value 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。</p>
<p>Vue 的计算属性会自动追踪响应式依赖。它会检测到 publishedBooksMessage 依赖于 author.books，所以当 author.books 改变时，任何依赖于 publishedBooksMessage 的绑定都会同时更新。</p>
<h2 id="二-计算属性使用注意事项"><a class="header" href="#二-计算属性使用注意事项">二 计算属性使用注意事项</a></h2>
<h3 id="21-计算属性缓存与方法的区别"><a class="header" href="#21-计算属性缓存与方法的区别">2.1 计算属性缓存与方法的区别</a></h3>
<p>在上述案例中，如果我们在组件中声明一个方法，用来获取 Yes 与 No 的结果：</p>
<pre><code class="language-js">function calculateBooksMessage() {
  return author.books.length &gt; 0 ? 'Yes' : 'No'
}
</code></pre>
<p>这个函数也可以利用插值形式获得与计算属性同样的显示效果：</p>
<pre><code class="language-html">&lt;p&gt;{ { calculateBooksMessage() } }&lt;/p&gt;
</code></pre>
<p>不同之处在于计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage 都会立即返回先前的计算结果，而不用重复执行 getter 函数。</p>
<p>为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 list。没有缓存的话，我们会重复执行非常多次 list 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。</p>
<h3 id="22-可写计算属性"><a class="header" href="#22-可写计算属性">2.2 可写计算属性</a></h3>
<p>计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    ;[firstName.value, lastName.value] = newValue.split(' ')
  },
})
&lt;/script&gt;
</code></pre>
<p>现在当你再运行 fullName.value = 'John Doe' 时，setter 会被调用而 firstName 和 lastName 会随之更新。</p>
<h3 id="23-计算属性最佳实践"><a class="header" href="#23-计算属性最佳实践">2.3 计算属性最佳实践</a></h3>
<p>首先：Getter 不应有副作用。</p>
<p>计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，不要在 getter 中做异步请求或者更改 DOM！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用监听器根据其他响应式状态的变更来创建副作用。</p>
<p>其次：避免直接修改计算属性值。</p>
<p>从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</p>
<h2 id="三-计算属性在选项式-api-中的示例"><a class="header" href="#三-计算属性在选项式-api-中的示例">三 计算属性在选项式 API 中的示例</a></h2>
<p>上述组合式的示例如果使用选项式则代码如下：</p>
<pre><code class="language-js">export default {
  data() {
    return {
      author: {
        name: 'John Doe',
        books: [
          'Vue 2 - Advanced Guide',
          'Vue 3 - Basic Guide',
          'Vue 4 - The Mystery',
        ],
      },
    }
  },
  computed: {
    // 一个计算属性的 getter
    publishedBooksMessage() {
      // `this` 指向当前组件实例
      return this.author.books.length &gt; 0 ? 'Yes' : 'No'
    },
  },
}
</code></pre>
<p>如果需要可写的计算属性，则代码如下：</p>
<pre><code class="language-js">export default {
  data() {
    return {
      firstName: 'John',
      lastName: 'Doe',
    }
  },
  computed: {
    fullName: {
      // getter
      get() {
        return this.firstName + ' ' + this.lastName
      },
      // setter
      set(newValue) {
        // 注意：我们这里使用的是解构赋值语法
        ;[this.firstName, this.lastName] = newValue.split(' ')
      },
    },
  },
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="037-组件基础-侦听器"><a class="header" href="#037-组件基础-侦听器">03.7-组件基础-侦听器</a></h1>
<h2 id="一-侦听器-api"><a class="header" href="#一-侦听器-api">一 侦听器 API</a></h2>
<h3 id="11-组合式-api-示例"><a class="header" href="#11-组合式-api-示例">1.1 组合式 API 示例</a></h3>
<p>计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。</p>
<p>在组合式 API 中，我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, watch } from 'vue'

const question = ref('')
const answer = ref('Questions usually contain a question mark. ;-)')

// 可以直接侦听一个 ref
watch(question, async (newQuestion, oldQuestion) =&gt; {
  if (newQuestion.indexOf('?') &gt; -1) {
    answer.value = 'Thinking...'
    try {
      const res = await fetch('https://api.demo.com')
      answer.value = (await res.json()).answer
    } catch (error) {
      answer.value = 'Error! Could not reach the API. ' + error
    }
  }
})
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;
    Ask a yes/no question:
    &lt;input v-model=&quot;question&quot; /&gt;
  &lt;/p&gt;
  &lt;p&gt;{ { answer } }&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<h3 id="12-选项式-api-示例"><a class="header" href="#12-选项式-api-示例">1.2 选项式 API 示例</a></h3>
<p>在选项式 API 中，其结构为：</p>
<pre><code class="language-js">export default {
  data() {
    return {
      question: '',
      answer: 'Questions usually contain a question mark. ;-)',
    }
  },
  watch: {
    // 每当 question 改变时，这个函数就会执行
    question(newQuestion, oldQuestion) {
      if (newQuestion.includes('?')) {
        this.getAnswer()
      }
    },
  },
  methods: {
    async getAnswer() {
      this.answer = 'Thinking...'
      try {
        const res = await fetch('https://yesno.wtf/api')
        this.answer = (await res.json()).answer
      } catch (error) {
        this.answer = 'Error! Could not reach the API. ' + error
      }
    },
  },
}
</code></pre>
<p>watch 选项也支持把键设置成用 . 分隔的路径：</p>
<pre><code class="language-js">export default {
  watch: {
    // 注意：只能是简单的路径，不支持表达式。
    'some.nested.key'(newValue) {
      // ...
    },
  },
}
</code></pre>
<p>我们也可以使用组件实例的 $watch() 方法来命令式地创建一个侦听器：</p>
<pre><code class="language-js">export default {
  created() {
    this.$watch('question', (newQuestion) =&gt; {
      // ...
    })
  },
}
</code></pre>
<p>如果要在特定条件下设置一个侦听器，或者只侦听响应用户交互的内容，这方法很有用。它还允许你提前停止该侦听器。</p>
<h3 id="13-侦听数据源类型"><a class="header" href="#13-侦听数据源类型">1.3 侦听数据源类型</a></h3>
<p>watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p>
<pre><code class="language-js">const x = ref(0)
const y = ref(0)

// 单个 ref
watch(x, (newX) =&gt; {
  console.log(`x is ${newX}`)
})

// getter 函数
watch(
  () =&gt; x.value + y.value,
  (sum) =&gt; {
    console.log(`sum of x + y is: ${sum}`)
  }
)

// 多个来源组成的数组
watch([x, () =&gt; y.value], ([newX, newY]) =&gt; {
  console.log(`x is ${newX} and y is ${newY}`)
})
</code></pre>
<p>注意，你不能直接侦听响应式对象的属性值，例如:</p>
<pre><code class="language-js">const obj = reactive({ count: 0 })

// 错误，因为 watch() 得到的参数是一个 number
watch(obj.count, (count) =&gt; {
  console.log(`count is: ${count}`)
})
</code></pre>
<p>这里需要用一个返回该属性的 getter 函数：</p>
<pre><code class="language-js">// 提供一个 getter 函数
watch(
  () =&gt; obj.count,
  (count) =&gt; {
    console.log(`count is: ${count}`)
  }
)
</code></pre>
<h3 id="14-深层侦听器"><a class="header" href="#14-深层侦听器">1.4 深层侦听器</a></h3>
<p>直接给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：</p>
<pre><code class="language-js">const obj = reactive({ count: 0 })

watch(obj, (newValue, oldValue) =&gt; {
  // 在嵌套的属性变更时触发
  // 注意：`newValue` 此处和 `oldValue` 是相等的
  // 因为它们是同一个对象！
})

obj.count++
</code></pre>
<p>相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：</p>
<pre><code class="language-js">watch(
  () =&gt; state.someObject,
  () =&gt; {
    // 仅当 state.someObject 被替换时触发
  }
)
</code></pre>
<p>也可以给上面这个例子显式地加上 deep 选项，强制转成深层侦听器：</p>
<pre><code class="language-js">watch(
  () =&gt; state.someObject,
  (newValue, oldValue) =&gt; {
    // 注意：`newValue` 此处和 `oldValue` 是相等的
    // _除非_ state.someObject 被整个替换了
  },
  { deep: true }
)
</code></pre>
<p>贴士：选项式 API 中实现深层侦听，只需要设置 deep 属性即可：</p>
<pre><code class="language-js">export default {
  watch: {
    someObject: {
      handler(newValue, oldValue) {},
      deep: true,
    },
  },
}
</code></pre>
<h2 id="二-侦听器的回调"><a class="header" href="#二-侦听器的回调">二 侦听器的回调</a></h2>
<h3 id="21-即时回调的侦听器"><a class="header" href="#21-即时回调的侦听器">2.1 即时回调的侦听器</a></h3>
<p>watch 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。</p>
<p>我们可以通过传入 immediate: true 选项来强制侦听器的回调立即执行：</p>
<pre><code class="language-js">watch(
  source,
  (newValue, oldValue) =&gt; {
    // 立即执行，且当 `source` 改变时再次执行
  },
  { immediate: true }
)
</code></pre>
<p>贴士：在选项式 API 中，只要设置 immediate 即可：</p>
<pre><code class="language-js">export default {
  watch: {
    question: {
      handler(newQuestion) {
        // 在组件实例创建时会立即调用
      },
      // 强制立即执行回调
      immediate: true,
    },
  },
}
</code></pre>
<h3 id="22-watcheffect"><a class="header" href="#22-watcheffect">2.2 watchEffect()</a></h3>
<p>侦听器的回调使用与源完全相同的响应式状态是很常见的。例如下面的代码，在每当 todoId 的引用发生变化时使用侦听器来加载一个远程资源：</p>
<pre><code class="language-js">const todoId = ref(1)
const data = ref(null)

watch(
  todoId,
  async () =&gt; {
    const response = await fetch(
      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
    )
    data.value = await response.json()
  },
  { immediate: true }
)
</code></pre>
<p>特别是注意侦听器是如何两次使用 todoId 的，一次是作为源，另一次是在回调中。</p>
<p>我们可以用 watchEffect 函数 来简化上面的代码。watchEffect() 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：</p>
<pre><code class="language-js">watchEffect(async () =&gt; {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
})
</code></pre>
<p>这个例子中，回调会立即执行，不需要指定 immediate: true。在执行期间，它会自动追踪 todoId.value 作为依赖（和计算属性类似）。每当 todoId.value 变化时，回调会再次执行。有了 watchEffect()，我们不再需要明确传递 todoId 作为源值。</p>
<p>对于有多个依赖项的侦听器来说，使用 watchEffect() 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，watchEffect() 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。</p>
<h3 id="23-watch-与-watcheffect-对比"><a class="header" href="#23-watch-与-watcheffect-对比">2.3 watch 与 watchEffect 对比</a></h3>
<p>watch 和 watchEffect 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：</p>
<ul>
<li>watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</li>
<li>watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。</li>
</ul>
<h3 id="24-回调的触发时机"><a class="header" href="#24-回调的触发时机">2.4 回调的触发时机</a></h3>
<p>当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。</p>
<p>默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。</p>
<p>如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: 'post' 选项：</p>
<pre><code class="language-js">watch(source, callback, {
  flush: 'post',
})

watchEffect(callback, {
  flush: 'post',
})
</code></pre>
<p>后置刷新的 watchEffect() 有个更方便的别名 watchPostEffect()：</p>
<pre><code class="language-js">import { watchPostEffect } from 'vue'

watchPostEffect(() =&gt; {
  /* 在 Vue 更新后执行 */
})
</code></pre>
<p>贴士：在选项式 API 中，原理与组合式 API 一致：</p>
<pre><code class="language-js">export default {
  // ...
  watch: {
    key: {
      handler() {},
      flush: 'post',
    },
  },
}
</code></pre>
<h3 id="三-停止侦听器"><a class="header" href="#三-停止侦听器">三 停止侦听器</a></h3>
<p>在 setup() 或 <code>&lt;script setup&gt;</code> 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。</p>
<p>一个关键点是，侦听器必须用同步语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下方这个例子：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { watchEffect } from 'vue'

// 它会自动停止
watchEffect(() =&gt; {})

// ...这个则不会！
setTimeout(() =&gt; {
  watchEffect(() =&gt; {})
}, 100)
&lt;/script&gt;
</code></pre>
<p>要手动停止一个侦听器，请调用 watch 或 watchEffect 返回的函数：</p>
<pre><code class="language-js">const unwatch = watchEffect(() =&gt; {})

// ...当该侦听器不再需要时
unwatch()
</code></pre>
<p>注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：</p>
<pre><code class="language-js">// 需要异步请求得到的数据
const data = ref(null)

watchEffect(() =&gt; {
  if (data.value) {
    // 数据加载后执行某些操作...
  }
})
</code></pre>
<p>在选项式 API 中，用 watch 选项或者 $watch() 实例方法声明的侦听器，会在宿主组件卸载时自动停止。因此，在大多数场景下，你无需关心怎么停止它。
在少数情况下，你的确需要在组件卸载之前就停止一个侦听器，这时可以调用 $watch() API 返回的函数：</p>
<pre><code class="language-js">const unwatch = this.$watch('foo', callback)
// ...当该侦听器不再需要时
unwatch()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-常见操作-事件"><a class="header" href="#041-常见操作-事件">04.1-常见操作-事件</a></h1>
<h3 id="一-v-on-绑定事件示例"><a class="header" href="#一-v-on-绑定事件示例">一 v-on 绑定事件示例</a></h3>
<h3 id="11-基础示例-1"><a class="header" href="#11-基础示例-1">1.1 基础示例</a></h3>
<p>v-on 用于组件绑定事件，也可以使用 @ 方式简写</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div @click=&quot;increment&quot;&gt;{ { count } }&lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
  import { ref } from 'vue'
  const count = ref(0)

  const increment = () =&gt; {
    count.value++
  }
&lt;/script&gt;
</code></pre>
<h3 id="12-事件函数参数"><a class="header" href="#12-事件函数参数">1.2 事件函数参数</a></h3>
<p>绑定的事件函数可以写函数名，也可以书写函数调用：</p>
<pre><code class="language-js">@click='do'                         // 该方式默认会携带事件对象，do 函数的第一个参数就是事件对象
@click='do(&quot;hello&quot;, $event)'        // $event 只有显式传递才能获取到，顺序可在前在后，vue 会对参数进行扫描
</code></pre>
<p>有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 $event 变量，或者使用内联箭头函数：</p>
<pre><code class="language-html">&lt;!-- 使用特殊的 $event 变量 --&gt;
&lt;button @click=&quot;warn('Form cannot be submitted yet.', $event)&quot;&gt;Submit&lt;/button&gt;

&lt;!-- 使用内联箭头函数 --&gt;
&lt;button @click=&quot;(event) =&gt; warn('Form cannot be submitted yet.', event)&quot;&gt;
  Submit
&lt;/button&gt;

&lt;script&gt;
    methods: {
    warn(message, event) {
      // 这里可以访问 DOM 原生事件
      if (event) {
        event.preventDefault()
      }
      alert(message)
    }
  }
&lt;/script&gt;
</code></pre>
<h2 id="二-事件修饰符"><a class="header" href="#二-事件修饰符">二 事件修饰符</a></h2>
<h3 id="21-事件修饰符汇总"><a class="header" href="#21-事件修饰符汇总">2.1 事件修饰符汇总</a></h3>
<p>开发者可以在事件处理函数中对事件进行阻止冒泡、阻止默认事件等操作，vue 也提供了更简便的工具-事件修饰符。示例：</p>
<pre><code class="language-html">&lt;a @click.stop=&quot;handle&quot;&gt;跳转&lt;/a&gt;
</code></pre>
<p>事件修饰符是可以串联写的：如：<code>@click.prevent.once=&quot;clickHandler&quot;</code>。常见事件修饰符有：</p>
<ul>
<li>stop：阻止冒泡，所有冒泡行为都被阻止</li>
<li>self：只有 event.target 是当前操作的元素时才会触发</li>
<li>prevent：阻止默认事件</li>
<li>capture：使事件在捕获阶段即可触发</li>
<li>once：事件只触发一次</li>
<li>一些特殊标签也拥有自身专属的事件修饰符，如按键修饰符：<code>@keyup.enter=''</code>等</li>
<li>passive：事件的默认行为立即执行，无需等待事件回调完毕</li>
</ul>
<h3 id="22-exact-修饰符"><a class="header" href="#22-exact-修饰符">2.2 .exact 修饰符</a></h3>
<p>.exact 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。</p>
<pre><code class="language-vue">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;
&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;
&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;
&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
</code></pre>
<h3 id="23-键盘事件"><a class="header" href="#23-键盘事件">2.3 键盘事件</a></h3>
<p>Vue 为一些常用键盘事件提供了别名：</p>
<ul>
<li>enter：回车</li>
<li>delete：删除</li>
<li>esc：退出</li>
<li>space：空格</li>
<li>tab：换行</li>
<li>up：上</li>
<li>down：下</li>
<li>left：左</li>
<li>right：右</li>
</ul>
<p>使用示例：</p>
<pre><code class="language-js">&lt;input @keyup.enter=&quot;show&quot;&gt;
</code></pre>
<p>未提供别名的按键，可以使用键盘事件进行自定义：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;button @keyup.move=&quot;handle&quot;&gt;&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
  // 全局中使用 Vue 类本身
  Vue.config.keyCodes.move = 65 // 65 代表 a 键 按该键触发函数
&lt;/script&gt;
</code></pre>
<h3 id="24-鼠标按键修饰符"><a class="header" href="#24-鼠标按键修饰符">2.4 鼠标按键修饰符</a></h3>
<p>鼠标按键修饰符有：<code>.left</code>，<code>.right</code>，<code>.middle</code>，这些修饰符将处理程序限定为由特定鼠标按键触发的事件。</p>
<h2 id="三-自定义事件"><a class="header" href="#三-自定义事件">三 自定义事件</a></h2>
<h3 id="31-emit-触发自定义事件"><a class="header" href="#31-emit-触发自定义事件">3.1 $emit 触发自定义事件</a></h3>
<p>在组件的模板表达式中，可以直接使用 $emit 方法触发自定义事件 (例如：在 v-on 的处理函数中)：</p>
<pre><code class="language-vue">&lt;!-- 子组件 MyComponent 触发自定义事件--&gt;
&lt;button @click=&quot;$emit('someEvent')&quot;&gt;click me&lt;/button&gt;

&lt;!-- 父组件监听事件 --&gt;
&lt;MyComponent @some-event=&quot;callback&quot; /&gt;
</code></pre>
<h3 id="32-emit-传参方式"><a class="header" href="#32-emit-传参方式">3.2 $emit 传参方式</a></h3>
<p><code>$emit</code> 传参方式：</p>
<pre><code class="language-vue">&lt;button @click=&quot;$emit('increaseBy', 1)&quot;&gt;
  Increase by 1
&lt;/button&gt;
</code></pre>
<p>然后我们在父组件中监听事件：</p>
<pre><code class="language-js">&lt;MyButton @increase-by=&quot;increaseCount&quot; /&gt;

// 对应事件函数
function increaseCount(n) {
  count.value += n
}
</code></pre>
<h3 id="33-声明触发的事件"><a class="header" href="#33-声明触发的事件">3.3 声明触发的事件</a></h3>
<p>组件可以显式地通过 defineEmits() 宏来声明它要触发的事件：</p>
<pre><code class="language-vue">&lt;script setup&gt;
defineEmits(['inFocus', 'submit'])
&lt;/script&gt;
</code></pre>
<p>我们在 <code>&lt;template&gt;</code> 中使用的 $emit 方法不能在组件的 <code>&lt;script setup&gt;</code> 部分中使用，但 defineEmits() 会返回一个相同作用的函数供我们使用：</p>
<pre><code class="language-vue">&lt;script setup&gt;
const emit = defineEmits(['inFocus', 'submit'])

function buttonClick() {
  emit('submit')
}
&lt;/script&gt;
</code></pre>
<p>defineEmits() 宏不能在子函数中使用。如上所示，它必须直接放置在 <code>&lt;script setup&gt;</code> 的顶级作用域下。</p>
<p>如果你显式地使用了 setup 函数而不是 <code>&lt;script setup&gt;</code>，则事件需要通过 emits 选项来定义，emit 函数也被暴露在 setup() 的上下文对象上：</p>
<pre><code class="language-js">export default {
  emits: ['inFocus', 'submit'],
  setup(props, ctx) {
    ctx.emit('submit')
  },
}
</code></pre>
<p>与 setup() 上下文对象中的其他属性一样，emit 可以安全地被解构：</p>
<pre><code class="language-js">export default {
  emits: ['inFocus', 'submit'],
  setup(props, { emit }) {
    emit('submit')
  },
}
</code></pre>
<p>这个 emits 选项还支持对象语法，它允许我们对触发事件的参数进行验证：</p>
<pre><code class="language-vue">&lt;script setup&gt;
const emit = defineEmits({
  submit(payload) {
    // 通过返回值为 `true` 还是为 `false` 来判断
    // 验证是否通过
  },
})
&lt;/script&gt;
</code></pre>
<h3 id="34-事件校验"><a class="header" href="#34-事件校验">3.4 事件校验</a></h3>
<p>和对 props 添加类型校验的方式类似，所有触发的事件也可以使用对象形式来描述。</p>
<p>要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 emit 的内容，返回一个布尔值来表明事件是否合法。</p>
<pre><code class="language-vue">&lt;script setup&gt;
const emit = defineEmits({
  // 没有校验
  click: null,

  // 校验 submit 事件
  submit: ({ email, password }) =&gt; {
    if (email &amp;&amp; password) {
      return true
    } else {
      console.warn('Invalid submit event payload!')
      return false
    }
  },
})

function submitForm(email, password) {
  emit('submit', { email, password })
}
&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="042-常见操作-绑定样式"><a class="header" href="#042-常见操作-绑定样式">04.2-常见操作-绑定样式</a></h1>
<h2 id="一-标签上设置样式"><a class="header" href="#一-标签上设置样式">一 标签上设置样式</a></h2>
<h3 id="11-内联方式-style"><a class="header" href="#11-内联方式-style">1.1 内联方式 <code>:style</code></a></h3>
<p>内联方式有以下几种形式：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;h2 :style=&quot;{'background-color': 'green'}&quot;&gt;test1&lt;/h2&gt;
  &lt;h2 :style=&quot;styleObj1&quot;&gt;test2&lt;/h2&gt;
  &lt;h2 :style=&quot;[styleObj1,styleObj2]&quot;&gt;test3&lt;/h2&gt;
&lt;/div&gt;

&lt;script&gt;
  new Vue({
    el: '#app',
    data: {
      msg: 'hello',
      isActive: true,
      styleObj1: { 'background-color': 'green' },
      styleObj2: { 'font-size': '100px' },
    },
    methods: {},
  })
&lt;/script&gt;
</code></pre>
<p><strong>注意：如果属性带有横线“-”，则此属性必须用冒号引起来；</strong></p>
<h3 id="12-类名方式-class"><a class="header" href="#12-类名方式-class">1.2 类名方式 <code>:class</code></a></h3>
<pre><code class="language-html">&lt;style&gt;
  .green {
    background-color: green;
  }
  .big {
    font-weigth: 200;
  }
  .active {
    letter-spacing: 0.5em;
  }
&lt;/style&gt;

&lt;div id=&quot;app&quot;&gt;
  &lt;h2 :class=&quot;['green', 'big']&quot;&gt;test1&lt;/h2&gt;
  &lt;h2 :class=&quot;['green', 'big', isActive?'active':'']&quot;&gt;test2&lt;/h2&gt;
  &lt;h2 :class=&quot;['green', 'big', {'active': isActive}]&quot;&gt;test3&lt;/h2&gt;
  &lt;h2 :class=&quot;{ green:true, big:true }&quot;&gt;test4&lt;/h2&gt;
  &lt;h2 :class=&quot;classObj&quot;&gt;test5&lt;/h2&gt;
&lt;/div&gt;

&lt;script&gt;
      new Vue({
      el: &quot;#app&quot;,
      data: {
          msg: &quot;hello&quot;,
          isActive: true，
          classObj: { green:true, big:true }
      }
  });
&lt;/script&gt;
</code></pre>
<p>贴士： <code>:class</code> 是动态绑定，其值为表达式，如果不加冒号，<code>class</code> 则是 DOM 中的原生 class 样式。</p>
<h3 id="13-vue-文件中直接设置-class"><a class="header" href="#13-vue-文件中直接设置-class">1.3 .vue 文件中直接设置 class</a></h3>
<p>如果使用了组件化开发模式，则可以在 <code>.vue</code> 后缀的文件中直接设置 class：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;p class=&quot;green&quot;&gt;绿色&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;&lt;/script&gt;

&lt;!-- 直接在此处设置 --&gt;
&lt;style&gt;
  .green {
    background-color: green;
  }
&lt;/style&gt;
</code></pre>
<h2 id="二-引入-css-文件"><a class="header" href="#二-引入-css-文件">二 引入 css 文件</a></h2>
<p>在 js 文件中可以直接引用 css 文件：</p>
<pre><code class="language-js">import 'element-ui/lib/theme-default/index.css'
</code></pre>
<p>如果使用了组件化开发模式，在 .vue 文件中有三种引入方式 css 文件的方式：</p>
<pre><code class="language-html">&lt;!-- 方式一：在 script 标签中引入 --&gt;
&lt;script&gt;
  import '../static/css/global.css'
&lt;/script&gt;

&lt;!-- 方式二：在 style 中引入样式 --&gt;
&lt;style scoped&gt;
  @import '../css/style.css';
&lt;/style&gt;

&lt;!-- 方式三：在 style 标签的 src 上引入 --&gt;
&lt;style scoped src=&quot;../static/css/user.css&quot;&gt;&lt;/style&gt;
</code></pre>
<p>CSS 引入顺序注意事项：</p>
<ul>
<li>应该在样式导入之后引入组件，以避免样式覆盖问题</li>
<li>我们自己书写的全局样式应该在组件库样式后导入，才会生效、覆盖库里的样式</li>
</ul>
<h2 id="三-样式的作用域"><a class="header" href="#三-样式的作用域">三 样式的作用域</a></h2>
<p>默认情况下引入的样式也是全局的，如果想要组件的样式私有化，就要添加 scoped，如：</p>
<pre><code class="language-html">&lt;style scoped&gt;
  /* 添加 scoped 后，此处的样式只是针对此组件的，不会污染全局 */
  .h1 {
    color: red;
  }
&lt;/style&gt;
</code></pre>
<p>注意：使用 scoped 后，父组件的样式将不会渗透到子组件中，想要在子组件中重新设置父组件的样式，可以使用深度作用选择器 /deep/，如：</p>
<pre><code class="language-html">&lt;style scoped&gt;
  /deep/ .text-box input {
    width: 166px;
  }
&lt;/style&gt;
</code></pre>
<h2 id="四-css-预处理器的使用"><a class="header" href="#四-css-预处理器的使用">四 css 预处理器的使用</a></h2>
<p>在 style 标签上设置属性 lang 的值，如：lang=&quot;less&quot;</p>
<pre><code class="language-html">&lt;style lang=&quot;less&quot; scoped&gt;
  .text-box {
    input {
      width: 166px;
    }
  }
&lt;/style&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="043-常见操作-列表渲染-1"><a class="header" href="#043-常见操作-列表渲染-1">04.3-常见操作-列表渲染</a></h1>
<h2 id="一-v-for-渲染示例"><a class="header" href="#一-v-for-渲染示例">一 v-for 渲染示例</a></h2>
<p>v-for 指令可以基于一个数组渲染一个列表，其语法是： <code>item in items</code>：</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;!--推荐写法--&gt;
  &lt;h2 v-for=&quot;item in arr&quot; :key=&quot;item.id&quot;&gt;{ {item} }&lt;/h2&gt;
  &lt;h5 v-for=&quot;(item, index) of arr&quot; :key=&quot;item.id&quot;&gt;{ {item} }&lt;/h5&gt;

  &lt;!--不推荐该写法--&gt;
  &lt;h5 v-for=&quot;(item, index) in arr&quot; :key=&quot;index&quot;&gt;{ {item} }&lt;/h5&gt;
&lt;/div&gt;
</code></pre>
<p>v-for 遍历对象时，会基于 <code>Object.keys()</code> 遍历该对象的所有属性，第二个参数为属性名，第三个参数为位置索引：</p>
<pre><code class="language-html">&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt;
  { { index } }. { { key } }: { { value } }
&lt;/li&gt;
</code></pre>
<p>此外 v-for 也可以直接接受一个数值：</p>
<pre><code class="language-js">// n 从 1 开始
&lt;span v-for=&quot;n in 10&quot;&gt;{ { n } }&lt;/span&gt;
</code></pre>
<h2 id="二-v-if-与-v-for"><a class="header" href="#二-v-if-与-v-for">二 v-if 与 v-for</a></h2>
<p>同时使用 v-if 和 v-for 是不推荐的，因为这样二者的优先级不明显。</p>
<p>当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名：</p>
<pre><code class="language-js">// 这会抛出一个错误，因为属性 todo 此时没有在该实例上定义
&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;
  { { todo.name } }
&lt;/li&gt;
</code></pre>
<p>在外新包装一层 <code>&lt;template&gt;</code> 再在其上使用 v-for 可以解决这个问题 (这也更加明显易读)：</p>
<pre><code class="language-js">&lt;template v-for=&quot;todo in todos&quot;&gt;
  &lt;li v-if=&quot;!todo.isComplete&quot;&gt;
    { { todo.name } }
  &lt;/li&gt;
&lt;/template&gt;
</code></pre>
<h2 id="三-通过-key-管理状态"><a class="header" href="#三-通过-key-管理状态">三 通过 key 管理状态</a></h2>
<p>如果没有写 key，vue 默认会使用循环索引 index 作为 key。默认模式是高效的，但只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。</p>
<p>但是默认循环的 key 在一些特殊场景下会产生 BUG，且存在性能问题，如图所示：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/vue/key-01.jpg" alt="vue key原理" /></p>
<p>如图所示，左侧的数据在虚拟 DOM 中准备好后渲染在了真实 DOM 上，且用户在真实 DOM 上输入了对应数据。当我们为添加一行数据，且该数据添加在第一行后，新的虚拟 DOM 与旧的虚拟 DOM 对比时就会发现第一行的数据发生了变化，但是 input 输入框没有变化，在渲染时，第一行的用户名被正确渲染，但是输入框部分仍然使用了旧虚拟 DOM 中的输入框。且这种插入顺序也会导致所有的数据被重新渲染了一遍，性能较低。</p>
<h2 id="四-数组数据的变更"><a class="header" href="#四-数组数据的变更">四 数组数据的变更</a></h2>
<p>Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<p>相对地，也有一些不可变 (immutable) 方法，例如 filter()，concat() 和 slice()，这些都不会更改原数组，而总是返回一个新数组。当遇到的是非变更方法时，我们需要将旧的数组替换为新的：</p>
<pre><code class="language-js">this.items = this.items.filter((item) =&gt; item.message.match(/Foo/))
</code></pre>
<p>你可能认为这将导致 Vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。Vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作。</p>
<h2 id="五-展示过滤或排序后的结果"><a class="header" href="#五-展示过滤或排序后的结果">五 展示过滤或排序后的结果</a></h2>
<p>有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。</p>
<p>举例来说：</p>
<pre><code class="language-js">// template
&lt;li v-for=&quot;n in evenNumbers&quot;&gt;{ { n } }&lt;/li&gt;

// script
data() {
  return {
    numbers: [1, 2, 3, 4, 5]
  }
},
computed: {
  evenNumbers() {
    return this.numbers.filter(n =&gt; n % 2 === 0)
  }
}
</code></pre>
<p>在计算属性不可行的情况下 (例如在多层嵌套的 v-for 循环中)，你可以使用以下方法：</p>
<pre><code class="language-js">// template
&lt;ul v-for=&quot;numbers in sets&quot;&gt;
  &lt;li v-for=&quot;n in even(numbers)&quot;&gt;{ { n } }&lt;/li&gt;
&lt;/ul&gt;

// script
data() {
  return {
    sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]
  }
},
methods: {
  even(numbers) {
    return numbers.filter(number =&gt; number % 2 === 0)
  }
}
</code></pre>
<p>在计算属性中使用 reverse() 和 sort() 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：</p>
<pre><code class="language-js">// diff
- return numbers.reverse()
* return [...numbers].reverse()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="044-常见操作-透传-attributes"><a class="header" href="#044-常见操作-透传-attributes">04.4-常见操作-透传 Attributes</a></h1>
<h2 id="一-attributes-继承"><a class="header" href="#一-attributes-继承">一 Attributes 继承</a></h2>
<p>“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。</p>
<p>当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上：</p>
<pre><code class="language-js">// 绑定class
&lt;MyButton class=&quot;large&quot; /&gt; // MyButton模板是：&lt;button&gt;click me&lt;/button&gt;

// 渲染的DOM为
&lt;button class=&quot;large&quot;&gt;click me&lt;/button&gt;
</code></pre>
<p><code>&lt;MyButton&gt;</code> 并没有将 class 声明为一个它所接受的 prop，所以 class 被视作透传 attribute，自动透传到了 <code>&lt;MyButton&gt;</code> 的根元素上。</p>
<p>这些透传进来的 attribute 可以在模板的表达式中直接用 $attrs 访问到。这个 $attrs 对象包含了除组件所声明的 props 和 emits 之外的所有其他 attribute，例如 class，style，v-on 监听器等等。</p>
<p>注意：</p>
<ul>
<li>和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 foo-bar 这样的一个 attribute 需要通过 $attrs<code>['foo-bar']</code> 来访问。</li>
<li>像 @click 这样的一个 v-on 事件监听器将在此对象下被暴露为一个函数 $attrs.onClick。</li>
</ul>
<h2 id="二-禁用-attributes-继承"><a class="header" href="#二-禁用-attributes-继承">二 禁用 Attributes 继承</a></h2>
<p>如果不想要一个组件自动地继承 attribute，你可以在组件选项中设置 inheritAttrs: false。</p>
<p>如果你使用了 <code>&lt;script setup&gt;</code>，你需要一个额外的 <code>&lt;script&gt;</code> 块来书写这个选项声明：</p>
<pre><code class="language-vue">&lt;script&gt;
// 使用普通的 &lt;script&gt; 来声明选项
export default {
  inheritAttrs: false,
}
&lt;/script&gt;

&lt;script setup&gt;
// ...setup 部分逻辑
&lt;/script&gt;
</code></pre>
<p>最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 inheritAttrs 选项为 false，你可以完全控制透传进来的 attribute 被如何使用。</p>
<h2 id="三-多根节点的-attributes-继承"><a class="header" href="#三-多根节点的-attributes-继承">三 多根节点的 Attributes 继承</a></h2>
<p>和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 $attrs 没有被显式绑定，将会抛出一个运行时警告。</p>
<pre><code class="language-vue">&lt;CustomLayout id=&quot;custom-layout&quot; @click=&quot;changeValue&quot; /&gt;
</code></pre>
<p>如果 <CustomLayout> 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。</p>
<pre><code class="language-vue">&lt;header&gt;...&lt;/header&gt;
&lt;main&gt;...&lt;/main&gt;
&lt;footer&gt;...&lt;/footer&gt;
</code></pre>
<p>如果 $attrs 被显式绑定，则不会有警告：</p>
<pre><code class="language-vue">&lt;header&gt;...&lt;/header&gt;
&lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;
&lt;footer&gt;...&lt;/footer&gt;
</code></pre>
<h2 id="四-在-javascript-中访问透传-attributes"><a class="header" href="#四-在-javascript-中访问透传-attributes">四 在 JavaScript 中访问透传 Attributes</a></h2>
<p>如果需要，你可以在 <code>&lt;script setup&gt;</code> 中使用 useAttrs() API 来访问一个组件的所有透传 attribute：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { useAttrs } from 'vue'

const attrs = useAttrs()
&lt;/script&gt;
</code></pre>
<p>如果没有使用 <code>&lt;script setup&gt;</code>，attrs 会作为 setup() 上下文对象的一个属性暴露：</p>
<pre><code class="language-js">// 组合式API
export default {
  setup(props, ctx) {
    // 透传 attribute 被暴露为 ctx.attrs
    console.log(ctx.attrs)
  },
}

// 选项式API
export default {
  created() {
    console.log(this.$attrs)
  }
}
</code></pre>
<p>需要注意的是，虽然这里的 attrs 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。如果你需要响应性，可以使用 prop。或者你也可以使用 onUpdated() 使得在每次更新时结合最新的 attrs 执行副作用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="045-常见操作-组件-v-model"><a class="header" href="#045-常见操作-组件-v-model">04.5-常见操作-组件 v-model</a></h1>
<h2 id="一-组件上使用-v-model"><a class="header" href="#一-组件上使用-v-model">一 组件上使用 v-model</a></h2>
<p>默认情况下，v-model 在组件上都是使用 modelValue 作为 prop，并以 update:modelValue 作为对应的事件。我们可以通过给 v-model 指定一个参数来更改这些名字：</p>
<pre><code class="language-vue">&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;

&lt;!-- MyComponent.vue --&gt;
&lt;script setup&gt;
defineProps(['title'])
defineEmits(['update:title'])
&lt;/script&gt;

&lt;template&gt;
  &lt;input
    type=&quot;text&quot;
    :value=&quot;title&quot;
    @input=&quot;$emit('update:title', $event.target.value)&quot;
  /&gt;
&lt;/template&gt;
</code></pre>
<h2 id="二-v-model原理"><a class="header" href="#二-v-model原理">二 <code>v-model</code>原理</a></h2>
<p><code>v-model</code>的底层其实是利用了事件绑定、属性绑定的机制：</p>
<pre><code class="language-js">// v-model绑定原本写法
&lt;input v-model=&quot;searchText&quot; /&gt;

// v-model绑定在vue中被解析为
&lt;input
  :value=&quot;searchText&quot;
  @input=&quot;searchText = $event.target.value&quot;
/&gt;
</code></pre>
<p>如果在组件上绑定一个 model：</p>
<pre><code class="language-vue">&lt;!-- CustomInput.vue --&gt;
&lt;script setup&gt;
defineProps(['modelValue'])
defineEmits(['update:modelValue'])
&lt;/script&gt;

&lt;template&gt;
  &lt;input
    :value=&quot;modelValue&quot;
    @input=&quot;$emit('update:modelValue', $event.target.value)&quot;
  /&gt;
&lt;/template&gt;
</code></pre>
<p><code>&lt;CustomInput&gt;</code> 组件内部需要做两件事：</p>
<ul>
<li>将内部原生 <code>&lt;input&gt; </code>元素的 value attribute 绑定到 modelValue prop</li>
<li>当原生的 input 事件触发时，触发一个携带了新值的 update:modelValue 自定义事件</li>
</ul>
<p>代码被被解析为：</p>
<pre><code class="language-js">{/* &lt;CustomInput v-model=&quot;searchText&quot; /&gt; */}
&lt;CustomInput
  :modelValue=&quot;searchText&quot;
  @update:modelValue=&quot;(newValue) =&gt; (searchText = newValue)&quot;
/&gt;
</code></pre>
<p>另一种在组件内实现 v-model 的方式是使用一个可写的，同时具有 getter 和 setter 的 computed 属性。get 方法需返回 modelValue prop，而 set 方法需触发相应的事件：</p>
<pre><code class="language-vue">&lt;!-- CustomInput.vue --&gt;
&lt;script setup&gt;
import { computed } from 'vue'

const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])

const value = computed({
  get() {
    return props.modelValue
  },
  set(value) {
    emit('update:modelValue', value)
  },
})
&lt;/script&gt;

&lt;template&gt;
  &lt;input v-model=&quot;value&quot; /&gt;
&lt;/template&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-组件通信-基础通信方式"><a class="header" href="#051-组件通信-基础通信方式">05.1-组件通信-基础通信方式</a></h1>
<h2 id="一-父传子"><a class="header" href="#一-父传子">一 父传子</a></h2>
<h3 id="11-props-方式实现父传子"><a class="header" href="#11-props-方式实现父传子">1.1 props 方式实现父传子</a></h3>
<p>props 是 Vue 的常见选项对象之一，用于父子关系组件的数据传递。</p>
<p>父组件向子组件传递数据：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;!-- 传递静态数据 --&gt;
  &lt;Son name=&quot;lisi&quot; /&gt;

  &lt;!-- 传递动态数据 --&gt;
  &lt;Son :age=&quot;data.age&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        age: 30,
      }
    },
  }
&lt;/script&gt;
</code></pre>
<p>子组件接收数据：</p>
<pre><code class="language-html">&lt;script&gt;
  export default {
    props: [name, age],
  }
&lt;/script&gt;
</code></pre>
<h2 id="二-子传父-1"><a class="header" href="#二-子传父-1">二 子传父</a></h2>
<h3 id="21-props-实现子传父"><a class="header" href="#21-props-实现子传父">2.1 props 实现子传父</a></h3>
<p>通过传递函数可以实现子传父。</p>
<p>父组件传递函数给子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;Son :getSonName=&quot;getSonName&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;
  // 内部定义该函数
  export default {
    methods: {
      getSonName(data) {
        console.log(data)
      },
    },
  }
&lt;/script&gt;
</code></pre>
<p>子组件接收函数，并传递数据：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;sendData&quot;&gt;传递数据给父组件&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
  // 内部定义该函数
  export default {
    props: ['getSonName']
    methods: {
      sendData() {
        this.getSonName('zs')
      },
    },
  }
&lt;/script&gt;
</code></pre>
<h3 id="22-自定义事件实现数据传递"><a class="header" href="#22-自定义事件实现数据传递">2.2 自定义事件实现数据传递</a></h3>
<p>父组件中给子组将绑定事件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;!-- 给子组件绑定自定义事件 showname --&gt;
  &lt;Son @show=&quot;getSonName&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      getSonName(data) {
        console.log(data)
      },
    },
  }
&lt;/script&gt;
</code></pre>
<p>子组件触发事件，这里无需使用 props 接收了，由<code>$emit</code>触发：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;sendData&quot;&gt;传递数据给父组件&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      sendData() {
        this.$emit('show', 'lisi')
      },
    },
  }
&lt;/script&gt;
</code></pre>
<p>解绑自定义事件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;unBind&quot;&gt;解绑&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      unBind() {
        // 解绑多个参数为 ['show', 'post']
        this.$off('show')
      },
    },
  }
&lt;/script&gt;
</code></pre>
<p>注意：销毁组件会移除该组件实例上的成员，自定义事件也会因此不再生效。</p>
<h2 id="三-事件总线实现组件通信"><a class="header" href="#三-事件总线实现组件通信">三 事件总线实现组件通信</a></h2>
<p>组件之间一般都存在着联系，可以通过祖先组件层级关系进行互相通信，由于该方式需要层层跨越，实现起来也比较麻烦。</p>
<p>Vue 为非父子关系组件提供了事件总线机制来实现通信。事件总线独立于所有组件之外，其本质就是一个空的 Vue 实例。</p>
<p>贴士：事件总线的操作类似在 window 上添加一个属性，这样所有地方就可以访问到该属性，同理在 Vue 上添加的属性，在该 Vue 产生的实例上也都可以访问到。</p>
<pre><code class="language-html">&lt;script&gt;
  let bus = new Vue() // 新建中央事件总线

  Vue.component('publish', {
    template: `
                &lt;div&gt;
                    &lt;input type=&quot;text&quot; /&gt;
                    &lt;button @click=&quot;handleClick()&quot;&gt;发布&lt;/button&gt;
                &lt;/div&gt;`,
    methods: {
      handleClick() {
        bus.$emit('msg', 'helloworld')
      },
    },
  })

  Vue.component('subcribe', {
    template: `
                &lt;div&gt;
                    数据为：
                &lt;/div&gt;`,
    mounted() {
      // 这里让组件尽早的订阅总线消息
      bus.$on('msg', (data) =&gt; {
        alert(data)
      })
    },
  })

  let app = new Vue({
    el: '#app',
    data: {},
  })
&lt;/script&gt;
</code></pre>
<p>一般使用全局事件总线，定义方式如下：</p>
<pre><code class="language-js">// main.js
new Vue({
  el: '#app',
  render: (h) =&gt; h(App),
  beforeCreate() {
    Vue.prototype.$bus = this // 定义全局事件总线
  },
})
</code></pre>
<p>使用全局事件总线发送数据：</p>
<pre><code class="language-js">methods: {
  sendData(){
    this.$bus.$emit('hi', 'Lisi')
  }
}
</code></pre>
<p>使用全局事件总线接收数据、销毁事件：</p>
<pre><code class="language-js">mounted(){
  this.$bus.$on('hi', data =&gt; {})
},
beforeDestroy(){
  this.$bus.$off('hi')
}
</code></pre>
<h2 id="四-不推荐的父子通信方式"><a class="header" href="#四-不推荐的父子通信方式">四 不推荐的父子通信方式</a></h2>
<h3 id="41-ref-实现父访问子"><a class="header" href="#41-ref-实现父访问子">4.1 ref 实现父访问子</a></h3>
<p>ref 可以获取到原生节点，用于在父组件中直接操作子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;input ref=&quot;mytext&quot; /&gt;
  &lt;button @click=&quot;getData&quot;&gt;传递数据给父组件&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      getData() {
        console.log(this.$refs.mytext.value)
      },
    },
  }
&lt;/script&gt;
</code></pre>
<p>ref 通信方式需要在视图结构上添加 ref，不太推荐，但是灵活性强，与自定义事件结合使用如下：</p>
<p>父组件定义 ref：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;Son ref=&quot;mySon&quot; /&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    mounted() {
      this.$refs.mySon.$on('show', function (data) {
        console.log(data)
      })
    },
  }
&lt;/script&gt;
</code></pre>
<p>子组件传递数据：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;sendData&quot;&gt;传递数据给父组件&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      sendData() {
        this.$emit('show', 'lisi')
      },
    },
  }
&lt;/script&gt;
</code></pre>
<p>灵活性的体现示例：可以定时设定接收事件触发。</p>
<h3 id="42-parent-实现子访问父"><a class="header" href="#42-parent-实现子访问父">4.2 parent 实现子访问父</a></h3>
<p><code>this.$parent</code> 是当前组件的父组件，该方法也不推荐使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="052-组件通信-依赖注入"><a class="header" href="#052-组件通信-依赖注入">05.2-组件通信-依赖注入</a></h1>
<h2 id="一-依赖注入实现"><a class="header" href="#一-依赖注入实现">一 依赖注入实现</a></h2>
<h3 id="11-provide-示例"><a class="header" href="#11-provide-示例">1.1 provide 示例</a></h3>
<p>有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去。</p>
<p>provide 和 inject 可以帮助我们解决这一问题。 一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖。</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/vue/provide.png" alt="provide" /></p>
<p>祖先组件为后代提供数据：</p>
<pre><code class="language-vue">&lt;!-- setup 方式--&gt;
&lt;script setup&gt;
import { provide } from 'vue'

// 参数一：注入名（字符串或者Symbol） 参数二：提供的值，可以是响应式状态
provide('message', /* 值 */ 'hello!')
&lt;/script&gt;

&lt;!--非setup 方式--&gt;
&lt;script&gt;
import { provide } from 'vue'

export default {
  // 确保 provide() 是在 setup() 同步调用的
  setup() {
    provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
  },
}
&lt;/script&gt;
</code></pre>
<p>贴士：一个组件可以多次调用 provide()，使用不同的注入名，注入不同的依赖值。</p>
<p>选项式 API 写法如下：</p>
<pre><code class="language-js">export default {
  provide: {
    message: 'hello!',
  },
}

// 如果需要提供依赖当前组件实例的状态 (如由data()定义的数据属性)，则可以以函数形式使用：
export default {
  data() {
    return {
      message: 'hello!'
    }
  },
  provide() {
    // 使用函数的形式，可以访问到 `this`
    return {
      message: this.message
    }
  }
}
</code></pre>
<h3 id="12-inject-示例"><a class="header" href="#12-inject-示例">1.2 Inject 示例</a></h3>
<p>注入上层组件提供的数据示例：</p>
<pre><code class="language-vue">&lt;!--setup 方式--&gt;
&lt;script setup&gt;
import { inject } from 'vue'

const message = inject('message')
&lt;/script&gt;

&lt;!--非setup 方式--&gt;
&lt;script&gt;
import { inject } from 'vue'

export default {
  setup() {
    const message = inject('message')
    return { message }
  },
}
&lt;/script&gt;
</code></pre>
<p>贴士：如果提供的值是一个 ref，注入进来的会是该 ref 对象，而不会自动解包为其内部的值。这使得注入方组件能够通过 ref 对象保持了和供给方的响应性链接。</p>
<p>选项式 API 写法如下：</p>
<pre><code class="language-js">export default {
  inject: ['message'],
  created() {
    console.log(this.message) // injected value
  },
}

// 注入会在组件自身的状态之前被解析，因此你可以在 data() 中访问到注入的属性：
export default {
  inject: ['message'],
  data() {
    return {
      // 基于注入值的初始数据
      fullMessage: this.message
    }
  }
}
</code></pre>
<h3 id="13-注入默认值"><a class="header" href="#13-注入默认值">1.3 注入默认值</a></h3>
<p>默认情况下，inject 假设传入的注入名会被某个祖先链上的组件提供。如果该注入名的确没有任何组件提供，则会抛出一个运行时警告。</p>
<p>如果在注入一个值时不要求必须有提供者，那么我们应该声明一个默认值，和 props 类似：</p>
<pre><code class="language-js">// 如果没有祖先组件提供 &quot;message&quot;
// `value` 会是 &quot;这是默认值&quot;
const value = inject('message', '这是默认值')
</code></pre>
<p>在一些场景中，默认值可能需要通过调用一个函数或初始化一个类来取得。为了避免在用不到默认值的情况下进行不必要的计算或产生副作用，我们可以使用工厂函数来创建默认值：</p>
<pre><code class="language-js">const value = inject('key', () =&gt; new ExpensiveClass())
</code></pre>
<h2 id="二-应用层-provide"><a class="header" href="#二-应用层-provide">二 应用层 Provide</a></h2>
<p>可以在整个应用层面提供依赖：</p>
<pre><code class="language-js">import { createApp } from 'vue'

const app = createApp({})

app.provide('message', 'hello!')
</code></pre>
<p>在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写插件时会特别有用，因为插件一般都不会使用组件形式来提供值。</p>
<h2 id="三-和响应式数据配合使用"><a class="header" href="#三-和响应式数据配合使用">三 和响应式数据配合使用</a></h2>
<p>当提供 / 注入响应式的数据时，建议尽可能将任何对响应式状态的变更都保持在供给方组件中。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。</p>
<p>有的时候，我们可能需要在注入方组件中更改数据。在这种情况下，我们推荐在供给方组件内声明并提供一个更改数据的方法函数：</p>
<pre><code class="language-vue">&lt;!-- 在供给方组件内 --&gt;
&lt;script setup&gt;
import { provide, ref } from 'vue'

const location = ref('North Pole')

function updateLocation() {
  location.value = 'South Pole'
}

provide('location', {
  location,
  updateLocation,
})
&lt;/script&gt;

&lt;!-- 在注入方组件 --&gt;
&lt;script setup&gt;
import { inject } from 'vue'

const { location, updateLocation } = inject('location')
&lt;/script&gt;

&lt;template&gt;
  &lt;button @click=&quot;updateLocation&quot;&gt;{ { location } }&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>最后，如果你想确保提供的数据不能被注入方的组件更改，你可以使用 readonly() 来包装提供的值。</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, provide, readonly } from 'vue'

const count = ref(0)
provide('read-only-count', readonly(count))
&lt;/script&gt;
</code></pre>
<h2 id="四-使用-symbol-作注入名"><a class="header" href="#四-使用-symbol-作注入名">四 使用 Symbol 作注入名</a></h2>
<p>如果是大型应用，包含非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突。</p>
<p>我们通常推荐在一个单独的文件中导出这些注入名 Symbol：</p>
<pre><code class="language-js">// keys.js
export const myInjectionKey = Symbol()

// 在供给方组件中
import { provide } from 'vue'
import { myInjectionKey } from './keys.js'

provide(myInjectionKey, {})

// 注入方组件
import { inject } from 'vue'
import { myInjectionKey } from './keys.js'

const injected = inject(myInjectionKey)
</code></pre>
<pre><code class="language-js">
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-vue-生命周期"><a class="header" href="#061-vue-生命周期">06.1-Vue 生命周期</a></h1>
<h2 id="一-vue-生命周期"><a class="header" href="#一-vue-生命周期">一 Vue 生命周期</a></h2>
<p>Vue 生命周期：Vue 的实例从创建、运行到销毁期间的过程即其生命周期，在此期间伴随着的各种状态改变事件，这些事件也称之为生命周期钩子函数。</p>
<p>如图所示：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/mvvm/vue-lifecycle.jpg" alt="vue 生命周期" /></p>
<p>Vue 的生命周期一般经过：创建--&gt;挂载--&gt;更新--&gt;销毁几个步骤。</p>
<p>创建期间的初始化、挂载函数：</p>
<ul>
<li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li>
<li>created：实例已经在内存中创建 OK，此时 data 和 methods 已经创建 OK，此时还没有开始 编译模板</li>
<li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li>
<li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li>
</ul>
<p>运行期间的更新函数：</p>
<ul>
<li>beforeUpdate：状态更新之前执行此函数，此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染 DOM 节点</li>
<li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>
</ul>
<p>被 keep-alive 缓存的组件激活时或停用时调用：
这两个生命周期函数都是组件在 <code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code> 中包裹时才生效。</p>
<ul>
<li>activated: 被 keep-alive 缓存的组件激活时调用。可以用来在列表页面进入详情页，然后返回列表页面依然停留在上次访问的地方。</li>
<li>deactivated: 被 keep-alive 缓存的组件停用时调用。
<blockquote>
<p>使用场景：用 keep-alive 包裹两个组件：A 和 B，从 A 组件切换到 B 组件时（如 A 组件是列表界面，从当前位置点击进到 B 组件详情界面），会执行 A 组件的 deactivated 生命周期，从 B 组件切换到 A 组件时会执行 A 组件的 activated 生命周期，此时还是停留在 A 组件的上次点击的那条列表信息处。</p>
</blockquote>
</li>
</ul>
<p>销毁期间的摧毁函数：</p>
<ul>
<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
<p>注意：keep-alive 包裹的组件停用时是不会被销毁的，也就是说 <code>beforeDestroy</code>，如果销毁钩子中需要设置定时器销毁就会出现定时器不会被销毁的问题，需要利用 deactivated 钩子实现。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="071-vue-插槽-slot"><a class="header" href="#071-vue-插槽-slot">07.1-Vue 插槽 slot</a></h1>
<h2 id="一-插槽-slot-的使用"><a class="header" href="#一-插槽-slot-的使用">一 插槽 slot 的使用</a></h2>
<h3 id="11-使用示例"><a class="header" href="#11-使用示例">1.1 使用示例</a></h3>
<p>组件可以使用 props 接受 JavaScript 值，接收模板内容需要使用 slot。比如在某些场景中，需要为子组件传递一些模板片段，让子组件渲染这些片段。</p>
<p>传递模板信息仅仅书写普通的 html 元素不可行，在 vue 的初始化项目中，HomeView 引用了 HelloWorld 组件，在视图中还要额外添加信息：</p>
<pre><code class="language-js">&lt;HelloWorld&gt;
    &lt;div&gt;新增内容&lt;div&gt;
&lt;/HelloWorld&gt;
</code></pre>
<p>此时添加的 div 信息是不显示的，因为 Vue 在 new 的时候，去查找 HelloWorld 组件 的 template 内容，从而直接对视图中的 <code>HelloWorld</code> 标签进行了替换。</p>
<p>vue 提供了 slot 插槽，只要在子组件 HelloWorld 中使用 slot，告知 Vue 插入的内容放置在子组建的位置（类似挖坑等待组件使用者填充）：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    插入内容：
    &lt;!--使用者插槽位置未传递数据，则显示默认信息：未传入数据--&gt;
    &lt;slot&gt;无模板传入&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><code>&lt;slot&gt;</code> 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/vue/slot.png" alt="slot" /></p>
<h3 id="12-渲染作用域"><a class="header" href="#12-渲染作用域">1.2 渲染作用域</a></h3>
<p>插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的：</p>
<pre><code class="language-js">&lt;span&gt;{ { message } }&lt;/span&gt;
&lt;FancyButton&gt;{ { message } }&lt;/FancyButton&gt;
</code></pre>
<p>这里的两个 <code>{ { message } }</code> 插值表达式渲染的内容都是一样的。</p>
<p>插槽内容无法访问子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。</p>
<h3 id="13-具名插槽"><a class="header" href="#13-具名插槽">1.3 具名插槽</a></h3>
<p>多个插槽共同使用时，如果需要对单独的插槽进行个性设计，就需要给插槽命名 (不带 name 的插槽其 name 值是 default)。</p>
<p>父组件中定义具名插槽：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;Son&gt;
      &lt;div v-slot:left&gt;hello1&lt;/div&gt;
      &lt;!--#简写--&gt;
      &lt;div #right&gt;hello2&lt;/div&gt;
    &lt;/Son&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件制作插槽：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;slot name=&quot;left&quot;&gt;默认值 left&lt;/slot&gt;
    &lt;slot name=&quot;right&quot;&gt;默认值 right&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="13-动态插槽"><a class="header" href="#13-动态插槽">1.3 动态插槽</a></h3>
<p>动态指令参数在 v-slot 上也是有效的，即可以定义下面这样的动态插槽名：</p>
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:[dynamicSlotName]&gt; ... &lt;/template&gt;

  &lt;!-- 缩写为 --&gt;
  &lt;template #[dynamicSlotName]&gt; ... &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<h2 id="二-作用域插槽"><a class="header" href="#二-作用域插槽">二 作用域插槽</a></h2>
<h3 id="21-作用域插槽示例"><a class="header" href="#21-作用域插槽示例">2.1 作用域插槽示例</a></h3>
<p>组件在编译时，其数据的来源有作用域限制，如果现在父组件需要对子组件内容进行加工处理 (父使用子数据)，就需要设定作用域，以实现父组件在渲染子组件时，子组件能够提供一部分数据给插槽。</p>
<p>可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：</p>
<pre><code class="language-vue">&lt;!-- &lt;MyComponent&gt; 的模板 --&gt;
&lt;div&gt;
  &lt;slot :text=&quot;greetingMessage&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<p>当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 v-slot 指令，直接接收到了一个插槽 props 对象：</p>
<pre><code class="language-vue">&lt;MyComponent v-slot=&quot;slotProps&quot;&gt;
  { { slotProps.text } } { { slotProps.count } }
&lt;/MyComponent&gt;
</code></pre>
<p>子组件传入插槽的 props 作为了 v-slot 指令的值，可以在插槽内的表达式中访问。</p>
<p>你可以将作用域插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它：</p>
<pre><code class="language-js">MyComponent({
  // 类比默认插槽，将其想成一个函数
  default: (slotProps) =&gt; {
    return `${slotProps.text} ${slotProps.count}`
  },
})

function MyComponent(slots) {
  const greetingMessage = 'hello'
  return `&lt;div&gt;${
    // 在插槽函数调用时传入 props
    slots.default({ text: greetingMessage, count: 1 })
  }&lt;/div&gt;`
}
</code></pre>
<p>实际上，这已经和作用域插槽的最终代码编译结果、以及手动编写渲染函数时使用作用域插槽的方式非常类似了。</p>
<p>v-slot=&quot;slotProps&quot; 可以类比这里的函数签名，和函数的参数类似，我们也可以在 v-slot 中使用解构：</p>
<pre><code class="language-js">&lt;MyComponent v-slot=&quot;{ text, count }&quot;&gt;
  { { text } } { { count } }
&lt;/MyComponent&gt;
</code></pre>
<h3 id="22-具名作用域插槽"><a class="header" href="#22-具名作用域插槽">2.2 具名作用域插槽</a></h3>
<p>具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 v-slot 指令的值被访问到：v-slot:name=&quot;slotProps&quot;。当使用缩写时是这样：</p>
<pre><code class="language-js">&lt;MyComponent&gt;
  &lt;template #header=&quot;headerProps&quot;&gt;
    { { headerProps } }
  &lt;/template&gt;

  &lt;template #default=&quot;defaultProps&quot;&gt;
    { { defaultProps } }
  &lt;/template&gt;

  &lt;template #footer=&quot;footerProps&quot;&gt;
    { { footerProps } }
  &lt;/template&gt;
&lt;/MyComponent&gt;
</code></pre>
<p>向具名插槽中传入 props：</p>
<pre><code class="language-js">&lt;slot name=&quot;header&quot; message=&quot;hello&quot;&gt;&lt;/slot&gt;
</code></pre>
<p>注意插槽上的 name 是一个 Vue 特别保留的 attribute，不会作为 props 传递给插槽。因此最终 headerProps 的结果是 { message: 'hello' }。</p>
<p>如果你混用了具名插槽与默认插槽，则需要为默认插槽使用显式的 <code>&lt;template&gt;</code> 标签。尝试直接为组件添加 v-slot 指令将导致编译错误。这是为了避免因默认插槽的 props 的作用域而困惑。举例：</p>
<pre><code class="language-vue">&lt;!-- 该模板无法编译 --&gt;
&lt;template&gt;
  &lt;MyComponent v-slot=&quot;{ message }&quot;&gt;
    &lt;p&gt;{ { message } }&lt;/p&gt;
    &lt;template #footer&gt;
      &lt;!-- message 属于默认插槽，此处不可用 --&gt;
      &lt;p&gt;{ { message } }&lt;/p&gt;
    &lt;/template&gt;
  &lt;/MyComponent&gt;
&lt;/template&gt;
</code></pre>
<p>为默认插槽使用显式的 <code>&lt;template&gt; </code>标签有助于更清晰地指出 message 属性在其他插槽中不可用：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;MyComponent&gt;
    &lt;!-- 使用显式的默认插槽 --&gt;
    &lt;template #default=&quot;{ message }&quot;&gt;
      &lt;p&gt;{ { message } }&lt;/p&gt;
    &lt;/template&gt;

    &lt;template #footer&gt;
      &lt;p&gt;Here's some contact info&lt;/p&gt;
    &lt;/template&gt;
  &lt;/MyComponent&gt;
&lt;/template&gt;
</code></pre>
<h2 id="三-vue26-之后的插槽变化"><a class="header" href="#三-vue26-之后的插槽变化">三 vue2.6 之后的插槽变化</a></h2>
<p>在 vue2.6 之后，为了兼容性，普通插槽与作用域插槽基本没有了太大区别。</p>
<p>插槽在 vue2.6 前后的写法略有不同，在 <code>&lt;template&gt;&lt;/template&gt;</code> 元素中支持 <code>v-slot</code> 写法。</p>
<ul>
<li>普通插槽：
<ul>
<li>2.6 之前：<code>&lt;template slot=&quot;user&quot;&gt;&lt;/template&gt;</code></li>
<li>2.6 之后：<code>&lt;template v-slot:&quot;user&quot;&gt;&lt;/template&gt;</code></li>
</ul>
</li>
<li>作用域插槽：
<ul>
<li>2.6 之前：<code>&lt;template scope=&quot;{users}&quot;&gt;&lt;/template&gt;</code></li>
<li>2.6 之后：<code>&lt;template slot-scope=&quot;{users}&quot;&gt;&lt;/template&gt;</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="081-组合式-api-vue3-与组合式-api"><a class="header" href="#081-组合式-api-vue3-与组合式-api">08.1-组合式 API-Vue3 与组合式 API</a></h1>
<h2 id="一-vue3-介绍"><a class="header" href="#一-vue3-介绍">一 Vue3 介绍</a></h2>
<h3 id="11-vue3-带来的变化"><a class="header" href="#11-vue3-带来的变化">1.1 Vue3 带来的变化</a></h3>
<p>Vue3 核心变化：</p>
<ul>
<li><strong>按需编译</strong>：使得 Vue3 项目的体积比 Vue2 小。</li>
<li><strong>Composition API</strong>：即组合式 API，用来更好的组织、复用业务代码，其目的是用来替代 vue2 的生命周期函数</li>
<li><strong>性能提升</strong>：性能相比 Vue2 提升较大</li>
</ul>
<p>Vue3 其他新特性：</p>
<ul>
<li>更先进的组件：Fragment、Teleport、Suspense</li>
<li>更好的 TypeScript 支持：Vue3 本身是由 TS 书写，其对 TS 的支持度更高</li>
<li>暴露了自定义渲染 API（Custom Renderer API）</li>
</ul>
<h3 id="12-diff-算法优化"><a class="header" href="#12-diff-算法优化">1.2 diff 算法优化</a></h3>
<p>Vue2 的虚拟 DOM 是进行全量对比的，Vue3 新增了静态标记（PatchFlag），在与上次的虚拟节点进行比较时，只对比带有 patch flag 的节点。flag 信息中更进一步也存储了具体要比较的具体内容。</p>
<h3 id="13-组件渲染优化"><a class="header" href="#13-组件渲染优化">1.3 组件渲染优化</a></h3>
<p>Vue2 中的元素每次在更新都会重新创建，Vue3 对于不参与更新的元素，只会被创建一次。</p>
<p>Vue2 中节点渲染伪代码：</p>
<pre><code class="language-js">export function render(){
  return (
    _createNode(&quot;p&quot;, null, &quot;无变动节点 1&quot;)
    _createNode(&quot;p&quot;, null, &quot;无变动节点 2&quot;)
    _createNode(&quot;p&quot;, null, &quot;更新节点 3&quot;)
  )
}
</code></pre>
<p>静态提升后渲染方式伪代码：</p>
<pre><code class="language-js">const _hoisted_1 = _createNode('p', null, '无变动节点 1')
const _hoisted_2 = _createNode('p', null, '无变动节点 2')

export function render() {
  return (
    _hoisted_1,
    _hoisted_2,
    _createVNode('p', null, _toDisplayString('有变动节点 3'))
  )
}
</code></pre>
<h3 id="14-事件侦听优化"><a class="header" href="#14-事件侦听优化">1.4 事件侦听优化</a></h3>
<p>事件绑定函数在默认情况下是动态绑定的，会一直被追踪其变化，源码中使用一个静态标记进行标记。</p>
<p>但是同一个函数，若追踪无变化，组件重新渲染时，静态标记会被取消掉，即不再比较函数的变化。</p>
<h3 id="15-静态内容缓存"><a class="header" href="#15-静态内容缓存">1.5 静态内容缓存</a></h3>
<p>当组件中包含大量静态内容时，这些内容会被当做纯字符串放在 buffer 内，比以前仍然创建虚拟 DOM 渲染快很多。</p>
<h2 id="二-组合函数"><a class="header" href="#二-组合函数">二 组合函数</a></h2>
<h3 id="21-组合函数概念"><a class="header" href="#21-组合函数概念">2.1 组合函数概念</a></h3>
<p>在 Vue 应用的概念中，“组合式函数”(Composables) 是一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：</p>
<ul>
<li>响应式 API：例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。</li>
<li>生命周期钩子：例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。</li>
<li>依赖注入：例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。</li>
</ul>
<p>组合式 API 是 Vue 3 及 Vue 2.7 的内置功能。对于更老的 Vue 2 版本，可以使用官方维护的插件 @vue/composition-api。</p>
<p>当构建前端应用时，我们常常需要复用公共任务的逻辑。例如为了在不同地方格式化时间，我们可能会抽取一个可复用的日期格式化函数。这个函数封装了无状态的逻辑：它在接收一些输入后立刻返回所期望的输出。复用无状态逻辑的库有很多，比如你可能已经用过的 lodash 或是 date-fns。</p>
<p>相比之下，有状态逻辑负责管理会随时间而变化的状态。一个简单的例子是跟踪当前鼠标在页面中的位置。在实际应用中，也可能是像触摸手势或与数据库的连接状态这样的更复杂的逻辑。</p>
<p>如果我们要直接在组件中使用组合式 API 实现鼠标跟踪功能，它会是这样的：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, onMounted, onUnmounted } from 'vue'

const x = ref(0)
const y = ref(0)

function update(event) {
  x.value = event.pageX
  y.value = event.pageY
}

onMounted(() =&gt; window.addEventListener('mousemove', update))
onUnmounted(() =&gt; window.removeEventListener('mousemove', update))
&lt;/script&gt;

&lt;template&gt;Mouse position is at: { { x } }, { { y } }&lt;/template&gt;
</code></pre>
<p>但是，如果我们想在多个组件中复用这个相同的逻辑呢？我们可以把这个逻辑以一个组合式函数的形式提取到外部文件中：</p>
<pre><code class="language-js">// mouse.js
import { ref, onMounted, onUnmounted } from 'vue'

// 按照惯例，组合式函数名以“use”开头
export function useMouse() {
  // 被组合式函数封装和管理的状态
  const x = ref(0)
  const y = ref(0)

  // 组合式函数可以随时更改其状态。
  function update(event) {
    x.value = event.pageX
    y.value = event.pageY
  }

  // 一个组合式函数也可以挂靠在所属组件的生命周期上
  // 来启动和卸载副作用
  onMounted(() =&gt; window.addEventListener('mousemove', update))
  onUnmounted(() =&gt; window.removeEventListener('mousemove', update))

  // 通过返回值暴露所管理的状态
  return { x, y }
}
</code></pre>
<p>下面是它在组件中使用的方式：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { useMouse } from './mouse.js'

const { x, y } = useMouse()
&lt;/script&gt;

&lt;template&gt;Mouse position is at: { { x } }, { { y } }&lt;/template&gt;
</code></pre>
<p>如你所见，核心逻辑完全一致，我们做的只是把它移到一个外部函数中去，并返回需要暴露的状态。和在组件中一样，你也可以在组合式函数中使用所有的组合式 API。现在，useMouse() 的功能可以在任何组件中轻易复用了。</p>
<p>更酷的是，你还可以嵌套多个组合式函数：一个组合式函数可以调用一个或多个其他的组合式函数。这使得我们可以像使用多个组件组合成整个应用一样，用多个较小且逻辑独立的单元来组合形成复杂的逻辑。实际上，这正是为什么我们决定将实现了这一设计模式的 API 集合命名为组合式 API。</p>
<p>举例来说，我们可以将添加和清除 DOM 事件监听器的逻辑也封装进一个组合式函数中：</p>
<pre><code class="language-js">// event.js
import { onMounted, onUnmounted } from 'vue'

export function useEventListener(target, event, callback) {
  // 如果你想的话，
  // 也可以用字符串形式的 CSS 选择器来寻找目标 DOM 元素
  onMounted(() =&gt; target.addEventListener(event, callback))
  onUnmounted(() =&gt; target.removeEventListener(event, callback))
}
</code></pre>
<p>有了它，之前的 useMouse() 组合式函数可以被简化为：</p>
<pre><code class="language-js">// mouse.js
import { ref } from 'vue'
import { useEventListener } from './event'

export function useMouse() {
  const x = ref(0)
  const y = ref(0)

  useEventListener(window, 'mousemove', (event) =&gt; {
    x.value = event.pageX
    y.value = event.pageY
  })

  return { x, y }
}
</code></pre>
<h3 id="22-异步状态示例"><a class="header" href="#22-异步状态示例">2.2 异步状态示例</a></h3>
<p>useMouse() 组合式函数没有接收任何参数，因此让我们再来看一个需要接收一个参数的组合式函数示例。在做异步数据请求时，我们常常需要处理不同的状态：加载中、加载成功和加载失败。</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref } from 'vue'

const data = ref(null)
const error = ref(null)

fetch('...')
  .then((res) =&gt; res.json())
  .then((json) =&gt; (data.value = json))
  .catch((err) =&gt; (error.value = err))
&lt;/script&gt;

&lt;template&gt;
  &lt;div v-if=&quot;error&quot;&gt;Oops! Error encountered: { { error.message } }&lt;/div&gt;
  &lt;div v-else-if=&quot;data&quot;&gt;
    Data loaded:
    &lt;pre&gt;{ { data } }&lt;/pre&gt;
  &lt;/div&gt;
  &lt;div v-else&gt;Loading...&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>如果在每个需要获取数据的组件中都要重复这种模式，那就太繁琐了。让我们把它抽取成一个组合式函数：</p>
<pre><code class="language-js">// fetch.js
import { ref } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)

  fetch(url)
    .then((res) =&gt; res.json())
    .then((json) =&gt; (data.value = json))
    .catch((err) =&gt; (error.value = err))

  return { data, error }
}
</code></pre>
<p>现在我们在组件里只需要：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { useFetch } from './fetch.js'

const { data, error } = useFetch('...')
&lt;/script&gt;
</code></pre>
<p>useFetch() 接收一个静态的 URL 字符串作为输入，所以它只执行一次请求，然后就完成了。但如果我们想让它在每次 URL 变化时都重新请求呢？那我们可以让它同时允许接收 ref 作为参数：</p>
<pre><code class="language-js">// fetch.js
import { ref, isRef, unref, watchEffect } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)

  function doFetch() {
    // 在请求之前重设状态...
    data.value = null
    error.value = null
    // unref() 解包可能为 ref 的值
    fetch(unref(url))
      .then((res) =&gt; res.json())
      .then((json) =&gt; (data.value = json))
      .catch((err) =&gt; (error.value = err))
  }

  if (isRef(url)) {
    // 若输入的 URL 是一个 ref，那么启动一个响应式的请求
    watchEffect(doFetch)
  } else {
    // 否则只请求一次
    // 避免监听器的额外开销
    doFetch()
  }

  return { data, error }
}
</code></pre>
<p>这个版本的 useFetch() 现在同时可以接收静态的 URL 字符串和 URL 字符串的 ref。当通过 isRef() 检测到 URL 是一个动态 ref 时，它会使用 watchEffect() 启动一个响应式的 effect。该 effect 会立刻执行一次，并在此过程中将 URL 的 ref 作为依赖进行跟踪。当 URL 的 ref 发生改变时，数据就会被重置，并重新请求。</p>
<h2 id="三-组合式-api-的利弊"><a class="header" href="#三-组合式-api-的利弊">三 组合式 API 的利弊</a></h2>
<h3 id="31-组合式-api-的作用"><a class="header" href="#31-组合式-api-的作用">3.1 组合式 API 的作用</a></h3>
<blockquote>
<p>更好的逻辑复用</p>
</blockquote>
<p>组合式 API 最基本的优势是它使我们能够通过组合函数来实现更加简洁高效的逻辑复用。在选项式 API 中我们主要的逻辑复用机制是 mixins，而组合式 API 解决了 mixins 的所有缺陷。</p>
<p>组合式 API 提供的逻辑复用能力孵化了一些非常棒的社区项目，比如 VueUse，一个不断成长的工具型组合式函数集合。组合式 API 还为其他第三方状态管理库与 Vue 的响应式系统之间的集成提供了一套简洁清晰的机制，例如 RxJS。</p>
<blockquote>
<p>更灵活的代码组织</p>
</blockquote>
<p>许多用户喜欢选项式 API 的原因是它在默认情况下就能够让人写出有组织的代码：大部分代码都自然地被放进了对应的选项里。然而，选项式 API 在单个组件的逻辑复杂到一定程度时，会面临一些无法忽视的限制。这些限制主要体现在需要处理多个逻辑关注点的组件中，这是我们在许多 Vue 2 的实际案例中所观察到的。</p>
<p>使用组合式 API 会让同一个逻辑关注点相关的代码被归为了一组：我们无需再为了一个逻辑关注点在不同的选项块间来回滚动切换。此外，我们现在可以很轻松地将这一组代码移动到一个外部文件中，不再需要为了抽象而重新组织代码，大大降低了重构成本，这在长期维护的大型项目中非常关键。</p>
<blockquote>
<p>更好的类型推导</p>
</blockquote>
<p>选项式 API 的类型推导在处理 mixins 和依赖注入类型时依然不甚理想。</p>
<p>因此，很多想要搭配 TS 使用 Vue 的开发者采用了由 vue-class-component 提供的 Class API。然而，基于 Class 的 API 非常依赖 ES 装饰器，在 2019 年我们开始开发 Vue 3 时，它仍是一个仅处于 stage 2 的语言功能。我们认为基于一个不稳定的语言提案去设计框架的核心 API 风险实在太大了，因此没有继续向 Class API 的方向发展。在那之后装饰器提案果然又发生了很大的变动，在 2022 年才终于到达 stage 3。另一个问题是，基于 Class 的 API 和选项式 API 在逻辑复用和代码组织方面存在相同的限制。</p>
<p>相比之下，组合式 API 主要利用基本的变量和函数，它们本身就是类型友好的。用组合式 API 重写的代码可以享受到完整的类型推导，不需要书写太多类型标注。大多数时候，用 TypeScript 书写的组合式 API 代码和用 JavaScript 写都差不太多！这也让许多纯 JavaScript 用户也能从 IDE 中享受到部分类型推导功能。</p>
<blockquote>
<p>更小的生产包体积</p>
</blockquote>
<p>搭配 <code>&lt;script setup&gt;</code> 使用组合式 API 比等价情况下的选项式 API 更高效，对代码压缩也更友好。这是由于 <code>&lt;script setup&gt;</code> 形式书写的组件模板被编译为了一个内联函数，和 <code>&lt;script setup&gt;</code> 中的代码位于同一作用域。不像选项式 API 需要依赖 this 上下文对象访问属性，被编译的模板可以直接访问 <code>&lt;script setup&gt;</code> 中定义的变量，无需从实例中代理。这对代码压缩更友好，因为本地变量的名字可以被压缩，但对象的属性名则不能</p>
<h3 id="32-与选项式-api-的关系"><a class="header" href="#32-与选项式-api-的关系">3.2 与选项式 API 的关系</a></h3>
<blockquote>
<p>取舍</p>
</blockquote>
<p>一些从选项式 API 迁移来的用户发现，他们的组合式 API 代码缺乏组织性，并得出了组合式 API 在代码组织方面“更糟糕”的结论。我们建议持有这类观点的用户换个角度思考这个问题。</p>
<p>组合式 API 不像选项式 API 那样会手把手教你该把代码放在哪里。但反过来，它却让你可以像编写普通的 JavaScript 那样来编写组件代码。这意味着你能够，并且应该在写组合式 API 的代码时也运用上所有普通 JavaScript 代码组织的最佳实践。如果你可以编写组织良好的 JavaScript，你也应该有能力编写组织良好的组合式 API 代码。</p>
<p>选项式 API 确实允许你在编写组件代码时“少思考”，这是许多用户喜欢它的原因。然而，在减少费神思考的同时，它也将你锁定在规定的代码组织模式中，没有摆脱的余地，这会导致在更大规模的项目中难以进行重构或提高代码质量。在这方面，组合式 API 提供了更好的长期可维护性。</p>
<blockquote>
<p>组合式 API 能覆盖所有场景</p>
</blockquote>
<p>组合式 API 能够覆盖所有状态逻辑方面的需求。除此之外，只需要用到一小部分选项：props，emits，name 和 inheritAttrs。如果使用 <code>&lt;script setup&gt;</code>，那么 inheritAttrs 应该是唯一一个需要用额外的 <code>&lt;script&gt;</code> 块书写的选项了。</p>
<p>如果你在代码中只使用了组合式 API (以及上述必需的选项)，那么你可以通过配置编译时标记来去掉 Vue 运行时中针对选项式 API 支持的代码，从而减小生产包大概几 kb 左右的体积。注意这个配置也会影响你依赖中的 Vue 组件。</p>
<h3 id="33-与-class-api-的关系"><a class="header" href="#33-与-class-api-的关系">3.3 与 Class API 的关系</a></h3>
<p>我们不再推荐在 Vue 3 中使用 Class API，因为组合式 API 提供了很好的 TypeScript 集成，并具有额外的逻辑重用和代码组织优势</p>
<h3 id="34-react-hooks-的对比"><a class="header" href="#34-react-hooks-的对比">3.4 React Hooks 的对比</a></h3>
<p>组合式 API 提供了和 React Hooks 相同级别的逻辑组织能力，但它们之间有着一些重要的区别。</p>
<p>React Hooks 在组件每次更新时都会重新调用。这就产生了一些即使是经验丰富的 React 开发者也会感到困惑的问题。这也带来了一些性能问题，并且相当影响开发体验。例如：</p>
<ul>
<li>Hooks 有严格的调用顺序，并不可以写在条件分支中。</li>
<li>React 组件中定义的变量会被一个钩子函数闭包捕获，若开发者传递了错误的依赖数组，它会变得“过期”。这导致了 React 开发者非常依赖 ESLint 规则以确保传递了正确的依赖，然而，这些规则往往不够智能，保持正确的代价过高，在一些边缘情况时会遇到令人头疼的、不必要的报错信息。</li>
<li>昂贵的计算需要使用 useMemo，这也需要传入正确的依赖数组。</li>
<li>在默认情况下，传递给子组件的事件处理函数会导致子组件进行不必要的更新。子组件默认更新，并需要显式的调用 useCallback 作优化。这个优化同样需要正确的依赖数组，并且几乎在任何时候都需要。忽视这一点会导致默认情况下对应用进行过度渲染，并可能在不知不觉中导致性能问题。</li>
<li>要解决变量闭包导致的问题，再结合并发功能，使得很难推理出一段钩子代码是什么时候运行的，并且很不好处理需要在多次渲染间保持引用 (通过 useRef) 的可变状态。</li>
</ul>
<p>相比起来，Vue 的组合式 API：</p>
<ul>
<li>仅调用 setup() 或 <code>&lt;script setup&gt;</code> 的代码一次。这使得代码更符合日常 JavaScript 的直觉，不需要担心闭包变量的问题。组合式 API 也并不限制调用顺序，还可以有条件地进行调用。</li>
<li>Vue 的响应性系统运行时会自动收集计算属性和侦听器的依赖，因此无需手动声明依赖。</li>
<li>无需手动缓存回调函数来避免不必要的组件更新。Vue 细粒度的响应性系统能够确保在绝大部分情况下组件仅执行必要的更新。对 Vue 开发者来说几乎不怎么需要对子组件更新进行手动优化。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="082-组合式-api-最佳实践"><a class="header" href="#082-组合式-api-最佳实践">08.2-组合式 API-最佳实践</a></h1>
<h2 id="一-约定与最佳实践"><a class="header" href="#一-约定与最佳实践">一 约定与最佳实践</a></h2>
<h3 id="11-命名"><a class="header" href="#11-命名">1.1 命名</a></h3>
<p>组合式函数约定用驼峰命名法命名，并以“use”作为开头。</p>
<h3 id="12-输入参数"><a class="header" href="#12-输入参数">1.2 输入参数</a></h3>
<p>尽管其响应性不依赖 ref，组合式函数仍可接收 ref 参数。如果编写的组合式函数会被其他开发者使用，你最好在处理输入参数时兼容 ref 而不只是原始的值。unref() 工具函数会对此非常有帮助：</p>
<pre><code class="language-js">import { unref } from 'vue'

function useFeature(maybeRef) {
  // 若 maybeRef 确实是一个 ref，它的 .value 会被返回
  // 否则，maybeRef 会被原样返回
  const value = unref(maybeRef)
}
</code></pre>
<p>如果你的组合式函数在接收 ref 为参数时会产生响应式 effect，请确保使用 watch() 显式地监听此 ref，或者在 watchEffect() 中调用 unref() 来进行正确的追踪。</p>
<h3 id="13-返回值"><a class="header" href="#13-返回值">1.3 返回值</a></h3>
<p>你可能已经注意到了，我们一直在组合式函数中使用 ref() 而不是 reactive()。我们推荐的约定是组合式函数始终返回一个包含多个 ref 的普通的非响应式对象，这样该对象在组件中被解构为 ref 之后仍可以保持响应性：</p>
<pre><code class="language-js">// x 和 y 是两个 ref
const { x, y } = useMouse()
</code></pre>
<p>从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。与之相反，ref 则可以维持这一响应性连接。</p>
<p>如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用 reactive() 包装一次，这样其中的 ref 会被自动解包，例如：</p>
<pre><code class="language-js">const mouse = reactive(useMouse())
// mouse.x 链接到了原来的 x ref
console.log(mouse.x)
</code></pre>
<h3 id="14-副作用"><a class="header" href="#14-副作用">1.4 副作用</a></h3>
<p>在组合式函数中的确可以执行副作用 (例如：添加 DOM 事件监听器或者请求数据)，但请注意以下规则：</p>
<ul>
<li>如果你的应用用到了服务端渲染 (SSR)，请确保在组件挂载后才调用的生命周期钩子中执行 DOM 相关的副作用，例如：onMounted()。这些钩子仅会在浏览器中被调用，因此可以确保能访问到 DOM。</li>
<li>确保在 onUnmounted() 时清理副作用。举例来说，如果一个组合式函数设置了一个事件监听器，它就应该在 onUnmounted() 中被移除 (就像我们在 useMouse() 示例中看到的一样)。当然也可以像之前的 useEventListener() 示例那样，使用一个组合式函数来自动帮你做这些事。</li>
</ul>
<h3 id="15-使用限制"><a class="header" href="#15-使用限制">1.5 使用限制</a></h3>
<p>组合式函数在 <code>&lt;script setup&gt;</code> 或 <code>setup()</code> 钩子中，应始终被同步地调用。在某些场景下，你也可以在像 onMounted() 这样的生命周期钩子中使用他们。</p>
<p>这个限制是为了让 Vue 能够确定当前正在被执行的到底是哪个组件实例，只有能确认当前组件实例，才能够：</p>
<ul>
<li>将生命周期钩子注册到该组件实例上</li>
<li>将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。</li>
</ul>
<h2 id="二-通过抽取组合式函数改善代码结构"><a class="header" href="#二-通过抽取组合式函数改善代码结构">二 通过抽取组合式函数改善代码结构</a></h2>
<p>抽取组合式函数不仅是为了复用，也是为了代码组织。随着组件复杂度的增高，你可能会最终发现组件多得难以查询和理解。组合式 API 会给予你足够的灵活性，让你可以基于逻辑问题将组件代码拆分成更小的函数：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { useFeatureA } from './featureA.js'
import { useFeatureB } from './featureB.js'
import { useFeatureC } from './featureC.js'

const { foo, bar } = useFeatureA()
const { baz } = useFeatureB(foo)
const { qux } = useFeatureC(baz)
&lt;/script&gt;
</code></pre>
<h2 id="三-在选项式-api-中使用组合式函数"><a class="header" href="#三-在选项式-api-中使用组合式函数">三 在选项式 API 中使用组合式函数</a></h2>
<p>如果你正在使用选项式 API，组合式函数必须在 setup() 中调用。且其返回的绑定必须在 setup() 中返回，以便暴露给 this 及其模板：</p>
<pre><code class="language-js">import { useMouse } from './mouse.js'
import { useFetch } from './fetch.js'

export default {
  setup() {
    const { x, y } = useMouse()
    const { data, error } = useFetch('...')
    return { x, y, data, error }
  },
  mounted() {
    // setup() 暴露的属性可以在通过 `this` 访问到
    console.log(this.x)
  },
  // ...其他选项
}
</code></pre>
<h2 id="四-与其他模式比较"><a class="header" href="#四-与其他模式比较">四 与其他模式比较</a></h2>
<h3 id="41-与-mixin-对比"><a class="header" href="#41-与-mixin-对比">4.1 与 Mixin 对比</a></h3>
<p>Vue 2 的用户可能会对 mixins 选项比较熟悉。它也让我们能够把组件逻辑提取到可复用的单元里。然而 mixins 有三个主要的短板：</p>
<p>不清晰的数据来源：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。这也是我们推荐在组合式函数中使用 ref + 解构模式的理由：让属性的来源在消费组件时一目了然。</p>
<p>命名空间冲突：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。若使用组合式函数，你可以通过在解构变量时对变量进行重命名来避免相同的键名。</p>
<p>隐式的跨 mixin 交流：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。</p>
<p>基于上述理由，我们不再推荐在 Vue 3 中继续使用 mixin。保留该功能只是为了项目迁移的需求和照顾熟悉它的用户。</p>
<h3 id="42-和无渲染组件的对比"><a class="header" href="#42-和无渲染组件的对比">4.2 和无渲染组件的对比#</a></h3>
<p>在组件插槽一章中，我们讨论过了基于作用域插槽的无渲染组件。我们甚至用它实现了一样的鼠标追踪器示例。</p>
<p>组合式函数相对于无渲染组件的主要优势是：组合式函数不会产生额外的组件实例开销。当在整个应用中使用时，由无渲染组件产生的额外组件实例会带来无法忽视的性能开销。</p>
<p>我们推荐在纯逻辑复用时使用组合式函数，在需要同时复用逻辑和视图布局时使用无渲染组件</p>
<h3 id="43-和-react-hooks-的对比"><a class="header" href="#43-和-react-hooks-的对比">4.3 和 React Hooks 的对比</a></h3>
<p>如果你有 React 的开发经验，你可能注意到组合式函数和自定义 React hooks 非常相似。组合式 API 的一部分灵感正来自于 React hooks，Vue 的组合式函数也的确在逻辑组合能力上与 React hooks 相近。然而，Vue 的组合式函数是基于 Vue 细粒度的响应性系统，这和 React hooks 的执行模型有本质上的不同。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="083-组合式-api-常见组合式-api-原理"><a class="header" href="#083-组合式-api-常见组合式-api-原理">08.3-组合式 API-常见组合式 API 原理</a></h1>
<h2 id="一-shallowreactiveshallowref"><a class="header" href="#一-shallowreactiveshallowref">一 shallowReactive()、shallowRef()</a></h2>
<h3 id="11-shallowreactiveshallowref的使用"><a class="header" href="#11-shallowreactiveshallowref的使用">1.1 shallowReactive()、shallowRef()的使用</a></h3>
<p><code>shallowRef()</code> 只用来实现基本数据类型的响应式，当参数为引用类型则无法实现响应式。应用场景：对象数据在后续使用中不会修改器属性，而是产生新对象来替换。</p>
<p><code>shallowReactive()</code> 只用来保障对象的最外层实现响应式，深层次的对象成员不会被实现响应式。应用场景：应用只有外层属性变化的结构较深的引用类型数据。</p>
<p>浅劫持存在的原因：reactive 内部需要使用递归对嵌套结构的数据进行层层包装为 Proxy 对象，这会造成性能问题，<code>shallowReactive()</code>、<code>shallowRef()</code>是非递归的。</p>
<p>贴士：shallowRef() 创建的监听数据，同样监听的是 .value 的变化，value 才是第一层。</p>
<h3 id="12-实现-shallowreative-reactive"><a class="header" href="#12-实现-shallowreative-reactive">1.2 实现 shallowReative() reactive()</a></h3>
<p>shallowReative() 是最简单的响应式函数，因为其无需递归响应，且参数为对象：</p>
<pre><code class="language-js">function shallowReactive(target) {
    let flag = target &amp;&amp; typeof target === 'object'
    if (!flag) {
        // 基本类型可以直接 return
        return
    }

    return new Proxy(target, reactiveHandler)
}

const reactiveHandler = {
    get(target, prop) {
        return Reflect.get(target, prop)
    },
    set(target, prop, value) {
        return Reflect.set(target, prop, value)
    },
    deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop)
    },
}

function reactive(target) {
    if (Array.isArray(target)) {
        target.forEach((item, index) =&gt; {
            target[index] = reactive(item)
        })
    } else {
        Object.keys(target).forEach((key) =&gt; {
            target[key] = reactive(target[key])
        })
    }

    return new Proxy(target, reactiveHandler)
}
</code></pre>
<h2 id="二-toref-torefs-实现返回值响应式"><a class="header" href="#二-toref-torefs-实现返回值响应式">二 toRef() toRefs() 实现返回值响应式</a></h2>
<h3 id="21-toref"><a class="header" href="#21-toref">2.1 toRef()</a></h3>
<p>如下场景的响应式是无法实现的，需要借助 toRef()：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;h1&gt;{ { age } }&lt;/h1&gt;
    &lt;h1&gt;{ { id } }&lt;/h1&gt;
    &lt;button @click=&quot;updObj&quot;&gt;changeObj&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
    import { reactive, toRef } from 'vue'
    export default {
        name: 'HelloWorld',
        setup() {
            let obj = reactive({
                name: 'zs',
                age: 10,
                p: {
                    id: 1,
                },
            })

            function updObj() {
                obj.value.age++
                obj.value.p.id++
            }

            // 这里返回的是普通字符串，而不是响应式数据
            //   return {
            //     obj.value.age,
            //     obj.value.p.id,
            //   }

            // 不嫩使用 ref(obj.age),在响应式关系中，如果是用户修改了界面，被响应的数据是 age，而不是 obj,age
            // toRef() 是引用，ref() 是引用
            const age = toRef(obj, 'age')
            const id = toRef(obj.p, 'id')
            return {
                age,
                id,
            }
        },
    }
&lt;/script&gt;
</code></pre>
<p>toRef() 用于创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。一般使用场景为：要将响应式对象中的某个属性单独提供给外部使用时才会使用到 toRef()。</p>
<h3 id="22-torefs"><a class="header" href="#22-torefs">2.2 toRefs()</a></h3>
<p>toRefs() 用于引用多个属性：</p>
<pre><code class="language-js">setup(){

    // ,,,

    return {
        ...toRefs(obj)
    }
}
</code></pre>
<h2 id="三-只读-readonlyshallowreadonly"><a class="header" href="#三-只读-readonlyshallowreadonly">三 只读 readonly()、shallowReadonly()</a></h2>
<p>readonly()、shallowReadonly() 函数均接收一个响应式数据，返回一个新的数据：</p>
<pre><code class="language-js">let p = reactive({ age: 10, name: 'zs' })

p = readonly(p)
</code></pre>
<p>经过 readonly() 加工的响应式数据是只读的，shallowReadonly() 只会加工对象的最外层。</p>
<h2 id="四-torawmarkrow-转变响应式数据为普通对象"><a class="header" href="#四-torawmarkrow-转变响应式数据为普通对象">四 toRaw()、markRow() 转变响应式数据为普通对象</a></h2>
<p>toRow()：将 reactive() 生成的响应式对象转化为普通对象。一般用于操作数据时不想造成页面更新的场景。</p>
<p>markRow()：标记一个对象，使其永远不会成为响应式对象。一般用于一些复杂的第三方库、渲染不可变数据源的大列表。</p>
<h2 id="五-customref-显式控制-ref"><a class="header" href="#五-customref-显式控制-ref">五 customRef() 显式控制 ref</a></h2>
<p><code>customRef()</code> 用于创建一个自定义 ref，并对其依赖项进行跟踪，以及对其更新触发进行显式控制。</p>
<p>实现防抖效果：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; /&gt;
    &lt;h3&gt;{ {keyword} }&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
    import { ref, customRef } from 'vue'
    export default {
        name: 'Demo',
        setyp() {
            // let keyword = ref('hello')
            function myRef(val, delay = 300) {
                let timer
                return customRef((track, trigger) =&gt; {
                    return {
                        get() {
                            track()
                            return val
                        },
                        set(newVal) {
                            clearTimeout(timer)
                            timer = setTimeout(() =&gt; {
                                val = newVal
                                trigger()
                            }, delay)
                        },
                    }
                })
            }

            // 自定义 myRef
            let keyword = myRef('hello')
            return { keyword }
        },
    }
&lt;/script&gt;
</code></pre>
<h2 id="六-响应式数据判断"><a class="header" href="#六-响应式数据判断">六 响应式数据判断</a></h2>
<ul>
<li>isRef()：检查值是否由 ref() 创建</li>
<li>isReactive()：检查对象是否由 reactive() 创建</li>
<li>isReadonly()：检查对象是否由 readonly() 创建</li>
<li>isProxy()：检查对象是否由 readonly()/readonly() 创建</li>
</ul>
<h2 id="七-自定义-hook-函数"><a class="header" href="#七-自定义-hook-函数">七 自定义 hook 函数</a></h2>
<p>vue3 的组合 api 可以封装为复杂的可复用的功能函数，类似 vue2 中的 mixin，但是更加清晰：</p>
<pre><code class="language-js">// 新建一个 hook 文件夹，内部创建多个 hookapi 文件，如下示例
import { ref, onMounted, onUnmounted } from 'vue'

export default function useShowMousePosition() {
  const x = ref(-1)
  const y = ref(-1)

  const run = (e: MouseEvent) =&gt; {
    x.value = e.pageX
    y.value = e.pageY
  }

  onMounted(() =&gt; {
    document.addEventListener('click', updPos)
  })

  onUnMounted(() =&gt; {
    document.addEventListener('click', updPos)
  })
}

// 业务代码中使用
export default {
  name: 'HelloWorld',
  setup() {
    const { x, y } = useMousePosition()
  },
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="091-路由-前端路由"><a class="header" href="#091-路由-前端路由">09.1-路由-前端路由</a></h1>
<h2 id="一-vue-router-简介"><a class="header" href="#一-vue-router-简介">一 vue-router 简介</a></h2>
<p>在后端中，路由的概念是：一个路由对应着一个接口，根据路由的不同，返回不同的响应数据。</p>
<p>前端路由的概念是依据 url 的不同，分配不同的界面组件。</p>
<p>Vue 中实现前端路由的模块是：vue-router，通过管理 url，实现组件与 url 的对应，通过 url 进行组件之间的切换。其本质是：用户事件与事件处理函数之间的对应关系！</p>
<p>vue-router 是独立于 vue 的一个库，所以在引入 vue 之后，还需要额外引入该库才能使用，但是使用 Vue-Router 的项目已经具备了工程化的概念，推荐直接采用 vue-cli 构建工具初始化项目。</p>
<p>vue-router 实现的原理简单示例：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref, computed } from 'vue'
import Home from './Home.vue'
import About from './About.vue'
import NotFound from './NotFound.vue'
const routes = {
  '/': Home,
  '/about': About,
}
const currentPath = ref(window.location.hash)
window.addEventListener('hashchange', () =&gt; {
  currentPath.value = window.location.hash
})
const currentView = computed(() =&gt; {
  return routes[currentPath.value.slice(1) || '/'] || NotFound
})
&lt;/script&gt;
&lt;template&gt;
  &lt;a href=&quot;#/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;#/about&quot;&gt;About&lt;/a&gt; |
  &lt;a href=&quot;#/non-existent-path&quot;&gt;Broken Link&lt;/a&gt;
  &lt;component :is=&quot;currentView&quot; /&gt;
&lt;/template&gt;
</code></pre>
<h2 id="二-vue-router-使用示例"><a class="header" href="#二-vue-router-使用示例">二 vue-router 使用示例</a></h2>
<h3 id="21-routerjs"><a class="header" href="#21-routerjs">2.1 router.js</a></h3>
<p>由于一个项目路由众多，推荐对路由进行集中管理。创建路由管理文件 <code>src/router/router.js</code>：</p>
<pre><code class="language-js">import Vue from 'vue'
import VueRouter from 'vue-router'

import Home from '@/views/Home.vue'

// 启用路由
Vue.use(VueRouter)

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home,
  },
  {
    path: '/about',
    name: 'About',
    component: () =&gt; import('../views/About.vue'),
  },
]

const router = new VueRouter({
  mode: 'history',
  routes,
})

export default router
</code></pre>
<p>Home 与 About 是自定义的两个组件。</p>
<h3 id="22-mainjs"><a class="header" href="#22-mainjs">2.2 main.js</a></h3>
<p>创建完路由映射晚间后，需要在 main.js 中使用该路由文件：</p>
<pre><code class="language-js">import Vue from 'vue'
import App from './App.vue'
import router from './router/router'

Vue.config.productionTip = false

new Vue({
  router,
  store,
  render: (h) =&gt; h(App),
}).$mount('#app')
</code></pre>
<h3 id="22-appvue"><a class="header" href="#22-appvue">2.2 App.vue</a></h3>
<p>App.vue 是整个项目的根组件，界面的内容在此显示，引入路由后，需要利用标签 <code>&lt;router-view&gt;</code> 进行显示：</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{ {msg} }&lt;/p&gt;
    &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;
    &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  data(){
    return {
      msg: &quot;hello world&quot;
    }
  }
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;
</code></pre>
<p><code>router-view</code> 是 vue-router 提供的页面显示区域，<code>router-link</code>是 vue-router 提供的链接导航。</p>
<h3 id="23-访问项目"><a class="header" href="#23-访问项目">2.3 访问项目</a></h3>
<p>在 <code>npm run serve</code>后就可以访问项目了，默认地址为：<a href="http://localhost:8080/home">http://localhost:8080/home</a></p>
<h2 id="三-vue-路由原理"><a class="header" href="#三-vue-路由原理">三 vue 路由原理</a></h2>
<p>vue 的路由中无论是哈希模式还是历史模式都可以不制造页面刷新。</p>
<p>哈希路由原理：</p>
<pre><code class="language-js">location.hash = 'about' // 地址为： /#/about
location.hash = 'news' // 地址为： /#/news
</code></pre>
<p>历史路由原理 (栈结构)：</p>
<pre><code class="language-js">location.pushState({}, '', 'about') // 地址为： /about
location.pushState({}, '', 'news') // 地址为： /news
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="092-路由-vuerouter"><a class="header" href="#092-路由-vuerouter">09.2-路由-VueRouter</a></h1>
<h2 id="一-路由常见配置"><a class="header" href="#一-路由常见配置">一 路由常见配置</a></h2>
<h3 id="11-路由模式"><a class="header" href="#11-路由模式">1.1 路由模式</a></h3>
<p>路由模式有两种：</p>
<ul>
<li>hash 模式：默认的 vue 路由模式，地址为需要有#号：&quot;#/home&quot;</li>
<li>history 模式</li>
</ul>
<p>如下所示：</p>
<pre><code class="language-js">let router = new VueRouter({
  mode: 'history', // 默认是 hash，此时设置为 history 模式
  routes: [
    {
      path: '/home',
      component: Home,
    },
  ],
})
</code></pre>
<h3 id="12-路由别名"><a class="header" href="#12-路由别名">1.2 路由别名</a></h3>
<p>路由中的 name 属性是个可选项，作用是给路由起个名字。</p>
<p>name 的使用场景一：</p>
<pre><code class="language-js">let router = new VueRouter({
  routes: [
    {
      path: '/home',
      component: Home,
      name: 'Home', // 可选项
      alias: '/index', // 别名：访问/index 渲染 Home
    },
    {
      path: '*',
      redirect: { name: 'Home' },
    },
  ],
})
</code></pre>
<p>name 的使用场景二：</p>
<pre><code class="language-html">&lt;router-link :to=&quot;{name:'路由的名字'}&quot;&gt;&lt;/router-link&gt;
</code></pre>
<h3 id="13-路由重定向"><a class="header" href="#13-路由重定向">1.3 路由重定向</a></h3>
<p>重定向设置：</p>
<pre><code class="language-js">let router = new VueRouter({
  routes: [
    {
      path: '/home',
      component: Home,
      name: 'Home',
      alias: '/index',
    },
    {
      path: '*', // 配置在最后，当所有路由都未被匹配到则如何处理
      // component: Error,          // 可以直接调转到错误提示页

      // redirect 会替换掉浏览器中的地址，alias 不会
      // redirect: '/index'         // 也可以配置重定向
      // redirect: {path: '/home'} // 重定向方式二
      // redirect: {name: 'Home'}   // 重定向方式三，name 是路由的名字
      redirect: (to) =&gt; {
        // 重定向方式四，动态设置重定向的目标；
        //     console.log(to);       // to 目标路由对象，就是访问的路径的路由信息
        //     return '/home'         // return 值也可以写为  {path:} 或 {name:}

        //除了可以直接 return 重定向的路由外，还可以通过 path\hash\query 等判断，动态设置重定向的目标路由：

        if (to.path === '/123') {
          return '/home'
        } else if (to.path === '/456') {
          return { path: '/document' }
        } else {
          return { name: 'about' }
        }
      },
    },
  ],
})
</code></pre>
<h3 id="14-动态路由"><a class="header" href="#14-动态路由">1.4 动态路由</a></h3>
<p>路由中直接设定参数：</p>
<pre><code class="language-js">routes: [{ path: '/user/:uid', component: User }]
</code></pre>
<h3 id="15-router-与-route"><a class="header" href="#15-router-与-route">1.5 $router 与 $route</a></h3>
<ul>
<li><code>$router</code>：VueRouter 的实例，用于路由切换，如<code>$router.push</code></li>
<li><code>$route</code>：用于获取当前路由跳转对象中的 name、path、query、params 等</li>
</ul>
<h2 id="二-router-link"><a class="header" href="#二-router-link">二 router-link</a></h2>
<h3 id="21-router-link-的作用"><a class="header" href="#21-router-link-的作用">2.1 router-link 的作用</a></h3>
<p>采用 history 模式会带来新的问题：a 连接会引起页面刷新。vue 为了解决这个问题，提供了 router-link 标签，该标签仍然会被解析为 a 链接，但是其默认行为 (刷新页面) 被阻止了。在 hash 模式下，使用 router-link 也无需修改跳转地址为 &quot;#/home&quot;！</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;router-link to=&quot;/home&quot;&gt;显示 home&lt;/router-link&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
</code></pre>
<h3 id="22-router-link-的常见配置"><a class="header" href="#22-router-link-的常见配置">2.2 router-link 的常见配置</a></h3>
<ul>
<li>to 的书写支持多种形式：<code>:to=&quot;home&quot;</code>，<code>:to=&quot;{path: '/home'}&quot;</code></li>
<li>默认的触发组件事件是点击事件，也可以修改为别的事件：添加属性：<code>event=&quot;mouseover&quot;</code></li>
<li>添加<code>exact</code>属性会让样式渲染变为不包含形式（即精确匹配），<code>&lt;router-link to=&quot;about&quot; exact tag=&quot;li&quot;&gt; &lt;/router-link&gt;</code></li>
</ul>
<p>router-link 默认生成的是 a 标签，也可以生成 div、p 等标签，添加属性：<code>tag=&quot;div&quot;</code>，此时 div 会自动拥有监听点击事件的功能。很多导航中，使用导航标签既包含图标又包含文字，router-link 可以这样配置：</p>
<pre><code class="language-html">&lt;router-link :to=&quot;home&quot; tag=&quot;li&quot;&gt;
  &lt;i&gt;&lt;img src=&quot;&quot; /&gt;&lt;/i&gt;
  &lt;span&gt;首页&lt;/span&gt;
&lt;/router-link&gt;
</code></pre>
<h3 id="23-router-link-配置当前激活状态的-class-名"><a class="header" href="#23-router-link-配置当前激活状态的-class-名">2.3 router-link 配置当前激活状态的 class 名</a></h3>
<p>router-link 生成的 li 元素，被点击的 li 上会带有 router-link-active 的 class 属性，用来配置激活状态的样式。这个 class 名字很长可以自己配置新名字：</p>
<pre><code class="language-js">// 第一种：全局配置方式：在 router 里面修改，linkActiveClass:“” ，所有生成的元素的 router-link-active 都被修改
let router = new VueRouter({
    linkActiveClass: 'isActive',            // 此时 class 名为 isActive
})

// 第二种：局部修改：在 router-link 标签上添加属性 active-class=“” ，只支持当前组件
&lt;router-link to=&quot;/home&quot; active-class=&quot;isActive&quot;&gt;显示 home&lt;/router-link&gt;
</code></pre>
<h3 id="24-router-link-配置路由跳转模式"><a class="header" href="#24-router-link-配置路由跳转模式">2.4 router-link 配置路由跳转模式</a></h3>
<p>浏览器的历史记录以压栈的方式进行跳转，模式有：push（默认）、replace 两种，默认 push 模式点击浏览器回退按钮时，会移动栈顶指针的位置为上一个位置。</p>
<p>replace 操作则在入栈时会将原本的栈顶指针替换为要跳转的路由！配置方式：</p>
<pre><code class="language-html">&lt;router-link replace to=&quot;/user&quot;&gt;&lt;/router-link&gt;
</code></pre>
<h3 id="25-router-view-保活"><a class="header" href="#25-router-view-保活">2.5 router-view 保活</a></h3>
<p>随着路由的切换，router-view 中的组件也会随之销毁，如果被切换的组件是输入框，且已经输入了内容，切换路由后再次切换回来，之前输入框的内容就不存在了。为了解决该问题，可以使用 keep-alive：</p>
<pre><code class="language-html">&lt;!-- include 用于设置哪些组件保活，不设置该属性则 router-view 中组件全部被保活---&gt;
&lt;keep-alive include=&quot;User&quot;&gt; &lt;!-- 组件名 --&gt;
  &lt;router-view \&gt;
&lt;/keep-alive&gt;
</code></pre>
<p>缓存多个写法：<code>:include=&quot;['User', 'News']&quot;</code>。</p>
<h2 id="三-路由传参"><a class="header" href="#三-路由传参">三 路由传参</a></h2>
<h3 id="31-query-方式传参"><a class="header" href="#31-query-方式传参">3.1 query 方式传参</a></h3>
<pre><code class="language-html">&lt;!--发送方式一--&gt;
&lt;router-link :to=&quot;`/user?id=${id} }&amp;age=${age}`&quot;&gt;&lt;/router-link&gt;
&lt;!--发送方式二--&gt;
&lt;router-link :to=&quot;{path:'/user'}, query:{id: 13, age:21}&quot;&gt;&lt;/router-link&gt;

&lt;!--接收--&gt;
&lt;template&gt;
  &lt;div&gt;id={ {$router.query.id} }&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="32-params-方式传递参数"><a class="header" href="#32-params-方式传递参数">3.2 params 方式传递参数</a></h3>
<pre><code class="language-html">&lt;!---路由层级配置：动态路由--&gt;
{ path: '/user/:id/:age' }

&lt;!--发送方式一--&gt;
&lt;router-link :to=&quot;`/user/${id}/${age}`&quot;&gt;&lt;/router-link&gt;
&lt;!--发送方式二：此处只能用 name，不能用 path--&gt;
&lt;router-link
  :to=&quot;{name:'userComponent'}, params:{id: 13, age:21}&quot;
&gt;&lt;/router-link&gt;

&lt;!--接收--&gt;
&lt;template&gt;
  &lt;div&gt;id={ {$router.params.id} }&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="33-props-统一接收"><a class="header" href="#33-props-统一接收">3.3 props 统一接收</a></h3>
<p>在路由中，props 属性可以将对象中所有的 kv 都以 props 形式传递给对应配置的组件：</p>
<pre><code class="language-js">{
  name: 'father',
  path: '/user/info',
  component: Son,
  // 写法一：直接传递参数，一般不使用
  // props: {name: 1, id: 1001}

  // 写法二：此时会把路由组件收到的所有 params 参数，以 props 形式传递给 Son 组件
  // props: true

  // 写法三：返回值成为子组件的 props
  // props(){
  //   return {id: 1001, name: 'zs'}
  // }

  // 写法三：变更。不推荐
  props({$route}){
    return {id: $route.query.id}
  }
}
</code></pre>
<h2 id="四-router-view"><a class="header" href="#四-router-view">四 router-view</a></h2>
<p>router-view 是组件渲染的地方。</p>
<p><strong>同时给子组件添加相同的类名</strong>：在 router-view 标签添加 class=&quot;center&quot;，那么所有子组件渲染的时候，外层根节点标签就会自动添加 class=&quot;center&quot;；</p>
<pre><code class="language-html">&lt;!-- 配置样式 --&gt;
&lt;router-view class=&quot;center&quot;&gt;&lt;/router-view&gt;
</code></pre>
<h2 id="五-嵌套路由"><a class="header" href="#五-嵌套路由">五 嵌套路由</a></h2>
<p>路由往往有嵌套的情况，如下所示：</p>
<pre><code class="language-html">&lt;ul class=&quot;nav&quot;&gt;
  &lt;router-link to=&quot;/about&quot; tag=&quot;li&quot;&gt;
    &lt;a&gt;study&lt;/a&gt;
  &lt;/router-link&gt;

  &lt;router-link to=&quot;/about/work&quot; tag=&quot;li&quot;&gt;
    &lt;a&gt;work&lt;/a&gt;
  &lt;/router-link&gt;

  &lt;router-link to=&quot;/about/tel&quot; tag=&quot;li&quot;&gt;
    &lt;a&gt;tel&lt;/a&gt;
  &lt;/router-link&gt;
&lt;/ul&gt;
</code></pre>
<p>对应的路由控制：</p>
<pre><code class="language-js">{
    path: '/about',
    component: about,
    children: [
        {
            path: '',          // 当访问 /about 也会默认渲染 children 第一个
            component: study,
            name: about       // 父路由的 name 要放在默认的子路由上
        },
        {
            path: 'work',          // 匹配地址为： /about/work
            component: work,
            name: work
        },
        {
            path: 'tel',          // 匹配地址为： /about/tel
            component: tel,
            name: tel
        }
    ]
}
</code></pre>
<p>path 值前面添加斜杠 '/'，表示相对于根路径。</p>
<h2 id="六-编程式导航"><a class="header" href="#六-编程式导航">六 编程式导航</a></h2>
<blockquote>
<p>声明式导航：通过点击链接实现的导航，如 html 中的 <code>&lt;a&gt;&lt;/a&gt;</code> 链接，vue 中的 <code>&lt;router-link&gt;&lt;/router-link&gt;</code>
编程式导航：通过调用 JS 的 API 实现的导航，如 <code>location.href</code></p>
</blockquote>
<p><strong>router 实例提供的方法：</strong></p>
<ul>
<li>back 回退一步</li>
<li>forward 前进一步</li>
<li>go 指定 前进/回退 步数</li>
<li>push 导航到不同的 url，向 history 栈 添加一个新的记录</li>
<li>replace 导航到不同的 url，替换 history 栈 中当前记录</li>
</ul>
<pre><code class="language-html">&lt;div&gt;
  &lt;input type=&quot;button&quot; value=&quot;后退&quot; @click=&quot;backHandle&quot; /&gt;
  &lt;input type=&quot;button&quot; value=&quot;前进&quot; @click=&quot;forwardHandle&quot; /&gt;
  &lt;input type=&quot;button&quot; value=&quot;前进/后退 到指定步数&quot; @click=&quot;goHandle&quot; /&gt;
  &lt;input type=&quot;button&quot; value=&quot;控制指定的导航 push&quot; @click=&quot;pushHandle&quot; /&gt;
  &lt;input type=&quot;button&quot; value=&quot;控制指定的导航 replace&quot; @click=&quot;replaceHandle&quot; /&gt;
&lt;/div&gt;

&lt;script&gt;
  export default {
    methods: {
      backHandle() {
        this.$router.back()
      },
      forwardHandle() {
        this.$router.forward()
      },
      goHandle() {
        this.$router.go(-2) // 负数是后退，正数是前进，0 是刷新当前页面，超过步数的话没有效果；
      },
      pushHandle() {
        this.$router.push('/document') // 目标链接 -- 字符串形式
        this.$router.push({ path: '/document', query: { uid: '1' } }) // 目标链接 -- 对象形式
      },
      replaceHandle() {
        this.$router.replace('/document') // 目标链接 -- 字符串形式
        this.$router.replace({ path: '/document', query: { uid: '1' } }) // 目标链接 -- 对象形式
      },
    },
  }
&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="093-路由-路由守卫"><a class="header" href="#093-路由-路由守卫">09.3-路由-路由守卫</a></h1>
<h2 id="一-路由守卫概念"><a class="header" href="#一-路由守卫概念">一 路由守卫概念</a></h2>
<p>导航发生变化的时候，导航钩子主要用来拦截导航，让它完成跳转或取消：</p>
<ul>
<li>router 实例身上：<code>beforeEach(to, from, next)</code>、<code>afterEach;(to, from)</code></li>
<li>单个路由中：<code>beforeEnter(to, from, next)</code></li>
<li>组件内的钩子：<code>beforeRouteEnter(to, from, next)</code>、<code>beforeRouteUpdate(to, from, next)</code>、<code>beforeRouteLeave(to, from, next)</code></li>
</ul>
<p>导航钩子函数的参数：</p>
<pre><code class="language-txt">to：目标导航的路由信息对象；
from：离开的路由信息对象；
next：是否要进入导航，如果需要进入导航就执行 next();
</code></pre>
<h2 id="二-路由守卫示例"><a class="header" href="#二-路由守卫示例">二 路由守卫示例</a></h2>
<h3 id="21-router-实例上的钩子函数-beforeeach"><a class="header" href="#21-router-实例上的钩子函数-beforeeach">2.1 router 实例上的钩子函数 beforeEach()</a></h3>
<pre><code class="language-js">let router = new VueRouter()
// 只要切换不同的导航，beforeEach 这个导航钩子就会被执行
router.beforeEach((to, from, next) =&gt; {
  console.log('beforeEach')
  next()
})
</code></pre>
<p>next 里面可以接收参数：<code>next(false)</code> 用于取消导航，不会进入导航内。比如 登录功能，如果没有登录，就重定向到登录页面；</p>
<pre><code class="language-js">// 路由配置：
routes: [
  {
    path: '/user',
    component: user,
    meta: {
      // 一般用于存储组件元信息，如权限
      login: true, // 添加 login 标识
    },
  },
]

// 钩子函数判断：
router.beforeEach((to, from, next) =&gt; {
  if (to.meta.login) {
    next('/login') // 如果需要登录就进入登录页
  } else {
    next() // 如果不需要登录就进入导航页
  }
})
</code></pre>
<h3 id="22-router-实例上的钩子函数-aftereach"><a class="header" href="#22-router-实例上的钩子函数-aftereach">2.2 router 实例上的钩子函数 afterEach()</a></h3>
<p>进入导航后触发：<code>afterEach()</code>。在下列案例中，当渲染不同的导航时，页面的 title 对应的改变：</p>
<pre><code class="language-js">routes: [
  {
    path: '/user',
    component: user,
    meta: {
      title: 'user', // 添加 title 标识
    },
  },
]

// 钩子函数判断：
router.afterEach((to, from) =&gt; {
  if (to.meta.title) {
    window.document.title = to.meta.title // 如果 title 存在，就改变页面的 title 为 to.meta.title
  } else {
    window.document.title = '给个固定的 title'
  }
})

// 钩子函数内部是不能直接访问 document 的，需要通过 window 去访问，所以不能直接写成：document.title
</code></pre>
<h3 id="23-单个路由中的钩子函数-beforeenterto-from-next"><a class="header" href="#23-单个路由中的钩子函数-beforeenterto-from-next">2.3 单个路由中的钩子函数 beforeEnter(to, from, next)</a></h3>
<pre><code class="language-js">routes: [
  {
    path: '/user',
    component: user,
    beforeEnter(to, from, next) {
      // 当访问 /user 这个导航的时候，执行这个钩子函数
      console.log('beforeEnter')
      next()
    },
    meta: {
      login: true,
    },
  },
]
</code></pre>
<h3 id="24-组件内的钩子函数-beforerouteenter"><a class="header" href="#24-组件内的钩子函数-beforerouteenter">2.4 组件内的钩子函数 beforeRouteEnter()</a></h3>
<p>beforeRouteEnter 执行的时候，组件还没有创建，所以在 beforeRouteEnter 里面是不能直接用 this 来获取这个组件的数据的。</p>
<p>进入组件的时候，执行的第一个生命周期函数是 beforeCreate, 这时候其实是先执行了路由内的钩子函数，再执行组件里的钩子函数：</p>
<pre><code class="language-txt">beforeRouteEnter =&gt; beforeCreate
</code></pre>
<p>路由的钩子函数执行的时候，组件的实例还没有创建，所以 this 是 undefined。</p>
<p><strong>那么要怎么在 beforeRouteEnter 里去修改数据呢？</strong></p>
<p>可以通过 beforeRouteEnter 的参数 next(),里面传递一个回调函数，这个回调函数会在进入导航之后执行，同时这个回调函数会接收一个参数，这个参数就是当前的组件实例 vm，此时就可以获取到实例了：</p>
<pre><code class="language-html">&lt;div&gt;测试：{ {test} }&lt;/div&gt;

&lt;script&gt;
  export default {
    data() {
      return {
        test: '改变前',
      }
    },
    beforeCreate() {
      console.log('beforeCreate')
    },
    // 进入组件之前执行 beforeRouteEnter
    beforeRouteEnter(to, from, next) {
      console.log('beforeRouteEnter')
      next((vm) =&gt; {
        vm.test = '改变了'
      })
    },
  }
&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="101-内置组件-异步组件与-suspense"><a class="header" href="#101-内置组件-异步组件与-suspense">10.1-内置组件-异步组件与 Suspense</a></h1>
<h2 id="一-异步组件"><a class="header" href="#一-异步组件">一 异步组件</a></h2>
<h3 id="11-异步组件实例"><a class="header" href="#11-异步组件实例">1.1 异步组件实例</a></h3>
<p>在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能：</p>
<pre><code class="language-js">import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // ...从服务器获取组件
    resolve(/* 获取到的组件 */)
  })
})
// ... 像使用其他一般组件一样使用 `AsyncComp`
</code></pre>
<p>如你所见，defineAsyncComponent 方法接收一个返回 Promise 的加载函数。这个 Promise 的 resolve 回调方法应该在从服务器获得组件定义时调用。你也可以调用 reject(reason) 表明加载失败。</p>
<p>ES 模块动态导入也会返回一个 Promise，所以多数情况下我们会将它和 defineAsyncComponent 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：</p>
<pre><code class="language-js">import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() =&gt;
  import('./components/MyComponent.vue')
)
</code></pre>
<p>最后得到的 AsyncComp 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。</p>
<p>与普通组件一样，异步组件可以使用 app.component() 全局注册：</p>
<pre><code class="language-js">app.component(
  'MyComponent',
  defineAsyncComponent(() =&gt; import('./components/MyComponent.vue'))
)
</code></pre>
<p>也可以在局部注册组件时使用 defineAsyncComponent：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { defineAsyncComponent } from 'vue'

const AdminPage = defineAsyncComponent(() =&gt;
  import('./components/AdminPageComponent.vue')
)
&lt;/script&gt;

&lt;template&gt;
  &lt;AdminPage /&gt;
&lt;/template&gt;
</code></pre>
<h3 id="12-加载与错误状态"><a class="header" href="#12-加载与错误状态">1.2 加载与错误状态</a></h3>
<p>异步操作不可避免地会涉及到加载和错误状态，因此 defineAsyncComponent() 也支持在高级选项中处理这些状态：</p>
<pre><code class="language-js">const AsyncComp = defineAsyncComponent({
  // 加载函数
  loader: () =&gt; import('./Foo.vue'),

  // 加载异步组件时使用的组件
  loadingComponent: LoadingComponent,
  // 展示加载组件前的延迟时间，默认为 200ms
  delay: 200,

  // 加载失败后展示的组件
  errorComponent: ErrorComponent,
  // 如果提供了一个 timeout 时间限制，并超时了
  // 也会显示这里配置的报错组件，默认值是：Infinity
  timeout: 3000,
})
</code></pre>
<p>如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。</p>
<p>如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。</p>
<h2 id="二-suspense"><a class="header" href="#二-suspense">二 Suspense</a></h2>
<h3 id="21-异步依赖"><a class="header" href="#21-异步依赖">2.1 异步依赖</a></h3>
<p><code>&lt;Suspense&gt;</code> 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。</p>
<p>有这样的层级结构：</p>
<pre><code class="language-txt">&lt;Suspense&gt;
└─ &lt;Dashboard&gt;
   ├─ &lt;Profile&gt;
   │  └─ &lt;FriendStatus&gt;（组件有异步的 setup()）
   └─ &lt;Content&gt;
      ├─ &lt;ActivityFeed&gt; （异步组件）
      └─ &lt;Stats&gt;（异步组件）
</code></pre>
<p>在这个组件树中有多个嵌套组件，要渲染出它们，首先得解析一些异步资源。如果没有 <code>&lt;Suspense&gt;</code>，则它们每个都需要处理自己的加载、报错和完成状态。在最坏的情况下，我们可能会在页面上看到三个旋转的加载态，在不同的时间显示出内容。</p>
<p>有了 <code>&lt;Suspense&gt;</code> 组件后，我们就可以在等待整个多层级组件树中的各个异步依赖获取结果时，在顶层展示出加载中或加载失败的状态。</p>
<p><code>&lt;Suspense&gt;</code> 可以等待的异步依赖有两种：</p>
<ul>
<li>带有异步 setup() 钩子的组件。这也包含了使用 <code>&lt;script setup&gt;</code> 时有顶层 await 表达式的组件。</li>
<li>异步组件。</li>
</ul>
<h3 id="22-async-setup"><a class="header" href="#22-async-setup">2.2 async setup()</a></h3>
<p>组合式 API 中组件的 setup() 钩子可以是异步的：</p>
<pre><code class="language-vue">&lt;!--setup--&gt;
&lt;script setup&gt;
const res = await fetch(...)
const posts = await res.json()
&lt;/script&gt;

&lt;template&gt;
  { { posts } }
&lt;/template&gt;

&lt;!--非setup--&gt;
&lt;script&gt;
export default {
  async setup() {
    const res = await fetch(...)
    const posts = await res.json()
    return {
      posts
    }
  }
}
&lt;/script&gt;
</code></pre>
<h3 id="23-异步组件"><a class="header" href="#23-异步组件">2.3 异步组件</a></h3>
<p>异步组件默认就是“suspensible”的。这意味着如果组件关系链上有一个 <code>&lt;Suspense&gt;</code>，那么这个异步组件就会被当作这个 <code>&lt;Suspense&gt;</code> 的一个异步依赖。在这种情况下，加载状态是由 <code>&lt;Suspense&gt;</code> 控制，而该组件自己的加载、报错、延时和超时等选项都将被忽略。</p>
<p>异步组件也可以通过在选项中指定 suspensible: false 表明不用 Suspense 控制，并让组件始终自己控制其加载状态。</p>
<h3 id="24-加载中状态"><a class="header" href="#24-加载中状态">2.4 加载中状态</a></h3>
<p><code>&lt;Suspense&gt;</code> 组件有两个插槽：#default 和 #fallback。两个插槽都只允许一个直接子节点。在可能的时候都将显示默认槽中的节点。否则将显示后备槽中的节点。</p>
<pre><code class="language-vue">&lt;Suspense&gt;
  &lt;!-- 具有深层异步依赖的组件 --&gt;
  &lt;Dashboard /&gt;

  &lt;!-- 在 #fallback 插槽中显示 “正在加载中” --&gt;
  &lt;template #fallback&gt;
    Loading...
  &lt;/template&gt;
&lt;/Suspense&gt;
</code></pre>
<p>在初始渲染时，<code>&lt;Suspense&gt;</code> 将在内存中渲染其默认的插槽内容。如果在这个过程中遇到任何异步依赖，则会进入挂起状态。在挂起状态期间，展示的是后备内容。当所有遇到的异步依赖都完成后，<code>&lt;Suspense&gt;</code> 会进入完成状态，并将展示出默认插槽的内容。</p>
<p>如果在初次渲染时没有遇到异步依赖，<code>&lt;Suspense&gt;</code> 会直接进入完成状态。</p>
<p>进入完成状态后，只有当默认插槽的根节点被替换时，<code>&lt;Suspense&gt;</code>才会回到挂起状态。组件树中新的更深层次的异步依赖不会造成 <code>&lt;Suspense&gt;</code> 回退到挂起状态。</p>
<p>发生回退时，后备内容不会立即展示出来。相反，<code>&lt;Suspense&gt;</code> 在等待新内容和异步依赖完成时，会展示之前 #default 插槽的内容。这个行为可以通过一个 timeout prop 进行配置：在等待渲染新内容耗时超过 timeout 之后，<code>&lt;Suspense&gt;</code> 将会切换为展示后备内容。若 timeout 值为 0 将导致在替换默认内容时立即显示后备内容。</p>
<h3 id="25-事件"><a class="header" href="#25-事件">2.5 事件</a></h3>
<p><code>&lt;Suspense&gt;</code> 组件会触发三个事件：pending、resolve 和 fallback。pending 事件是在进入挂起状态时触发。resolve 事件是在 default 插槽完成获取新内容时触发。fallback 事件则是在 fallback 插槽的内容显示时触发。</p>
<p>例如，可以使用这些事件在加载新组件时在之前的 DOM 最上层显示一个加载指示器。</p>
<h3 id="26-错误处理"><a class="header" href="#26-错误处理">2.6 错误处理</a></h3>
<p><code>&lt;Suspense&gt;</code> 组件自身目前还不提供错误处理，不过你可以使用 errorCaptured 选项或者 onErrorCaptured() 钩子，在使用到 <code>&lt;Suspense&gt;</code> 的父组件中捕获和处理异步错误。</p>
<h3 id="27-和其他组件结合"><a class="header" href="#27-和其他组件结合">2.7 和其他组件结合</a></h3>
<p>我们常常会将 <code>&lt;Suspense&gt;</code> 和 <code>&lt;Transition&gt;</code>、<code>&lt;KeepAlive&gt;</code> 等组件结合。要保证这些组件都能正常工作，嵌套的顺序非常重要。</p>
<p>另外，这些组件都通常与 Vue Router 中的 <code>&lt;RouterView&gt;</code> 组件结合使用。</p>
<p>下面的示例展示了如何嵌套这些组件，使它们都能按照预期的方式运行。若想组合得更简单，你也可以删除一些你不需要的组件：</p>
<pre><code class="language-vue">&lt;RouterView v-slot=&quot;{ Component }&quot;&gt;
  &lt;template v-if=&quot;Component&quot;&gt;
    &lt;Transition mode=&quot;out-in&quot;&gt;
      &lt;KeepAlive&gt;
        &lt;Suspense&gt;
          &lt;!-- 主要内容 --&gt;
          &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt;

          &lt;!-- 加载中状态 --&gt;
          &lt;template #fallback&gt;
            正在加载...
          &lt;/template&gt;
        &lt;/Suspense&gt;
      &lt;/KeepAlive&gt;
    &lt;/Transition&gt;
  &lt;/template&gt;
&lt;/RouterView&gt;
</code></pre>
<p>Vue Router 使用动态导入对懒加载组件进行了内置支持。这些与异步组件不同，目前他们不会触发 <code>&lt;Suspense&gt;</code>。但是，它们仍然可以有异步组件作为后代，这些组件可以照常触发 <code>&lt;Suspense&gt;</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="102-内置组件-keepalive"><a class="header" href="#102-内置组件-keepalive">10.2-内置组件-KeepAlive</a></h1>
<h2 id="一-keepalive-基本使用"><a class="header" href="#一-keepalive-基本使用">一 KeepAlive 基本使用</a></h2>
<p><code>&lt;KeepAlive&gt;</code> 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</p>
<p>过特殊的 <code>&lt;component&gt;</code> 元素可以实现动态组件的用法：</p>
<pre><code class="language-vue">&lt;component :is=&quot;activeComponent&quot; /&gt;
</code></pre>
<p>默认情况下，一个组件实例在被替换掉后会被销毁。这会导致它丢失其中所有已变化的状态——当这个组件再一次被显示时，会创建一个只带有初始状态的新实例。</p>
<p>在下面的例子中，你会看到两个有状态的组件——A 有一个计数器，而 B 有一个通过 v-model 同步 input 框输入内容的文字展示。尝试先更改一下任意一个组件的状态，然后切走，再切回来。</p>
<p>父组件：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;true&quot; /&gt;
  A
  &lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;false&quot; /&gt;
  B
  &lt;div&gt;Current component: { { pick === true ? 'A' : 'B' } }&lt;/div&gt;
  &lt;CompA v-if=&quot;pick&quot;&gt;&lt;/CompA&gt;
  &lt;CompB v-if=&quot;!pick&quot;&gt;&lt;/CompB&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot; setup&gt;
import { ref } from 'vue'
import CompA from '@/components/CompA.vue'
import CompB from '@/components/CompB.vue'

const pick = ref(true)
&lt;/script&gt;
</code></pre>
<p>子组件 A：</p>
<pre><code class="language-vue">&lt;template&gt;
  count: { { count } }
  &lt;button @click=&quot;changeNum&quot;&gt;+&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot; setup&gt;
import { ref } from 'vue'

const count = ref(0)

const changeNum = () =&gt; {
  count.value++
}
&lt;/script&gt;
</code></pre>
<p>子组件 B：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;msg is:&lt;input v-model=&quot;msg&quot; /&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot; setup&gt;
import { ref } from 'vue'

const msg = ref('')
&lt;/script&gt;
</code></pre>
<p>在切回来之后，之前已更改的状态都被重置了。</p>
<p>在切换时创建新的组件实例通常是有意义的，但在这个例子中，我们的确想要组件能在被“切走”的时候保留它们的状态。要解决这个问题，我们可以用 <KeepAlive> 内置组件将这些动态组件包装起来：</p>
<pre><code class="language-vue">&lt;!-- 非活跃的组件将会被缓存！ --&gt;
&lt;KeepAlive&gt;
  &lt;component :is=&quot;activeComponent&quot; /&gt;
&lt;/KeepAlive&gt;
</code></pre>
<h2 id="二-包含与排除"><a class="header" href="#二-包含与排除">二 包含与排除</a></h2>
<p><code>&lt;KeepAlive&gt;</code> 默认会缓存内部的所有组件实例，但我们可以通过 include 和 exclude prop 来定制该行为。这两个 prop 的值都可以是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两种类型的一个数组：</p>
<pre><code class="language-vue">&lt;!-- 以英文逗号分隔的字符串 --&gt;
&lt;KeepAlive include=&quot;a,b&quot;&gt;
  &lt;component :is=&quot;view&quot; /&gt;
&lt;/KeepAlive&gt;

&lt;!-- 正则表达式 (需使用 `v-bind`) --&gt;
&lt;KeepAlive :include=&quot;/a|b/&quot;&gt;
  &lt;component :is=&quot;view&quot; /&gt;
&lt;/KeepAlive&gt;

&lt;!-- 数组 (需使用 `v-bind`) --&gt;
&lt;KeepAlive :include=&quot;['a', 'b']&quot;&gt;
  &lt;component :is=&quot;view&quot; /&gt;
&lt;/KeepAlive&gt;
</code></pre>
<p>它会根据组件的 name 选项进行匹配，所以组件如果想要条件性地被 KeepAlive 缓存，就必须显式声明一个 name 选项。</p>
<h2 id="三-最大缓存实例数"><a class="header" href="#三-最大缓存实例数">三 最大缓存实例数#</a></h2>
<p>我们可以通过传入 max prop 来限制可被缓存的最大组件实例数。<code>&lt;KeepAlive&gt;</code> 的行为在指定了 max 后类似一个 LRU 缓存：如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。</p>
<pre><code class="language-vue">&lt;KeepAlive :max=&quot;10&quot;&gt;
  &lt;component :is=&quot;activeComponent&quot; /&gt;
&lt;/KeepAlive&gt;
</code></pre>
<h2 id="四-缓存实例的生命周期"><a class="header" href="#四-缓存实例的生命周期">四 缓存实例的生命周期</a></h2>
<p>当一个组件实例从 DOM 上移除但因为被 <code>&lt;KeepAlive&gt;</code> 缓存而仍作为组件树的一部分时，它将变为不活跃状态而不是被卸载。当一个组件实例作为缓存树的一部分插入到 DOM 中时，它将重新被激活。</p>
<p>一个持续存在的组件可以通过 onActivated() 和 onDeactivated() 注册相应的两个状态的生命周期钩子：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { onActivated, onDeactivated } from 'vue'

onActivated(() =&gt; {
  // 调用时机为首次挂载
  // 以及每次从缓存中被重新插入时
})

onDeactivated(() =&gt; {
  // 在从 DOM 上移除、进入缓存
  // 以及组件卸载时调用
})
&lt;/script&gt;
</code></pre>
<p>请注意：</p>
<ul>
<li>onActivated 在组件挂载时也会调用，并且 onDeactivated 在组件卸载时也会调用。</li>
<li>这两个钩子不仅适用于 <code>&lt;KeepAlive&gt;</code> 缓存的根组件，也适用于缓存树中的后代组件。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="103-内置组件-teleport"><a class="header" href="#103-内置组件-teleport">10.3-内置组件-Teleport</a></h1>
<h2 id="一-teleport-基本用法"><a class="header" href="#一-teleport-基本用法">一 Teleport 基本用法</a></h2>
<p>Teleport 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去</p>
<p>场景：一个组件模板的一部分在逻辑上从属于该组件，但从整个应用视图的角度来看，它在 DOM 中应该被渲染在整个 Vue 应用外部的其他地方。</p>
<p>这类场景最常见的例子就是全屏的模态框。理想情况下，我们希望触发模态框的按钮和模态框本身是在同一个组件中，因为它们都与组件的开关状态有关。但这意味着该模态框将与按钮一起渲染在应用 DOM 结构里很深的地方。这会导致该模态框的 CSS 布局代码很难写。</p>
<p>试想下面这样的 HTML 结构：</p>
<pre><code class="language-html">&lt;div class=&quot;outer&quot;&gt;
  &lt;h3&gt;Tooltips with Vue 3 Teleport&lt;/h3&gt;
  &lt;div&gt;
    &lt;MyModal /&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>接下来我们来看看 <code>&lt;MyModal&gt;</code> 的实现：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref } from 'vue'

const open = ref(false)
&lt;/script&gt;

&lt;template&gt;
  &lt;button @click=&quot;open = true&quot;&gt;Open Modal&lt;/button&gt;

  &lt;div v-if=&quot;open&quot; class=&quot;modal&quot;&gt;
    &lt;p&gt;Hello from the modal!&lt;/p&gt;
    &lt;button @click=&quot;open = false&quot;&gt;Close&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
.modal {
  position: fixed;
  z-index: 999;
  top: 20%;
  left: 50%;
  width: 300px;
  margin-left: -150px;
}
&lt;/style&gt;
</code></pre>
<p>这个组件中有一个 <code>&lt;button&gt;</code> 按钮来触发打开模态框，和一个 class 名为 .modal 的 <code>&lt;div&gt;</code>，它包含了模态框的内容和一个用来关闭的按钮。</p>
<p>当在初始 HTML 结构中使用这个组件时，会有一些潜在的问题：</p>
<ul>
<li>position: fixed 能够相对于浏览器窗口放置有一个条件，那就是不能有任何祖先元素设置了 transform、perspective 或者 filter 样式属性。也就是说如果我们想要用 CSS transform 为祖先节点 <code>&lt;div class=&quot;outer&quot;&gt;</code> 设置动画，就会不小心破坏模态框的布局！</li>
<li>这个模态框的 z-index 受限于它的容器元素。如果有其他元素与 <code>&lt;div class=&quot;outer&quot;&gt;</code> 重叠并有更高的 z-index，则它会覆盖住我们的模态框。</li>
</ul>
<p><code>&lt;Teleport&gt;</code> 提供了一个更简单的方式来解决此类问题，让我们不需要再顾虑 DOM 结构的问题。让我们用 <code>&lt;Teleport&gt;</code> 改写一下 <MyModal>：</p>
<pre><code class="language-vue">&lt;button @click=&quot;open = true&quot;&gt;Open Modal&lt;/button&gt;

&lt;Teleport to=&quot;body&quot;&gt;
  &lt;div v-if=&quot;open&quot; class=&quot;modal&quot;&gt;
    &lt;p&gt;Hello from the modal!&lt;/p&gt;
    &lt;button @click=&quot;open = false&quot;&gt;Close&lt;/button&gt;
  &lt;/div&gt;
&lt;/Teleport&gt;
</code></pre>
<p><code>&lt;Teleport&gt;</code> 接收一个 to prop 来指定传送的目标。to 的值可以是一个 CSS 选择器字符串，也可以是一个 DOM 元素对象。这段代码的作用就是告诉 Vue“把以下模板片段传送到 body 标签下”。</p>
<p><code>&lt;Teleport&gt;</code> 挂载时，传送的 to 目标必须已经存在于 DOM 中。理想情况下，这应该是整个 Vue 应用 DOM 树外部的一个元素。如果目标元素也是由 Vue 渲染的，你需要确保在挂载 <code>&lt;Teleport&gt;</code> 之前先挂载该元素。</p>
<h2 id="二-搭配组件使用"><a class="header" href="#二-搭配组件使用">二 搭配组件使用#</a></h2>
<p><code>&lt;Teleport&gt;</code> 只改变了渲染的 DOM 结构，它不会影响组件间的逻辑关系。也就是说，如果 <code>&lt;Teleport&gt;</code> 包含了一个组件，那么该组件始终和这个使用了 <code>&lt;teleport&gt;</code> 的组件保持逻辑上的父子关系。传入的 props 和触发的事件也会照常工作。</p>
<p>这也意味着来自父组件的注入也会按预期工作，子组件将在 Vue Devtools 中嵌套在父级组件下面，而不是放在实际内容移动到的地方。</p>
<h2 id="三-禁用-teleport"><a class="header" href="#三-禁用-teleport">三 禁用 Teleport</a></h2>
<p>在某些场景下可能需要视情况禁用 <code>&lt;Teleport&gt;</code>。举例来说，我们想要在桌面端将一个组件当做浮层来渲染，但在移动端则当作行内组件。我们可以通过对 <code>&lt;Teleport&gt;</code> 动态地传入一个 disabled prop 来处理这两种不同情况。</p>
<pre><code class="language-vue">&lt;Teleport :disabled=&quot;isMobile&quot;&gt;
  ...
&lt;/Teleport&gt;
</code></pre>
<p>这里的 isMobile 状态可以根据 CSS media query 的不同结果动态地更新。</p>
<h2 id="四-多个-teleport-共享目标"><a class="header" href="#四-多个-teleport-共享目标">四 多个 Teleport 共享目标</a></h2>
<p>一个可重用的模态框组件可能同时存在多个实例。对于此类场景，多个 <code>&lt;Teleport&gt;</code> 组件可以将其内容挂载在同一个目标元素上，而顺序就是简单的顺次追加，后挂载的将排在目标元素下更后面的位置上。</p>
<p>比如下面这样的用例：</p>
<pre><code class="language-vue">&lt;Teleport to=&quot;#modals&quot;&gt;
  &lt;div&gt;A&lt;/div&gt;
&lt;/Teleport&gt;
&lt;Teleport to=&quot;#modals&quot;&gt;
  &lt;div&gt;B&lt;/div&gt;
&lt;/Teleport&gt;
</code></pre>
<p>渲染的结果为：</p>
<pre><code class="language-html">&lt;div id=&quot;modals&quot;&gt;
  &lt;div&gt;A&lt;/div&gt;
  &lt;div&gt;B&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-状态管理-状态与-pinia"><a class="header" href="#111-状态管理-状态与-pinia">11.1-状态管理-状态与 Pinia</a></h1>
<h2 id="一-状态管理概念"><a class="header" href="#一-状态管理概念">一 状态管理概念</a></h2>
<p>理论上来说，每一个 Vue 组件实例都已经在“管理”它自己的响应式状态了。我们以一个简单的计数器组件为例：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref } from 'vue'

// 状态
const count = ref(0)

// 动作
function increment() {
  count.value++
}
&lt;/script&gt;

&lt;!-- 视图 --&gt;
&lt;template&gt;{ { count } }&lt;/template&gt;
</code></pre>
<p>它是一个独立的单元，由以下几个部分组成：</p>
<ul>
<li>状态：驱动整个应用的数据源；</li>
<li>视图：对状态的一种声明式映射；</li>
<li>交互：状态根据用户在视图中的输入而作出相应变更的可能方式。</li>
</ul>
<p>“单向数据流”概念如下所示：
<img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/vue/state-flow.png" alt="单向数据流" /></p>
<p>当我们有多个组件共享一个共同的状态时，就会有很多问题：</p>
<ul>
<li>多个视图可能都依赖于同一份状态。</li>
<li>来自不同视图的交互也可能需要更改同一份状态。</li>
</ul>
<p>对于情景 1，一个可行的办法是将共享状态“提升”到共同的祖先组件上去，再通过 props 传递下来。然而在深层次的组件树结构中这么做的话，很快就会使得代码变得繁琐冗长。这会导致另一个问题：Prop 逐级透传问题。</p>
<p>对于情景 2，我们经常发现自己会直接通过模板引用获取父/子实例，或者通过触发的事件尝试改变和同步多个状态的副本。但这些模式的健壮性都不甚理想，很容易就会导致代码难以维护。</p>
<p>一个更简单直接的解决方案是抽取出组件间的共享状态，放在一个全局单例中来管理。这样我们的组件树就变成了一个大的“视图”，而任何位置上的组件都可以访问其中的状态或触发动作。</p>
<h2 id="二-设计状态管库"><a class="header" href="#二-设计状态管库">二 设计状态管库</a></h2>
<h3 id="21-用响应式-api-做简单状态管理"><a class="header" href="#21-用响应式-api-做简单状态管理">2.1 用响应式 API 做简单状态管理</a></h3>
<p>如果你有一部分状态需要在多个组件实例间共享，你可以使用 reactive() 来创建一个响应式对象，并将它导入到多个组件中：</p>
<pre><code class="language-js">// store.js
import { reactive } from 'vue'

export const store = reactive({
  count: 0,
})
</code></pre>
<pre><code class="language-vue">&lt;!-- ComponentA.vue --&gt;
&lt;script setup&gt;
import { store } from './store.js'
&lt;/script&gt;

&lt;template&gt;From A: { { store.count } }&lt;/template&gt;
</code></pre>
<pre><code class="language-vue">&lt;!-- ComponentB.vue --&gt;
&lt;script setup&gt;
import { store } from './store.js'
&lt;/script&gt;

&lt;template&gt;From B: { { store.count } }&lt;/template&gt;
</code></pre>
<p>现在每当 store 对象被更改时，<code>&lt;ComponentA&gt;</code> 与 <code>&lt;ComponentB&gt;</code> 都会自动更新它们的视图。现在我们有了单一的数据源。</p>
<p>然而，这也意味着任意一个导入了 store 的组件都可以随意修改它的状态：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;button @click=&quot;store.count++&quot;&gt;From B: { { store.count } }&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>虽然这在简单的情况下是可行的，但从长远来看，可以被任何组件任意改变的全局状态是不太容易维护的。为了确保改变状态的逻辑像状态本身一样集中，建议在 store 上定义方法，方法的名称应该要能表达出行动的意图：</p>
<pre><code class="language-js">// store.js
import { reactive } from 'vue'

export const store = reactive({
  count: 0,
  increment() {
    this.count++
  },
})
</code></pre>
<pre><code class="language-vue">&lt;template&gt;
  &lt;button @click=&quot;store.increment()&quot;&gt;From B: { { store.count } }&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>除了我们这里用到的单个响应式对象作为一个 store 之外，你还可以使用其他响应式 API 例如 ref() 或是 computed()，或是甚至通过一个组合式函数来返回一个全局状态：</p>
<pre><code class="language-js">import { ref } from 'vue'

// 全局状态，创建在模块作用域下
const globalCount = ref(1)

export function useCount() {
  // 局部状态，每个组件都会创建
  const localCount = ref(1)

  return {
    globalCount,
    localCount
  }
</code></pre>
<p>事实上，Vue 的响应性系统与组件层是解耦的，这使得它非常灵活。</p>
<h2 id="二-pnia"><a class="header" href="#二-pnia">二 Pnia</a></h2>
<p>虽然我们的手动状态管理解决方案在简单的场景中已经足够了，但是在大规模的生产应用中还有很多其他事项需要考虑：</p>
<ul>
<li>更强的团队协作约定</li>
<li>与 Vue DevTools 集成，包括时间轴、组件内部审查和时间旅行调试</li>
<li>模块热更新 (HMR)</li>
<li>服务端渲染支持</li>
</ul>
<p>Pinia 就是一个实现了上述需求的状态管理库，由 Vue 核心团队维护，对 Vue 2 和 Vue 3 都可用。</p>
<p>现有用户可能对 Vuex 更熟悉，它是 Vue 之前的官方状态管理库。由于 Pinia 在生态系统中能够承担相同的职责且能做得更好，因此 Vuex 现在处于维护模式。它仍然可以工作，但不再接受新的功能。对于新的应用，建议使用 Pinia。</p>
<p>事实上，Pinia 最初正是为了探索 Vuex 的下一个版本而开发的，因此整合了核心团队关于 Vuex 5 的许多想法。最终，我们意识到 Pinia 已经实现了我们想要在 Vuex 5 中提供的大部分内容，因此决定将其作为新的官方推荐。</p>
<p>相比于 Vuex，Pinia 提供了更简洁直接的 API，并提供了组合式风格的 API，最重要的是，在使用 TypeScript 时它提供了更完善的类型推导。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="112-状态管理-vuex"><a class="header" href="#112-状态管理-vuex">11.2-状态管理-Vuex</a></h1>
<h2 id="一-vuex-概念"><a class="header" href="#一-vuex-概念">一 vuex 概念</a></h2>
<p>在 Vue 中，有三种基础的数据共享或者传递方式：</p>
<ul>
<li>父传子：通过 v-bind 属性绑定方式传递</li>
<li>子传父：通过 v-on 事件绑定方式传递</li>
<li>兄弟传递：通过 EventBus 事件总线方式传递（<code>$on</code> 接收，<code>$emit</code> 发送）</li>
</ul>
<p>上述三种方式适合在小型项目中使用，且事件总线管理这些数据相当复杂，且耦合度很高。复杂度较高的项目推荐使用一个全新的插件：vuex。</p>
<p>vuex 可以对 vue 应用中多个组件的共享状态进行集中式管理（读/写），其主要作用是状态管理，而非通信，但是由于状态管理即是数据的管理，vuex 也可以用来进行数据通信。</p>
<p>项目使用 vuex 与否的对比：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/mvvm/vuex-01.png" alt="vuex 在项目中的使用" /></p>
<p>vuex 优点：</p>
<ul>
<li>vuex 对数据进行了集中管理，易于开发、维护</li>
<li>vuex 中的数据是响应式的，能够实时保持数据与页面的同步</li>
</ul>
<p>state 保存的数据推荐使用 单一状态树 的形式，即大量的不同的数据都统一使用一个 store，而不是多个 store 对象。在这唯一的 store 中，进行数据的树形划分。</p>
<p>其实我们手动书写一个全局对象来保存数据也是可行的，类似后端的 redis，但是 vuex 还具备响应式驱动 DOM 更新的能力。</p>
<p>一般情况下，vuex 用来存储：登录、购物车信息、地理位置等多个界面共享的数据。</p>
<h2 id="二-vuex-简单使用"><a class="header" href="#二-vuex-简单使用">二 vuex 简单使用</a></h2>
<p>状态自管理应用包含以下三个部分：</p>
<ul>
<li><code>state</code>：应用的数据，即状态</li>
<li><code>view</code>：以声明方式将 state 映射到视图；</li>
<li><code>actions</code>：响应在 view 上的用户输入导致的状态变化 (包含 n 个更新状态方法)。</li>
</ul>
<pre><code class="language-txt"># 安装 (vue-cli 在安装时若勾选了 vuex，则无需安装)
npm i vuex -D
</code></pre>
<p>在项目根目录新建状态管理文件<code>store/index.js</code>：</p>
<pre><code class="language-js">import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

const store = new Vuex.Store({
  state: {
    // 自定义的共享状态，它应该是唯一的
    uid: 10001,
  },
  mutations: {},
  actions: {},
  getters: {},
  modules: {},
})

export default store
</code></pre>
<h2 id="三-vuex-的核心-api"><a class="header" href="#三-vuex-的核心-api">三 vuex 的核心 API</a></h2>
<h3 id="31-state"><a class="header" href="#31-state">3.1 state</a></h3>
<p>state 属性是 vuex 管理的状态对象，里面会包含一些具体的状态，也即通用的数据，如登录信息、购物车信息、地理位置信息。</p>
<p>示例：</p>
<pre><code class="language-js">const store = new Vuex.Store({
  // 全局共享数据
  state: {
    count: 10, // 定义一个全局数据名 count，值为 10
  },
  mutations: {},
  actions: {},
  modules: {},
})
</code></pre>
<p>使用 state 中的数据有两种方式。</p>
<p>方式一：在组件模板中直接使用（无需 this）</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;div&gt;count：{ { $store.state.count } }&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>方式二：使用 vuex 提供的 mapState 方法，将全局数据映射为当前组件的计算属性。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;count：{ { count } }&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import { mapState } from 'vuex'
  export default {
    name: 'Sub',
    computed: {
      ...mapState(['count']),
    },
  }
&lt;/script&gt;
</code></pre>
<h3 id="32-mutations"><a class="header" href="#32-mutations">3.2 mutations</a></h3>
<p>vuex 并不推荐直接修改 state 数据，而是铜鼓 mutations 内的函数来修改数据。</p>
<p>首先在 store 中提供 state 数据修改的方法：</p>
<pre><code class="language-js">const store = new Vuex.Store({
  state: {
    count: 10,
  },
  mutations: {
    addCount(state, num) {
      state.count += num
    },
  },
  actions: {},
  modules: {},
})
</code></pre>
<p>在组件中利用 commit 使用：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;count：{ { $store.state.count } }&lt;/div&gt;
    &lt;button @click=&quot;handleAdd&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name: 'Add',
    data() {
      return {}
    },
    methods: {
      handleAdd() {
        this.$store.commit('addCount', 5) //在组件中调用该方法时使用该方法名字符串
      },
    },
  }
&lt;/script&gt;
</code></pre>
<p>mutations 也拥有映射机制，可以将状态更新函数映射到 vue 组件的 methods 中：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;count：{ { count } }&lt;/div&gt;
    &lt;button @click=&quot;handleAdd2&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import { mapMutations, mapState } from 'vuex'
  export default {
    name: 'Sub',
    computed: {
      ...mapState(['count']),
    },
    methods: {
      ...mapMutations(['addCount']),
      handleAdd2() {
        this.addCount(6)
      },
    },
  }
&lt;/script&gt;
</code></pre>
<h3 id="33-actions"><a class="header" href="#33-actions">3.3 actions</a></h3>
<p>mutations 中推荐保存 同步 操作，而 actions 中推荐保存 异步 操作。如果不按照这个规范，Devtools 工具会出现跟踪问题。actions 仍然是通过触发 mutations 的方式间接变更数据的。</p>
<p>actions 示例：</p>
<pre><code class="language-js">const store = new Vuex.Store({
  state: {
    count: 10,
  },
  mutations: {
    addCount(state, num) {
      state.count += num
    },
  },
  actions: {
    // 默认参数为 context 上下问对象，这里是 store 对象
    addCountAsync(context, num) {
      setTimeout(() =&gt; {
        context.commit('addCount', num) // 只能触发 mutations
      }, 2000)
    },
  },
})
</code></pre>
<p>组件中使用：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;原始数据：{ {this.$store.state.count} }&lt;/p&gt;
    &lt;button @click=&quot;handleAdd(10)&quot;&gt;同步改变 count&lt;/button&gt;&lt;br /&gt;
    &lt;button @click=&quot;handleAddAsync(10)&quot;&gt;异步改变 count&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    data() {
      return {}
    },
    methods: {
      handleAdd(count) {
        this.$store.commit('addCount', count)
      },
      handleAddAsync(count) {
        this.$store.dispatch('addCountAsync', count)
      },
    },
  }
&lt;/script&gt;
</code></pre>
<p>同理，actions 也可以通过映射方式，映射到 vue 组件的 methods 中：</p>
<pre><code class="language-js">methods: {
  ...mapActions(['addAsync','subAsync'])
}
</code></pre>
<h3 id="34-getters"><a class="header" href="#34-getters">3.4 getters</a></h3>
<p>类似 vue 中的计算属性，在这里可以对获取到 state 数据进行修饰。</p>
<pre><code class="language-js">  getters: {
    getNum(state){
      return state.num + 5
    }
  },
</code></pre>
<p>组件中使用：</p>
<pre><code class="language-html">&lt;p&gt;{ {$store.getters.getNum} }&lt;/p&gt;
</code></pre>
<h3 id="35-modules"><a class="header" href="#35-modules">3.5 modules</a></h3>
<p>由于 vuex 推荐使用单个状态树，状态过多也很容易造成混乱，modules 可以将这些状态进行划分。每个 modules 就是一个 store 的配置对象，一般与一个组件对应：</p>
<pre><code class="language-js">  modules: {
    moduleA: {
      state:{},
      mutations:{}
    },
    moduleB: {
      state:{},
      mutations:{}
    }
  }
</code></pre>
<p>在组件中使用：</p>
<pre><code class="language-html">&lt;p&gt;{ {$store.state.moduleA.num} }&lt;/p&gt;
</code></pre>
<h2 id="四-vuex-的响应规则"><a class="header" href="#四-vuex-的响应规则">四 vuex 的响应规则</a></h2>
<p>Vuex 的 store 中的 state 是响应的，当 state 数据发生改变时，组件中的数据也会发生改变，不过 store 中必须 初始化好所需要的属性！</p>
<p>给 state 对象添加新属性时，此时 state 中新增了数据，但是界面是不会发生变化的，使用下面的方式可以进行响应</p>
<ul>
<li>方式一：给 state 的 person 对象新增 age 属性：
<ul>
<li><code>Vue.set(state.person, 'age', 26)</code></li>
<li>删除也可以做到响应：<code>Vue.delete(state.person, 'age')</code></li>
</ul>
</li>
<li>方式二：用新对象给旧对象重新赋值</li>
</ul>
<p>组件要更新数据时，依次经过：actions -&gt; mutations -&gt; state，这样的路径进行修改。能够修改 state 的操作就是：mutations。如图所示：</p>
<p><img src="09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/../images/mvvm/vuex-02.jpg" alt="mutations" /></p>
<p>为什么要绕一大圈？</p>
<p>在当前一个页面中，状态发生了变化，并不知道其来自于哪个地方触发了状态改变，调试很困难。vue 的开发工具 Devtools 可以在浏览器中清晰的展示是哪个组件的更新导致了状态的变化，该工具依赖于 mutations，所以我们使用 mutations 中状态更新的方法来改变状态。</p>
<h2 id="五-状态相关文件的组织格式"><a class="header" href="#五-状态相关文件的组织格式">五 状态相关文件的组织格式</a></h2>
<p>由于状态文件极大，可以对其分模块使用，store 文件夹中使用下列文件：</p>
<ul>
<li>index.js：store 的导出信息</li>
<li>mutations.js：数据更新方法文件</li>
<li>acitions.js：数据异步更新方法文件</li>
<li>....依次类推，每个 vuex 的属性单独一个文件保存</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">// actions.js
export default {
  updNumAsync(context, count) {
    // 默认参数为 context 上下问对象，这里是 store 对象
    setTimeout(() =&gt; {
      context.commit('updNumAsync', count)
    }, 2000)
  },
}

// index.js
import actions from './actions'

const store = new Vuex.Store({
  actions: actions,
})
</code></pre>
<h2 id="六"><a class="header" href="#六">六</a></h2>
<p>如果当前组件使用的 vuex 的成员过多，使用起来较为繁琐，如：</p>
<pre><code class="language-js">this.$store.state.user
this.$store.state.order
this.$store.state.category
</code></pre>
<p>vuex 提供了 mapState/mapGetters 优化为计算属性：</p>
<pre><code class="language-html">&lt;template&gt; &lt;/template&gt;

&lt;script&gt;
  import {mapState, mapGetters} from 'vuex
  export defatul {
    computed: {
      ...mapState(['user','order', 'category']),  // 映射 sate 数据
      ...mapGetters(['name'])  // 映射 getters 数据
      ...mapMutations(['infoUser', 'infoOrder']), //映射 commit
      ...mapActions(['getUser', 'getOrder'])//映射 dispatch() 的函数

    },
  }
&lt;/script&gt;
</code></pre>
<p>其本质是：</p>
<pre><code class="language-js">computed: {
  user(){
    return this.$store.state.user
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="121-vue-插件编写"><a class="header" href="#121-vue-插件编写">12.1-Vue 插件编写</a></h1>
<h2 id="一-vue-插件编写方式"><a class="header" href="#一-vue-插件编写方式">一 Vue 插件编写方式</a></h2>
<p>Vue 插件用于扩展 Vue，有两种方式自定义插件。</p>
<p>方式一：</p>
<pre><code class="language-js">// 直接在 prototype 身上定义
Vue.prototype.$aaa = '这是定义的插件'
</code></pre>
<p>方式二：</p>
<pre><code class="language-js">// 定义一个对象为插件，然后在 use() 里调用
    let obj = {
        // 必须有一个 install 函数，由 vue 调用
        install:function(Vue,opt){
            Vue.prototype.$aaa = '这是定义的插件';
        }
    }

    Vue.use(obj, {a:1})；
</code></pre>
<h2 id="二-示例"><a class="header" href="#二-示例">二 示例</a></h2>
<p>案列：获取和设置 localStorage 的存储</p>
<pre><code class="language-js">// 对象文件：utils.js
let local = {
  save(key, value) {
    localStorage.setItem(key, JSON.stringify(value))
  },
  fetch() {
    return JSON.parse(localStorage.getItem(key) || {})
  },
}

export default {
  install: function (vm) {
    vm.prototype.$local = local // local 对象挂载到 Vue 原型上
  },
}
</code></pre>
<pre><code class="language-js">    // 使用 utils 插件的文件：

    import Utile from './lib/utils';

    Vue.use(Utile)；

    // 一旦作为一个插件使用之后，就可以在每个组件里面通过 this 访问到 local 对象了
</code></pre>
<p><strong>可以用一个文件写很多的对象，把想要暴露出去的对象挂载到 Vue 原型身上就行；如：</strong></p>
<pre><code class="language-js">let obj1 = {}
let obj2 = {}
let obj3 = {}

export default {
  install: function (vm) {
    vm.prototype.$obj1 = obj1
    vm.prototype.$obj2 = obj2
    vm.prototype.$obj3 = obj3
  },
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="131-vue-动画"><a class="header" href="#131-vue-动画">13.1-Vue 动画</a></h1>
<h2 id="一-vue-过渡动画"><a class="header" href="#一-vue-过渡动画">一 Vue 过渡动画</a></h2>
<p>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 进入/离开 过渡：</p>
<ul>
<li>条件渲染 (使用 v-if)</li>
<li>条件展示 (使用 v-show)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<p>一个完整的动画分为了两部分：进入部分和离开部分。进入和离开部分都分为两个时间点和一个时间段。</p>
<p>进入部分：</p>
<pre><code class="language-txt">v-enter：
        动画进入之前元素的初始状态。
        在元素被插入之前生效，在元素被插入之后的下一帧移除。

v-enter-to：
        动画进入完成之后的结束状态；
        在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。

v-enter-active：
        进入动画的时间段。
        在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。
</code></pre>
<p>离开部分：</p>
<pre><code class="language-txt">v-leave：
      动画离开之前元素的初始状态；
      在离开过渡被触发时立刻生效，下一帧被移除。

v-leave-to：
      动画离开完成之后的借宿状态；
      在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。

v-leave-active：
      离开动画的时间段；
      在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。
</code></pre>
<p>贴士：</p>
<ul>
<li>v-enter 和 v-leave-to 的状态是一致的；</li>
<li>v-enter-to 和 v-leave 的状态是一致的；</li>
</ul>
<h2 id="二-元素过渡步骤"><a class="header" href="#二-元素过渡步骤">二 元素过渡步骤</a></h2>
<p>使用 transition 元素，把 需要被动画控制的元素 包裹起来，自定义两组样式，来控制 transition 内部元素实现动画；</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;flag=!flag&quot;&gt;显示/隐藏&lt;/button&gt;

  &lt;transition&gt;
    &lt;p v-show=&quot;flag&quot;&gt;我想通过动画显示隐藏&lt;/p&gt;
  &lt;/transition&gt;
&lt;/template&gt;

&lt;script&gt;
  new Vue({
      data:{
          flag: true;
      }
  })
&lt;/script&gt;

&lt;style&gt;
  .v-enter,
  .v-leave-to {
    opacity: 0;
  }
  .v-leave-active,
  .v-enter-active {
    transition: all 0.4s;
  }
&lt;/style&gt;
</code></pre>
<h2 id="三-自定义过渡类名"><a class="header" href="#三-自定义过渡类名">三 自定义过渡类名</a></h2>
<p><strong>8.2.1 步骤</strong>：</p>
<ul>
<li>在 transition 标签上添加 name 属性，并给 name 属性赋值，赋的值替换 <code>v-</code> 来作为过渡类类名的前缀；</li>
<li>使用自定义过渡类名 定义两组样式，来控制 transition 内部元素实现动画；</li>
</ul>
<pre><code class="language-html">&lt;button @click=&quot;flag=!flag&quot;&gt;显示/隐藏&lt;/button&gt;

&lt;transition name=&quot;my&quot;&gt;
  &lt;p v-show=&quot;flag&quot;&gt;我想通过动画显示隐藏&lt;/p&gt;
&lt;/transition&gt;

&lt;script&gt;
  new Vue({
      data:{
          flag: true;
      }
  })
&lt;/script&gt;

&lt;style&gt;
  .my-enter,
  .my-leave-to {
    opacity: 0;
  }
  .my-leave-active,
  .my-enter-active {
    transition: all 0.4s;
  }
&lt;/style&gt;
</code></pre>
<h2 id="四-钩子函数实现动画"><a class="header" href="#四-钩子函数实现动画">四 钩子函数实现动画</a></h2>
<p>使用过渡类名和使用第三方的库来实现动画，都不能实现半场动画，有时候我们只需要半场，不需要整场动画（比如加入购物车动画），只能借助于钩子函数来实现。</p>
<p>钩子函数页可以说是动画的生命周期函数：
入场的钩子函数</p>
<pre><code class="language-html">&lt;transition
  v-on:before-enter=&quot;beforeEnter&quot;
  v-on:enter=&quot;enter&quot;
  v-on:after-enter=&quot;afterEnter&quot;
  v-on:enter-cancelled=&quot;enterCancelled&quot;
  v-on:before-leave=&quot;beforeLeave&quot;
  v-on:leave=&quot;leave&quot;
  v-on:after-leave=&quot;afterLeave&quot;
  v-on:leave-cancelled=&quot;leaveCancelled&quot;
&gt;
&lt;/transition&gt;
</code></pre>
<p>上面四个是入场的动画生命周期函数；后面四个是出场的动画生命周期函数；</p>
<p>当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。</p>
<pre><code class="language-js">methods: {
  // 进入中

  beforeEnter: function (el) {
    // ...
  },
  // 当与 CSS 结合使用时
  // 回调函数 done 是可选的
  enter: function (el, done) {//此时的 done 其实就是 afterEnter 函数的引用
    // ...    // 当需要的操作完成之后，就会自动去调用 done()，也就是立即调用 afterEnter 函数；
    done()
  },
  afterEnter: function (el) {
    // ...
  },
  enterCancelled: function (el) {
    // ...
  },
</code></pre>
<h2 id="五-多元素过渡"><a class="header" href="#五-多元素过渡">五 多元素过渡</a></h2>
<p>transition 只能让一个元素实现动画，如果要多个元素实现过渡，需要使用 <code>transition-group</code>：</p>
<pre><code class="language-html">&lt;transition-group appear&gt;
  &lt;div key=&quot;1&quot;&gt;&lt;/div&gt;
  &lt;div key=&quot;2&quot;&gt;&lt;/div&gt;
&lt;/transition-group&gt;
</code></pre>
<h2 id="六-集成第三方库"><a class="header" href="#六-集成第三方库">六 集成第三方库</a></h2>
<p>较为成熟的动画库为：animate.css，vue 集成方式：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;transition-group
    appear
    name=&quot;animate_animated animate_bounce&quot;
    enter-active-class=&quot;animate_swing&quot;
    leave-active-class=&quot;animate_backOutup&quot;
  &gt;
    &lt;div key=&quot;1&quot;&gt;&lt;/div&gt;
    &lt;div key=&quot;2&quot;&gt;&lt;/div&gt;
  &lt;/transition-group&gt;
  &gt;&lt;/template
&gt;
&lt;script&gt;
  import 'animate.css'
&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="141-vue-服务端渲染"><a class="header" href="#141-vue-服务端渲染">14.1-Vue 服务端渲染</a></h1>
<h2 id="一-服务端渲染-ssr-概念"><a class="header" href="#一-服务端渲染-ssr-概念">一 服务端渲染 SSR 概念</a></h2>
<p>Vue.js 是一个用于构建客户端应用的框架。默认情况下，Vue 组件的职责是在浏览器中生成和操作 DOM。然而，Vue 也支持将组件在服务端直接渲染成 HTML 字符串，作为服务端响应返回给浏览器，最后在浏览器端将静态的 HTML“激活”(hydrate) 为能够交互的客户端应用。</p>
<p>一个由服务端渲染的 Vue.js 应用也可以被认为是“同构的”(Isomorphic) 或“通用的”(Universal)，因为应用的大部分代码同时运行在服务端和客户端。</p>
<p>与客户端的单页应用 (SPA) 相比，SSR 的优势主要在于：</p>
<ul>
<li>更快的首屏加载：这一点在慢网速或者运行缓慢的设备上尤为重要。服务端渲染的 HTML 无需等到所有的 JavaScript 都下载并执行完成之后才显示，所以你的用户将会更快地看到完整渲染的页面。除此之外，数据获取过程在首次访问时在服务端完成，相比于从客户端获取，可能有更快的数据库连接。这通常可以带来更高的核心 Web 指标评分、更好的用户体验，而对于那些“首屏加载速度与转化率直接相关”的应用来说，这点可能至关重要。</li>
<li>统一的心智模型：你可以使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。</li>
<li>更好的 SEO：搜索引擎爬虫可以直接看到完全渲染的页面。</li>
</ul>
<p>使用 SSR 时还有一些权衡之处需要考量：</p>
<ul>
<li>开发中的限制。浏览器端特定的代码只能在某些生命周期钩子中使用；一些外部库可能需要特殊处理才能在服务端渲染的应用中运行。</li>
<li>更多的与构建配置和部署相关的要求。服务端渲染的应用需要一个能让 Node.js 服务器运行的环境，不像完全静态的 SPA 那样可以部署在任意的静态文件服务器上。</li>
<li>更高的服务端负载。在 Node.js 中渲染一个完整的应用要比仅仅托管静态文件更加占用 CPU 资源，因此如果你预期有高流量，请为相应的服务器负载做好准备，并采用合理的缓存策略。</li>
</ul>
<p>在为你的应用使用 SSR 之前，你首先应该问自己是否真的需要它。这主要取决于首屏加载速度对应用的重要程度。例如，如果你正在开发一个内部的管理面板，初始加载时的那额外几百毫秒对你来说并不重要，这种情况下使用 SSR 就没有太多必要了。然而，在内容展示速度极其重要的场景下，SSR 可以尽可能地帮你实现最优的初始加载性能。</p>
<p>静态站点生成 (Static-Site Generation，缩写为 SSG)，也被称为预渲染，是另一种流行的构建快速网站的技术。如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那么我们可以只渲染一次，提前在构建过程中完成，而不是每次请求进来都重新渲染页面。预渲染的页面生成后作为静态 HTML 文件被服务器托管。</p>
<p>SSG 保留了和 SSR 应用相同的性能表现：它带来了优秀的首屏加载性能。同时，它比 SSR 应用的花销更小，也更容易部署，因为它输出的是静态 HTML 和资源文件。这里的关键词是静态：SSG 仅可以用于消费静态数据的页面，即数据在构建期间就是已知的，并且在多次部署期间不会改变。每当数据变化时，都需要重新部署。</p>
<p>如果你调研 SSR 只是为了优化为数不多的营销页面的 SEO (例如 /、/about 和 /contact 等)，那么你可能需要 SSG 而不是 SSR。SSG 也非常适合构建基于内容的网站，比如文档站点或者博客。事实上，你现在正在阅读的这个网站就是使用 VitePress 静态生成的，它是一个由 Vue 驱动的静态站点生成器。</p>
<h2 id="二-ssr-基础教程"><a class="header" href="#二-ssr-基础教程">二 SSR 基础教程</a></h2>
<h3 id="21-渲染一个应用"><a class="header" href="#21-渲染一个应用">2.1 渲染一个应用</a></h3>
<p>新建一个项目后，在 package.json 中添加 &quot;type&quot;: &quot;module&quot; 使 Node.js 以 ES modules mode 运行。创建一个 example.js 文件：</p>
<pre><code class="language-js">// 此文件运行在 Node.js 服务器上
import { createSSRApp } from 'vue'
// Vue 的服务端渲染 API 位于 `vue/server-renderer` 路径下
import { renderToString } from 'vue/server-renderer'

const app = createSSRApp({
  data: () =&gt; ({ count: 1 }),
  template: `&lt;button @click=&quot;count++&quot;&gt;{ { count } }&lt;/button&gt;`,
})

renderToString(app).then((html) =&gt; {
  console.log(html)
})
</code></pre>
<p>运行：</p>
<pre><code class="language-txt">node example.js // &lt;button&gt;1&lt;/button&gt;
</code></pre>
<p>renderToString() 接收一个 Vue 应用实例作为参数，返回一个 Promise，当 Promise resolve 时得到应用渲染的 HTML。当然你也可以使用 Node.js Stream API 或者 Web Streams API 来执行流式渲染。</p>
<p>然后我们可以把 Vue SSR 的代码移动到一个服务器请求处理函数里，它将应用的 HTML 片段包装为完整的页面 HTML。接下来的几步我们将会使用 express：</p>
<pre><code class="language-js">import express from 'express'
import { createSSRApp } from 'vue'
import { renderToString } from 'vue/server-renderer'

const server = express()

server.get('/', (req, res) =&gt; {
  const app = createSSRApp({
    data: () =&gt; ({ count: 1 }),
    template: `&lt;button @click=&quot;count++&quot;&gt;{ { count } }&lt;/button&gt;`,
  })

  renderToString(app).then((html) =&gt; {
    res.send(`
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Vue SSR Example&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;${html}&lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
    `)
  })
})

server.listen(3000, () =&gt; {
  console.log('ready')
})
</code></pre>
<p>最后，执行 node server.js，访问 http://localhost:3000。你应该可以看到页面中的按钮了。</p>
<h3 id="22-客户端激活"><a class="header" href="#22-客户端激活">2.2 客户端激活</a></h3>
<p>如果你点击该按钮，你会发现数字并没有改变。这段 HTML 在客户端是完全静态的，因为我们没有在浏览器中加载 Vue。</p>
<p>为了使客户端的应用可交互，Vue 需要执行一个激活步骤。在激活过程中，Vue 会创建一个与服务端完全相同的应用实例，然后将每个组件与它应该控制的 DOM 节点相匹配，并添加 DOM 事件监听器。</p>
<p>为了在激活模式下挂载应用，我们应该使用 createSSRApp() 而不是 createApp()：</p>
<pre><code class="language-js">// 该文件运行在浏览器中
import { createSSRApp } from 'vue'

const app = createSSRApp({
  // ...和服务端完全一致的应用实例
})

// 在客户端挂载一个 SSR 应用时会假定
// HTML 是预渲染的，然后执行激活过程，
// 而不是挂载新的 DOM 节点
app.mount('#app')
</code></pre>
<h3 id="23-代码结构"><a class="header" href="#23-代码结构">2.3 代码结构</a></h3>
<p>想想我们该如何在客户端复用服务端的应用实现。这时我们就需要开始考虑 SSR 应用中的代码结构了——我们如何在服务器和客户端之间共享相同的应用代码呢？</p>
<p>这里我们将演示最基础的设置。首先，让我们将应用的创建逻辑拆分到一个单独的文件 app.js 中：</p>
<pre><code class="language-js">// app.js (在服务器和客户端之间共享)
import { createSSRApp } from 'vue'

export function createApp() {
  return createSSRApp({
    data: () =&gt; ({ count: 1 }),
    template: `&lt;button @click=&quot;count++&quot;&gt;{ { count } }&lt;/button&gt;`,
  })
}
</code></pre>
<p>该文件及其依赖项在服务器和客户端之间共享——我们称它们为通用代码。</p>
<p>我们在客户端入口导入通用代码，创建应用并执行挂载：</p>
<pre><code class="language-js">// client.js
import { createApp } from './app.js'

createApp().mount('#app')
</code></pre>
<p>服务器在请求处理函数中使用相同的应用创建逻辑：</p>
<pre><code class="language-js">// server.js (不相关的代码省略)
import { createApp } from './app.js'

server.get('/', (req, res) =&gt; {
  const app = createApp()
  renderToString(app).then((html) =&gt; {
    // ...
  })
})
</code></pre>
<p>此外，为了在浏览器中加载客户端文件，我们还需要：</p>
<ul>
<li>在 server.js 中添加 server.use(express.static('.')) 来托管客户端文件。</li>
<li>将 <code>&lt;script type=&quot;module&quot; src=&quot;/client.js&quot;&gt;&lt;/script&gt;</code> 添加到 HTML 外壳以加载客户端入口文件。</li>
<li>通过在 HTML 外壳中添加 Import Map 以支持在浏览器中使用 <code>import from 'vue'</code>。</li>
</ul>
<h2 id="三-通用的解决方案"><a class="header" href="#三-通用的解决方案">三 通用的解决方案</a></h2>
<p>在企业级生产环境中，还需要考虑：</p>
<ul>
<li>支持 Vue SFC 且满足其他构建步骤要求。事实上，我们需要为同一个应用执行两次构建过程：一次用于客户端，一次用于服务器。</li>
<li>在服务器请求处理函数中，确保返回的 HTML 包含正确的客户端资源链接和最优的资源加载提示 (如 prefetch 和 preload)。我们可能还需要在 SSR 和 SSG 模式之间切换，甚至在同一个应用中混合使用这两种模式。</li>
<li>以一种通用的方式管理路由、数据获取和状态存储。</li>
</ul>
<p>完整的实现会非常复杂，并且取决于你选择使用的构建工具链。因此，我们强烈建议你使用一种更通用的、更集成化的解决方案，帮你抽象掉那些复杂的东西。下面推荐几个 Vue 生态中的 SSR 解决方案。</p>
<p>常见实践方案有：</p>
<ul>
<li>Nuxt 是一个构建于 Vue 生态系统之上的全栈框架，它为编写 Vue SSR 应用提供了丝滑的开发体验。更棒的是，你还可以把它当作一个静态站点生成器来用！我们强烈建议你试一试。</li>
<li>Quasar 是一个基于 Vue 的完整解决方案，它可以让你用同一套代码库构建不同目标的应用，如 SPA、SSR、PWA、移动端应用、桌面端应用以及浏览器插件。除此之外，它还提供了一整套 Material Design 风格的组件库。</li>
<li>Vite 提供了内置的 Vue 服务端渲染支持，但它在设计上是偏底层的。如果你想要直接使用 Vite，可以看看 vite-plugin-ssr，一个帮你抽象掉许多复杂细节的社区插件。</li>
</ul>
<h2 id="四-书写-ssr-友好的代码"><a class="header" href="#四-书写-ssr-友好的代码">四 书写 SSR 友好的代码</a></h2>
<h3 id="41-服务端的响应性"><a class="header" href="#41-服务端的响应性">4.1 服务端的响应性</a></h3>
<p>在 SSR 期间，每一个请求 URL 都会映射到我们应用中的一个期望状态。因为没有用户交互和 DOM 更新，所以响应性在服务端是不必要的。为了更好的性能，默认情况下响应性在 SSR 期间是禁用的。</p>
<h3 id="42-组件生命周期钩子"><a class="header" href="#42-组件生命周期钩子">4.2 组件生命周期钩子</a></h3>
<p>因为没有任何动态更新，所以像 onMounted 或者 onUpdated 这样的生命周期钩子不会在 SSR 期间被调用，而只会在客户端运行。
你应该避免在 setup() 或者 <code>&lt;script setup&gt;</code> 的根作用域中使用会产生副作用且需要被清理的代码。这类副作用的常见例子是使用 setInterval 设置定时器。我们可能会在客户端特有的代码中设置定时器，然后在 onBeforeUnmount 或 onUnmounted 中清除。然而，由于 unmount 钩子不会在 SSR 期间被调用，所以定时器会永远存在。为了避免这种情况，请将含有副作用的代码放到 onMounted 中。</p>
<h3 id="43-访问平台特有-api"><a class="header" href="#43-访问平台特有-api">4.3 访问平台特有 API</a></h3>
<p>通用代码不能访问平台特有的 API，如果你的代码直接使用了浏览器特有的全局变量，比如 window 或 document，他们会在 Node.js 运行时报错，反过来也一样。</p>
<p>对于在服务器和客户端之间共享，但使用了不同的平台 API 的任务，建议将平台特定的实现封装在一个通用的 API 中，或者使用能为你做这件事的库。例如你可以使用 node-fetch 在服务端和客户端使用相同的 fetch API。</p>
<p>对于浏览器特有的 API，通常的方法是在仅客户端特有的生命周期钩子中惰性地访问它们，例如 onMounted。</p>
<p>请注意，如果一个第三方库编写时没有考虑到通用性，那么要将它集成到一个 SSR 应用中可能会很棘手。你或许可以通过模拟一些全局变量来让它工作，但这只是一种 hack 手段并且可能会影响到其他库的环境检测代码。</p>
<h3 id="44-跨请求状态污染"><a class="header" href="#44-跨请求状态污染">4.4 跨请求状态污染</a></h3>
<p>在状态管理一章中，我们介绍了一种使用响应式 API 的简单状态管理模式。而在 SSR 环境中，这种模式需要一些额外的调整。</p>
<p>上述模式在一个 JavaScript 模块的根作用域中声明共享的状态。这是一种单例模式——即在应用的整个生命周期中只有一个响应式对象的实例。这在纯客户端的 Vue 应用中是可以的，因为对于浏览器的每一个页面访问，应用模块都会重新初始化。</p>
<p>然而，在 SSR 环境下，应用模块通常只在服务器启动时初始化一次。同一个应用模块会在多个服务器请求之间被复用，而我们的单例状态对象也一样。如果我们用单个用户特定的数据对共享的单例状态进行修改，那么这个状态可能会意外地泄露给另一个用户的请求。我们把这种情况称为跨请求状态污染。</p>
<p>从技术上讲，我们可以在每个请求上重新初始化所有 JavaScript 模块，就像我们在浏览器中所做的那样。但是，初始化 JavaScript 模块的成本可能很高，因此这会显著影响服务器性能。</p>
<p>推荐的解决方案是在每个请求中为整个应用创建一个全新的实例，包括 router 和全局 store。然后，我们使用应用层级的 provide 方法来提供共享状态，并将其注入到需要它的组件中，而不是直接在组件中将其导入：</p>
<pre><code class="language-js">// app.js （在服务端和客户端间共享）
import { createSSRApp } from 'vue'
import { createStore } from './store.js'

// 每次请求时调用
export function createApp() {
  const app = createSSRApp(/* ... */)
  // 对每个请求都创建新的 store 实例
  const store = createStore(/* ... */)
  // 提供应用级别的 store
  app.provide('store', store)
  // 也为激活过程暴露出 store
  return { app, store }
}
</code></pre>
<h3 id="45-激活不匹配"><a class="header" href="#45-激活不匹配">4.5 激活不匹配</a></h3>
<p>如果预渲染的 HTML 的 DOM 结构不符合客户端应用的期望，就会出现激活不匹配。最常见的激活不匹配是以下几种原因导致的：</p>
<p>第一：组件模板中存在不符合规范的 HTML 结构，渲染后的 HTML 被浏览器原生的 HTML 解析行为纠正导致不匹配。举例来说，一个常见的错误是 <code>&lt;div&gt;</code> 不能被放在 <p> 中：</p>
<pre><code class="language-js">&lt;p&gt;
  &lt;div&gt;hi&lt;/div&gt;
&lt;/p&gt;
</code></pre>
<p>如果我们在服务器渲染的 HTML 中出现这样的代码，当遇到 <code>&lt;div&gt;</code> 时，浏览器会结束第一个 <code>&lt;p&gt;</code>，并解析为以下 DOM 结构：</p>
<pre><code class="language-js">&lt;p&gt;&lt;/p&gt;
&lt;div&gt;hi&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;
</code></pre>
<p>第二：渲染所用的数据中包含随机生成的值。由于同一个应用会在服务端和客户端执行两次，每次执行生成的随机数都不能保证相同。避免随机数不匹配有两种选择：</p>
<ul>
<li>利用 v-if + onMounted 让需要用到随机数的模板只在客户端渲染。你所用的上层框架可能也会提供简化这个用例的内置 API，比如 VitePress 的 <code>&lt;ClientOnly&gt;</code> 组件。</li>
<li>使用一个能够接受随机种子的随机数生成库，并确保服务端和客户端使用同样的随机数种子 (比如把种子包含在序列化的状态中，然后在客户端取回)。</li>
</ul>
<p>第三：服务端和客户端的时区不一致。有时候我们可能会想要把一个时间转换为用户的当地时间，但在服务端的时区跟用户的时区可能并不一致，我们也并不能可靠的在服务端预先知道用户的时区。这种情况下，当地时间的转换也应该作为纯客户端逻辑去执行。</p>
<p>当 Vue 遇到激活不匹配时，它将尝试自动恢复并调整预渲染的 DOM 以匹配客户端的状态。这将导致一些渲染性能的损失，因为需要丢弃不匹配的节点并渲染新的节点，但大多数情况下，应用应该会如预期一样继续工作。尽管如此，最好还是在开发过程中发现并避免激活不匹配。</p>
<h3 id="46-自定义指令"><a class="header" href="#46-自定义指令">4.6 自定义指令</a></h3>
<p>因为大多数的自定义指令都包含了对 DOM 的直接操作，所以它们会在 SSR 时被忽略。但如果你想要自己控制一个自定义指令在 SSR 时应该如何被渲染 (即应该在渲染的元素上添加哪些 attribute)，你可以使用 getSSRProps 指令钩子：</p>
<pre><code class="language-js">const myDirective = {
  mounted(el, binding) {
    // 客户端实现：
    // 直接更新 DOM
    el.id = binding.value
  },
  getSSRProps(binding) {
    // 服务端实现：
    // 返回需要渲染的 prop
    // getSSRProps 只接收一个 binding 参数
    return {
      id: binding.value,
    }
  },
}
</code></pre>
<h3 id="47-teleports"><a class="header" href="#47-teleports">4.7 Teleports</a></h3>
<p>在 SSR 的过程中 Teleport 需要特殊处理。如果渲染的应用包含 Teleport，那么其传送的内容将不会包含在主应用渲染出的字符串中。在大多数情况下，更推荐的方案是在客户端挂载时条件式地渲染 Teleport。</p>
<p>如果你需要激活 Teleport 内容，它们会暴露在服务端渲染上下文对象的 teleports 属性下：</p>
<pre><code class="language-js">const ctx = {}
const html = await renderToString(app, ctx)

console.log(ctx.teleports) // { '#teleported': 'teleported content' }
</code></pre>
<p>跟主应用的 HTML 一样，你需要自己将 Teleport 对应的 HTML 嵌入到最终页面上的正确位置处。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="151-vue-测试"><a class="header" href="#151-vue-测试">15.1-Vue 测试</a></h1>
<h2 id="一-测试的类型"><a class="header" href="#一-测试的类型">一 测试的类型</a></h2>
<p>测试类型有：</p>
<ul>
<li>单元测试：检查给定函数、类或组合式函数的输入是否产生预期的输出或副作用。</li>
<li>组件测试：检查你的组件是否正常挂载和渲染、是否可以与之互动，以及表现是否符合预期。这些测试比单元测试导入了更多的代码，更复杂，需要更多时间来执行。</li>
<li>端到端测试：检查跨越多个页面的功能，并对生产构建的 Vue 应用进行实际的网络请求。这些测试通常涉及到建立一个数据库或其他后端。</li>
</ul>
<p>每种测试类型在你的应用的测试策略中都发挥着作用，保护你免受不同类型的问题的影响。</p>
<h2 id="二-单元测试"><a class="header" href="#二-单元测试">二 单元测试</a></h2>
<h3 id="21-单元测试示例"><a class="header" href="#21-单元测试示例">2.1 单元测试示例</a></h3>
<p>编写单元测试是为了验证小的、独立的代码单元是否按预期工作。一个单元测试通常覆盖一个单个函数、类、组合式函数或模块。单元测试侧重于逻辑上的正确性，只关注应用整体功能的一小部分。他们可能会模拟你的应用环境的很大一部分（如初始状态、复杂的类、第三方模块和网络请求）。</p>
<p>一般来说，单元测试将捕获函数的业务逻辑和逻辑正确性的问题。</p>
<p>以这个 increment 函数为例：</p>
<pre><code class="language-js">// helpers.js
export function increment(current, max = 10) {
  if (current &lt; max) {
    return current + 1
  }
  return current
}
</code></pre>
<p>因为它很独立，可以很容易地调用 increment 函数并断言它是否返回了所期望的内容，所以我们将编写一个单元测试。</p>
<p>如果任何一条断言失败了，那么问题一定是出在 increment 函数上。</p>
<pre><code class="language-js">// helpers.spec.js
import { increment } from './helpers'

describe('increment', () =&gt; {
  test('increments the current number by 1', () =&gt; {
    expect(increment(0, 10)).toBe(1)
  })

  test('does not increment the current number over the max', () =&gt; {
    expect(increment(10, 10)).toBe(10)
  })

  test('has a default max of 10', () =&gt; {
    expect(increment(10)).toBe(10)
  })
})
</code></pre>
<p>单元测试通常适用于独立的业务逻辑、组件、类、模块或函数，不涉及 UI 渲染、网络请求或其他环境问题。这些通常是与 Vue 无关的纯 JavaScript/TypeScript 模块。一般来说，在 Vue 应用中为业务逻辑编写单元测试与使用其他框架的应用没有明显区别。</p>
<p>但有两种情况，你必须对 Vue 的特定功能进行单元测试：</p>
<ul>
<li>组合式函数</li>
<li>组件</li>
</ul>
<h3 id="22-组合式函数单元测试"><a class="header" href="#22-组合式函数单元测试">2.2 组合式函数单元测试</a></h3>
<p>当涉及到测试组合式函数时，我们可以根据是否依赖宿主组件实例把它们分为两类。</p>
<p>当一个组合式函数使用以下 API 时，它依赖于一个宿主组件实例：</p>
<ul>
<li>生命周期钩子</li>
<li>供给/注入</li>
</ul>
<p>如果一个组合式程序只使用响应式 API，那么它可以通过直接调用并断言其返回的状态或方法来进行测试。</p>
<pre><code class="language-js">// counter.js
import { ref } from 'vue'

export function useCounter() {
  const count = ref(0)
  const increment = () =&gt; count.value++

  return {
    count,
    increment,
  }
}
</code></pre>
<pre><code class="language-js">// counter.test.js
import { useCounter } from './counter.js'

test('useCounter', () =&gt; {
  const { count, increment } = useCounter()
  expect(count.value).toBe(0)

  increment()
  expect(count.value).toBe(1)
})
</code></pre>
<p>一个依赖生命周期钩子或供给/注入的组合式函数需要被包装在一个宿主组件中才可以测试。我们可以创建下面这样的帮手函数：</p>
<pre><code class="language-js">// test-utils.js
import { createApp } from 'vue'

export function withSetup(composable) {
  let result
  const app = createApp({
    setup() {
      result = composable()
      // 忽略模板警告
      return () =&gt; {}
    },
  })
  app.mount(document.createElement('div'))
  // 返回结果与应用实例
  // 用来测试供给和组件卸载
  return [result, app]
}
</code></pre>
<pre><code class="language-js">import { withSetup } from './test-utils'
import { useFoo } from './foo'

test('useFoo', () =&gt; {
  const [result, app] = withSetup(() =&gt; useFoo(123))
  // 为注入的测试模拟一方供给
  app.provide(...)
  // 执行断言
  expect(result.foo.value).toBe(1)
  // 如果需要的话可以这样触发
  app.unmount()
})
</code></pre>
<p>对于更复杂的组合式函数，通过使用组件测试编写针对这个包装器组件的测试，这会容易很多。</p>
<h3 id="23-组件单元测试"><a class="header" href="#23-组件单元测试">2.3 组件单元测试</a></h3>
<p>一个组件可以通过两种方式测试：</p>
<ul>
<li>白盒：单元测试。白盒测试知晓一个组件的实现细节和依赖关系。它们更专注于将组件进行更 独立 的测试。这些测试通常会涉及到模拟一些组件的部分子组件，以及设置插件的状态和依赖性（例如 Vuex）。</li>
<li>黑盒：组件测试。黑盒测试不知晓一个组件的实现细节。这些测试尽可能少地模拟，以测试组件在整个系统中的集成情况。它们通常会渲染所有子组件，因而会被认为更像一种“集成测试”。请查看下方的组件测试建议作进一步了解。</li>
</ul>
<h2 id="三-测试推荐方案"><a class="header" href="#三-测试推荐方案">三 测试推荐方案</a></h2>
<blockquote>
<p>Vitest</p>
</blockquote>
<p>因为由 create-vue 创建的官方项目配置是基于 Vite 的，所以我们推荐你使用一个可以利用同一套 Vite 配置和转换管道的单元测试框架。Vitest 正是一个针对此目标设计的单元测试框架，它由 Vue / Vite 团队成员开发和维护。在 Vite 的项目集成它会非常简单，而且速度非常快。</p>
<blockquote>
<p>Jest</p>
</blockquote>
<p>Jest 是一个广受欢迎的单元测试框架，并可通过 vite-jest 这个包在 Vite 中使用。不过，我们只推荐你在已有一套 Jest 测试配置、且需要迁移到基于 Vite 的项目时使用它，因为 Vitest 提供了更无缝的集成和更好的性能。</p>
<h2 id="四-组件测试"><a class="header" href="#四-组件测试">四 组件测试</a></h2>
<h3 id="41-组件测试概念"><a class="header" href="#41-组件测试概念">4.1 组件测试概念</a></h3>
<p>在 Vue 应用中，主要用组件来构建用户界面。因此，当验证应用的行为时，组件是一个很自然的独立单元。从粒度的角度来看，组件测试位于单元测试之上，可以被认为是集成测试的一种形式。你的 Vue 应用中大部分内容都应该由组件测试来覆盖，我们建议每个 Vue 组件都应有自己的组件测试文件。</p>
<p>组件测试应该捕捉组件中的 prop、事件、提供的插槽、样式、CSS class 名、生命周期钩子，和其他相关的问题。</p>
<p>组件测试不应该模拟子组件，而应该像用户一样，通过与组件互动来测试组件和其子组件之间的交互。例如，组件测试应该像用户那样点击一个元素，而不是编程式地与组件进行交互。</p>
<p>组件测试主要需要关心组件的公开接口而不是内部实现细节。对于大部分的组件来说，公开接口包括触发的事件、prop 和插槽。当进行测试时，请记住，测试这个组件做了什么，而不是测试它是怎么做到的。</p>
<p>推荐的做法：</p>
<ul>
<li>对于 视图 的测试：根据输入 prop 和插槽断言渲染输出是否正确。</li>
<li>对于 交互 的测试：断言渲染的更新是否正确或触发的事件是否正确地响应了用户输入事件。</li>
</ul>
<p>应避免的做法：</p>
<ul>
<li>不要去断言一个组件实例的私有状态或测试一个组件的私有方法。测试实现细节会使测试代码太脆弱，因为当实现发生变化时，它们更有可能失败并需要更新重写。</li>
<li>组件的最终工作是渲染正确的 DOM 输出，所以专注于 DOM 输出的测试提供了足够的正确性保证（如果你不需要更多其他方面测试的话），同时更加健壮、需要的改动更少。</li>
<li>不要完全依赖快照测试。断言 HTML 字符串并不能完全说明正确性。应当编写有意图的测试。</li>
<li>如果一个方法需要测试，把它提取到一个独立的实用函数中，并为它写一个专门的单元测试。如果它不能被直截了当地抽离出来，那么对它的调用应该作为交互测试的一部分。</li>
</ul>
<h3 id="42-组件测试推荐方案"><a class="header" href="#42-组件测试推荐方案">4.2 组件测试推荐方案</a></h3>
<ul>
<li>Vitest 对于组件和组合式函数都采用无头渲染的方式 (例如 VueUse 中的 useFavicon 函数)。组件和 DOM 都可以通过 @testing-library/vue 来测试。</li>
<li>Cypress 组件测试 会预期其准确地渲染样式或者触发原生 DOM 事件。可以搭配 @testing-library/cypress 这个库一同进行测试。</li>
</ul>
<p>Vitest 和基于浏览器的运行器之间的主要区别是速度和执行上下文。简而言之，基于浏览器的运行器，如 Cypress，可以捕捉到基于 Node 的运行器（如 Vitest）所不能捕捉的问题（比如样式问题、原生 DOM 事件、Cookies、本地存储和网络故障），但基于浏览器的运行器比 Vitest 慢几个数量级，因为它们要执行打开浏览器，编译样式表以及其他步骤。Cypress 是一个基于浏览器的运行器，支持组件测试。请阅读 Vitest 文档的“比较”这一章 了解 Vitest 和 Cypress 最新的比较信息。</p>
<h3 id="43-组件挂载库"><a class="header" href="#43-组件挂载库">4.3 组件挂载库</a></h3>
<p>组件测试通常涉及到单独挂载被测试的组件，触发模拟的用户输入事件，并对渲染的 DOM 输出进行断言。有一些专门的工具库可以使这些任务变得更简单。</p>
<ul>
<li>@testing-library/vue 是一个 Vue 的测试库，专注于测试组件而不依赖其他实现细节。因其良好的设计使得代码重构也变得非常容易。它的指导原则是，测试代码越接近软件的使用方式，它们就越值得信赖。</li>
<li>@vue/test-utils 是官方的底层组件测试库，用来提供给用户访问 Vue 特有的 API。@testing-library/vue 也是基于此库构建的。</li>
</ul>
<p>我们推荐使用 @testing-library/vue 测试应用中的组件, 因为它更匹配整个应用的测试优先级。只有在你构建高级组件、并需要测试内部的 Vue 特有 API 时再使用 @vue/test-utils。</p>
<h2 id="五-端到端e2e测试"><a class="header" href="#五-端到端e2e测试">五 端到端（E2E）测试#</a></h2>
<p>虽然单元测试为所写的代码提供了一定程度的验证，但单元测试和组件测试在部署到生产时，对应用整体覆盖的能力有限。因此，端到端测试针对的可以说是应用最重要的方面：当用户实际使用你的应用时发生了什么。</p>
<p>端到端测试的重点是多页面的应用表现，针对你的应用在生产环境下进行网络请求。他们通常需要建立一个数据库或其他形式的后端，甚至可能针对一个预备上线的环境运行。</p>
<p>端到端测试通常会捕捉到路由、状态管理库、顶级组件（常见为 App 或 Layout）、公共资源或任何请求处理方面的问题。如上所述，它们可以捕捉到单元测试或组件测试无法捕捉的关键问题。</p>
<p>端到端测试不导入任何 Vue 应用的代码，而是完全依靠在真实浏览器中浏览整个页面来测试你的应用。</p>
<p>端到端测试验证了你的应用中的许多层。可以在你的本地构建的应用中，甚至是一个预上线的环境中运行。针对预上线环境的测试不仅包括你的前端代码和静态服务器，还包括所有相关的后端服务和基础设施。</p>
<p>通过测试用户操作如何影响你的应用，端到端测试通常是提高应用能否正常运行的置信度的关键。</p>
<p>端到端测试的一个主要优点是你可以了解你的应用在多个不同浏览器上运行的情况。尽管理想情况应该是 100% 的跨浏览器覆盖率，但很重要的一点是跨浏览器测试对团队资源的回报是递减的，因为需要额外的时间和机器来持续运行它们。因此，在选择应用所需的跨浏览器测试的数量时，注意权衡是很有必要的。</p>
<p>端到端测试和相应开发过程的主要问题之一是，运行整个套件需要很长的时间。通常情况下，这只在持续集成和部署（CI/CD）管道中进行。现代的端到端测试框架通过增加并行化等功能来帮助解决这个问题，这使得 CI/CD 管道的运行速度比以前快了几倍。此外，在本地开发时，能够有选择地为你正在工作的页面运行单个测试，同时还提供测试的热重载，大大提高了开发者的工作流程和生产力。</p>
<p>当端到端测试在 CI/CD 管道中运行时，它们通常在无头浏览器（即不带界面的浏览器）中运行。因此，当错误发生时，现代端到端测试框架的一个关键特性是能够在不同的测试阶段查看应用的快照、视频，从而深入了解错误的原因。而在很早以前，要手动维护这些集成是非常繁琐的。</p>
<p>推荐方案：</p>
<ul>
<li>Cypress。 Cypress 提供了最完整的端到端解决方案，其具有信息丰富的图形界面、出色的调试性、内置断言和存根、抗剥落性、并行化和快照等诸多特性。而且如上所述，它还提供对 组件测试 的支持。不过，它只支持测试基于 Chromium 的浏览器和 Firefox。</li>
<li>Nightwatch v2 是一个基于 Selenium WebDriver 的端到端测试解决方案。它的浏览器品类支持范围是最广的。</li>
</ul>
<h2 id="六-用例指南"><a class="header" href="#六-用例指南">六 用例指南</a></h2>
<p>在一个基于 Vite 的 Vue 项目中，运行如下命令：</p>
<pre><code class="language-txt">npm install -D vitest happy-dom @testing-library/vue
</code></pre>
<p>接着，更新你的 Vite 配置，添加上 test 选项：</p>
<pre><code class="language-js">// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  // ...
  test: {
    // 启用类似 jest 的全局测试 API
    globals: true,
    // 使用 happy-dom 模拟 DOM
    // 这需要你安装 happy-dom 作为对等依赖（peer dependency）
    environment: 'happy-dom',
  },
})
</code></pre>
<p>如果你在使用 TypeScript，请将 vitest/globals 添加到 tsconfig.json 的 types 字段当中。</p>
<pre><code class="language-json">// tsconfig.json

{
  &quot;compilerOptions&quot;: {
    &quot;types&quot;: [&quot;vitest/globals&quot;]
  }
}
</code></pre>
<p>接着在你的项目中创建名字以 *.test.js 结尾的文件。你可以把所有的测试文件放在项目根目录下的 test 目录中，或者放在源文件旁边的 test 目录中。Vitest 会使用命名规则自动搜索它们。</p>
<pre><code class="language-js">// MyComponent.test.js
import { render } from '@testing-library/vue'
import MyComponent from './MyComponent.vue'

test('it should work', () =&gt; {
  const { getByText } = render(MyComponent, {
    props: {
      /* ... */
    },
  })

  // 断言输出
  getByText('...')
})
</code></pre>
<p>最后，在 package.json 之中添加测试命令，然后运行它：</p>
<pre><code class="language-js">{
  // ...
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;vitest&quot;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="161-vue-性能优化"><a class="header" href="#161-vue-性能优化">16.1-Vue 性能优化</a></h1>
<h2 id="一-web-应用性能优化关注点"><a class="header" href="#一-web-应用性能优化关注点">一 Web 应用性能优化关注点</a></h2>
<p>web 应用性能的两个主要方面是：</p>
<ul>
<li>页面加载性能：首次访问时，应用展示出内容与达到可交互状态的速度。这通常会用 Google 所定义的一系列 Web 指标 (Web Vitals) 来进行衡量，如最大内容绘制 (Largest Contentful Paint，缩写为 LCP) 和首次输入延迟 (First Input Delay，缩写为 FID)。</li>
<li>更新性能：应用响应用户输入更新的速度。比如当用户在搜索框中输入时结果列表的更新速度，或者用户在一个单页面应用 (SPA) 中点击链接跳转页面时的切换速度。</li>
</ul>
<p>为了提高性能，我们首先需要知道如何衡量它。在这方面，有一些很棒的工具可以提供帮助：</p>
<p>用于生产部署的负载性能分析：</p>
<ul>
<li>PageSpeed Insights</li>
<li>WebPageTest</li>
</ul>
<p>用于本地开发期间的性能分析：</p>
<ul>
<li>Chrome 开发者工具“性能”面板：app.config.performance 将会开启 Vue 特有的性能标记，标记在 Chrome 开发者工具的性能时间线上。</li>
<li>Vue 开发者扩展也提供了性能分析的功能。</li>
</ul>
<h2 id="二-页面加载优化"><a class="header" href="#二-页面加载优化">二 页面加载优化</a></h2>
<h3 id="21-选用正确的架构"><a class="header" href="#21-选用正确的架构">2.1 选用正确的架构</a></h3>
<p>如果你的用例对页面加载性能很敏感，请避免将其部署为纯客户端的 SPA，而是让服务器直接发送包含用户想要查看的内容的 HTML 代码。纯客户端渲染存在首屏加载缓慢的问题，这可以通过服务器端渲染 (SSR) 或静态站点生成 (SSG) 来缓解。查看 SSR 指南以了解如何使用 Vue 实现 SSR。如果应用对交互性要求不高，你还可以使用传统的后端服务器来渲染 HTML，并在客户端使用 Vue 对其进行增强。</p>
<p>如果你的主应用必须是 SPA，但还有其他的营销相关页面 (落地页、关于页、博客等)，请单独部署这些页面！理想情况下，营销页面应该是包含尽可能少 JS 的静态 HTML，并用 SSG 方式部署。</p>
<h3 id="22-包体积与-tree-shaking-优化"><a class="header" href="#22-包体积与-tree-shaking-优化">2.2 包体积与 Tree-shaking 优化</a></h3>
<p>一个最有效的提升页面加载速度的方法就是压缩 JavaScript 打包产物的体积。当使用 Vue 时有下面一些办法来减小打包产物体积：</p>
<p>尽可能地采用构建步骤：</p>
<ul>
<li>如果使用的是相对现代的打包工具，许多 Vue 的 API 都是可以被 tree-shake 的。举例来说，如果你根本没有使用到内置的 <Transition> 组件，它将不会被打包进入最终的产物里。Tree-shaking 也可以移除你源代码中其他未使用到的模块。</li>
<li>当使用了构建步骤时，模板会被预编译，因此我们无须在浏览器中载入 Vue 编译器。这在同样最小化加上 gzip 优化下会相对缩小 14kb 并避免运行时的编译开销。</li>
</ul>
<p>在引入新的依赖项时要小心包体积膨胀！在现实的应用中，包体积膨胀通常因为无意识地引入了过重的依赖导致的。</p>
<ul>
<li>如果使用了构建步骤，应当尽量选择提供 ES 模块格式的依赖，它们对 tree-shaking 更友好。举例来说，选择 lodash-es 比 lodash 更好。</li>
<li>查看依赖的体积，并评估与其所提供的功能之间的性价比。如果依赖对 tree-shaking 友好，实际增加的体积大小将取决于你从它之中导入的 API。像 bundlejs.com 这样的工具可以用来做快速的检查，但是根据实际的构建设置来评估总是最准确的。</li>
</ul>
<p>如果你只在渐进式增强的场景下使用 Vue，并想要避免使用构建步骤，请考虑使用 petite-vue (只有 6kb) 来代替。</p>
<h3 id="23-代码分割"><a class="header" href="#23-代码分割">2.3 代码分割</a></h3>
<p>代码分割是指构建工具将构建后的 JavaScript 包拆分为多个较小的，可以按需或并行加载的文件。通过适当的代码分割，页面加载时需要的功能可以立即下载，而额外的块只在需要时才加载，从而提高性能。</p>
<p>像 Rollup (Vite 就是基于它之上开发的) 或者 webpack 这样的打包工具可以通过分析 ESM 动态导入的语法来自动进行代码分割：</p>
<pre><code class="language-js">// lazy.js 及其依赖会被拆分到一个单独的文件中
// 并只在 `loadLazy()` 调用时才加载
function loadLazy() {
  return import('./lazy.js')
}
</code></pre>
<p>懒加载对于页面初次加载时的优化帮助极大，它帮助应用暂时略过了那些不是立即需要的功能。在 Vue 应用中，这可以与 Vue 的异步组件搭配使用，为组件树创建分离的代码块：</p>
<pre><code class="language-js">import { defineAsyncComponent } from 'vue'

// 会为 Foo.vue 及其依赖创建单独的一个块
// 它只会按需加载
//（即该异步组件在页面中被渲染时）
const Foo = defineAsyncComponent(() =&gt; import('./Foo.vue'))
</code></pre>
<p>对于使用了 Vue Router 的应用，强烈建议使用异步组件作为路由组件。Vue Router 已经显性地支持了独立于 defineAsyncComponent 的懒加载。</p>
<h2 id="三-更新优化"><a class="header" href="#三-更新优化">三 更新优化</a></h2>
<h3 id="31-props-稳定性"><a class="header" href="#31-props-稳定性">3.1 Props 稳定性</a></h3>
<p>在 Vue 之中，一个子组件只会在其至少一个 props 改变时才会更新。思考以下示例：</p>
<pre><code class="language-vue">&lt;ListItem v-for=&quot;item in list&quot; :id=&quot;item.id&quot; :active-id=&quot;activeId&quot; /&gt;
</code></pre>
<p>在 <code>&lt;ListItem&gt;</code> 组件中，它使用了 id 和 activeId 两个 props 来确定它是否是当前活跃的那一项。虽然这是可行的，但问题是每当 activeId 更新时，列表中的每一个 <code>&lt;ListItem&gt;</code> 都会跟着更新！</p>
<p>理想情况下，只有活跃状态发生改变的项才应该更新。我们可以将活跃状态比对的逻辑移入父组件来实现这一点，然后让 <ListItem> 改为接收一个 active prop：</p>
<pre><code class="language-vue">&lt;ListItem v-for=&quot;item in list&quot; :id=&quot;item.id&quot; :active=&quot;item.id === activeId&quot; /&gt;
</code></pre>
<p>现在，对于大多数的组件来说，activeId 改变时，它们的 active prop 都会保持不变，因此它们无需再更新。总结一下，这个技巧的核心思想就是让传给子组件的 props 尽量保持稳定。</p>
<h3 id="32-v-once"><a class="header" href="#32-v-once">3.2 v-once</a></h3>
<p>v-once 是一个内置的指令，可以用来渲染依赖运行时数据但无需再更新的内容。它的整个子树都会在未来的更新中被跳过。</p>
<h3 id="33-v-memo"><a class="header" href="#33-v-memo">3.3 v-memo</a></h3>
<p>v-memo 是一个内置指令，可以用来有条件地跳过某些大型子树或者 v-for 列表的更新。</p>
<h2 id="四-通用优化"><a class="header" href="#四-通用优化">四 通用优化</a></h2>
<h3 id="41-大型虚拟列表"><a class="header" href="#41-大型虚拟列表">4.1 大型虚拟列表</a></h3>
<p>所有的前端应用中最常见的性能问题就是渲染大型列表。无论一个框架性能有多好，渲染成千上万个列表项都会变得很慢，因为浏览器需要处理大量的 DOM 节点。</p>
<p>但是，我们并不需要立刻渲染出全部的列表。在大多数场景中，用户的屏幕尺寸只会展示这个巨大列表中的一小部分。我们可以通过列表虚拟化来提升性能，这项技术使我们只需要渲染用户视口中能看到的部分。</p>
<p>要实现列表虚拟化并不简单，幸运的是，你可以直接使用现有的社区库：</p>
<ul>
<li>vue-virtual-scroller</li>
<li>vue-virtual-scroll-grid</li>
<li>vueuc/VVirtualList</li>
</ul>
<h3 id="42-减少大型不可变数据的响应性开销"><a class="header" href="#42-减少大型不可变数据的响应性开销">4.2 减少大型不可变数据的响应性开销</a></h3>
<p>Vue 的响应性系统默认是深度的。虽然这让状态管理变得更直观，但在数据量巨大时，深度响应性也会导致不小的性能负担，因为每个属性访问都将触发代理的依赖追踪。好在这种性能负担通常这只有在处理超大型数组或层级很深的对象时，例如一次渲染需要访问 100,000+ 个属性时，才会变得比较明显。因此，它只会影响少数特定的场景。</p>
<p>Vue 确实也为此提供了一种解决方案，通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理。这使得对深层级属性的访问变得更快，但代价是，我们现在必须将所有深层级对象视为不可变的，并且只能通过替换整个根状态来触发更新：</p>
<pre><code class="language-js">const shallowArray = shallowRef([
  /* 巨大的列表，里面包含深层的对象 */
])

// 这不会触发更新...
shallowArray.value.push(newObject)
// 这才会触发更新
shallowArray.value = [...shallowArray.value, newObject]

// 这不会触发更新...
shallowArray.value[0].foo = 1
// 这才会触发更新
shallowArray.value = [
  {
    ...shallowArray.value[0],
    foo: 1,
  },
  ...shallowArray.value.slice(1),
]
</code></pre>
<h3 id="43-避免不必要的组件抽象"><a class="header" href="#43-避免不必要的组件抽象">4.3 避免不必要的组件抽象</a></h3>
<p>有些时候我们会去创建无渲染组件或高阶组件 (用来渲染具有额外 props 的其他组件) 来实现更好的抽象或代码组织。虽然这并没有什么问题，但请记住，组件实例比普通 DOM 节点要昂贵得多，而且为了逻辑抽象创建太多组件实例将会导致性能损失。</p>
<p>需要提醒的是，只减少几个组件实例对于性能不会有明显的改善，所以如果一个用于抽象的组件在应用中只会渲染几次，就不用操心去优化它了。考虑这种优化的最佳场景还是在大型列表中。想象一下一个有 100 项的列表，每项的组件都包含许多子组件。在这里去掉一个不必要的组件抽象，可能会减少数百个组件实例的无谓性能消耗。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="171-typescript-与-vue-结合"><a class="header" href="#171-typescript-与-vue-结合">17.1-TypeScript 与 Vue 结合</a></h1>
<h2 id="一-为-props-标注类型"><a class="header" href="#一-为-props-标注类型">一 为 Props 标注类型</a></h2>
<h3 id="11-使用-setup"><a class="header" href="#11-使用-setup">1.1 使用 setup</a></h3>
<p>当使用 <code>&lt;script setup&gt;</code> 时，defineProps() 宏函数支持从它的参数中推导类型：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
const props = defineProps({
  foo: { type: String, required: true },
  bar: Number,
})

props.foo // string
props.bar // number | undefined
&lt;/script&gt;
</code></pre>
<p>这被称之为“运行时声明”，因为传递给 defineProps() 的参数会作为运行时的 props 选项使用。</p>
<p>然而，通过泛型参数来定义 props 的类型通常更直接：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
interface Props {
  foo: string
  bar?: number
}

const props = defineProps&lt;Props&gt;()
&lt;/script&gt;
</code></pre>
<p>这被称之为“基于类型的声明”。编译器会尽可能地尝试根据类型参数推导出等价的运行时选项。在这种场景下，我们第二个例子中编译出的运行时选项和第一个是完全一致的。</p>
<h3 id="12-非-setup-场景下"><a class="header" href="#12-非-setup-场景下">1.2 非 setup 场景下</a></h3>
<pre><code class="language-js">import { defineComponent } from 'vue'

export default defineComponent({
  props: {
    message: String,
  },
  setup(props) {
    props.message // &lt;-- 类型：string
  },
})
</code></pre>
<h2 id="二-为组件的-emits-标注类型"><a class="header" href="#二-为组件的-emits-标注类型">二 为组件的 emits 标注类型</a></h2>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
// 运行时
const emit = defineEmits(['change', 'update'])

// 基于类型
const emit = defineEmits&lt;{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}&gt;()
&lt;/script&gt;
</code></pre>
<p>这个类型参数应该是一个带调用签名的类型字面量。这个类型字面量的类型就是返回的 emit 函数的类型。我们可以看到，基于类型的声明使我们可以对所触发事件的类型进行更细粒度的控制。</p>
<p>若没有使用 setup，defineComponent() 也可以根据 emits 选项推导暴露在 setup 上下文中的 emit 函数的类型：</p>
<pre><code class="language-js">import { defineComponent } from 'vue'

export default defineComponent({
  emits: ['change'],
  setup(props, { emit }) {
    emit('change') // &lt;-- 类型检查 / 自动补全
  },
})
</code></pre>
<h2 id="三-为-ref-标注类型"><a class="header" href="#三-为-ref-标注类型">三 为 ref() 标注类型#</a></h2>
<p>ref 会根据初始化时的值推导其类型，也可以通过使用 Ref 指定一个更复杂的类型：</p>
<pre><code class="language-ts">import { ref } from 'vue'
import type { Ref } from 'vue'

const year: Ref&lt;string | number&gt; = ref('2020')

year.value = 2020 // 成功！
</code></pre>
<p>或者，在调用 ref() 时传入一个泛型参数，来覆盖默认的推导行为：</p>
<pre><code class="language-ts">// 得到的类型：Ref&lt;string | number&gt;
const year = ref&lt;string | number&gt;('2020')

year.value = 2020 // 成功！
</code></pre>
<p>如果你指定了一个泛型参数但没有给出初始值，那么最后得到的就将是一个包含 undefined 的联合类型：</p>
<pre><code class="language-ts">// 推导得到的类型：Ref&lt;number | undefined&gt;
const n = ref&lt;number&gt;()
</code></pre>
<h2 id="四-为-reactive-标注类型"><a class="header" href="#四-为-reactive-标注类型">四 为 reactive() 标注类型</a></h2>
<p>reactive() 也会隐式地从它的参数中推导类型，要显式地标注一个 reactive 变量的类型，我们可以使用接口：</p>
<pre><code class="language-ts">import { reactive } from 'vue'

interface Book {
  title: string
  year?: number
}

const book: Book = reactive({ title: 'Vue 3 指引' })
</code></pre>
<h2 id="五-为-computed-标注类型"><a class="header" href="#五-为-computed-标注类型">五 为 computed() 标注类型#</a></h2>
<p>computed() 会自动从其计算函数的返回值上推导出类型，可以通过泛型参数显式指定类型：</p>
<pre><code class="language-ts">const double = computed&lt;number&gt;(() =&gt; {
  // 若返回值不是 number 类型则会报错
})
</code></pre>
<h2 id="六-为事件处理函数标注类型"><a class="header" href="#六-为事件处理函数标注类型">六 为事件处理函数标注类型#</a></h2>
<p>在处理原生 DOM 事件时，应该为我们传递给事件处理函数的参数正确地标注类型。让我们看一下这个例子：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
function handleChange(event) {
  // `event` 隐式地标注为 `any` 类型
  console.log(event.target.value)
}
&lt;/script&gt;

&lt;template&gt;
  &lt;input type=&quot;text&quot; @change=&quot;handleChange&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>没有类型标注时，这个 event 参数会隐式地标注为 any 类型。这也会在 tsconfig.json 中配置了 &quot;strict&quot;: true 或 &quot;noImplicitAny&quot;: true 时报出一个 TS 错误。因此，建议显式地为事件处理函数的参数标注类型。此外，你可能需要显式地强制转换 event 上的属性：</p>
<pre><code class="language-ts">function handleChange(event: Event) {
  console.log((event.target as HTMLInputElement).value)
}
</code></pre>
<h2 id="七-为-provide--inject-标注类型"><a class="header" href="#七-为-provide--inject-标注类型">七 为 provide / inject 标注类型</a></h2>
<p>provide 和 inject 通常会在不同的组件中运行。要正确地为注入的值标记类型，Vue 提供了一个 InjectionKey 接口，它是一个继承自 Symbol 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型：</p>
<pre><code class="language-ts">import { provide, inject } from 'vue'
import type { InjectionKey } from 'vue'

const key = Symbol() as InjectionKey&lt;string&gt;

provide(key, 'foo') // 若提供的是非字符串值会导致错误

const foo = inject(key) // foo 的类型：string | undefined
</code></pre>
<p>建议将注入 key 的类型放在一个单独的文件中，这样它就可以被多个组件导入。</p>
<p>当使用字符串注入 key 时，注入值的类型是 unknown，需要通过泛型参数显式声明：</p>
<pre><code class="language-ts">const foo = inject&lt;string&gt;('foo') // 类型：string | undefined
</code></pre>
<p>注意注入的值仍然可以是 undefined，因为无法保证提供者一定会在运行时 provide 这个值。</p>
<p>当提供了一个默认值后，这个 undefined 类型就可以被移除：</p>
<pre><code class="language-ts">const foo = inject&lt;string&gt;('foo', 'bar') // 类型：string
</code></pre>
<p>如果你确定该值将始终被提供，则还可以强制转换该值：</p>
<pre><code class="language-ts">const foo = inject('foo') as string
</code></pre>
<h2 id="八-为模板引用标注类型"><a class="header" href="#八-为模板引用标注类型">八 为模板引用标注类型#</a></h2>
<p>模板引用需要通过一个显式指定的泛型参数和一个初始值 null 来创建：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
import { ref, onMounted } from 'vue'

const el = ref&lt;HTMLInputElement | null&gt;(null)

onMounted(() =&gt; {
  el.value?.focus()
})
&lt;/script&gt;

&lt;template&gt;
  &lt;input ref=&quot;el&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>注意为了严格的类型安全，有必要在访问 el.value 时使用可选链或类型守卫。这是因为直到组件被挂载前，这个 ref 的值都是初始的 null，并且在由于 v-if 的行为将引用的元素卸载时也可以被设置为 null。</p>
<h2 id="九-为组件模板引用标注类型"><a class="header" href="#九-为组件模板引用标注类型">九 为组件模板引用标注类型</a></h2>
<p>有时，你可能需要为一个子组件添加一个模板引用，以便调用它公开的方法。举例来说，我们有一个 MyModal 子组件，它有一个打开模态框的方法：</p>
<p>有时，你可能需要为一个子组件添加一个模板引用，以便调用它公开的方法。举例来说，我们有一个 MyModal 子组件，它有一个打开模态框的方法：</p>
<pre><code class="language-vue">&lt;!-- MyModal.vue --&gt;
&lt;script setup lang=&quot;ts&quot;&gt;
import { ref } from 'vue'

const isContentShown = ref(false)
const open = () =&gt; (isContentShown.value = true)

defineExpose({
  open,
})
&lt;/script&gt;
</code></pre>
<p>为了获取 MyModal 的类型，我们首先需要通过 typeof 得到其类型，再使用 TypeScript 内置的 InstanceType 工具类型来获取其实例类型：</p>
<pre><code class="language-vue">&lt;!-- App.vue --&gt;
&lt;script setup lang=&quot;ts&quot;&gt;
import MyModal from './MyModal.vue'

const modal = ref&lt;InstanceType&lt;typeof MyModal&gt; | null&gt;(null)

const openModal = () =&gt; {
  modal.value?.open()
}
&lt;/script&gt;
</code></pre>
<p>注意，如果你想在 TypeScript 文件而不是在 Vue SFC 中使用这种技巧，需要开启 Volar 的 Takeover 模式。</p>
<h2 id="十-扩展全局属性"><a class="header" href="#十-扩展全局属性">十 扩展全局属性</a></h2>
<p>某些插件会通过 app.config.globalProperties 为所有组件都安装全局可用的属性。举例来说，我们可能为了请求数据而安装了 this.$http，或者为了国际化而安装了 this.$translate。为了使 TypeScript 更好地支持这个行为，Vue 暴露了一个被设计为可以通过 TypeScript 模块扩展来扩展的 ComponentCustomProperties 接口：</p>
<pre><code class="language-ts">import axios from 'axios'

declare module 'vue' {
  interface ComponentCustomProperties {
    $http: typeof axios
    $translate: (key: string) =&gt; string
  }
}
</code></pre>
<p>我们可以将这些类型扩展放在一个 .ts 文件，或是一个影响整个项目的 *.d.ts 文件中。无论哪一种，都应确保在 tsconfig.json 中包括了此文件。对于库或插件作者，这个文件应该在 package.json 的 types 属性中被列出。</p>
<p>为了利用模块扩展的优势，你需要确保将扩展的模块放在 TypeScript 模块 中。 也就是说，该文件需要包含至少一个顶级的 import 或 export，即使它只是 export {}。如果扩展被放在模块之外，它将覆盖原始类型，而不是扩展!</p>
<pre><code class="language-ts">// 不工作，将覆盖原始类型。
declare module 'vue' {
  interface ComponentCustomProperties {
    $translate: (key: string) =&gt; string
  }
}
</code></pre>
<pre><code class="language-ts">// 正常工作。
export {}

declare module 'vue' {
  interface ComponentCustomProperties {
    $translate: (key: string) =&gt; string
  }
}
</code></pre>
<h2 id="十一-扩展自定义选项"><a class="header" href="#十一-扩展自定义选项">十一 扩展自定义选项</a></h2>
<p>某些插件，比如 vue-router，提供了一些自定义的组件选项，比如 beforeRouteEnter：</p>
<pre><code class="language-ts">import { defineComponent } from 'vue'

export default defineComponent({
  beforeRouteEnter(to, from, next) {
    // ...
  },
})
</code></pre>
<p>如果没有确切的类型标注，这个钩子函数的参数会隐式地标注为 any 类型。我们可以为 ComponentCustomOptions 接口扩展自定义的选项来支持：</p>
<pre><code class="language-ts">import { Route } from 'vue-router'

declare module 'vue' {
  interface ComponentCustomOptions {
    beforeRouteEnter?(to: Route, from: Route, next: () =&gt; void): void
  }
}
</code></pre>
<p>现在这个 beforeRouteEnter 选项会被准确地标注类型。注意这只是一个例子——像 vue-router 这种类型完备的库应该在它们自己的类型定义中自动执行这些扩展。</p>
<p>这种类型扩展和全局属性扩展受到相同的限制。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-nestjs-框架基础"><a class="header" href="#011-nestjs-框架基础">01.1-Nestjs 框架基础</a></h1>
<h2 id="一-nest-简介"><a class="header" href="#一-nest-简介">一 Nest 简介</a></h2>
<p>Nest 是使用 TypeScript 开发的 Node 服务端框架，其文档地址为：<a href="https://docs.nestjs.com/">https://docs.nestjs.com/</a>。</p>
<p>Express 与 Koa 适合小型项目，如个人博客等，但是其约定很差，项目格式会因为不同开发者的个人风格而千奇百怪，阿里的 egg 虽然也做了约束，但是仍然只适合对项目做了普通约束，他们都是只适合作为上层框架的底层框架而存在。</p>
<p>Nest 借鉴了 Spring、Anular 的设计思想， 是 NodeJS 真正意义上的第一个 Web 框架，本质上 Nest 解决的是：Express、Koa 这些底层框架在开发时遇到的项目架构问题，即：高效性、可扩展、可靠性。</p>
<p>Nest 的默认内核是 Express（可切换为 fastify），主要特点有：</p>
<ul>
<li>基于 TypeScript 语言开发，具备类型校验功能，也有更便利的语法联想，适合大型工程项目</li>
<li>具备依赖注入（DI）、控制反转（IOC）功能，解耦了业务代码</li>
<li>提供了大量 cli 工具命令与第三方模块，开发起来相对方便</li>
<li>支持函数式、面向对象、函数式响应编程等范式</li>
</ul>
<h2 id="二-nest-初步使用"><a class="header" href="#二-nest-初步使用">二 Nest 初步使用</a></h2>
<h3 id="21-环境搭建"><a class="header" href="#21-环境搭建">2.1 环境搭建</a></h3>
<pre><code class="language-txt"># 安装 nest 脚手架
npm i -g @nestjs/cli

# 创建 nest 项目
nest new demo

# 启动
cd demo
npm run start:dev           # :参数为启动形式，:dev 支持热重启

# 访问
http://localhost:3000
</code></pre>
<h3 id="22-目录分析"><a class="header" href="#22-目录分析">2.2 目录分析</a></h3>
<pre><code class="language-txt">src
├── main.ts                 # 入口：使用 NestFactory 创建了实例
├── app.module.ts           # 应用程序的根模块
├── app.controller.ts       # 带有单个路由的基本控制器示例
├── app.controller.spec.ts  # 具备拦截功能
├── app.service.ts          # 服务层示例
</code></pre>
<p>nest 项目是由 ts-node 运行的，可以在开发时节省编译 .ts 的过程，其目录是按照业务模块进行划分（module），比如<code>user.module.ts</code>，<code>order.module.ts</code>，在每个模块下进行控制层、服务层的开发。</p>
<p>注意：
<strong>nest 的工厂管理了大量的模块（module），当使用到该模块时，直接取用即可，由 nest 框架自己负责注入，而无需开发者自己手动去 new。</strong>，这也是 Java 的 Web 框架 Spring 的核心思想。</p>
<h3 id="23-nest-cli-命令使用"><a class="header" href="#23-nest-cli-命令使用">2.3 nest cli 命令使用</a></h3>
<p>nest 无需手动创建目录，并为目录中的 controller、service、module 添加依赖关系，而是使用 cli 命令即可自动完成上述功能：</p>
<pre><code class="language-txt"># 创建模块
nest g mo user          # g 即 generator，mo 是 module 的缩写

# 在模块基础上创建控制层
nest g co user          # co 是 controller 的缩写

# 在模块基础上创建服务层
nest g s user           # s 是 service 的缩写

# 创建一个完整的模块：包含控制器和服务层以及模块
nest g res user
</code></pre>
<p>贴士：<code>nest --help</code> 可以查看缩写规范。</p>
<h3 id="24-在-module-中注册控制器与服务"><a class="header" href="#24-在-module-中注册控制器与服务">2.4 在 module 中注册控制器与服务</a></h3>
<p>在 Nestjs 中，所有的 controller 和 service 都要在对应的 module 中注册：</p>
<pre><code class="language-ts">import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
</code></pre>
<h2 id="三-控制层"><a class="header" href="#三-控制层">三 控制层</a></h2>
<h3 id="31-路由参数"><a class="header" href="#31-路由参数">3.1 路由参数</a></h3>
<p>Nestjs 路由不是集中式管理，而是分散在 controller 中。如图所示：</p>
<p><img src="09-%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-Nest/../images/nest/01.png" alt="控制器" /></p>
<p>控制器使用了大量请求相关的装饰器来实现业务：</p>
<pre><code class="language-ts">import { Controller, Get } from '@nestjs/common'

import { CatsService } from './cats.service'

@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  // query 参数：自动解析参数
  @Get('demo1')
  demoA(@Query() query: Record&lt;string, any&gt;) {
    console.log('query:', query)
    return {}
  }

  // 多个参数
  @Get('demo2')
  demoB(@Query() { uid, name }): string {
    console.log(uid, name)
    return {}
  }

  // param 参数
  @Get('demo3/:uid')
  demoC(@Param() param: { uid: number }) {
    console.log('uid:', param.uid)
    return {}
  }

  // body 参数：这里如果前端传递了非 dto 属性，也是被接收到了。因为 TS 不严格，只在开发时检查！
  // dto 层主要是在开发阶段进行前端数据校验，其类型如下：
  //   export class CreateDemoDto implements Demo {
  //     uid: number
  //     name: string
  //     username: string
  //     password: string
  // }
  @Post('demo4')
  demoE(@Body() demo: CreateDemoDto) {
    console.log('demo:', demo)
    return {}
  }
}
</code></pre>
<h3 id="32-路由前缀-1"><a class="header" href="#32-路由前缀-1">3.2 路由前缀</a></h3>
<p>如果需要在所有请求之前加上 prefix，可以在 main.ts 中直接设置 GlobalPrefix：</p>
<pre><code class="language-ts">import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  app.setGlobalPrefix('api/v1')
  await app.listen(3000)
}
bootstrap()
</code></pre>
<h3 id="33-路由请求方式装饰器"><a class="header" href="#33-路由请求方式装饰器">3.3 路由请求方式装饰器</a></h3>
<p>除了使用 @Get 装饰器，我们还可以使用其它 HTTP 方法装饰器。比如：</p>
<ul>
<li>@Put()</li>
<li>@Delete()</li>
<li>@Patch()</li>
<li>@Options()</li>
<li>@Head()</li>
<li>@All()： All 并不是 HTTP 的方法，而是 Nest 提供的一个快捷方式，表示接收任何类型的 HTTP 请求。</li>
</ul>
<p>Nest 支持基于模式的路由规则匹配，比如 <code>*</code> 表示匹配任意的字母组合：</p>
<pre><code class="language-ts">// 将匹配 abcd, ab_cd, abecd 等规则
@Get('ab*cd')
</code></pre>
<p>匹配规则如下：</p>
<ul>
<li><code>*</code> 匹配任意数量的任意字符</li>
<li><code>?</code> 匹配任意单个字符</li>
<li><code>[abc]</code> 匹配方括号中的任意一个字符</li>
<li><code>[a-z]</code> 匹配字母、数字区间</li>
</ul>
<p>贴士：路由的注册顺序与控制器类中的方法顺序相关，如果你先装饰了一个 cats/:id 的路由，后面又装饰了一个 cats 路由。</p>
<h3 id="34-路由请求对象"><a class="header" href="#34-路由请求对象">3.4 路由请求对象</a></h3>
<p>请求对象包括：</p>
<pre><code class="language-ts">@Request() req
@Response() res
@Next() next
@Session() req.session
@Param(key?: string) req.params / req.params[key]
@Body(key?: string) req.body / req.body[key]
@Query(key?: string) req.query / req.query[key]
@Headers(name?: string) req.headers / req.headers[name]
</code></pre>
<p>示例：</p>
<pre><code class="language-ts">// http://localhost:3000/?username=zs
@Get()
getHello(@Query() q: String): string {
    console.log(q)  // { username: 'zs' }
    return this.appService.getHello();
}
</code></pre>
<h3 id="35-响应对象"><a class="header" href="#35-响应对象">3.5 响应对象</a></h3>
<p>响应的默认状态码是 200，POST 则是 201，可以采用下面的方式指定响应：</p>
<ul>
<li>内置方法：推荐该方式。如果返回一个 js 对象或者数据会自动序列化 <code>json</code>，如果是字符串则不会序列化。可以使用@HttpCode()装饰器改变</li>
<li>指定框架：可以使用<code>@Res()</code>装饰器装饰响应对象，这样可以使用 <code>Express</code> 的方式处理响应： <code>res.status(200).send()</code></li>
</ul>
<p>使用装饰器 @HttpCode(204) 来指定处理器级别的 默认 HttpCode 为 204 示例：</p>
<pre><code class="language-ts">@Post()
@HttpCode(204)
create() {
  return 'This action adds a new cat';
}
</code></pre>
<p>可以使用 <code>@Header()</code> 来设置自定义的请求头，也可以使用 <code>response.header()</code> 设置:</p>
<pre><code class="language-ts">@Post()
@Header('Cache-Control', 'none')
create() {
return 'This action adds a new cat';
}
</code></pre>
<h2 id="四-服务层"><a class="header" href="#四-服务层">四 服务层</a></h2>
<p>在 MVC 模式中，controller 通过 model 获取数据。对应的，在 Nestjs 中，controller 负责处理传入的请求，并调用对应的 service 完成业务处理，返回对客户端的响应。service 可以看做夹在 controller 和 model 之间的一层，在 service 调用 DAO（在 Nestjs 中是各种 ORM 工具或者自己封装的 DAO 层）实现数据库的访问，进行数据的处理整合。</p>
<pre><code class="language-ts">import { Injectable } from '@nestjs/common'

@Injectable()
export class CatsService {
  getCat(id: string): string {
    return `This action returns ${id} cats`
  }
}
</code></pre>
<p>上面代码中通过 @Injectable() 定义了一个 service，这样你就可以在其他 controller 或者 service 中注入这个 service。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-nestjs-设计思想-控制反转与切面编程"><a class="header" href="#021-nestjs-设计思想-控制反转与切面编程">02.1-Nestjs 设计思想-控制反转与切面编程</a></h1>
<h2 id="一-控制反转"><a class="header" href="#一-控制反转">一 控制反转</a></h2>
<h3 id="11-控制反转的意义"><a class="header" href="#11-控制反转的意义">1.1 控制反转的意义</a></h3>
<p>控制反转 (Inversion of Control) 即事情的控制权转交给其他人，在编程中，程序的流程控制权发生了转变。在反转前：项目的代码决定程序的工作流程，并调用框架代码，在反转后，框架代码反而直接决定了程序的工作流程，并能调用项目代码。控制反转的核心作用就是：复用。</p>
<p>常见的控制反转实现方式有：</p>
<ul>
<li>依赖注入（DI:Dependency Inject）：被动接收依赖对象，由容器将被依赖对象注入到对象内部；</li>
<li>依赖查询 (DL:Dependency Lookup)：主动查询依赖对象，由对象自身通过 服务定位器 查询被依赖对象；依赖查询也经常以服务定位器模式（Service Locator）的形式出现。</li>
</ul>
<h3 id="12-依赖注入实现"><a class="header" href="#12-依赖注入实现">1.2 依赖注入实现</a></h3>
<p>DI 是面向对象中控制反转最常见的实现方式，可以极大程度降低代码的耦合度。</p>
<p>下面是传统开发的示例：</p>
<pre><code class="language-js">// 制作一台电脑，需要CPU与屏幕
class Cpu {}
class Screen {}

// 电脑类：内部包含Cpu类与Screen类
class Computer {
  cpu: Cpu
  screen: Screen
  constructor() {
    this.cpu = new Cpu()
    this.screen = new Screen()
  }
  show() {
    console.log(this.cpu)
    console.log(this.screen)
  }
}

const c = new Computer()
c.show()
</code></pre>
<p>此时 Computer 类就依赖了 Cpu 和 Screen 类，构造器执行了：实例化、赋值两个动作。现在市面上 CPU 类型很多，比如 X86，Arm，如果现在 CPU 现在更换为 Arm 类型：ArmCpu，那么 Computer 类的属性 cpu 类型也要替换为 ArmCpu：</p>
<pre><code class="language-js">class Cpu {}
class Screen {}
class ArmCpu {}

class Computer {
  cpu: ArmCpu
  screen: Screen
  constructor() {
    this.cpu = new ArmCpu()
    this.screen = new Screen()
  }
  show() {
    console.log(this.cpu)
    console.log(this.screen)
  }
}
</code></pre>
<p>依次类推，如果当初用到 Computer 类的地方很多，或者有很多电脑类都依赖这个属性，那么都要执行对应替换，这是无法想象的。</p>
<p>使用 IoC 改造下：</p>
<pre><code class="language-js">class Cpu {}
class Screen {}

// 新增容器类，用于构建真正的实例
class Container {
  pool: Map&lt;string, any&gt;
  constructor() {
    this.pool = new Map()
  }
  resgisterr&lt;T&gt;(name: string, constructor: T) {
    this.pool.set(name, constructor)
  }
  get(name: string) {
    const Target = this.pool.get(name)
    if (!Target) {
      return null
    }
    return new Target()
  }
}

const container = new Container()
container.resgisterr('Cpu', Cpu)
container.resgisterr('Screen', Screen)

class Computer {
  cpu: Cpu
  screen: Screen
  constructor() {
    this.cpu = c.get('Cpu')
    this.screen = c.get('Screen')
  }
  show() {
    console.log(this.cpu)
    console.log(this.screen)
  }
}

const c = new Computer()
c.show()
</code></pre>
<p>Container 类即是 IoC 的容器类，用于关联要使用的类 Computer 与其他类 Cpu、Screen 之间进行关联。我们如果需要 Computer 的实例，并不是通过 new 来实现，而是通过容器的 get 方法来实现，解除了 Computer 与 Cpu、Screen 之间的耦合，即：Cpu、Screen 的实例化的流程交给了 Container。如果现在我们要调整 Computer 的属性类型，只需要调整容器中输出的类型即可。</p>
<h2 id="二-nest-中的装饰器的使用"><a class="header" href="#二-nest-中的装饰器的使用">二 Nest 中的装饰器的使用</a></h2>
<p>Nest 中，通过 @Injectable 装饰器向 IoC 容器注册：</p>
<pre><code class="language-ts">// 在 service 层向 IoC 注册
import { Injectable } from '@nestjs/common'
import { Cat } from './interfaces/cat.interface'

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = []

  create(cat: Cat) {
    this.cats.push(cat)
  }

  findAll(): Cat[] {
    return this.cats
  }
}

// 在控制层注入 service 实例
import { Controller, Get, Post, Body } from '@nestjs/common'
import { CreateCatDto } from './dto/create-cat.dto'
import { CatsService } from './cats.service'
import { Cat } from './interfaces/cat.interface'

@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto)
  }

  @Get()
  async findAll(): Promise&lt;Cat[]&gt; {
    return this.catsService.findAll()
  }
}
</code></pre>
<p>注入进容器工厂中的类才能在其他地方使用他的实例，CatsService 作为一个 privider，需要在 module 中注册，这样在该 module 启动时，会解析 module 中所有的依赖，当 module 销毁时，provider 也会一起销毁。</p>
<pre><code class="language-ts">import { Module } from '@nestjs/common'
import { CatsController } from './cats/cats.controller'
import { CatsService } from './cats/cats.service'

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class ApplicationModule {}
</code></pre>
<h2 id="三-面向切面编程-aop"><a class="header" href="#三-面向切面编程-aop">三 面向切面编程 AOP</a></h2>
<p>面向切面编程（Aspect Oriented Programming，简称 AOP）主要是针对业务处理过程中的切面进行提取，在某个步骤和阶段进行一些操作，从而达到 DRY（Don't Repeat Yourself）的目的。AOP 对 OOP 来说，是一种补充，比如可以在某一切面中对全局的 Log、错误进行处理，这种一刀切的方式，也就意味着，AOP 的处理方式相对比较粗粒度。</p>
<p>在 Nestjs 中，AOP 分为下面几个部分（按顺序排列）：</p>
<ul>
<li>Middlewares</li>
<li>Guards</li>
<li>Interceptors (在流被操纵之前)</li>
<li>Pipes</li>
<li>Interceptors (在流被操纵之后)</li>
<li>Exception filters (如果发现任何异常)</li>
</ul>
<p>AOP 的核心意义：AOP 能在不破坏封装功能的前提下，额外增加功能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="022-nestjs-设计思想-核心概念"><a class="header" href="#022-nestjs-设计思想-核心概念">02.2-Nestjs 设计思想-核心概念</a></h1>
<h2 id="一-nestj-模块"><a class="header" href="#一-nestj-模块">一 Nestj 模块</a></h2>
<h3 id="11-模块的基本使用"><a class="header" href="#11-模块的基本使用">1.1 模块的基本使用</a></h3>
<p>模块化可以更加清晰地组织代码，Nest 通过 Module 装饰器把同一个分层下的代码组织成单独的模块，并能互相聚合称为一个功能完备的功能块。如图所示：</p>
<p><img src="09-%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-Nest/../images/nest/02.png" alt="模块" /></p>
<p>实例代码：</p>
<pre><code class="language-ts">import { Module } from '@nestjs/common'
import { CatsController } from './cats.controller'
import { CatsService } from './cats.service'
import { CoreModule } from './core/core.module'

@Module({
  imports: [CoreModule],
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
</code></pre>
<p>每个应用都至少有一个根模块，根模块就是 Nest 应用的入口。Nest 会从这里查找出整个应用的依赖/调用图。@Module() 装饰器的四个参数是：</p>
<ul>
<li>imports：该模块需要使用其他模块时，在此处将需要使用的模块导入</li>
<li>controllers：该模块需要用到的控制器集合</li>
<li>providers：该模块中共享的 provider 集合，provider 可以是 service 等</li>
<li>exports：让该模块可以被其他模块使用。如果要在不同模块之间共享 provider 可以在 exports 参数中指定。</li>
</ul>
<h3 id="12-全局模块"><a class="header" href="#12-全局模块">1.2 全局模块</a></h3>
<p>Nest 默认会将 provider 注册到模块作用域上，如果没有显式的导出 provider，那么其他地方就无法使用。如果需要让一个模块随处可见，那么就可以使用 <code>@Global()</code> 装饰器来装饰这个模块：</p>
<pre><code class="language-ts">@Global()
@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
</code></pre>
<h3 id="13-共享模块"><a class="header" href="#13-共享模块">1.3 共享模块</a></h3>
<p>Nest 中的模块是单例的，可以在不同的模块之间共享任意 Provider 实例，且可以重复导出：</p>
<pre><code class="language-ts">@Module({
  imports: [CommonModule],
  exports: [CommonModule],
})
export class CoreModule {}
</code></pre>
<p>模块的构造函数中也可以注入指定的 provider，通常用于配置参数：</p>
<pre><code class="language-ts">@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {
  constructor(private readonly catsService: CatsService) {}
}
</code></pre>
<p>注意：模块类本身并不可以装饰成 provider，因为这会造成循环依赖。</p>
<h3 id="14-动态模块"><a class="header" href="#14-动态模块">1.4 动态模块</a></h3>
<p>模块的静态方法 forRoot 返回一个动态模块，可以是同步或者异步模块，用于自定义模块：</p>
<pre><code class="language-ts">import { Module, DynamicModule } from '@nestjs/common'
import { createDatabaseProviders } from './database.providers'
import { Connection } from './connection.provider'

@Module({
  providers: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options?): DynamicModule {
    const providers = createDatabaseProviders(options, entities)
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    }
  }
}
</code></pre>
<h2 id="二-生命周期"><a class="header" href="#二-生命周期">二 生命周期</a></h2>
<p><img src="09-%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-Nest/../images/nest/life.svg" alt="nest生命周期" /></p>
<p>贴士：这些环节的本质只是切面，在这个切面中执行图中对应的钩子方法而已。</p>
<h2 id="三-nest-核心设计"><a class="header" href="#三-nest-核心设计">三 nest 核心设计</a></h2>
<p>nest 的核心设计有：</p>
<ul>
<li>控制器 Controllers：处理请求</li>
<li>服务 Services：数据访问与核心逻辑</li>
<li>模块 Modules：组织代码</li>
<li>管道 Pipes：校验请求数据</li>
<li>过滤器 Filters：处理请求时的错误</li>
<li>守卫 Guards：鉴权、认证</li>
<li>拦截器 Interceptors：给请求、响应加入额外逻辑</li>
<li>存储库 Repositories：处理数据库中数据</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-nestjs-主要功能-中间件"><a class="header" href="#031-nestjs-主要功能-中间件">03.1-Nestjs 主要功能-中间件</a></h1>
<h2 id="一-中间件的功能"><a class="header" href="#一-中间件的功能">一 中间件的功能</a></h2>
<p>中间件的本质是一个函数，在路由处理器之前会被调用。所以中间件函数可以访问到请求对象、响应对象、next()函数，如果 Nest 的内核采用的是 Express，则 Nest 项目的中间件其实就是 Express，此时中间件函数主要功能是：</p>
<ul>
<li>执行任意的代码</li>
<li>对请求/响应做操作</li>
<li>终结请求-响应周期</li>
<li>调用下一个栈中的中间件函数</li>
<li>如果当前的中间间函数没有终结请求响应周期，那么它必须调用 next() 方法将控制权传递给下一个中间件函数。否则请求将被挂起</li>
</ul>
<p><img src="09-%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-Nest/../images/nest/03.png" alt="中间件" /></p>
<h2 id="二-中间件的实现与应用"><a class="header" href="#二-中间件的实现与应用">二 中间件的实现与应用</a></h2>
<h3 id="21-类中间件"><a class="header" href="#21-类中间件">2.1 类中间件</a></h3>
<p>Nest 的中间件可以是函数也可以是类，如果用类实现，则需要使用 @Injectable() 装饰，并且实现 NestMiddleware 接口：</p>
<pre><code class="language-ts">import { Injectable, NestMiddleware } from '@nestjs/common'
import { Request, Response } from 'express'

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: Function) {
    console.log('Request...')
    next()
  }
}
</code></pre>
<h3 id="22-函数式中间件"><a class="header" href="#22-函数式中间件">2.2 函数式中间件</a></h3>
<p>函数式中间件可以直接是一个无以来的函数：</p>
<pre><code class="language-ts">export function logger(req, res, next) {
  console.log(`Request...`)
  next()
}
</code></pre>
<h3 id="23-应用中间件"><a class="header" href="#23-应用中间件">2.3 应用中间件</a></h3>
<p>中间件在模块类的 <code>configure()</code> 方法中应用：</p>
<pre><code class="language-ts">export class DemoModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    // 只让 /cats 路由走 LoggerMiddleware
    consumer.apply(LoggerMiddleware).forRoutes('cats')
  }
}
</code></pre>
<p>forRoutes 方法表示只将中间件应用在 cats 路由上，还可以指定 HTTP 方法，设定路由通配符：</p>
<pre><code class="language-ts">// 所有路由都要走该中间件
.forRoutes('')

// 只有 /cats 路由下的GET方法才会走该中间件
.forRoutes({ path: 'cats', method: RequestMethod.GET })

// /ab*cd 路由下的所有方法都会走该中间件
.forRoutes({ path: 'ab*cd', method: RequestMethod.ALL })

// 所有Demo控制器都会走该中间件
.forRoutes(DemoController)
</code></pre>
<p>路由规则也实现忽略：</p>
<pre><code class="language-ts">consumer
  .apply(LoggerMiddleware)
  .exclude(
    { path: 'cats', method: RequestMethod.GET },
    { path: 'cats', method: RequestMethod.POST }
  )
  .forRoutes(CatsController)
</code></pre>
<p>注意： exclude 方法不能运用在函数式的中间件上，而且这里指定的 path 也不支持通配符，这只是个快捷方法，如果你真的需要某种路由级别的控制，那完全可以把逻辑写在一个单独的中间件中。</p>
<h3 id="24-多个中间件"><a class="header" href="#24-多个中间件">2.4 多个中间件</a></h3>
<p>apply 方法可以传入多个中间件：</p>
<pre><code class="language-ts">consumer.apply(cors(), helmet(), logger).forRoutes(CatsController)
</code></pre>
<h3 id="25-全局中间件"><a class="header" href="#25-全局中间件">2.5 全局中间件</a></h3>
<p>实现了 INestApplication 接口的实例上调用 use(函数式中间件) 方法可以实现全局中间件功能：</p>
<pre><code class="language-ts">const app = await NestFactory.create(ApplicationModule)
app.use(logger)
await app.listen(3000)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="032-nestjs-主要功能-异常过滤器"><a class="header" href="#032-nestjs-主要功能-异常过滤器">03.2-Nestjs 主要功能-异常过滤器</a></h1>
<h2 id="一-异常类的使用"><a class="header" href="#一-异常类的使用">一 异常类的使用</a></h2>
<h3 id="11-基础异常类的使用"><a class="header" href="#11-基础异常类的使用">1.1 基础异常类的使用</a></h3>
<p>Nest 内部配置了全局异常类，默认情况下未处理的异常会被全局异常 HttpException 处理：</p>
<p><img src="09-%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-Nest/../images/nest/04.png" alt="过滤器" /></p>
<p>示例如下：</p>
<pre><code class="language-ts">// 服务端抛出异常
@Get()
async find() {
  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);
}

// 客户端收到的信息
{
  &quot;statusCode&quot;: 403,
  &quot;message&quot;: &quot;Forbidden&quot;
}
</code></pre>
<p>此外为了减少样板代码，官方还提供了继承自 HttpException 的可用异常，如：BadRequestException、NotFoundException 等，用法同上。</p>
<p>如果一个未识别的异常，即非 HttpException 类型的异常被抛出，则会返回下面的信息：</p>
<pre><code class="language-ts">{
  &quot;statusCode&quot;: 500,
  &quot;message&quot;: &quot;Internal server error&quot;
}
</code></pre>
<h3 id="12-自定义异常类"><a class="header" href="#12-自定义异常类">1.2 自定义异常类</a></h3>
<p>当然也可以简单的自定义返回信息：</p>
<pre><code class="language-ts">@Get()
async findAll() {
  throw new HttpException({
    status: HttpStatus.FORBIDDEN,
    error: 'This is a custom message',
  }, 403);
}
</code></pre>
<p>如果想要自定义一些异常信息，最好的办法是自己实现一个异常类：</p>
<pre><code class="language-ts">// 定义一个sql异常，专门用于抛出数据库异常
export class SqlException extends HttpException {
  constructor(excetption: string) {
    super(excetption, 200)
  }
}

// 定义一个server异常，结合Code使用，专门用于抛出服务端所有异常
export class ServerException extends HttpException {
  public code: number
  constructor(excetption: string, code: number) {
    super(excetption, 200)
    this.code = code
  }
}
</code></pre>
<h2 id="二-异常过滤器的使用"><a class="header" href="#二-异常过滤器的使用">二 异常过滤器的使用</a></h2>
<h3 id="21-创建异常过滤器"><a class="header" href="#21-创建异常过滤器">2.1 创建异常过滤器</a></h3>
<p>如果需要给异常的返回值动态添加一些信息，需要异常过滤器实现，且该过滤器必须实现泛型接口 <code>ExceptionFilter&lt;T&gt;</code>：</p>
<pre><code class="language-ts">import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
} from '@nestjs/common'
import { Request, Response } from 'express'

// 也可以捕获自定义异常 @Catch(MyException)
@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp()
    const response = ctx.getResponse&lt;Response&gt;()
    const request = ctx.getRequest&lt;Request&gt;()
    const status = exception.getStatus()

    response.status(status).json({
      code: status,
      timestamp: new Date().toISOString(),
      path: request.url,
    })
  }
}
</code></pre>
<p>贴士： <strong>@Catch() 装饰器不传入参数就默认捕获所有的异常</strong>。</p>
<p>贴士：通常情况下，完全自定义一个异常过滤器是不需要的，直接继承自 BaseExceptionFilter 即可复用内置的过滤器逻辑：</p>
<pre><code class="language-ts">import { Catch, ArgumentsHost } from '@nestjs/common'
import { BaseExceptionFilter } from '@nestjs/core'

@Catch()
export class AllExceptionsFilter extends BaseExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    super.catch(exception, host)
  }
}
</code></pre>
<h3 id="22-全局使用异常过滤器"><a class="header" href="#22-全局使用异常过滤器">2.2 全局使用异常过滤器</a></h3>
<p>在 2.1 中创建的全局异常过滤器可以使用在 app 上：</p>
<pre><code class="language-js">const app = await NestFactory.create(AppModule, {
  logger: WinstonModule.createLogger(winsonInstance),
})

app.setGlobalPrefix('api/v1')
app.useGlobalFilters(new HttpExceptionFilter())
</code></pre>
<p>此时访问一个不存在的地址就可以看到异常过滤器的结果被响应到了前端。</p>
<p>注意：全局 filter 只能有一个！</p>
<p>但是这种全局过滤器无法进入依赖注入，因为它在模块作用域之外。为了解决这个问题，可以在根模块上面注册一个全局作用域的过滤器：</p>
<pre><code class="language-ts">import { Module } from '@nestjs/common'
import { APP_FILTER } from '@nestjs/core'

@Module({
  providers: [
    {
      provide: APP_FILTER,
      useClass: HttpExceptionFilter,
    },
  ],
})
export class ApplicationModule {}
</code></pre>
<h3 id="23-其他地方使用异常过滤器"><a class="header" href="#23-其他地方使用异常过滤器">2.3 其他地方使用异常过滤器</a></h3>
<p>过滤器可以使用在多种作用域上，如：方法作用域、控制器作用域、全局作用域。</p>
<p>过滤器应用在控制器方法上：</p>
<pre><code class="language-ts">@Post()
@UseFilters(HttpExceptionFilter)
async create(@Body() createCatDto: CreateCatDto) {
  throw new ForbiddenException();
}
</code></pre>
<p>过滤器应用在控制器上：</p>
<pre><code class="language-ts">@UseFilters(new HttpExceptionFilter())
export class CatsController {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="033-nestjs-主要功能-管道"><a class="header" href="#033-nestjs-主要功能-管道">03.3-Nestjs 主要功能-管道</a></h1>
<h2 id="一-管道作用"><a class="header" href="#一-管道作用">一 管道作用</a></h2>
<p>管道是实现了 PipeTransform 接口的类，通常 pipe 用来将输入数据转换为所需的输出或者处理验证。与过滤器不同的是，管道偏向于服务端逻辑控制，过滤器偏向于客户端逻辑。</p>
<p><img src="09-%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-Nest/../images/nest/04.png" alt="管道" /></p>
<p>一般情况下，管道用于：</p>
<ul>
<li>转换/变形：转换输入数据为目标格式</li>
<li>验证：对输入数据时行验证，如果合法让数据通过管道，否则抛出异常。</li>
</ul>
<p>如果控制器的方法内写入了管道，则 Nest 会在控制器方法调用前插入管道。不过如果管道会在异常范围内执行，这表示异常处理层可以处理管道异常。如果管道发生了异常，控制器的执行将会停止。</p>
<h2 id="二-管道的基础使用"><a class="header" href="#二-管道的基础使用">二 管道的基础使用</a></h2>
<p>Nest 内置了两种管道：ValidationPipe 和 ParseIntPipe。</p>
<p>管道最常用的地方是参数的转换，如：</p>
<pre><code class="language-ts">// 这里如果 uid 不是数字，则自动报 404 错误
@Get('demo5/:uid')
demoD(@Param('uid', ParseIntPipe) uid: number) {
  console.log('uid:', uid)
  return uid
}
</code></pre>
<p>实现 PipeTransform 后，可以自己实现上述管道：</p>
<pre><code class="language-ts">// nest g pi users/create-user --no-spec
import {
  PipeTransform,
  Injectable,
  ArgumentMetadata,
  BadRequestException,
} from '@nestjs/common'

@Injectable()
export class CreateUserPipe implements PipeTransform&lt;string, number&gt; {
  transform(value: string, metadata: ArgumentMetadata): number {
    const val = parseInt(value, 10)
    if (isNaN(val)) {
      throw new BadRequestException('Validation failed')
    }
    return val // pipe 的return可以返回转换、处理后的数据
  }
}
</code></pre>
<p>使用自定义管道：</p>
<pre><code class="language-ts">@Post
addUser(@Body(CreateUserPipe)  dto:any){

}
</code></pre>
<h2 id="二-validationpipe-管道的使用"><a class="header" href="#二-validationpipe-管道的使用">二 ValidationPipe 管道的使用</a></h2>
<h3 id="31-创建管道"><a class="header" href="#31-创建管道">3.1 创建管道</a></h3>
<pre><code class="language-ts">import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common'

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value
  }
}
</code></pre>
<p>dto 用于定义数据模型类型，但是 TypeScript 类型是静态的、编译时类型，当编译成 JavaScript 后在运行时并没有任何类型校验。这时我们就需要自己去验证，或者借助第三方工具、库来验证。</p>
<p>Nest 官方文档使用的 joi 验证库，需要传入一个 schema，实际上对应着我们的在 Nest 中写的 dto 类型，所以我们只需要给 joi 传入一个 CreateCatDto 类的实例即可。</p>
<p>首页在 ValidationPipe 管道中添加 joi 的验证功能。验证通过就返回，不通过直接抛出异常：</p>
<pre><code class="language-ts">@Injectable()
export class JoiValidationPipe implements PipeTransform {
  constructor(private readonly schema: Object) {}

  transform(value: any, metadata: ArgumentMetadata) {
    const { error } = Joi.validate(value, this.schema)
    if (error) {
      throw new BadRequestException(SON.stringify(error.details))
    }
    return value
  }
}
</code></pre>
<h3 id="32-使用管道"><a class="header" href="#32-使用管道">3.2 使用管道</a></h3>
<p>在控制器方法上绑定管道：</p>
<pre><code class="language-ts">@Post()
@UsePipes(new JoiValidationPipe(createCatSchema))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
</code></pre>
<p>使用 @UsePipes 修饰器即可，传入管道的实例，并构造 schema。此时我们的应用就可以在运行时通过 schema 去校验参数对象的开头了。
JOI 文档地址：<a href="https://github.com/sideway/joi/blob/v15.1.0/API.md">https://github.com/sideway/joi/blob/v15.1.0/API.md</a>：</p>
<pre><code class="language-ts">const createCatSchema = {
  name: Joi.string().required(),
  age: Joi.number().required(),
  breed: Joi.string().required(),
}
</code></pre>
<p>例如上面的 schema，如果客户端发送的 POST 请求中如果缺少任意参数 Nest 都会捕获到这个异常并返回信息：</p>
<pre><code class="language-ts">{
    &quot;statusCode&quot;: 400,
    &quot;error&quot;: &quot;Bad Request&quot;,
    &quot;message&quot;: &quot;[{\&quot;message\&quot;:\&quot;\\\&quot;name\\\&quot; is required\&quot;,\&quot;path\&quot;:[\&quot;name\&quot;],\&quot;type\&quot;:\&quot;any.required\&quot;,\&quot;context\&quot;:{\&quot;key\&quot;:\&quot;name\&quot;,\&quot;label\&quot;:\&quot;name\&quot;} }]&quot;
}
</code></pre>
<h3 id="33-类验证器"><a class="header" href="#33-类验证器">3.3 类验证器</a></h3>
<p>3.2 的方式中 CreateCatDto 和 createCatSchema 过于重复，Nest 在第三方库支持下，也能支持类验证器：</p>
<pre><code class="language-txt">npm i -S class-validator class-transformer
</code></pre>
<p>class-validator 可以利用装饰器给类添加额外的验证功能：</p>
<pre><code class="language-ts">import { IsString, IsInt } from 'class-validator'

export class CreateCatDto {
  @IsString()
  readonly name: string

  @IsInt()
  readonly age: number

  @IsString()
  readonly breed: string
}
</code></pre>
<p>管道验证器中的代码也需要适配一下：</p>
<pre><code class="language-ts">import { validate } from 'class-validator'
import { plainToClass } from 'class-transformer'

@Injectable()
export class ValidationPipe implements PipeTransform&lt;any&gt; {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value
    }
    const object = plainToClass(metatype, value)
    const errors = await validate(object)
    if (errors.length &gt; 0) {
      throw new BadRequestException('Validation failed')
    }
    return value
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object]
    return !types.includes(metatype)
  }
}
</code></pre>
<p>贴士： 上述示例中的 transform 是 async 异步的，因为内部需要用到异步验证方法。Nest 的管道可以是异步的。</p>
<p>上述管道可以方法、参数内使用：</p>
<pre><code class="language-ts">// 参数内使用
@Post()
async create(
  @Body(new ValidationPipe()) createCatDto: CreateCatDto,
) {
  this.catsService.create(createCatDto);
}

// 方法内使用
@Post()
@UsePipes(new ValidationPipe())
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
</code></pre>
<p>管道修饰器入参可以是类而不必是管道实例：</p>
<pre><code class="language-ts">@Post()
@UsePipes(ValidationPipe)
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
</code></pre>
<p>由于 ValidationPipe 被尽可能的泛化，所以它可以直接使用在全局作用域上：</p>
<pre><code class="language-ts">async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule)
  app.useGlobalPipes(new ValidationPipe())
  await app.listen(3000)
}
bootstrap()
</code></pre>
<h2 id="四-数据转模型-dto"><a class="header" href="#四-数据转模型-dto">四 数据转模型 DTO</a></h2>
<p>数据访问对象简称 DTO（Data Transfer Object），是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。</p>
<p>在 Nestjs 中，可以使用 TypeScript 接口或简单的类来完成。配合 class-validator 和 class-transformer 可以很方便地验证前端传过来的参数：</p>
<pre><code class="language-ts">import { IsString, IsInt, MinLength, MaxLength } from 'class-validator'
import { ApiModelProperty } from '@nestjs/swagger'

export class CreateCatDto {
  @ApiModelProperty()
  @IsString()
  @MinLength(10, {
    message: 'Name is too short',
  })
  @MaxLength(50, {
    message: 'Name is too long',
  })
  readonly name: string

  @ApiModelProperty()
  @IsInt()
  readonly age: number
  @ApiModelProperty()
  @IsString()
  readonly breed: string
}

import { Controller, Post, Body } from '@nestjs/common'
import { CreateCatDto } from './dto'

@Controller('cats')
export class CatsController {
  @Post()
  create(@Body() createCatDto: CreateCatDto) {
    return 'This action adds a new cat'
  }
}
</code></pre>
<p>在 Nestjs 中，DTO 主要定义如何通过网络发送数据的对象，通常会配合 class-validator 和 class-transformer 做校验。</p>
<pre><code class="language-ts">import { IsString, IsInt } from 'class-validator'

export class CreateCatDto {
  @IsString()
  readonly name: string

  @IsInt()
  readonly age: number

  @IsString()
  readonly breed: string
}
import {
  Controller,
  Get,
  Query,
  Post,
  Body,
  Put,
  Param,
  Delete,
} from '@nestjs/common'
import { CreateCatDto } from './dto'

@Controller('cats')
export class CatsController {
  @Post()
  create(@Body() createCatDto: CreateCatDto) {
    return 'This action adds a new cat'
  }
}
</code></pre>
<p>上面对请求 body 定义了一个 DTO，并且在 DTO 中对参数类型进行了限制，如果 body 中传过来的类型不符合要求，会直接报错。</p>
<p>DTO 中的 class-validator 还需要配合 pipe 才能完成校验功能：</p>
<pre><code class="language-ts">import {
  PipeTransform,
  ArgumentMetadata,
  BadRequestException,
  Injectable,
} from '@nestjs/common'
import { validate } from 'class-validator'
import { plainToClass } from 'class-transformer'
import * as _ from 'lodash'

@Injectable()
export class ValidationPipe implements PipeTransform&lt;any&gt; {
  async transform(value, metadata: ArgumentMetadata) {
    const { metatype } = metadata
    if (!metatype || !this.toValidate(metatype)) {
      return value
    }
    const object = plainToClass(metatype, value)
    const errors = await validate(object)
    if (errors.length &gt; 0) {
      const errorMessage = _.values(errors[0].constraints)[0]
      throw new BadRequestException(errorMessage)
    }
    return value
  }
  private toValidate(metatype): boolean {
    const types = [String, Boolean, Number, Array, Object]
    return !types.find((type) =&gt; metatype === type)
  }
}
</code></pre>
<p>这个 pipe 会根据元数据和对象实例，去构建原有类型，然后通过 validate 去校验。</p>
<p>这个 pipe 一般会作为全局的 pipe 去使用：</p>
<pre><code class="language-ts">async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule)
  app.setGlobalPrefix('api/v1')

  app.useGlobalPipes(new ValidationPipe())

  await app.listen(3000)
}
bootstrap()
</code></pre>
<p>假设我们没有这层 pipe，那在 controller 中就会进行参数校验，这样就会打破单一职责的原则。有了这一层 pipe 帮助我们校验参数，有效地降低了类的复杂度，提高了可读性和可维护性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="034-nestjs-主要功能-守卫"><a class="header" href="#034-nestjs-主要功能-守卫">03.4-Nestjs 主要功能-守卫</a></h1>
<h2 id="一-守卫的功能"><a class="header" href="#一-守卫的功能">一 守卫的功能</a></h2>
<p>守卫是实现了 CanActivate 接口的类，其功能是：决定请求是否需要被控制器处理。一般用在权限、角色的场景中。守卫会在中间件逻辑之后、拦截器/管道之前执行。</p>
<p>守卫和中间件的区别在于：中间件很简单，next 方法调用后中间的任务就完成了。但是守卫还需要鉴别请求与控制器之间的关系。</p>
<p><img src="09-%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-Nest/../images/nest/05.png" alt="守卫" /></p>
<h2 id="二-守卫的使用"><a class="header" href="#二-守卫的使用">二 守卫的使用</a></h2>
<h3 id="21-创建守卫"><a class="header" href="#21-创建守卫">2.1 创建守卫</a></h3>
<p>实现一个守卫：</p>
<pre><code class="language-ts">import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'
import { Observable } from 'rxjs'

@Injectable()
export class AuthGuard implements CanActivate {
  // canActivate 返回 true，控制器才正常执行
  canActivate(
    context: ExecutionContext
  ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; {
    const request = context.switchToHttp().getRequest()
    return validateRequest(request) // 函数实现 Request 的验证
  }
}
</code></pre>
<p>这里 ExecutionContext 拥有 2 个方法：</p>
<ul>
<li>getHandler() 方法会返回一个将被调用的方法处理器</li>
<li>getClass() 返回处理器对应的控制器类。</li>
</ul>
<h3 id="22-使用守卫"><a class="header" href="#22-使用守卫">2.2 使用守卫</a></h3>
<p>守卫可以是控制器作用域的，也可以是方法作用域或者全局作用域：</p>
<pre><code class="language-ts">// 控制器作用域
@Controller('cats')
@UseGuards(RolesGuard)
export class CatsController {}

// 全局作用域
const app = await NestFactory.create(ApplicationModule)
app.useGlobalGuards(new RolesGuard())
</code></pre>
<p>由于在根模块外层引用了全局守卫，这时守卫无法注入依赖，所以这里还需要在要模块上引入：</p>
<pre><code class="language-ts">import { Module } from '@nestjs/common'
import { APP_GUARD } from '@nestjs/core'

@Module({
  providers: [
    {
      provide: APP_GUARD,
      useClass: RolesGuard,
    },
  ],
})
export class ApplicationModule {}
</code></pre>
<h3 id="23-获取执行上下文"><a class="header" href="#23-获取执行上下文">2.3 获取执行上下文</a></h3>
<p>虽然现在已经有了守卫，但是它还没有执行上下文。CatsController 应该有一些需要访问到的权限类型。比如：管理员（admin）角色可以访问、其它角色不可以。这时我们需要对控制器（或方法）添加一些元数据，用来标记这个控制器的权限类型。在 Nest 中我们通常使用 @SetMetadata() 装饰器来完成这个工作。</p>
<pre><code class="language-ts">@Post()
@SetMetadata('roles', ['admin'])
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
</code></pre>
<p>贴士： SetMetadata 可以自定义：</p>
<pre><code class="language-ts">import { SetMetadata } from '@nestjs/common'

export const Roles = (...roles: string[]) =&gt; SetMetadata('roles', roles)
</code></pre>
<p>最终使用：</p>
<pre><code class="language-ts">@Post()
@Roles('admin')
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
</code></pre>
<p>利用反射机制获取控制器上的数据：</p>
<pre><code class="language-ts">import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'
import { Observable } from 'rxjs'
import { Reflector } from '@nestjs/core'

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.get&lt;string[]&gt;('roles', context.getHandler())
    if (!roles) {
      return true
    }
    const request = context.switchToHttp().getRequest()
    const user = request.user
    const hasRole = () =&gt; user.roles.some((role) =&gt; roles.includes(role))
    return user &amp;&amp; user.roles &amp;&amp; hasRole()
  }
}
</code></pre>
<h3 id="24-多个守卫的使用"><a class="header" href="#24-多个守卫的使用">2.4 多个守卫的使用</a></h3>
<p>多个 gurd 可以合并写在一起，从前往后执行，一旦前面的守卫没有通过，则后续 guard 不会执行：</p>
<pre><code class="language-ts">@Get()
@UseGuards(AuthGuard('jwt'), AdminGuard)
</code></pre>
<p>如果装饰器没有合并书写，则方法装饰器的执行顺序是从下往上执行：</p>
<pre><code class="language-ts">@UseGuards(AdminGuard)
@UseGuards(AuthGuard('jwt'))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="035-nestjs-主要功能-拦截器"><a class="header" href="#035-nestjs-主要功能-拦截器">03.5-Nestjs 主要功能-拦截器</a></h1>
<h2 id="一-拦截器功能"><a class="header" href="#一-拦截器功能">一 拦截器功能</a></h2>
<p>拦截器是实现了 NestInterceptor 接口 的类。其功能有：</p>
<ul>
<li>在函数执行前/后绑定额外的逻辑</li>
<li>转换一个函数的返回值</li>
<li>转换函数抛出的异常</li>
<li>扩展基础函数的行为</li>
<li>根据特定的条件完全的重写一个函数（比如：缓存）</li>
</ul>
<p><img src="09-%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6-Nest/../images/nest/06.png" alt="拦截器" /></p>
<p>每个拦截器都要实现 intercept() 方法，此方法有两个参数。第一个是 ExecutionContext 实例（这和守卫中的对象一样）。ExecutionContext 继承自 ArgumentsHost，ArgumentsHost 是一个包装了传递向原始处理器而且根据应用的不同包含不同的参数数组的类。</p>
<pre><code class="language-ts">export interface ExecutionContext extends ArgumentsHost {
  getClass&lt;T = any&gt;(): Type&lt;T&gt;
  getHandler(): Function
}
</code></pre>
<p>假如有一个的请求将被 CatsController 中的 create() 方法处理。如果一个没调用 handle() 方法的拦截器在某处被调用，create() 方法将不会被执行。一但 handle() 方法被调用（它的 Observable 已返回），create() 处理器将被触发。一但响应流通过 Observable 接收到，附加的操作可以在注上被执行，最后的结果将返回给调用方。</p>
<p>所以与 守卫、过滤器不同的是，拦截器对一次请求响应拥有绝对控制权。可以在 intercept() 方法中的 handle() 调用之前写自己的代码，而 handle()方法返回的是 Observable，后续又可以使用 RxJS 做到修改后来的响应。</p>
<h2 id="二-拦截器切面拦截示例"><a class="header" href="#二-拦截器切面拦截示例">二 拦截器切面拦截示例</a></h2>
<h3 id="21-创建拦截器"><a class="header" href="#21-创建拦截器">2.1 创建拦截器</a></h3>
<p>简单的日志拦截器：</p>
<pre><code class="language-ts">@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; {
    console.log('Before...')

    const now = Date.now()
    return next
      .handle()
      .pipe(tap(() =&gt; console.log(`After... ${Date.now() - now}ms`)))
  }
}
</code></pre>
<p>由于 handle() 方法返回了一个 RxJS 的 Observable 对象，对于修改流我们将有更多的选择。上面的示例中我们使用了 tap() 操作符。它在 Observable 流的正常或异常终止时调用我们的匿名日志记录函数，但不会干扰到响应周期。</p>
<h3 id="22-使用拦截器"><a class="header" href="#22-使用拦截器">2.2 使用拦截器</a></h3>
<p>@UseInterceptors() 装饰器来绑定一个拦截器，和管道、守卫一样，它即可以是控制器作用域的，也可以是方法作用域的，或者是全局的。</p>
<pre><code class="language-ts">@UseInterceptors(LoggingInterceptor)
export class CatsController {}
</code></pre>
<h3 id="23-响应映射"><a class="header" href="#23-响应映射">2.3 响应映射</a></h3>
<p>handle() 方法返回的 Observable 流包含路由处理器返回的值，可以修改响应：</p>
<pre><code class="language-ts">import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common'
import { Observable } from 'rxjs'
import { map } from 'rxjs/operators'

export interface Response&lt;T&gt; {
  data: T
}

@Injectable()
export class TransformInterceptor&lt;T&gt;
  implements NestInterceptor&lt;T, Response&lt;T&gt;&gt;
{
  intercept(
    context: ExecutionContext,
    next: CallHandler
  ): Observable&lt;Response&lt;T&gt;&gt; {
    return next.handle().pipe(map((data) =&gt; ({ data })))
  }
}
</code></pre>
<p>注意：响应映射功能并不适用于库级别的响应策略（不可以使用 @Res 装饰器）</p>
<p>当有请求进入时，响应看起来将会是下面这样：</p>
<pre><code class="language-ts">{
  &quot;data&quot;: []
}
</code></pre>
<h3 id="24-拦截器的复用性"><a class="header" href="#24-拦截器的复用性">2.4 拦截器的复用性</a></h3>
<p>拦截器对于创建整个应用层面的可复用方案有非常大的意义。比如说，我们需要将所有响应中出现的 null 值改成空字符串 &quot;&quot;。我们可以使用拦截器功能仅用下面一行代码就可以实现：</p>
<pre><code class="language-ts">import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common'
import { Observable } from 'rxjs'
import { map } from 'rxjs/operators'

@Injectable()
export class ExcludeNullInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; {
    return next.handle().pipe(map((value) =&gt; (value === null ? '' : value)))
  }
}
</code></pre>
<h3 id="25-异常捕获"><a class="header" href="#25-异常捕获">2.5 异常捕获</a></h3>
<p>RxJS 的 catchError() 操作符来可以重写异常捕获：</p>
<pre><code class="language-ts">import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  BadGatewayException,
  CallHandler,
} from '@nestjs/common'
import { Observable, throwError } from 'rxjs'
import { catchError } from 'rxjs/operators'

@Injectable()
export class ErrorsInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; {
    return next
      .handle()
      .pipe(catchError((err) =&gt; throwError(new BadGatewayException())))
  }
}
</code></pre>
<h3 id="26-流重写"><a class="header" href="#26-流重写">2.6 流重写</a></h3>
<p>如果希望完全阻止处理器的调用并返回一个不同的值。比如使用缓存拦截器来实现来简单实现：</p>
<pre><code class="language-ts">import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common'
import { Observable, of } from 'rxjs'

@Injectable()
export class CacheInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; {
    const isCached = true
    if (isCached) {
      return of([])
    }
    return next.handle()
  }
}
</code></pre>
<h3 id="27-超时处理"><a class="header" href="#27-超时处理">2.7 超时处理</a></h3>
<p>入股需要处理路由请求超时问题，当你的响应很久都没正常返回时，你会想把它关闭在规定时间内取消响应：</p>
<pre><code class="language-ts">import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common'
import { Observable } from 'rxjs'
import { timeout } from 'rxjs/operators'

@Injectable()
export class TimeoutInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; {
    return next.handle().pipe(timeout(5000))
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-nestjs-业务扩展-配置管理"><a class="header" href="#041-nestjs-业务扩展-配置管理">04.1-Nestjs 业务扩展-配置管理</a></h1>
<h2 id="一-nest-项目实现配置管理"><a class="header" href="#一-nest-项目实现配置管理">一 Nest 项目实现配置管理</a></h2>
<h3 id="11-配置管理的方式"><a class="header" href="#11-配置管理的方式">1.1 配置管理的方式</a></h3>
<p>配置管理有两种：</p>
<ul>
<li>dotenv：配置信息以键值对形式书写在不同的 env 文件，项目启动时配置信息被加载进 process.env 对象</li>
<li>config：多用于 Node 场合，支持以 json、yaml 配置文件方式读取配置信息</li>
</ul>
<p>dotenv 适合前端项目配置，在做键值对中，如果值是一个树形结构的对象，则很不好处理，需要起名类似 DATABASE_USERNAME 这样用前缀进行区分，所以 nest 中推荐使用 config 方式。</p>
<pre><code class="language-js">// npm i config js-yaml
// 在 src/config 目录下新建 default.yaml 进行配置

// 读取方式
const config = require('config')
const dbConf = config.get('db')
</code></pre>
<p>也可以创建 production.yaml、development.yaml 文件，这些文件会依据控制台环境自动解析，并将解析的文件内容合并、覆盖到 default.yaml 读取到的对象中。</p>
<h3 id="12-nestjsconfig"><a class="header" href="#12-nestjsconfig">1.2 @nestjs/config</a></h3>
<p>nest 官方提供了 @nestjs/config 库来实现上述配置。由于配置一般都是全局的，可以在 app.module.ts 中添加全局的 config 模块，这样就能在其他模块中注入使用了：</p>
<pre><code class="language-js">// npm i -D @nestjs/config
import { Module } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { DemoModule } from './demo/demo.module'
@Module({
  // forRoot：在根本路查找文件
  imports: [ConfigModule.forRoot({ isGlobal: true }), DemoModule],
  controllers: [],
  providers: [],
})
export class AppModule {}
</code></pre>
<p>贴士：使用@nestjs/config 模块，项目默认支持的是 dotenv 方式，即读取根目录的 .env 文件，如果要支持 yaml 也是额外需要安装 yaml 对应的解析库：</p>
<pre><code class="language-js">// npm i -D js-yaml @types/js-yaml

// 在src下新建 configuration.ts 文件
import { join } from 'path'
import * as yaml from 'js-yaml'
import { readFileSync } from 'fs'

const configPath = join(__dirname, '../config', 'default.config.yaml')

export default () =&gt; {
  return yaml.load(readFileSync(configPath, 'utf8'))
}
</code></pre>
<p>这时候在 controller 中使用：</p>
<pre><code class="language-ts">import { ConfigService } from '@nestjs/config'

@Controller('demo')
export class DemoController {
  constructor(
    private readonly demoService: DemoService,
    private configService: ConfigService
  ) {}

  @Get()
  findAll() {
    const dbConfig = this.configService.get('db')
    const tokenConfig = this.configService.get('token')
    console.log('config==', dbConfig, tokenConfig)
    return this.demoService.findAll()
  }
}
</code></pre>
<p>如果我们既需要 dotenv，也需要 yaml 等多种配置方式一起使用，则可以使用 lodash 组合这些配置对象：</p>
<pre><code class="language-ts">import { join } from 'path'
import * as yaml from 'js-yaml'
import { readFileSync } from 'fs'
import * as _ from 'lodash'

const configPath = join(__dirname, '../config', 'default.config.yaml')
const envPath = join(
  __dirname,
  '../config',
  `${process.env.NODE_ENV || 'development'}.config.yaml`
)

const commonConfig = yaml.load(readFileSync(configPath, 'utf8'))
const envConfig = yaml.load(readFileSync(envPath, 'utf8'))

export default () =&gt; {
  return _.merge(commonConfig, envConfig)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="042-nestjs-业务扩展-日志"><a class="header" href="#042-nestjs-业务扩展-日志">04.2-Nestjs 业务扩展-日志</a></h1>
<h2 id="一-日志的使用"><a class="header" href="#一-日志的使用">一 日志的使用</a></h2>
<h3 id="11-pino"><a class="header" href="#11-pino">1.1 pino</a></h3>
<p>日志的功能主要用来收集客户端请求信息、服务端错误信息，用来复盘 Bug 问题。生产级的日志还需要异常归类、日志存储与自动删除、接口信息记录等。</p>
<p>官方日志是在 console 中输出的，如果要保存则需要修改或者使用第三方日志。我们先关闭官方日志：</p>
<pre><code class="language-ts">// maint.ts
const app = await NestFactory.create(AppModule, { logger: false })
</code></pre>
<p>这里推荐采用 winston 或者 pino 来管理日志，其中 pino 的使用配置极度方便，在配置完成后会自动为所有请求添加上日志信息，适合懒人快速开发。</p>
<p>安装 pino：</p>
<pre><code class="language-txt">npm i -S nestjs-pino pino-http pino-pretty pino-roll
</code></pre>
<p>app.module：</p>
<pre><code class="language-ts">import { Module } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { DemoModule } from './demo/demo.module'
import configuration from './configuration'
import { join } from 'path'
import { LoggerModule } from 'nestjs-pino'

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      // envFilePath
      load: [configuration],
    }),
    DemoModule,
    LoggerModule.forRoot({
      pinoHttp: {
        transport: {
          targets: [
            {
              level: 'info',
              target: 'pino-pretty',
              options: {
                colorize: true,
              },
            },
            {
              level: 'info',
              target: 'pino-roll',
              options: {
                file: join('logs', 'log.txt'),
                frequency: 'daily', // hourly
                size: '5m',
                mdir: true,
              },
            },
          ],
        },
      },
    }),
  ],
  controllers: [],
  providers: [],
  exports: [],
})
export class AppModule {}
</code></pre>
<p>此时已经自动记录日制作了，也可以手动式书写日志：</p>
<pre><code class="language-ts">// demo.controller.ts
@Controller('demo')
export class DemoController {
  constructor(
    private readonly demoService: DemoService,
    private configService: ConfigService,
    private readonly logger: Logger
  ) {}

  @Get()
  findAll() {
    this.logger.log('findAll-----')
    const dbConfig = this.configService.get('db')
    const tokenConfig = this.configService.get('token')
    console.log('config==', dbConfig, tokenConfig)

    return this.demoService.findAll()
  }
}
</code></pre>
<h3 id="12-winston"><a class="header" href="#12-winston">1.2 winston</a></h3>
<p>使用第三方库 winston：</p>
<pre><code class="language-ts">// npm i -S winston nest-winston winston-daily-rotate-file
</code></pre>
<p>winston 是在 nest 官方的 logger 上实现的，所以无需挂壁官方日志，将官方日志替换为 winston 即可：</p>
<p>main.ts 中的配置：</p>
<pre><code class="language-ts">// import { HttpExceptionFilter } from './filters/http-exception.filter'
import { NestFactory } from '@nestjs/core'
import { WINSTON_MODULE_NEST_PROVIDER } from 'nest-winston'
import { AppModule } from './app.module'

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {})

  app.useLogger(app.get(WINSTON_MODULE_NEST_PROVIDER))

  app.setGlobalPrefix('api/v1')
  // app.useGlobalFilters(new HttpExceptionFilter(logger))// 用于异常中输出日志

  const port = 3001
  await app.listen(port)
}
bootstrap()
</code></pre>
<p>app.module:</p>
<pre><code class="language-ts">import { Module, Logger, Global } from '@nestjs/common'
import { ConfigModule } from '@nestjs/config'
import { DemoModule } from './demo/demo.module'
import { LogModule } from './log/log.module'
import configuration from './configuration'

@Global()
@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      // envFilePath
      load: [configuration],
    }),
    DemoModule,
    LogModule,
  ],
  controllers: [],
  providers: [Logger],
  exports: [Logger],
})
export class AppModule {}
</code></pre>
<p>控制器中使用：</p>
<pre><code class="language-ts">@Controller('demo')
export class DemoController {
  constructor(
    private readonly demoService: DemoService,
    private configService: ConfigService,
    @Inject(WINSTON_MODULE_NEST_PROVIDER)
    private readonly logger: LoggerService
  ) {}

  @Get()
  findAll() {
    this.logger.log('findAll-----')
    const dbConfig = this.configService.get('db')
    const tokenConfig = this.configService.get('token')
    console.log('config==', dbConfig, tokenConfig)

    return this.demoService.findAll()
  }
}
</code></pre>
<p>封装的 log.module.ts</p>
<pre><code class="language-ts">import { ConfigService } from '@nestjs/config'
import { WinstonModule, WinstonModuleOptions, utilities } from 'nest-winston'
import { Module } from '@nestjs/common'
import { format } from 'winston'
import 'winston-daily-rotate-file'
import { Console, DailyRotateFile } from 'winston/lib/winston/transports'

// 控制台日志
const consoleTransport = new Console({
  level: 'info',
  format: format.combine(
    format.timestamp(),
    // winston.format.prettyPrint()
    utilities.format.nestLike()
  ),
})

// 错误日志
const errorTransport = new DailyRotateFile({
  dirname: 'logs',
  level: 'warn',
  filename: 'warn-%DATE%.log',
  datePattern: 'YYYY-MM-DD-HH-mm',
  zippedArchive: true,
  maxSize: '20m',
  maxFiles: '365d',
  format: format.combine(
    format.timestamp(),
    // format.simple(),
    format.prettyPrint()
  ),
})

// 普通日志
const commonTransport = new DailyRotateFile({
  dirname: 'logs',
  level: 'info',
  filename: 'info-%DATE%.log',
  datePattern: 'YYYY-MM-DD-HH',
  zippedArchive: true,
  maxSize: '20m',
  maxFiles: '14d',
  format: format.combine(format.timestamp(), utilities.format.nestLike()),
})

@Module({
  imports: [
    WinstonModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (configService: ConfigService) =&gt;
        ({
          transports: [consoleTransport, errorTransport, commonTransport],
        } as WinstonModuleOptions),
    }),
  ],
})
export class LogModule {}
</code></pre>
<h2 id="二-基于-log4js-开发自己的日志"><a class="header" href="#二-基于-log4js-开发自己的日志">二 基于 Log4js 开发自己的日志</a></h2>
<h3 id="21-日志配置"><a class="header" href="#21-日志配置">2.1 日志配置</a></h3>
<p>安装：</p>
<pre><code class="language-txt">npm i -S log4js stacktrace-js
</code></pre>
<p>首先需要对日志输出样式进行配置：</p>
<pre><code class="language-ts">// config/log4js.config.ts
import { resolve } from 'path'

const baseLogPath = resolve(__dirname, '../logs')

export const log4jsConfig = {
  appenders: {
    console: { type: 'console' }, // 控制打印至控制台
    // 统计日志
    access: {
      type: 'dateFile', // 写入文件格式，并按照日期分类
      filename: `${baseLogPath}/access/access.log`, // 日志文件名，会命名为：access.2021-04-01.log
      alwaysIncludePattern: true, // 为 true, 则每个文件都会按 pattern 命名，否则最新的文件不会按照 pattern 命名
      pattern: 'yyyy-MM-dd', // 日期格式
      maxLogSize: 10485760, // 日志大小
      daysToKeep: 30, // 文件保存日期 30 天
      numBackups: 3, //  配置日志文件最多存在个数
      compress: true, // 配置日志文件是否压缩
      category: 'http', // category 类型
      keepFileExt: true, // 是否保留文件后缀
    },
    // 一些 app 的 应用日志
    app: {
      type: 'dateFile',
      filename: `${baseLogPath}/app-out/app.log`,
      alwaysIncludePattern: true,
      layout: {
        type: 'pattern',
        pattern: '[%d{yyyy-MM-dd hh:mm:ss}] [%p] -h: %h -pid: %z ',
      }, // 自定义的输出格式，可参考 https://blog.csdn.net/hello_word2/article/details/79295344
      pattern: 'yyyy-MM-dd',
      daysToKeep: 30,
      numBackups: 3,
      keepFileExt: true,
    },
    // 异常日志
    errorFile: {
      type: 'dateFile',
      filename: `${baseLogPath}/error/error.log`,
      alwaysIncludePattern: true,
      layout: {
        type: 'pattern',
        pattern:
          &quot;[%d{yyyy-MM-dd hh:mm:ss SSS}] [%p] -h: %h -pid: %z  msg: '%m' &quot;,
      },
      pattern: 'yyyy-MM-dd',
      daysToKeep: 30,
      numBackups: 3,
      keepFileExt: true,
    },
    errors: {
      type: 'logLevelFilter',
      level: 'ERROR',
      appender: 'errorFile',
    },
  },
  categories: {
    default: {
      appenders: ['console', 'access', 'app', 'errors'],
      level: 'DEBUG',
    },
    mysql: { appenders: ['access', 'errors'], level: 'info' },
    http: { appenders: ['access'], level: 'DEBUG' },
  },
}
</code></pre>
<h3 id="22-日志工具实现"><a class="header" href="#22-日志工具实现">2.2 日志工具实现</a></h3>
<p>新建日志工具用来实例化日志工具，并向外提供日志输出方法：</p>
<pre><code class="language-ts">// utils/log4js.util.ts
import * as Log4js from 'log4js'
import * as StackTrace from 'stacktrace-js'
import { basename } from 'path'
import { log4jsConfig } from 'src/config/log.config'

// 实例化
Log4js.configure(log4jsConfig)
const logger = Log4js.getLogger('default')
logger.level = Log4js.levels.TRACE

// 定义 log 类方法
export class Logger {
  static trace(...args) {
    logger.trace(Logger.getStackTrace(), ...args)
  }

  static debug(...args) {
    logger.debug(Logger.getStackTrace(), ...args)
  }

  static log(...args) {
    logger.info(Logger.getStackTrace(), ...args)
  }

  static info(...args) {
    logger.info(Logger.getStackTrace(), ...args)
  }

  static warn(...args) {
    logger.warn(Logger.getStackTrace(), ...args)
  }

  static error(...args) {
    logger.error(Logger.getStackTrace(), ...args)
  }

  static fatal(...args) {
    logger.fatal(Logger.getStackTrace(), ...args)
  }

  static access(...args) {
    const loggerCustom = Log4js.getLogger('http')
    loggerCustom.info(Logger.getStackTrace(), ...args)
  }

  // 日志追踪，可以追溯到哪个文件、第几行第几列 参考：https://www.npmjs.com/package/stacktrace-js
  private static getStackTrace(deep = 2): string {
    const stackList: StackTrace.StackFrame[] = StackTrace.getSync()
    const stackInfo: StackTrace.StackFrame = stackList[deep]
    const lineNumber: number = stackInfo.lineNumber
    const columnNumber: number = stackInfo.columnNumber
    const fileName: string = stackInfo.fileName
    const realName: string = basename(fileName)
    return `${realName}(line: ${lineNumber}, column: ${columnNumber}): \n`
  }
}
</code></pre>
<h3 id="23-日志中间件"><a class="header" href="#23-日志中间件">2.3 日志中间件</a></h3>
<p>创建日志中间件，以在项目中，进行常规化日志输出：</p>
<pre><code class="language-ts">// middleware/logger.middleware.ts
import { Request, Response } from 'express'
import { Logger } from '../../utils/log4js.util'

export function logger(req: Request, res: Response, next: () =&gt; any) {
  const code = res.statusCode //响应状态码
  next()

  if (req.originalUrl === '/favicon.ico') {
    return
  }

  // 组装日志信息
  const logFormat = `   origin: ${req.originalUrl}  ${code}  ${req.method}  ${
    req.ip
  }
    params: ${JSON.stringify(req.params)}
    query: ${JSON.stringify(req.query)}
    body: ${JSON.stringify(req.body)}`

  //根据状态码，进行日志类型区分
  if (code &gt;= 500) {
    Logger.error(logFormat)
  } else if (code &gt;= 400) {
    Logger.warn(logFormat)
  } else {
    Logger.access(logFormat)
    Logger.log(logFormat)
  }
}
</code></pre>
<h3 id="24-使用日志"><a class="header" href="#24-使用日志">2.4 使用日志</a></h3>
<p>在入口文件中应用中间件即可实现日志自动打印：</p>
<pre><code class="language-ts">const app = await NestFactory.create(AppModule)

// 全局日志中间件
app.use(logger)
</code></pre>
<p>在项目中手动输出日志：</p>
<pre><code class="language-ts">    @Get('demo1')
    demoA() {
        Logger.info('demo1-info')
        Logger.error('demo1-error')
        return {}
    }
</code></pre>
<h3 id="24-日志功能扩展日志记录响应信息"><a class="header" href="#24-日志功能扩展日志记录响应信息">2.4 日志功能扩展：日志记录响应信息</a></h3>
<p>如果需要记录一些响应信息，可以利用拦截器实现：</p>
<pre><code class="language-ts">// interceptor/response.interceptor.ts
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common'
import { Observable } from 'rxjs'
import { map } from 'rxjs/operators'
import { Code } from '../../config/code.config'
import { Logger } from '../../utils/log4js.util'

@Injectable()
export class ResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; {
    const req = context.getArgByIndex(1).req
    return next.handle().pipe(
      map((data) =&gt; {
        if (!req.data) {
          req.data = []
        }

        // 组装日志信息
        if (req.originalUrl === '/favicon.ico') {
          return
        }

        // 组装日志信息
        const logFormat = `   origin: ${req.originalUrl} ${req.method}  ${
          req.ip
        }
    params: ${JSON.stringify(req.params)}
    query: ${JSON.stringify(req.query)}
    body: ${JSON.stringify(req.body)}
    res:${JSON.stringify(data)}`

        Logger.log(logFormat)
        Logger.access(logFormat)
        return {
          ...Code.OK,
          data,
        }
      })
    )
  }
}
</code></pre>
<p>入口文件中使用该拦截器：</p>
<pre><code class="language-ts">//格式化 正确响应的返回体
app.useGlobalInterceptors(new ResponseInterceptor())
</code></pre>
<h3 id="25-日志功能扩展日志记录异常信息"><a class="header" href="#25-日志功能扩展日志记录异常信息">2.5 日志功能扩展：日志记录异常信息</a></h3>
<p>日志的核心功能是记录异常信息，这里通过过异常滤器来记录：</p>
<pre><code class="language-ts">// filter/any-exception.filter.ts
/**
 * 捕获任意异常
 */
import { ExceptionFilter, Catch, ArgumentsHost } from '@nestjs/common'
import { Request, Response } from 'express'
import { Code } from 'src/config/code.config'
import { Logger } from '../../utils/log4js.util'

// @Catch(HttpException) 则只接收 trhow new HttpException()
@Catch()
export class AnyExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp()
    const res = ctx.getResponse&lt;Response&gt;()
    const req = ctx.getRequest&lt;Request&gt;()

    // 组装日志信息
    if (req.originalUrl === '/favicon.ico') {
      return
    }

    // 组装日志信息
    const logFormat = `   origin: ${req.originalUrl} ${req.method}  ${req.ip}
    params: ${JSON.stringify(req.params)}
    query: ${JSON.stringify(req.query)}
    body: ${JSON.stringify(req.body)}
    exception:${exception}`

    Logger.error(logFormat)
    res.status(200)
    res.send(Code.ServerError)
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="043-nestjs-业务扩展-校验与认证"><a class="header" href="#043-nestjs-业务扩展-校验与认证">04.3-Nestjs 业务扩展-校验与认证</a></h1>
<h2 id="一-接口数据校验"><a class="header" href="#一-接口数据校验">一 接口数据校验</a></h2>
<p>我们往往需要对接口中的数据进行类似如下的校验：</p>
<pre><code class="language-ts">@Post('/signup')
signup(@Body() dto: CreateAuthDto){
    const {username, password} = dto
    if(!useranme || !password) {
        throw new HttpException('用户名或者密码不能为空', 400)
    }
    if(typeof username !== 'string' || typeof password !== 'string'){
        throw new HttpException('用户名或者密码格式不正确', 400)
    }
    // 长度判断
    // ...
}
</code></pre>
<p>手写这些校验比较麻烦，可以使用第三方库，利用装饰器直接校验 ：</p>
<pre><code class="language-ts">// npm i --save class-validator class-transformer
app.useGlobalPipes(
  new ValidationPipe({
    // whitelist: true // 会将客户端传递的无效数据清除，即去除类上不存在的字段
  })
)
</code></pre>
<p>这时候如果接口中使用下列校验装饰器，就无需进行类似下面的字符串值的手动校验了：</p>
<pre><code class="language-ts">export class CreateAuthDto {
  @IsString()
  @IsNotEmpty()
  @Length(6, 20, {
    /**
     * $value 当前用户传入的值
     * $property 当前属性名
     * $target 当前类
     * $constraint1 最小长度
     */
    message: `用户名长度必须在$constraint1到$constraint2之间`,
  })
  username: string

  @IsString()
  @IsNotEmpty()
  @Length(6, 32, {
    message: `密码长度必须在$constraint1到$constraint2之间`,
  })
  password: string
}
</code></pre>
<p>针对 query 参数也可以使用系统内置的一些管道。</p>
<h2 id="二-jwt-集成"><a class="header" href="#二-jwt-集成">二 jwt 集成</a></h2>
<h3 id="21-库安装"><a class="header" href="#21-库安装">2.1 库安装</a></h3>
<p>安装对应的库：</p>
<pre><code class="language-txt">npm i @nestjs/jwt @nestjs/passport passport passport-jwt -S
npm i @nestjs/jwt @types/passport-jwt -D
</code></pre>
<h3 id="22-jwt-签名服务"><a class="header" href="#22-jwt-签名服务">2.2 jwt 签名服务</a></h3>
<p>创建 jwt 解析的服务层文件 jwt.strategy.ts：</p>
<pre><code class="language-ts">import { ConfigService } from '@nestjs/config'
import { ExtractJwt, Strategy } from 'passport-jwt'
import { PassportStrategy } from '@nestjs/passport'
import { Injectable } from '@nestjs/common'
import { ConfigEnum, IJwtConfig } from './../common/config.enum'

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(protected configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      // 这里只是通过config获取secret，你可以任意使用自己的获取方式
      secretOrKey: configService.get&lt;IJwtConfig&gt;(ConfigEnum.JWT).secret,
    })
  }

  // 这里可以验证 token，当 token 有效时，允许进一步处理请求，否则返回 401(Unanthorized)
  // validate是继承方法，会自动获取解析后的payload，预留该方法方便以后扩展，比如在此进行数据库查询
  // 在接口中添加对应守卫就可以走该逻辑，return的 数据加在 @Req 上
  async validate(payload: any) {
    if (!payload) {
      throw new UnauthorizedException('身份验证失败')
    }
    return { id: payload.id, username: payload.username }
  }
}
</code></pre>
<p>使用 jwt 签名服务：</p>
<pre><code class="language-ts">@Injectable()
export class AuthService {
  constructor(
    private userService: UserService,
    private jwtService: JwtService
  ) {}

  // 签名
  async signin(tel: string, code: string) {
    const user = await this.userService.findOne(tel)
    if (!user) {
      throw new UnauthorizedException()
    }

    const token = await this.jwtService.signAsync(
      {
        id: user.id,
        username: user.username,
      }
      // refreshtoken使用
      // {
      //     expiresIn: '1d',
      // }
    )

    return token
  }
}
</code></pre>
<h3 id="23-解析-token"><a class="header" href="#23-解析-token">2.3 解析 token</a></h3>
<p>前端回传 token 后，后端服务解析 token 的示例：</p>
<pre><code class="language-ts">@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Get('/profile')
  @UseGuards(AuthGuard('jwt'))
  getUserProfile(@Req() req) {
    console.log('req.user=', req.user)

    return req.user
  }
}
</code></pre>
<p>这里可以简化 <code> @UseGuards(AuthGuard('jwt'))</code> 的书写，我们可以建立 <code>jwt.guard.ts</code>：</p>
<pre><code class="language-ts">import { AuthGuard } from '@nestjs/passport'
export class JwtGuard extends AuthGuard('jwt') {
  constructor() {
    super()
  }
}
</code></pre>
<p>这只是对 <code>AuthGuard('jwt')</code> 的优化写法，并不是自定义了一个 guard，此时接口位置就可以使用</p>
<pre><code class="language-ts">@UseGuards(JwtGuard)    // 代替 @UseGuards(AuthGuard('jwt'))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-nestjs-项目优化"><a class="header" href="#051-nestjs-项目优化">05.1-Nestjs 项目优化</a></h1>
<h2 id="一-项目环境"><a class="header" href="#一-项目环境">一 项目环境</a></h2>
<h3 id="11-热重载"><a class="header" href="#11-热重载">1.1 热重载</a></h3>
<p>在开发的时候，运行 npm run start:dev 的时候，是进行全量编译，如果项目比较大，全量编译耗时会比较长，这时候我们可以利用 webpack 来帮我们做增量编译，这样会大大增加开发效率。</p>
<p>在根目录下创建一个 webpack.config.js：</p>
<pre><code class="language-ts">// npm i --save-dev webpack webpack-cli webpack-node-externals ts-loader
const webpack = require('webpack')
const path = require('path')
const nodeExternals = require('webpack-node-externals')

module.exports = {
  entry: ['webpack/hot/poll?100', './src/main.ts'],
  watch: true,
  target: 'node',
  externals: [
    nodeExternals({
      whitelist: ['webpack/hot/poll?100'],
    }),
  ],
  module: {
    rules: [
      {
        test: /.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  mode: 'development',
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
  },
  plugins: [new webpack.HotModuleReplacementPlugin()],
  output: {
    path: path.join(__dirname, 'dist'),
    filename: 'server.js',
  },
}
</code></pre>
<p>在 main.ts 中启用 HMR：</p>
<pre><code class="language-ts">declare const module: any

async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule)
  await app.listen(3000)

  if (module.hot) {
    module.hot.accept()
    module.hot.dispose(() =&gt; app.close())
  }
}
bootstrap()
</code></pre>
<p>在 package.json 中增加下面两个命令：</p>
<pre><code class="language-ts">{
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node dist/server&quot;,
    &quot;webpack&quot;: &quot;webpack --config webpack.config.js&quot;
  }
}
</code></pre>
<p>运行 npm run webpack 之后，webpack 开始监视文件，然后在另一个命令行窗口中运行 npm start。</p>
<h2 id="二-项目业务优化"><a class="header" href="#二-项目业务优化">二 项目业务优化</a></h2>
<h3 id="21-安全"><a class="header" href="#21-安全">2.1 安全</a></h3>
<p>Web 安全中，常见有两种攻击方式：XSS（跨站脚本攻击）和 CSRF（跨站点请求伪造）。</p>
<p>对 JWT 的认证方式，因为没有 cookie，所以也就不存在 CSRF。如果你不是用的 JWT 认证方式，可以使用 csurf 这个库去解决这个安全问题。</p>
<p>对于 XSS，可以使用 helmet 去做安全防范。helmet 中有 12 个中间件，它们会设置一些安全相关的 HTTP 头。比如 xssFilter 就是用来做一些 XSS 相关的保护。</p>
<p>对于单 IP 大量请求的暴力攻击，可以用 <a href="https://github.com/nfriedly/express-rate-limit">https://github.com/nfriedly/express-rate-limit</a> 来进行限速。</p>
<p>对于常见的跨域问题，Nestjs 提供了两种方式解决，一种通过 app.enableCors() 的方式启用跨域，另一种像下面一样，在 Nest 选项对象中启用。</p>
<p>最后，所有这些设置都是作为全局的中间件启用，最后 main.ts 中，和安全相关的设置如下：</p>
<pre><code class="language-ts">import * as helmet from 'helmet'
import * as rateLimit from 'express-rate-limit'

async function bootstrap() {
  const app = await NestFactory.create(AppModule, { cors: true })

  app.use(helmet())
  app.use(
    rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // limit each IP to 100 requests per windowMs
    })
  )

  await app.listen(config.port, config.hostName, () =&gt; {
    Logger.log(
      `Awesome-nest API server has been started on http://${config.hostName}:${config.port}`
    )
  })
}
</code></pre>
<h3 id="22-http-请求"><a class="header" href="#22-http-请求">2.2 http 请求</a></h3>
<p>Nestjs 中对 Axios 进行了封装，并把它作为 HttpService 内置到 HttpModule 中。HttpService 返回的类型和 Angular 的 HttpClient Module 一样，都是 observables，所以可以使用 rxjs 中的操作符处理各种异步操作。</p>
<p>首先，我们需要导入 HttpModule：</p>
<pre><code class="language-ts">import { Global, HttpModule, Module } from '@nestjs/common'

import { CommonService } from './services/common.service'

@Global()
@Module({
  imports: [HttpModule],
  providers: [CommonService],
  exports: [HttpModule, CommonService],
})
export class CommonModule {}
</code></pre>
<p>这里我们把 HttpModule 作为全局模块，在 CommonModule 中导入并导出以便其他模块使用，比如在 CommonService 中注入 HttpService，然后调用其 get 方法获得 Observable 流。</p>
<p>这时候我们就可以使用 HttpService，比如我们在 LunarCalendarService 中注入 HttpService，然后调用其 get 方法请求当日的农历信息。这时候 get 返回的是 Observable。</p>
<p>对于这个 Observable 流，可以通过 pipe 进行一系列的操作，比如我们直接可以使用 rxjs 的 map 操作符帮助我们对数据进行一层筛选，并且超过 5s 后就会报 timeout 错误，catchError 会帮我们捕获所有的错误，返回的值通过 of 操作符转换为 observable：</p>
<pre><code class="language-ts">import { HttpService, Injectable } from '@nestjs/common'
import { of, Observable } from 'rxjs'
import { catchError, map, timeout } from 'rxjs/operators'

@Injectable()
export class CommonService {
  constructor(private readonly httpService: HttpService) {}

  getUid(): Observable&lt;any&gt; {
    return this.httpService.get('https://api.demo.com/uid').pipe(
      map((res) =&gt; res.data.data),
      timeout(5000),
      catchError((error) =&gt; of(`Bad Promise: ${error}`))
    )
  }
}
</code></pre>
<p>如果需要对 axios 进行配置，可以直接在 Module 注册的时候设置：</p>
<pre><code class="language-ts">import { Global, HttpModule, Module } from '@nestjs/common'

import { CommonService } from './services/common.service'

@Global()
@Module({
  imports: [
    HttpModule.register({
      timeout: 5000,
      maxRedirects: 5,
    }),
  ],
  providers: [CommonService],
  exports: [HttpModule, CommonService],
})
export class CommonModule {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="01-内存管理-1-垃圾回收算法"><a class="header" href="#01-内存管理-1-垃圾回收算法">01-内存管理-1-垃圾回收算法</a></h1>
<h2 id="一-垃圾回收概念"><a class="header" href="#一-垃圾回收概念">一 垃圾回收概念</a></h2>
<h3 id="11-内存的申请与释放"><a class="header" href="#11-内存的申请与释放">1.1 内存的申请与释放</a></h3>
<p>程序的运行需要操作系统提供内存支持，比如声明的变量、函数等都需要内存来进行存储。这些从操作系统申请的内存，在无需使用时必须进行释放，否则长时间占用操作系统资源，会引起不必要的性能降低、资源浪费，比如申请的变量已经在函数中使用完毕，其他地方无需使用，这个变量所占据的内存就需要释放！</p>
<p>简单来说：内存要一般有申请、使用、释放三个流程。</p>
<p>简单展示 C 语言内存的申请与释放操作：</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    // 申请：申请一个数组内存来存储整型数据，元素个数为5
    int *arr = malloc(5 * sizeof(int));

    // 使用：制作数组数据，并打印数据
    for(int i = 0; i &lt; 5; i++){
        arr[i] = i + 1;
    }
    for(int i = 0; i &lt; 5; i++){
        printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);
    }

    // 释放：
    free(arr);

    // 此时再打印数据会报错
    return 0;
}
</code></pre>
<p>从上看出，C 语言是需要手动进行内存管理的，通过 <code>malloc()</code> 函数申请内存，通过 <code>free()</code> 函数释放内存，这对开发者来说造成了极大的心理负担，尤其在大型复杂项目上，内存的申请与释放更要小心。</p>
<h3 id="12-自动销毁"><a class="header" href="#12-自动销毁">1.2 自动销毁</a></h3>
<p>一些适合快速开发普通业务的编程语言，如 Java、JavaScript 等语言的引擎内部会对内存进行自动申请、释放，能够有效提升开发效率，称为<strong>垃圾回收</strong>，其基本思路是：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。</p>
<p>js 示例：</p>
<pre><code class="language-js">// 申请
let arr = [1, 2, 3, 4, 5]

// 使用
arr.forEach((item) =&gt; {
  console.log(item)
})

// 释放:JS 没有释放的 API，是自动释放的，设置为 null 也不会直接触发释放，只是会清除其引用。
arr = null
</code></pre>
<h2 id="二-垃圾回收算法"><a class="header" href="#二-垃圾回收算法">二 垃圾回收算法</a></h2>
<h3 id="20-垃圾回收算法汇总"><a class="header" href="#20-垃圾回收算法汇总">2.0 垃圾回收算法汇总</a></h3>
<p>垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。</p>
<p>垃圾回收常用的两种标记策略是：标记清除、引用计数。</p>
<ul>
<li>引用计数：记录申请的内存被引用的数，当被引用数为 0 时，销毁该内存。可以即时回收垃圾对象，但是无法解决循环引用问题。</li>
<li>标记清除：遍历所有对象，并标记活动对象，对没有被标记的对象进行清除。不能即时回收垃圾对象，但是可以解决循环引用问题，且会产生内存碎片。</li>
</ul>
<p>此外，在使用上述算法进行回收时，还需要用到：标记整理、分代回收等算法机制，这些是垃圾回收机制的核心。</p>
<h3 id="21-引用计数"><a class="header" href="#21-引用计数">2.1 引用计数</a></h3>
<p>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p>
<p>引用计算 GC 示例：</p>
<pre><code class="language-js">let obj = { name: 'zs' }

let other = obj

obj = null
console.log(other.name) // zs

other = null
console.log(other.name) // 错误
</code></pre>
<p>引用计数缺点：</p>
<pre><code class="language-txt">程序暂停：使用引用计数进行垃圾回收时，程序会暂停运行，即 Stop The World，这显然是不合理的，应该最大限度减少程序的暂停
循环引用无法回收：应用计数无法解决循环依赖问题，会引起内泄露
开销大：程序需要使用一个数值监控数据的引用数，该数值需要时刻被监控，这会造成时间、空间的开销放大。
</code></pre>
<p>循环依赖即循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用：</p>
<pre><code class="language-js">function problem() {
  let A = {}
  let B = {}
  A.other = B
  B.other = A
}
</code></pre>
<p>上述示例中，全局作用已经找不到 A 和 B，但是在函数内存，A 与 B 是互相引用者，即产生了循环引用，是无法使用引用计数进行清除的，因为当函数执行完毕后，A 和 B 还将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。</p>
<h3 id="22-标记清除"><a class="header" href="#22-标记清除">2.2 标记清除</a></h3>
<p>标记清除算法（mark-and-sweep）是最常见的垃圾回收策略，包含两个阶段：</p>
<ul>
<li>标记：对活动对象（可达对象）进行标记</li>
<li>清除：清除没有标记的对象</li>
</ul>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，即变量进入上下文时，比如在函数内部声明一个变量，这个变量会被加上存在于上下文中的标记，当变量离开上下文时，也会被加上离开上下文的标记。</p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。</p>
<p>垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p>
<p>一般称呼可以访问到的对象为可达对象（通过引用、作用域链访问到）。可达的标准是：从根（全局上下文）出发是否能够访问到该对象。</p>
<pre><code class="language-js">let obj = { name: 'zs' }

let other = obj

obj = null

// 这里清除了 obj 对 {name: 'zs'} 的引用，但是 other 仍然在引用着 obj
// 所以 {name: 'zs'} 仍然是可达的
console.log(other.name) // zs
</code></pre>
<p>如果该对象不可达，就会执行标记清除。所以在循环引用案例中，A，B 对象都离开了作用域，变为不可达，就不会再有循环应用的问题了。</p>
<p>当然标记清除也不是没有缺点，标记清除很容易造成<strong>内存碎片</strong>。</p>
<h2 id="三-垃圾回收的性能"><a class="header" href="#三-垃圾回收的性能">三 垃圾回收的性能</a></h2>
<p>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始
收集垃圾，都能让它尽快结束工作。</p>
<p>现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如，根据 V8 团队 2016 年的一篇博文的说法：“在一次完整的垃圾回收之后， V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。”</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-内存管理--3-内存泄露与管理"><a class="header" href="#01-内存管理--3-内存泄露与管理">01-内存管理 -3-内存泄露与管理</a></h1>
<h2 id="一-内存泄露"><a class="header" href="#一-内存泄露">一 内存泄露</a></h2>
<h3 id="11-内存泄露概念"><a class="header" href="#11-内存泄露概念">1.1 内存泄露概念</a></h3>
<blockquote>
<p>内存泄露：在应用程序中，可能会存在一些被开发者认为已经回收，实际却未被回收的对象，这会导致内存的占用会随着这些对象实例的增加而不断增长（即：内存持续升高，没有下降趋势），一旦达到 V8 的内存限制，将会触发内存溢出错误，进而导致进程退出</p>
</blockquote>
<p>内存膨胀：应用的内存占用升高也可能是设备本身问题，如果在多数设备上都存在性能问题，则为内存泄露。</p>
<p>相对于常见桌面软件，浏览器获取到的内存要少的多，这是由于安全性的考虑，用来避免运行大量网页耗尽操作系统内存。对浏览器的内存限制，不仅影响了变量分配，也会影响到调用栈、同时在一个线程中执行语句的数量，不过将内存占用保持在一个较小值可以让页面的性能更好。</p>
<h3 id="12-造成内存泄露的原因"><a class="header" href="#12-造成内存泄露的原因">1.2 造成内存泄露的原因</a></h3>
<p>内存泄露的原因：</p>
<ul>
<li>作用域未释放</li>
<li>缓存</li>
<li>队列消费不及时</li>
</ul>
<p>滥用全局变量导致作用域未被释放是最常见的引发内存泄露问题的方式：</p>
<pre><code class="language-js">function setName() {
  // 该变量挂载到了 window 下，除非关闭浏览器，否贼不会清理
  name = 'Jake'
}
</code></pre>
<p>定时器也会造成内存泄露：</p>
<pre><code class="language-js">// let 声明的全局变量不会挂载到 window 上，但是这里由于定时器原因 name 无法被回收
let name = 'Jake'
setInterval(() =&gt; {
  console.log(name)
}, 100)
</code></pre>
<p>IE8 中滥用闭包造成内存泄露：</p>
<pre><code class="language-js">// 只要 返回的函数存在就不能清理 name
var outer = function () {
  var name = 'Jake'
  return function () {
    return name
  }
}
</code></pre>
<h3 id="13-确认内存泄露"><a class="header" href="#13-确认内存泄露">1.3 确认内存泄露</a></h3>
<p>查看内存工具有：</p>
<ul>
<li>浏览器的任务管理器查看：用来判断当前网页是否存在内存一直上升</li>
<li>Timeline 时序图：Chrome 的性能分析工具 Performance，注意要勾选 内存选项。</li>
<li>堆快照查找分离 DOM：位于浏览器的内存工具，可以找到代码中需要释放的 DOM，必须不再使用的 ul，据此可以在代码中设置 <code>ulDom=null</code></li>
</ul>
<p>如果应用在频繁 GC，就会导致应用假死，让用户感知到卡顿现象，判断是否存在频繁 GC：</p>
<ul>
<li>Timeline 中频繁的上升下降</li>
<li>任务管理器中数据频繁的增加减小</li>
</ul>
<h2 id="二-内存优化"><a class="header" href="#二-内存优化">二 内存优化</a></h2>
<h3 id="21-常见基础优化"><a class="header" href="#21-常见基础优化">2.1 常见基础优化</a></h3>
<p>优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据，即：尽量减少全局变量的定义，减少 window 上的挂载量，尽量减少不必要的全局查找都可以有效降低 GC 负荷。</p>
<pre><code class="language-js">function fn() {
  const h = window.innerHeight
  // 使用 h 而不使用 window.innerHeight
}
</code></pre>
<p>使用 null 避免循环引用：</p>
<pre><code class="language-js">function fn() {
  let obj = document.querySelector('.box')
  box.onclick = function () {
    console.log(this)
  }
  obj = null // 当场断开引用，避免循环
}
</code></pre>
<p>当然也可以更换为这种方案：</p>
<pre><code class="language-js">function action() {
  console.log(this)
}

function fn() {
  let obj = document.querySelector('.box')
  box.onclick = action
}
</code></pre>
<p>采用字面量替换 new：</p>
<pre><code class="language-js">let arr1 = [] // 推荐
let arr2 = new Object() //不推荐：new 的额外操作较多，多涉及了一次 Object() 函数的调用
</code></pre>
<p>采用事件委托，给多个元素循环添加事件。</p>
<p>使用文档碎片代替 append。</p>
<h3 id="22-作用域未释放问题"><a class="header" href="#22-作用域未释放问题">2.2 作用域未释放问题</a></h3>
<p>JS 的闭包机制使得被异步调用打断的逻辑，在等待异步完成的过程中，上下文环境仍然能够保留。异步调用完成之后，回调函数可以在它需要的上下文环境中继续执行。闭包的这个特点，使得它可以引用它之外的自由变量。一个函数执行完毕，其内部变量应该可以被回收，但是闭包的引用，使这个问题变得稍微复杂一些。如果闭包被引用，而这个闭包又在有效期内，则这些变量不会被回收。</p>
<pre><code class="language-JavaScript">function CreatePerson(name) {
    let o = {
        sayName:function () {
            console.log(_name);
        }
    };
    let _name = name;
    return o;
}
let p = CreatePerson('zs');
p.sayName();
</code></pre>
<p>构造函数创建的 p 对象是一个闭包，这个闭包引用了构造函数中的_name 变量，这个变量不会被释放，除非将 p 赋值为 null。</p>
<pre><code class="language-JavaScript">let fn = function () {
    let largeArr = new Array(1000);
    return function () {
        console.log('run once');
        return largeArr;
    };
}();
setTimeout(fn,2000);
fn = null;
</code></pre>
<p>虽然 fn 被设置为 null，但是对象不会被释放，回调的是 fn 原来的闭包。</p>
<p>只要满足以下条件中的任意一个，对象均不会被回收：</p>
<ul>
<li>全局变量或者由全局变量触发，可以访问到的对象；</li>
<li>正执行函数中的局部对象，包括这些局部对象可以访问到的对象；</li>
<li>一个非全局对象，如果被一个闭包引用，则这个对象将和引用它的闭包异同存在，即使离开了创建它的环境。这个对象称为自由变量，它为未来闭包执行的时候保留上下文。</li>
</ul>
<p>全局作用域的对象是常驻内存的（老生代），需要等到进程退出才能释放。如果需要释放常驻内存的对象，可以通过 delete 操作来删除引用关系，或者将变量重新赋值，让旧的对象脱离引用关系，在接下来的老生代内存清除和整理过程中，会被回收释放：</p>
<pre><code class="language-js">global.foo = 'global object!'
delete global.foo // 删除
global.foo = null // 或者赋值为 null、undefined
</code></pre>
<p>注意：</p>
<ul>
<li>非全局变量也可以使用赋值 null、delete 进行释放</li>
<li>v8 中，delete 和赋值 null 是不一样的，delete 删除对象会干扰 v8 优化，推荐使用赋值解除引用</li>
</ul>
<h3 id="23-null-解除引用"><a class="header" href="#23-null-解除引用">2.3 null 解除引用</a></h3>
<p>将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用：</p>
<pre><code class="language-js">function createPerson(name) {
  let localPerson = new Object()
  localPerson.name = name
  return localPerson
}
let globalPerson = createPerson('Nicholas')
// 解除 globalPerson 对值的引用
globalPerson = null
</code></pre>
<p>贴士：解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境（不在上下文），以便垃圾收集器下次运行时将其回收。</p>
<p>此外，IE8 及其之前的浏览器，BOM 和 DOM 中部分对象 是由 C++控制的，直到 IE9 才转变为纯 JS 控制对象。采用 C++控制的对象以 COM（Component Object Model，组件对象模型）的形式实现，而 COM 对象的垃圾收集机制采用的就是引用计数策略。因此，即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。下面这个简单的例子，展示了使用 COM 对象导致的循环引用问题：</p>
<pre><code class="language-js">let element = document.getElementById('some_element')
let myObject = new Object()
myObject.element = element
element.someObject = myObject
</code></pre>
<p>这个例子在一个 DOM 元素（element）与一个原生 JavaScript 对象（myObject）之间创建了循环引用。即使将例子中的 DOM 从页面中移除，它也不会被回收。</p>
<p>为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与 DOM 元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用：</p>
<pre><code class="language-js">myObject.element = null
element.someObject = null
</code></pre>
<p>将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。</p>
<h3 id="23-v8-的隐藏类和删除操作"><a class="header" href="#23-v8-的隐藏类和删除操作">2.3 V8 的隐藏类和删除操作</a></h3>
<pre><code class="language-js">function Article() {
  this.title = 'Inauguration Ceremony Features Kazoo Band'
}
let a1 = new Article()
let a2 = new Article()
</code></pre>
<p>V8 会创建一个隐藏类，a1 和 a2 共享隐藏类的对象，以保证性能，但是如果这里在 new 完之后，再新增一个属性，就无法共享了，所以可以提前将类的所有属性列出，以让更多的实例共享隐藏类：</p>
<pre><code class="language-js">function Article(opt_author) {
  this.title = 'Inauguration Ceremony Features Kazoo Band'
  this.author = opt_author
}
let a1 = new Article()
let a2 = new Article('Jake')
</code></pre>
<p>在代码结束后，即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为 null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。</p>
<pre><code class="language-js">function Article() {
  this.title = 'Inauguration Ceremony Features Kazoo Band'
  this.author = 'Jake'
}
let a1 = new Article()
let a2 = new Article()
a1.author = null // 不推荐：delete a1.author;
</code></pre>
<h3 id="23-静态分配对象池"><a class="header" href="#23-静态分配对象池">2.3 静态分配对象池</a></h3>
<p>开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能，最终达到压榨浏览器性能的效果。</p>
<p>浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。看一看下面的例子，这是一个计算二维矢量加法的函数：</p>
<pre><code class="language-js">function addVector(a, b) {
  let resultant = new Vector()
  resultant.x = a.x + b.x
  resultant.y = a.y + b.y
  return resultant
}
</code></pre>
<p>调用这个函数时，会在堆上创建一个新对象，然后修改它，最后再把它返回给调用者。如果这个矢量对象的生命周期很短，那么它会很快失去所有对它的引用，成为可以被回收的值。假如这个矢量加法函数频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。该问题的解决方案是不要动态创建矢量对象，比如可以修改上面的函数，让它使用一个已有的矢量对象：</p>
<pre><code class="language-js">function addVector(a, b, resultant) {
  resultant.x = a.x + b.x
  resultant.y = a.y + b.y
  return resultant
}
</code></pre>
<p>这需要在其他地方实例化矢量参数 resultant，但这个函数的行为没有变。那么在哪里创
建矢量可以不让垃圾回收调度程序盯上呢？</p>
<p>一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。下面是一个对象池的伪实现：</p>
<pre><code class="language-js">// vectorPool 是已有的对象池
let v1 = vectorPool.allocate()
let v2 = vectorPool.allocate()
let v3 = vectorPool.allocate()

v1.x = 10
v1.y = 5
v2.x = -3
v2.y = -6

addVector(v1, v2, v3)
console.log([v3.x, v3.y]) // [7, -1]

vectorPool.free(v1)
vectorPool.free(v2)
vectorPool.free(v3)

// 如果对象有属性引用了其他对象
// 则这里也需要把这些属性设置为 null
v1 = null
v2 = null
v3 = null
</code></pre>
<p>如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收。比如下面这个例子：</p>
<pre><code class="language-js">let vectorList = new Array(100)
let vector = new Vector()
vectorList.push(vector)
</code></pre>
<p>由于 JavaScript 数组的大小是动态可变的，引擎会删除大小为 100 的数组，再创建一个新的大小为 200 的数组。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。不过，必须事先想好这个数组有多大。</p>
<p>贴士：静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。</p>
<h3 id="24-缓存问题解决"><a class="header" href="#24-缓存问题解决">2.4 缓存问题解决</a></h3>
<p>缓存可以有效降低 I/O，提高性能，但是在 V8 中，一旦一个对象被当做缓存来使用，就会常驻在老生代中，缓存系统中的键越多，长期存活的对象也越多，最终导致 GC 在进行扫描和整理时，对这些对象做无用功。针对该问题，缓存必须限制缓存对象的大小，并加上适当的过期策略防止无限增长。</p>
<p>最简单的缓存限制策略就是查看键值对数量，当键值对数量达到最大限制时，删除最初添加的数据。当然这种做法显然也是不成熟的，推荐查看 npm 作者实现的 LRU 算法：<a href="https://github.com/isaacs/node-lru-cache">https://github.com/isaacs/node-lru-cache</a>。</p>
<p>缓存数据交给一些专业的内存管理工具处理，如：Redis 数据库、Kafka 消息队列。</p>
<h2 id="三-深入-js-运行时"><a class="header" href="#三-深入-js-运行时">三 深入 JS 运行时</a></h2>
<p>在静态类型语言中，每一个变量，都有唯一确定的类型，对象的成员信息在编译阶段就可确定，执行时 CPU 只需要用对象首地址---在 C++中是 this 指针，加上成员在对象内部的偏移量即可访问内部成员。</p>
<p>但是 JS 中，变量在运行时可以随时由不同类型的对象赋值，并且对象本身可以随时添加成员。访问对象属性需要的信息完完完全由运行时决定。</p>
<p>为了实现按照索引方式访问成员，V8 内部给运行中的对象分了类，产生了 V8 内部的数据结构，即隐藏类，隐藏类本身是一个对象。当定义一个构造函数，使用这个函数生成第一个对象时，V8 会为它初始化一个隐藏类。以后使用这个构造函数生成的对象指向同一个隐藏类。但假如程序中对某个对象添加或者删除了某个属性，V8 立即创建一个新的隐藏类，改变之后的对象指向新的隐藏类。</p>
<p>所以，隐藏类起到了给对象分组的作用。同一组对象，具有相同的成员名称，隐藏类记录了成员名称和偏移量，根据这些信息，V8 能够按照对象首地址 + 偏移量访问成员变量。在程序中，访问对象成员非常频繁，相比于把属性名作为键值，使用字典查找的方式存取成员，使用索引的方式对性能的改进更明显。</p>
<p>借助隐藏类，可以使用数组索引的方式存取对象成员。但成员的索引值是以哈希表的方式存储在隐藏类中。如果每次访问属性都搜寻隐藏类的哈希表，那么这种用偏移量的方式不会带来任何好处。内联缓存是基于程序运行的局部性原理，动态生成使用索引查找的代码。下一次存取成员不必再去搜寻哈希表。</p>
<p>V8 还使用了 Crankshaft 编译器生成更高效的机器码。当 V8 发现某函数执行频繁，就会将其标记为热点函数，V8 会认为该函数比较稳定，类型已经确定，会调用 Crankshaft 编译器，生成更高效的机器码，只有遇到类型变化，才会回退到优化前的情况。</p>
<p>示例：</p>
<pre><code class="language-JavaScript">//代码1
let obj1 = {};
obj1.name = 'lisi';
//代码2
let obj2 = {
    name:'lisi'
};
//代码2的效率要比代码1更高，因为代码1是在动态的添加属性。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-内存管理--2-v8-引擎与分代回收"><a class="header" href="#01-内存管理--2-v8-引擎与分代回收">01-内存管理 -2-V8 引擎与分代回收</a></h1>
<h2 id="一-v8-简介"><a class="header" href="#一-v8-简介">一 V8 简介</a></h2>
<p>V8 引擎是由 Google 开源的著名 JavaScript 引擎，使用该引擎的运行时平台，其 JS 的内存管理也是由 V8 负责的，如：Chrome、NodeJS。</p>
<p>V8 与其他 JS 引擎最大的区别是：V8 实现了即时编译，无需先解析再运行。</p>
<p>V8 对内存做了一部分限制：</p>
<ul>
<li>64 位系统下约为 1.4G</li>
<li>32 位系统下约为 0.7G</li>
</ul>
<p>在 V8 中，1.4G 内存进行一次完全的垃圾回收，需要 1 秒以上，这个暂停时间称为 <strong>Stop the world</strong>，在暂停期间，应用的性能和响应能力都会大幅下降。</p>
<p>V8 的这套内存管理机制是针对浏览器而设计的，这样的内存需求在前端页面中使用起来绰绰有余（因为每个网页选项卡都是一个 v8 实例），而在服务端开发，则在一些场合捉襟见肘。V8 的这个限制使得 Node 无法直接操作大内存对象，在单个 Node 进程中，计算机的内存资源无法得到充足的使用。</p>
<h2 id="二-v8-的内存限制"><a class="header" href="#二-v8-的内存限制">二 V8 的内存限制</a></h2>
<h3 id="21-内存占用"><a class="header" href="#21-内存占用">2.1 内存占用</a></h3>
<p>内存占用图：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/v8-01.svg" alt="v8 内存占用" /></p>
<p>Node 中输出数据样例：</p>
<pre><code class="language-js">// console.log(process.memoryUsage())
// 示例中 rss 大约占据 20M。heapUsed 大约为 4M
{
  rss: 20824064,                // resident set size：所有内存占用，包括指令区、堆栈
  heapTotal: 7159808,           // 堆内存已申请到空间，包括已使用和未使用的
  heapUsed: 4270176,            // 堆内存当前使用量，可以用来判断内存泄露
  external: 8224                // v8 内部的 C++ 对象占用的内存
}
</code></pre>
<p>堆内存中使用量占比图：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/v8-02.svg" alt="v8 内存占用" /></p>
<p>堆的大小会随着存储的对象变多，而逐步申请新空间，增大容量，直到堆的大小超过 V8 的限制为止。表面上看，V8 对内存的限制是因为浏览器不需要使用大内存，深层原因其实是 V8 的垃圾回收机制限制。1.5GB 堆内存的回收，V8 需要耗时 50ms 以上，而做一次非增量的垃圾回收需要 1s 以上，这是垃圾回收中引起 JS 线程暂停执行的时间，这样的时间暂停会严重影响服务器响应能力。所以 v8 直接选择限制大内存使用，就可以快速避免 GC 导致的 JS 线程暂停时间过长问题。</p>
<h3 id="22-查看垃圾回收日志"><a class="header" href="#22-查看垃圾回收日志">2.2 查看垃圾回收日志</a></h3>
<p>在 Node 启动时：</p>
<ul>
<li>添加<code>--trace_gc</code>参数，即可查看垃圾回收的日志信息。</li>
<li>添加<code>--prof</code>参数，即可得到 V8 执行时的性能分析数据</li>
</ul>
<p>但是得到的 v8.log 日志文件可读性很差，但是 v8 提供了日志统计工具，位于 Node 源码的 <code>deps/v8/tools</code>目录：</p>
<ul>
<li>Linux 中：linux-tick-processor v8.log</li>
<li>Win 中：windows-tick-processor.bat v8.log</li>
</ul>
<h2 id="三-v8-的垃圾回收机制"><a class="header" href="#三-v8-的垃圾回收机制">三 V8 的垃圾回收机制</a></h2>
<h3 id="30-v8-的垃圾回收算法"><a class="header" href="#30-v8-的垃圾回收算法">3.0 v8 的垃圾回收算法</a></h3>
<p>由于不同的对象，其生存周期长短不一，一种垃圾回收算法不能完全应对所有情况，所以 v8 的垃圾回收策略采用了更高效的<strong>分代式垃圾回收机制</strong>。即：按对象的存储时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存使用更适合其特征的 GC 算法。</p>
<p>V8 将内存设置为了 2 个分代，V8 堆的整体大小就是这 2 个分代所用的内存之和，在启动时候可以通过下面的参数设置其大小：</p>
<ul>
<li>新生代：<code>--max-new-space-size</code> 参数就是设置新生代空间的最大值，单位为 KB，在 64 位中占据 32M，32 位占据 16M。</li>
<li>老生代：<code>--max-old-space-size</code> 参数就是设置老生代空间的最大值，单位为 MB，在 64 位中占据 1400M，32 位占据 700M。</li>
</ul>
<p>新生代存储的是存活时间较短的对象，老生代用于存储长期活动的对象。</p>
<p>V8 中主要使用的策略与算法有：分代回收、空间复制、标记清除、标记整理、标记增量。</p>
<h3 id="31-新生代回收---复制算法"><a class="header" href="#31-新生代回收---复制算法">3.1 新生代回收 - 复制算法</a></h3>
<p>新生代垃圾回收算法是基于 Cheney 的算法 Scavenge，Cheney 采用复制的方式实现垃圾回收。</p>
<p>新生代堆内存也被分为 2 个相等的空间，都称呼为 semispace：</p>
<ul>
<li>From 空间：处于使用中</li>
<li>To 空间：处于闲置状态</li>
</ul>
<p>贴士：64 位系统中，新生代内存是 32M，From 和 To 各占 16M。（32 位系统中除以 2 即可）。</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/v8-03.svg" alt="v8 内存占用" /></p>
<p>复制算法过程：</p>
<pre><code class="language-txt">对象会优先从 From 区域进行分配，开始 GC 时，会检查 From 空间的存活对象；
存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放；
完成复制后，From 空间和 To 空间的角色发生互换。
</code></pre>
<p>简单来说，Cheney 复制算法就是通过将存活对象在两个 semispace 空间进行复制。</p>
<p>从上述理论看出，复制算法只有一半空间被程序使用了，另外一半始终作为了备用的存活对象存储区域，是典型的牺牲空间换取时间的算法。所以无法大规模应用到所有垃圾回收过程中，只适合新生代，因为新生代对象的生命周期很短，这样也能更大效率利用这两块区域。</p>
<h3 id="32-新生代晋升到老生代"><a class="header" href="#32-新生代晋升到老生代">3.2 新生代晋升到老生代</a></h3>
<p>当一个对象经过多次复制依然存活时，它会被认为是生命周期较长的对象，拷贝时会直接被迁移到老生代中，这就是晋升。</p>
<p>晋升的条件是下列条件之一：</p>
<ul>
<li>对象是否已经经过 Scavenge 回收</li>
<li>To 空间的内存占用比超过限制（25%）。因为 Scavenge 回收完成后，To 空间转变为 From 空间，接下来内存分配在该空间进行，占比过高会影响后续内存分配</li>
</ul>
<h3 id="33-老生代回收---标记清除"><a class="header" href="#33-老生代回收---标记清除">3.3 老生代回收 - 标记清除</a></h3>
<p>老生代中存活对象占比大，使用 Scavenge 会有 2 个问题：复制存活对象效率降低，也会出现一半空间浪费。所以 V8 在老生代使用的是 Mark-Sweep 和 Mark-Compact 相结合的方式进行垃圾回收。</p>
<p>Mark-Sweep：即标记清除，分为标记、清除 2 个阶段：</p>
<ul>
<li>标记时会遍历堆中所有对象，并标记活着的对象</li>
<li>清除阶段，只清除没有被标记的对象</li>
</ul>
<p>该算法与 Scavenge 的区别是：</p>
<ul>
<li>不会将内存划分为两半，所以不会造成内存空间浪费</li>
<li>Scavenge 只复制活着的对象，Mark-Sweep 只清理死亡的对象。</li>
</ul>
<p>新生代中活对象占据较小部分，而老生代中是死对象占据小部分，这就是采用两个算法不同的缘由。</p>
<h3 id="34-老生代回收---标记整理"><a class="header" href="#34-老生代回收---标记整理">3.4 老生代回收 - 标记整理</a></h3>
<p>标记清除一般用于处理老生代的回收，相比引用计数来说，无需移动数据，但是由于扫描后会清除无引用区域，会造成堆区出现内存碎片，即：在进行一次标记清除后，内存会出现不连续的情况，会产生碎片。</p>
<p>在后续如果要分配一个较大的对象内存时，这些碎片空间都无法完成此次分配，就需要提前触发垃圾回收，而这次回收其实是不必要的，如图所示，灰色部分为死对象：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/v8-04.svg" alt="v8 内存占用" /></p>
<p>Mark-Compact：是由 Mark-Sweep 演变而来的，用于解决上述碎片问题。他们的差别是在对象被标记为死亡后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。即：在扫描时，将要清理的内存移动在一侧，无需清理的移动在另一侧，扫描完毕后只需要清除其中一侧，这种做法付出了移动的时间代价，但是内存碎片更少。</p>
<p>如图所示完成标记并移动存活对象后的示意图，蓝色格子为存活对象，深色格子为死亡对象，浅色格子为存活对象移动后扣下的空洞。</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/v8-05.svg" alt="v8 内存占用" /></p>
<p>上图中，完成移动后直接清除最右边的存活对象后面的内存区域完成回收。</p>
<h3 id="35-老生代回收---增量标记与延迟清理"><a class="header" href="#35-老生代回收---增量标记与延迟清理">3.5 老生代回收 - 增量标记与延迟清理</a></h3>
<p>在执行垃圾回收时，必须让应用程序和垃圾回收期看到的情况一致！所以，一旦执行垃圾回收，就需要将应用程序暂停，等待 GC 完成后再恢复执行应用逻辑。一般称这个过程为 Stop-the-world（全停顿）。</p>
<p>V8 的新生代全停顿影响很小，因为新生代配置较小，且存活对象少。</p>
<p>但是 V8 的老生代中，存活对象多，全堆垃圾回收（full 垃圾回收）的标记、清理造成的停顿对用户影响较大。为了降低停顿带来的影响，V8 在标记阶段，将原本要一次性完成的动作改为增量标记（incremental marking），即拆分为许多小步骤，每做完一个小步骤，就让 JS 应用逻辑执行一会，垃圾回收应用逻辑交替执行直到标记阶段完成。</p>
<p>使用增量标记后，V8 的最大停顿时间减少了原本的 1/6 左右。</p>
<p>V8 还存在延迟清理（lazy sweeping），增量式整理（incremental compaction），让清理、整理动作也变成了增量式。</p>
<p>V8 也会在未来引进并行标记、并行清理等进一步利用多核，降低停顿时间。</p>
<h2 id="四-总结"><a class="header" href="#四-总结">四 总结</a></h2>
<div class="table-wrapper"><table><thead><tr><th>回收算法</th><th>速度</th><th>空间开销</th><th>是否移动对象</th></tr></thead><tbody>
<tr><td>Mark-Sweep</td><td>中等</td><td>少，有碎片</td><td>否</td></tr>
<tr><td>Mark-Compact</td><td>最慢</td><td>少，无碎片</td><td>是</td></tr>
<tr><td>Scavenge</td><td>最快</td><td>双倍空间，无碎片</td><td>是</td></tr>
</tbody></table>
</div>
<p>V8 主要使用 Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用 Mark-Compact。</p>
<p>V8 的堆分为：新生代（年轻分代）、老生代（年老分代）。</p>
<p>年轻分代的堆空间一分为二，</p>
<p>年轻分代主要用来保存声明周期短暂的对象，例如函数中的局部变量，当函数返回，调用栈中的局部变量就会被析构掉。当 V8 发现内存空间不够时，才会进行回收。</p>
<p>回收步骤是：</p>
<ul>
<li>将还被引用的对象复制到另一半区域；</li>
<li>释放当前一半空间，</li>
<li>把当前被释放的空间留作备用，两者角色互换。</li>
</ul>
<p>年轻分代类似线程的栈空间，本身不太大，占用它空间的对象类似 C++中的局部对象，生命周期非常短，因此大部分都是需要被清理掉的，需要赋值对象极少，虽然牺牲了部分内存，但是速度极快。</p>
<p>年老分代类似 C++中使用 new 操作符在堆中分配的对象。因为这类对象一般不会因为函数退出而销毁，因此生命周期较长。年老分代的大小远大于年轻分代（32 位为 700M，64 位为 1.4GB），包含：</p>
<ul>
<li>从年轻分代中移动过来的对象；</li>
<li>JIT 后产生的代码；</li>
<li>全局对象。</li>
</ul>
<p>如果年老分代采用年轻分代一样的清理算法，浪费一般空间不说，复制大块对象在时间上让人无法忍受，因此必须采用新的方式。V8 采用标记清除和标记整理的算法即将垃圾回收分为 2 个过程：</p>
<ul>
<li>标记清除阶段遍历堆中的所有对象，把有效的对象标记出来，之后清除垃圾对象。因为年老分代中需要回收的对象比例极小，所以效率极高。</li>
<li>当执行完一次标记清除后，堆内存变得不连续，内存碎片的存在使得不能有效使用内存。在后续的执行中，当遇到没有一块碎片内存能够满足申请对象需要的内存空间时，将处罚 V8 执行标记整理算法：标记整理移动对象，紧缩 V8 堆空间，将碎片的内存整理为大块内存。</li>
</ul>
<p>由于垃圾回收会阻塞 JS 代码的运行，上述两种算法是在 JS 运行时，会采取交替运行的方式，有效的减少了垃圾回收给程序造成的最大停顿时间。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="02-页面渲染流程"><a class="header" href="#02-页面渲染流程">02-页面渲染流程</a></h1>
<h2 id="一-渲染流程"><a class="header" href="#一-渲染流程">一 渲染流程</a></h2>
<h3 id="10-渲染基本流程"><a class="header" href="#10-渲染基本流程">1.0 渲染基本流程</a></h3>
<p>浏览器中的渲染引擎主要用于解析 HTML 文档、CSS 文档，并将 CSS 规则应用到 HTML 标签上，最终在浏览器内器窗口中展示出能够让用户理解的 DOM 内容。</p>
<p>Webkit 的渲染流程基本示例图：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/reflow-01.svg" alt="渲染流程" /></p>
<h3 id="11-html-文档解析"><a class="header" href="#11-html-文档解析">1.1 HTML 文档解析</a></h3>
<p>HTML 文档的解析是指将 HTML 文本字符串逐行解析生成具有父子关系的 DOM 节点数，如下所示：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/reflow-02.svg" alt="文档解析结构" /></p>
<p>浏览器从网络上下载的文件字节流是无法被渲染引擎直接理解的，需要转换为渲染引擎能够理解的 DOM（HTML 文档的结构化表述），网络进程加载了多少数据，HTML 解析器便解析多少数据。渲染引擎中的 <strong>HTML 解析器（HTMLParser）</strong> 即负责上述功能：将字节流转换为 DOM 结构。其转换过程是：</p>
<pre><code class="language-txt">字节流 --&gt; 分词器（Tokens）--&gt; 生成节点（Node）--&gt; DOM
</code></pre>
<p>网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p>
<p>字节流在解析时利用到了栈结构，首先创建一个为 document 的空 DOM 结构，同时将 document 的开始标签压入栈底，接着依次解析压入其他节点的开始标签、结束标签。</p>
<p>在解析 DOM 时，如果遇到 script 标签，则 HTML 解析器会暂停 DOM 解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构，此时 JS 引擎解析脚本内容并执行，执行完毕后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</p>
<p>Chrome 对解析过程进行了优化，即预解析操作：当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p>
<p>贴士：async 和 defer 会让 js 脚本变为异步，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</p>
<h3 id="12-css-解析"><a class="header" href="#12-css-解析">1.2 CSS 解析</a></h3>
<p>CSS 解析与 HTML 解析类似，首先也是通过词法分析生成 CSS 规则树状图，CSSRule 会保持每个不同的元素和对应样式的映射关系。</p>
<p>在渲染树的生成阶段，DOM 树中的节点会在 CSS 分析树中根据 CSS 选择器提取与之对应元素的 CSSRule，并且会进行层叠、权重运算，生成最终的 CSSRule 添加到 DOM 渲染树上。</p>
<p>当所有的 DOM 节点都提取完 CSS 时，渲染树就形成了。这时候可以开始进行布局、绘制。</p>
<h3 id="13-布局树"><a class="header" href="#13-布局树">1.3 布局树</a></h3>
<p>在 DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树，其本质：复制了 DOM 树的结构，并且过滤了不需要显式的元素，如： display:none 属性的元素、head 标签、script 标签等。</p>
<p>复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。</p>
<p>样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终布局树的构建。</p>
<h2 id="二-重排重绘"><a class="header" href="#二-重排重绘">二 重排重绘</a></h2>
<p>重排（reflow）：浏览器第一次渲染页面布局后，后续引起页面各个元素节点在页面所处位置的重新计算、重新布局。</p>
<p>重绘（repaint）：布局完成后，页面重新绘制，这时浏览器会遍历渲染树，绘制每个节点</p>
<p>重排一定会引起重绘。</p>
<p>涉及页面布局、位置改变，都会触发重排，如：offset 系列、scroll 系列、client 系列、resize。此外设置元素的 display 也会引起。</p>
<p>只改变颜色、背景、显示/隐藏（位置不变）只会引起重绘，如：visibility、outline、color、background。</p>
<p>不断的改变位置等触发重排、重绘，会造成性能损失，优化方案：先映射一个虚拟 DOM，对其进行操作，所有操作完毕后，才显示 DOM，可以极大限度减少重排、重绘次数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="022-浏览器-缓存机制"><a class="header" href="#022-浏览器-缓存机制">02.2-浏览器-缓存机制</a></h1>
<h2 id="一-浏览器缓存机制"><a class="header" href="#一-浏览器缓存机制">一 浏览器缓存机制</a></h2>
<p>浏览器的缓存机制其实是浏览器基于 HTTP 协议进行的文件缓存机制。当文件发生重复请求书会，浏览器可以根据 HTTP 响应头的协议信息判断是否从服务器请求文件还是从本地读取文件，其缓存判断机制如图：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/cache-01.svg" alt="缓存机制" /></p>
<p>第一步：浏览器查询 Cache-Control 是否过期。浏览器的 Expires 也会用来判断，只不过 Expires 用来设置的是绝对过期时间，而 Cache-Control 是相对过期时间。Cache-Control 中的 max-age 的单位是秒，如果和 Expires 同时存在，则采用 Cache-Control。</p>
<p>第二步：浏览器判断上次该资源的响应头中是否有 Etag 信息，有则连同 If-None-Match 一起向服务端发送请求，服务端判断 Etag 未修改则返回 304，修改则返回 200</p>
<p>第三步：浏览器判断上次该资源的响应头中是否有 Last-Modified 信息，有则连同 If-Modified-Since 一起向服务器发送请求，服务端判断 If-Modified-Since 是否失效，失效则返回 200，未失效则返回 304</p>
<p>第四步：如果 Etag 和 Last-Modified 都不存在，直接请求服务器资源。</p>
<p>客户端设置缓存：</p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;max-age=3600&quot; /&gt;
</code></pre>
<p>服务端设置缓存：</p>
<pre><code class="language-js">app.use(static('./index', maxage:3600))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="03-性能优化--1-优化汇总"><a class="header" href="#03-性能优化--1-优化汇总">03-性能优化 -1-优化汇总</a></h1>
<h2 id="一-html-优化"><a class="header" href="#一-html-优化">一 HTML 优化</a></h2>
<h3 id="11-简化-html-嵌套层级"><a class="header" href="#11-简化-html-嵌套层级">1.1 简化 HTML 嵌套层级</a></h3>
<p>浏览器在解析 HTML 文件时，会将标签挂载在 DOM 树中，标签嵌套的层级越深，DOM 树就越深。由于 DOM 树在访问时需要遍历，层级深会对遍历性能造成影响。</p>
<p>现代浏览器拥有很强的遍历算法，但是这并不代表算法可以将遍历时间降低到 0，适当减少 HTML 层级，仍然是优化 HTML 性能的策略之一。</p>
<p>对于 MVVM 框架来说，层级嵌套同样不能过深，比如 vue 中需要通过 replace() 函数绑定 setter、getter：</p>
<pre><code class="language-js">while (node.childNodes.length) {
  replace(node)
}
</code></pre>
<p>这是一个递归函数，每多一层嵌套，递归的深度就多一层，占用内存、时间消耗都会变多。</p>
<p>推荐组件的嵌套不超过 3 层。</p>
<h3 id="12-减少空格标签无用标签滥用"><a class="header" href="#12-减少空格标签无用标签滥用">1.2 减少空格标签、无用标签滥用</a></h3>
<p>很多没有多少实际作用的标签位可以无需书写标签，通过伪元素的方式生成。</p>
<h3 id="13-prefetchpreload-预加载-link-标签资源"><a class="header" href="#13-prefetchpreload-预加载-link-标签资源">1.3 prefetch、preload 预加载 link 标签资源</a></h3>
<p>link 标签设置 <code>rel=&quot;prefetch&quot;</code> 可以让浏览器在空闲时间下载该内容并缓存，下次再访问则是从缓存中获取，请求状态码为 304。</p>
<p>link 标签设置 <code>rel=&quot;dns-prefetch&quot;</code> 可以让浏览器在空闲时间预先解析 link 中该网址的 dns。</p>
<p>llink 标签设置 <code>rel=&quot;preload&quot;</code> 也会对资源进行预加载：</p>
<pre><code class="language-html">&lt;link rel=&quot;preload&quot; href=&quot;common.js&quot; as=&quot;script&quot; /&gt;
</code></pre>
<p>preload 预加载这个 js 文件后，不会被执行，而是在需要该 js 时候，动态插入执行，比如点击时执行：</p>
<pre><code class="language-js">btn.addEventListener('click', function () {
  let script = document.createElement('script')
  script.src = 'common.js'
  document.body.appendChild(script)
})
</code></pre>
<p>使用 preload 预加载，在页面开始显示之前，会多出一个请求，只不过该请求实在浏览器空闲时间完成，后续需要该资源时则无需再次请求。这样做牺牲了一定的首屏渲染时间，但是提升了整体性能。比如实际开发中，SSR 的导航需要从服务端获取，那么这个 js 可以使用 preload 加载。</p>
<p>不过当代浏览器一般都启用的隐式的预解析，无需专门设置。</p>
<h3 id="14-img-标签大小"><a class="header" href="#14-img-标签大小">1.4 img 标签大小</a></h3>
<p>img 很容易因为图像大小不同造成页面重绘、重排，在允许的情况下，可以固定其大小。</p>
<h3 id="15-src-与-href-值"><a class="header" href="#15-src-与-href-值">1.5 src 与 href 值</a></h3>
<p>src 和 href 的值为空时，页面找不到资源，会认为需要加载当前页面，从而拖慢一定的加载速度，一般需要对这些内容进行限定：</p>
<pre><code class="language-html">&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt;
</code></pre>
<h2 id="二-css-优化"><a class="header" href="#二-css-优化">二 CSS 优化</a></h2>
<h3 id="21-css-选择器层级不能过深"><a class="header" href="#21-css-选择器层级不能过深">2.1 CSS 选择器层级不能过深</a></h3>
<p>层级过深的选择器会让代码不利于维护，也会对性能产生一定的影响。</p>
<h3 id="22-利用继承性"><a class="header" href="#22-利用继承性">2.2 利用继承性</a></h3>
<p>类似 font、text-align、text-indent、visibility 这种支持继承的属性，在 CSS 中尽量利用其继承特性减少重复书写，既能提升开发效率，也能让浏览器在解析 CSS 时，减少重复解析。</p>
<h3 id="22-尽量使用-css-替代-javascript-实现动态效果"><a class="header" href="#22-尽量使用-css-替代-javascript-实现动态效果">2.2 尽量使用 CSS 替代 JavaScript 实现动态效果</a></h3>
<p>比如类似 :focus 这样的伪类能够很好的实现效果，而使用 JS 控制则会造成代码的繁冗。
比如 CSS3 的动画也具有同样的效果，浏览器对 CSS 动画进行了优化，更加流畅，比如 transform 会触发 GPU 硬件加速。</p>
<h3 id="23-尽量较少使用代价昂贵的-css-样式"><a class="header" href="#23-尽量较少使用代价昂贵的-css-样式">2.3 尽量较少使用代价昂贵的 CSS 样式</a></h3>
<p>一些 CSS 样式会造成大量的运算，代价昂贵，比如：box-shadows、gradients、filter、opacity、border-radius。</p>
<h3 id="24-关注重排重绘"><a class="header" href="#24-关注重排重绘">2.4 关注重排重绘</a></h3>
<h3 id="25-减少-float-滥用"><a class="header" href="#25-减少-float-滥用">2.5 减少 float 滥用</a></h3>
<p>float 的本意是：实现文字环绕，浮动后元素不受外部影响，自成一行，且会造成父元素高度塌陷，这需要消耗更多的浏览器计算性能。</p>
<p>通常需要 div 横向排列时，可以使用 <code>inline-block</code> 方式替代，后者没有脱离文档流，性能上略优。</p>
<h3 id="26-合理利用雪碧图"><a class="header" href="#26-合理利用雪碧图">2.6 合理利用雪碧图</a></h3>
<p>雪碧图可以用来合并请求，在很大程度上缓解网络性能压力！</p>
<p>不过雪碧图也有缺陷：更改雪碧图中一个小的 UI 的尺寸，可能会引起大量使用该雪碧图的地方的修改。</p>
<h2 id="三-javascript-优化"><a class="header" href="#三-javascript-优化">三 JavaScript 优化</a></h2>
<h3 id="31-合理利用定时器"><a class="header" href="#31-合理利用定时器">3.1 合理利用定时器</a></h3>
<p>定时器内部如果对 DOM 进行了操作，需要格外小心，很容易引起重排、重绘。而且要注意及时清除定时器。</p>
<h3 id="32-js-控制动画"><a class="header" href="#32-js-控制动画">3.2 JS 控制动画</a></h3>
<p>尽量使用 CSS3 控制动画，性能更好。</p>
<h3 id="33-利用事件委托"><a class="header" href="#33-利用事件委托">3.3 利用事件委托</a></h3>
<p>比如给 ul 中的 li 绑定事件，其实给 ul 本身绑定即可，li 的数量过多会绑定过多的事件函数，影响程序性能。</p>
<h3 id="34-避免事件重复监听"><a class="header" href="#34-避免事件重复监听">3.4 避免事件重复监听</a></h3>
<p>需要引入防抖、节流来控制事件重复监听。</p>
<p>当然也有一些特殊场景：比如秒杀活动中，只希望用户点击下单一次，其实在点击后，可以直接添加移除事件监听的函数。</p>
<h3 id="35-减少全局变量的使用"><a class="header" href="#35-减少全局变量的使用">3.5 减少全局变量的使用</a></h3>
<p>模块化、声明一个容器对象包裹私有对象都可以缓解全局变量过多问题。</p>
<h2 id="四-资源加载"><a class="header" href="#四-资源加载">四 资源加载</a></h2>
<h3 id="40-资源概念"><a class="header" href="#40-资源概念">4.0 资源概念</a></h3>
<p>显示一个网址需要加载的资源包括：HTML、CSS、JS、图片、音视频等等。大多时候，资源的加载性能对网页的性能影响能占据绝对作用。</p>
<h3 id="41-dns-预解析"><a class="header" href="#41-dns-预解析">4.1 DNS 预解析</a></h3>
<p>比如 link 标签设置 dns-pretech，不过当代浏览器一般都启用的隐式的预解析，无需专门设置。</p>
<h3 id="42-添加-cdn-支持"><a class="header" href="#42-添加-cdn-支持">4.2 添加 CDN 支持</a></h3>
<p>静态资源可以通过放置在 CDN 上进行加速，这是因为 CDN 会选择离用户最新的服务商提供资源。</p>
<p>同样，这里有个细节：同源下浏览器最大并发请求数为 6 个，即同一时间只能同时下载 6 张图片，但是通过使用不同的 CDN 可以突破该限制。</p>
<h3 id="43-http-缓存"><a class="header" href="#43-http-缓存">4.3 HTTP 缓存</a></h3>
<p>浏览器一般通过资源请求头部的参数来判断这个资源是走请求、还是走缓存：</p>
<pre><code class="language-txt">1)  判断是否命中强缓存，若命中则直接加载缓存资源。此时状态码为 200，Size 列会显示 from memory cache
2)  若未命中强缓存，则请求服务器获取资源。但是服务器会判定资源是否有效（协商缓存）：
        如果有效，则服务器不返回资源，只返回 304 状态码，浏览器收到响应后从本地缓存加载资源
        如果无效，则服务器返回资源，状态码为 200
</code></pre>
<p>强缓存由两个参数控制：</p>
<ul>
<li>Expires：服务器资源过期时间点。由于客户端可以随意修改自己的时间，会产生混乱。</li>
<li>Cache-Control：服务器资源过期的相对时间，且包含多个字段，控制粒度更细。Cache-Control 优先级比 Expires 高。</li>
</ul>
<p>强缓存没有被命中时，由以下参数控制协商缓存：</p>
<ul>
<li>Etag：如果资源的头部带有 Etag，则浏览器发送带有 if-Node-Match 的请求头。若服务端的 Etag 和 if-Node-Match 相同则资源未更新，返回 304。若不同，则返回 200，要求获取资源。</li>
<li>Last-Modified：若资源信息头部没有 Etag，则判断是否有 Last-Modified，若有则发送 if-Modified-Since，。若服务端的 Last-Modified &lt;= if-Modified-Since，即资源未改变，返回 304，否则返回 200 重新获取。</li>
</ul>
<h3 id="44-懒加载"><a class="header" href="#44-懒加载">4.4 懒加载</a></h3>
<p>懒加载即按需加载，对于一些图片、视频等媒体资源，列表无需全部展示，而是先展示可视区部分要展示的内容，浏览完可视区后，重新把接下来的数据加载出来。</p>
<h3 id="45-分页加载"><a class="header" href="#45-分页加载">4.5 分页加载</a></h3>
<p>是指数据并未被完全请求到前台，只请求了当前页面的一部分，用户点击下一页，则根据 limit（每页显示多少行）、page（页码）重新从服务端获取数据。</p>
<h3 id="46-避免重复加载"><a class="header" href="#46-避免重复加载">4.6 避免重复加载</a></h3>
<p>贴士：iframe 具备阻隔性质，无法使用父页面中已经加载的资源。尽量不要使用 iframe。</p>
<h3 id="五-资源优化"><a class="header" href="#五-资源优化">五 资源优化</a></h3>
<h3 id="51-减小资源体积"><a class="header" href="#51-减小资源体积">5.1 减小资源体积</a></h3>
<p>如 CSS 压缩、JavaScript 代码压缩、图片 base64 化。</p>
<p>通过一个图片也可以才使用大、中、小三种展示方式，来减轻压力。</p>
<p>策略实现：</p>
<ul>
<li>代码压缩：可以有效降低请求的代码文件的大小，如无效代码删除、html 删除换行符等</li>
<li>代码合并：可以有效减少请求的代码文件的数量。但是由于合并了多个文件，容易引起缓存失效，同时文件过大也会造成渲染延迟问题。</li>
<li>图片合并：雪碧图，合并了多个图片请求为一个雪碧图请求。</li>
<li>图片内嵌：转换为 base64、svg 等，这时候就没有请求了，已经成为原生的 html 可解析内容</li>
</ul>
<p>实践方案：</p>
<ul>
<li>代码压缩使用一些 fis3、现在工具等方式实现压缩合并</li>
<li>前端自己压缩合并：使用工程化开发方案，如 gulp、webpack</li>
<li>后端压缩：模板引擎自动压缩等</li>
<li>图片压缩与合并：精灵图、base64、svg</li>
</ul>
<h3 id="52-合理利用-浏览器数据存储机制"><a class="header" href="#52-合理利用-浏览器数据存储机制">5.2 合理利用 浏览器数据存储机制</a></h3>
<p>精简 cookie：浏览器每次请求都会发送 cookie，对 cookie 进行精简可以适量减轻压力。</p>
<p>利用 sessionStorage、localStorage、indexDB 存储机制也能存储一些无法服务端控制的资源。</p>
<h3 id="53-减少与服务端交互次数"><a class="header" href="#53-减少与服务端交互次数">5.3 减少与服务端交互次数</a></h3>
<p>比如利用中间层合并后端服务是最常见的策略。</p>
<p>此外之前提到的雪碧图、cookie、storage 等都属于尽量本地处理的策略。</p>
<h2 id="六-缓存策略详解"><a class="header" href="#六-缓存策略详解">六 缓存策略详解</a></h2>
<h3 id="61-cache-control-与-expires"><a class="header" href="#61-cache-control-与-expires">6.1 cache-control 与 expires</a></h3>
<p>cache-control 字段：多个字段之间逗号隔开</p>
<ul>
<li>public：文件的公共性，如 CDN 资源，与之对应的还有 private</li>
<li>max-age：第一次访问该资源时刻起，max-age 时间内都从缓存获取，不会发起新请求</li>
<li>s-maxage：针对 public 策略的文件设置的最大缓存时间</li>
<li>no-cache：一般搭配 max-age=0 使用，代表每次请求资源都要从服务端获取，而不是从缓存中获取，并不是禁止了缓存策略，no-store 才是禁止了缓存</li>
</ul>
<p>示例：</p>
<pre><code class="language-txt">Response Headers
  cache-control:max-age=315360000               # 第一次访问该资源时刻起，max-age 时间内都从缓存获取
  expires: Sun,15 Aug2027 01:09:24 GMT          # 与 max-age 类似，但是优先级较低。
</code></pre>
<p>总结：max-age 键值与 http 头中的 expires 字段作用一致，都会让资源直接从缓存中获取，不再请求服务端。expires 优先级更低，因为 expires 字段是 http1.0 的，http1.1 决定缓存策略交给 cache-control 统一管理。</p>
<h3 id="62-last-modified-与-if-modified-since"><a class="header" href="#62-last-modified-与-if-modified-since">6.2 Last-Modified 与 If-Modified-Since</a></h3>
<p>last-modified 与 if-modified-since 是客户端与服务端的协商缓存机制，需要与 cache-control 配合使用：</p>
<ul>
<li>last-modified：response header，服务端告诉客户端资源的最后修改时间</li>
<li>if-modified-since：request header，客户端告诉服务端资源的在客户端所知道的最后修改时间</li>
</ul>
<h3 id="63-etag-与-if-none-match"><a class="header" href="#63-etag-与-if-none-match">6.3 ETag 与 If-None-Match</a></h3>
<p>Last-Modified 的机制上存在一定的缺陷：文件的最后修改时间出现了变化，但是其内容其实并未出现变化，这时候会造成不必要的缓存失效。</p>
<ul>
<li>ETag：response header，其本质是文件内容的 hash 值，只有文件内容改变了，Etag 才会变化</li>
<li>If-None-Match：request header</li>
</ul>
<h3 id="64-分级缓存策略"><a class="header" href="#64-分级缓存策略">6.4 分级缓存策略</a></h3>
<ul>
<li>第一层：使用 200 状态码，当本地没有缓存、下一层失效、用户 Ctrol+F5 强制刷新，则浏览器会从服务端下载最新数据</li>
<li>第二层：使用 304 状态码，当下一层失效、用户 F5 刷新，则浏览器会发送请求给服务端，服务端若没有变化，则返回 304。本层由 last-modified、etag 控制</li>
<li>第三层：使用 200 状态码，浏览器访问自己的缓存，由于 cache-control、expires 控制</li>
</ul>
<h2 id="七-项目实践优化"><a class="header" href="#七-项目实践优化">七 项目实践优化</a></h2>
<h3 id="71-长列表性能优化"><a class="header" href="#71-长列表性能优化">7.1 长列表性能优化</a></h3>
<p>方案一：每次只渲染一部分，比如 10 条数据，滚动完毕前获取下一部分数据。不适用于超大列表数据。</p>
<p>方案二：可视区渲染，比如使用 react-virtualized。原理：只渲染页面可视区的列表项，非可视区数据不渲染，滚动时动态更新列表。（为了避免滑动过快，也会额外提前加载一部分数据）。适用于微博、聊天、大表格等。</p>
<p>formik 库：react 表单库。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="03-性能优化--2-代码优化示例"><a class="header" href="#03-性能优化--2-代码优化示例">03-性能优化 -2-代码优化示例</a></h1>
<h2 id="一-基础语法优化"><a class="header" href="#一-基础语法优化">一 基础语法优化</a></h2>
<h3 id="11-作用域"><a class="header" href="#11-作用域">1.1 作用域</a></h3>
<p>改进代码性能非常重要的一件事，可能就是要提防全局查询：随着作用域链中作用域数量的增加，访问当前作用域外部变量所需的时间也会增加。访问全局变量始终比访问局部变量慢，因为必须遍历作用域链。任何可以缩短遍历作用域链时间的举措都能提升代码性能。</p>
<pre><code class="language-js">function updateUI() {
  let imgs = document.getElementsByTagName('img')
  for (let i = 0, len = imgs.length; i &lt; len; i++) {
    imgs[i].title = '${document.title} image ${i}'
  }
  let msg = document.getElementById('msg')
  msg.innerHTML = 'Update complete.'
}
</code></pre>
<p>这个函数三个地方引用了全局 document 对象。如果页面的图片非常多，那么 for 循环中就需要引用 document 几十甚至上百次，每次都要遍历一次作用域链。通过在局部作用域中保存 document 对象的引用，能够明显提升这个函数的性能，因为只需要作用域链查找。</p>
<p>通过创建一个指向 document 对象的局部变量，可以通过将全局查找的数量限制为一个来提高这个函数的性能：</p>
<pre><code class="language-js">function updateUI() {
  let doc = document
  let imgs = doc.getElementsByTagName('img')
  for (let i = 0, len = imgs.length; i &lt; len; i++) {
    imgs[i].title = '${doc.title} image ${i}'
  }
  let msg = doc.getElementById('msg')
  msg.innerHTML = 'Update complete.'
}
</code></pre>
<h3 id="12-循环语句优化"><a class="header" href="#12-循环语句优化">1.2 循环语句优化</a></h3>
<p>循环会重复多次运行相同的代码，所以运行时间会自动增加。优化循环的基本步骤如下：</p>
<pre><code class="language-txt">(1) 简化终止条件。因为每次循环都会计算终止条件，所以它应该尽可能地快。这意味着要避免属性查找或其他 O(n) 操作。
(2) 简化循环体。循环体是最花时间的部分，因此要尽可能优化。要确保其中不包含可以轻松转移到循环外部的密集计算。
(3) 使用后测试循环。最常见的循环就是 for 和 while 循环，这两种循环都属于先测试循环。
  do-while 就是后测试循环，避免了对终止条件初始评估，因此应该会更快。
</code></pre>
<p>示例：</p>
<pre><code class="language-js">// 简单 for 循环
// for (let i = 0; i &lt; values.length; i++) {
//   process(values[i])
// }

//  i 从 0 递增至数组 values 的长度。假设处理这些值的顺序不重要，那么可以将循环变量改为递减的形式
// 终止条件的计算复杂度也从查找 values.length 的 O(n) 变成了访问 0 的 O(1)。
// for (let i = values.length - 1; i &gt;= 0; i--) {
//   process(values[i])
// }

// 整个循环可修改为后测试循环
let i = values.length - 1
if (i &gt; -1) {
  do {
    process(values[i])
  } while (--i &gt;= 0)
}
</code></pre>
<p>使用后测试循环时要注意，一定是至少有一个值需要处理一次。如果这里的数组是空的，那么会浪费一次循环，而先测试循环就可以避免这种情况。</p>
<p>如果循环的次数是有限的，那么通常抛弃循环而直接多次调用函数会更快。仍以前面的循环为例，如果数组长度始终一样，则可能对每个元素都调用一次 process() 效率更高：</p>
<pre><code class="language-js">// 抛弃循环
process(values[0])
process(values[1])
process(values[2])
</code></pre>
<p>如果不能提前预知循环的次数，那么或许可以使用一种叫作达夫设备（Duff’s Device）的技术：</p>
<pre><code class="language-js">// 来源：Jeff Greenberg 在 JavaScript 中实现的达夫设备
// 假设 values.length &gt; 0
let iterations = Math.ceil(values.length / 8)
let startAt = values.length % 8
let i = 0
do {
  switch (startAt) {
    case 0:
      process(values[i++])
    case 7:
      process(values[i++])
    case 6:
      process(values[i++])
    case 5:
      process(values[i++])
    case 4:
      process(values[i++])
    case 3:
      process(values[i++])
    case 2:
      process(values[i++])
    case 1:
      process(values[i++])
  }
  startAt = 0
} while (--iterations &gt; 0)
</code></pre>
<p>将 do-while 循环分成两个单独的循环后速度更快：</p>
<pre><code class="language-js">// 来源：Speed Up Your Site（New Riders，2003）
let iterations = Math.floor(values.length / 8)
let leftover = values.length % 8
let i = 0
if (leftover &gt; 0) {
  do {
    process(values[i++])
  } while (--leftover &gt; 0)
}
do {
  process(values[i++])
  process(values[i++])
  process(values[i++])
  process(values[i++])
  process(values[i++])
  process(values[i++])
  process(values[i++])
  process(values[i++])
} while (--iterations &gt; 0)
</code></pre>
<h2 id="二-dom-代码优化"><a class="header" href="#二-dom-代码优化">二 DOM 代码优化</a></h2>
<h3 id="21-实时更新最小化"><a class="header" href="#21-实时更新最小化">2.1 实时更新最小化</a></h3>
<p>涉及立即（实时）更新页面的显示，每次更新，无论是插入一个字符还是删除页面上的一节内容，都会导致性能损失。这是因为浏览器需要为此重新计算数千项指标，之
后才能执行更新。实时更新的次数越多，执行代码所需的时间也越长。反之，实时更新的次数越少，代码执行就越快：</p>
<pre><code class="language-js">let list = document.getElementById(&quot;myList&quot;),
item;
for (let i = 0; i &lt; 10; i++) {
item = document.createElement(&quot;li&quot;);
list.appendChild(item);
item.appendChild(document.createTextNode('Item ${i}');
}
</code></pre>
<p>解决：</p>
<pre><code class="language-js">let list = document.getElementById('myList'),
  fragment = document.createDocumentFragment(),
  item
for (let i = 0; i &lt; 10; i++) {
  item = document.createElement('li')
  fragment.appendChild(item)
  item.appendChild(document.createTextNode('Item ' + i))
}
list.appendChild(fragment)
</code></pre>
<h3 id="22-使用事件委托"><a class="header" href="#22-使用事件委托">2.2 使用事件委托</a></h3>
<h3 id="23-注意-htmlcollection"><a class="header" href="#23-注意-htmlcollection">2.3 注意 HTMLCollection</a></h3>
<p>任何时候，只要访问 HTMLCollection，无论是它的属性还是方法，就会触发查询文档，而这个查询相当耗时。减少访问 HTMLCollection 的次数可以极大地提升脚本的性能。</p>
<pre><code class="language-js">et images = document.getElementsByTagName(&quot;img&quot;);
for (let i = 0, len = images.length; i &lt; len; i++) {
// 处理
}
</code></pre>
<p>这里的关键是把 length 保存到了 len 变量中，而不是每次都读一次 HTMLCollection 的 length 属性。在循环中使用 HTMLCollection 时，应该首先取得对要使用的元素的引用，如下面所示。这样才能避免在循环体内多次调用 HTMLCollection：</p>
<pre><code class="language-js">let images = document.getElementsByTagName('img'),
  image
for (let i = 0, len = images.length; i &lt; len; i++) {
  image = images[i]
  // 处理
}
</code></pre>
<p>这段代码增加了 image 变量，用于保存当前的图片。有了这个局部变量，就不需要在循环中再访问 images HTMLCollection 了。</p>
<p>编写 JavaScript 代码时，关键是要记住，只要返回 HTMLCollection 对象，就应该尽量不访问它。以下情形会返回 HTMLCollection：</p>
<pre><code class="language-txt">调用 getElementsByTagName()；
读取元素的 childNodes 属性；
读取元素的 attributes 属性；
访问特殊集合，如 document.form、document.images 等。
</code></pre>
<h3 id="24-减少-dom-操作方式-1"><a class="header" href="#24-减少-dom-操作方式-1">2.4 减少 DOM 操作方式 1</a></h3>
<p>浏览器会将 DOM 与 JS 分开独立实现，如果使用 JS 操作 DOM 就像从一个区域跳转到了另外一个区域，每次跳转都会消耗性能，所以要尽量减少这种操作。
案例：</p>
<pre><code class="language-js">//第一种操作 DOM 方式：
var div = document.getElementById('div')
console.time('hi')
//5000 次来实现添加 html
for (var i = 0; i &lt; 5000; i++) {
  div.innerHTML += 'a'
}
console.timeEnd('hi') //chrome 下输出 hi: 241.7109375ms

//将 innerHTML 移除：
var div = document.getElementById('div')
console.time('hi')
var html = ''
for (var i = 0; i &lt; 5000; i++) {
  html += 'a'
}
div.innerHTML = html
console.timeEnd('hi') //chrome 下输出 hi: 7.304931640625ms
</code></pre>
<h3 id="25-减少-dom-操作方式-2使用节点克隆"><a class="header" href="#25-减少-dom-操作方式-2使用节点克隆">2.5 减少 DOM 操作方式 2：使用节点克隆</a></h3>
<p>创建多个相同节点时，推荐使用 clone，因为 clone 不是新创建节点，所以性能更高。
原本方式：</p>
<pre><code class="language-js">console.time('hi')
var oUl = document.getElementById('ul')
for (var i = 0; i &lt; 5000; i++) {
  var oLi = document.createElement('li')
  oLi.innerHTML = 'li'
  oUl.appendChild(oLi)
}

console.timeEnd('hi') //chrome 下输出 hi: 28ms
</code></pre>
<p>使用 clone 方式优化：</p>
<pre><code class="language-js">console.time('hi')
var oUl = document.getElementById('ul')
var oLi = document.createElement('li')
oLi.innerHTML = 'li'
for (var i = 0; i &lt; 5000; i++) {
  var newLi = oLi.cloneNode(true)
  oUl.appendChild(newLi)
}

console.timeEnd('hi') //chrome 下输出 hi: 8ms
</code></pre>
<h2 id="三-资源加载代码优化"><a class="header" href="#三-资源加载代码优化">三 资源加载代码优化</a></h2>
<h3 id="31-资源文件加载"><a class="header" href="#31-资源文件加载">3.1 资源文件加载</a></h3>
<p>整体的 html 文档是从上往下顺序执行的，但是引入的资源是并发请求的。</p>
<p>css 引入问题：</p>
<ul>
<li>在 header 中使用 link 引入，会阻塞渲染</li>
<li>CSS 的加载会阻塞 JS 的执行。因为 JS 要操作 DOM，可能需要知道一些 CSS 属性，那么 CSS 加载完后再加载 JS，在逻辑上是正确的。</li>
<li>CSS 不阻塞外部脚本的加载</li>
</ul>
<p>js 引入问题：</p>
<ul>
<li>指直接诶引入的 js 阻塞页面的渲染</li>
<li>js 不阻塞资源的加载，可以更加精细的控制预加载过程，但是存在跨域问题！第三方库有：PreloadJS。</li>
</ul>
<h3 id="32-懒加载和预加载"><a class="header" href="#32-懒加载和预加载">3.2 懒加载和预加载</a></h3>
<ul>
<li>懒加载：图片进入可视区之后才请求图片资源。</li>
<li>案例：瀑布流中的图片</li>
<li>实现：监听 scroll 事件，当图片到达可视区，图片 url 才会被加入。jQuery 中已经提供了更简便的 API。</li>
<li>预加载：与懒加载相反，是对资源的提前请求，当页面需要使用该资源时，可以直接从缓存中获取。</li>
<li>案例：九宫格抽奖，选中状态与非选中状态其实是提前都加载完毕的，这样才能</li>
</ul>
<p>预加载实现：</p>
<ul>
<li>方案一：html 中使用完整的 img 标签（JS 生成的 img 标签也可以），只需要将其隐藏即可，当需要展示时显示</li>
<li>方案二：使用 xhr 请求</li>
</ul>
<h3 id="33-重排与重绘"><a class="header" href="#33-重排与重绘">3.3 重排与重绘</a></h3>
<p>重排：页面元素的位置、形状发生了改变时就会触发，也称为回流（reflow）。</p>
<p>重绘：重排后的内容显示出来的过程叫做重绘。</p>
<p>注意：改变背景颜色不会触发重排，只会触发重绘，重排与重绘都会影响性能。</p>
<p>优化措施：尽量在 appendChild 前添加重排、重操作。</p>
<pre><code class="language-js">//旧方式
console.time('hi')
for (var i = 0; i &lt; 5000; i++) {
  var liObj = document.createElement('li')
  ulObj.appendChild(liObj)
  liObj.innerHTML = 'li'
}
console.timeEnd('hi') //750ms

//新方式
console.time('hi')
for (var i = 0; i &lt; 5000; i++) {
  var liObj = document.createElement('li')
  liObj.innerHTML = 'li'
  ulObj.appendChild(liObj)
}
console.timeEnd('hi') //440ms
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="04-前后分离--1-seo"><a class="header" href="#04-前后分离--1-seo">04-前后分离 -1-SEO</a></h1>
<h2 id="一-搜索引擎优化概念"><a class="header" href="#一-搜索引擎优化概念">一 搜索引擎优化概念</a></h2>
<p>搜索引擎优化（SEO）这个话题并不在前端开发的讨论范围之内，他也不属于性能优化的范畴。但是很多场景中，前端都与 SEO 有着联系。</p>
<p>我们知道，我们获取一些信息往往并不是直接通过在浏览器中输入网址而直接得到的，大多场景中，我们都是打开百度、谷歌这样的搜索网站，输入想要搜索的关键字来进行查询的。其查询结果如下所示：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/seo/01.png" alt="百度搜索结果" /></p>
<p>包含搜索关键字的网页就会在百度中一一<code>排列</code>出来。这个关键词可以是网页中的标题、说明、文本内容等各个区域。</p>
<p>很显然，网址的排名越靠前，就能获得越大的曝光度，对营销是有极大的帮助的。</p>
<p>这些最终的排序结果都来自于搜索引擎内部的算法得出，搜索引擎优化其实就是针对现在已知道的算法细节进行处理，让我们的网页能够更好的靠前展示。</p>
<p>现在常规的搜索引擎优化方法有：为网页设置合理的标题、说明，网页内容符合用户要求且更加原创化等等。</p>
<h2 id="二-收录与排名"><a class="header" href="#二-收录与排名">二 收录与排名</a></h2>
<h3 id="21-收录"><a class="header" href="#21-收录">2.1 收录</a></h3>
<p>一个新建的网站，即使内容再优秀，再原创，不到一定的时间，在搜索引擎内也是无法被搜索到的，同理，一些具体的文章页面也会有这样的规律，比如新浪博客内的文章发布后不会立刻在百度中被搜索到，而是需要等待一段时间，这个等待时间肯恩是几小时，几天，几个月甚至永久无法等到。</p>
<p>这种网址被百度记录下来的现象，我们称之为<strong>收录</strong>。</p>
<h3 id="22-简单理解搜索引擎"><a class="header" href="#22-简单理解搜索引擎">2.2 简单理解搜索引擎</a></h3>
<p>很多没有技术背景的产品、SEO 人员可能不会注意到，百度等搜索引擎与我们自己的内容网址，如新浪微博、人民网等是毫无关联的，我们在搜索内容的时候，搜索的关键字也是与具体收录的网址是无关的。我们的一切操作都是在百度这样的网站内部做的，百度等搜索引擎只是一个面向用户的网站，与我们登陆微博、使用微信没有本质区别。</p>
<p>但是百度内部维护了一份数据库，这个数据库将天下数以万亿记的网页全部都以快照的形式存储了下来，当我们搜索关键字的时候，百度会自己检索内部的这个数据库，找到与你搜索内容匹配度较高的网址列表，然后按照顺序一一展示出来。</p>
<blockquote>
<p>快照：类似拍照一样，百度并不是存储了网站，而是对一个网址进行内的内容进行当前时间点的保存。</p>
</blockquote>
<p>在百度的搜索结果列表中展示的，其实是某个时间点的快照内容，而不是当前网页内容，只有通过点击链接进入才能实时查看，当然百度、谷歌这样的公司也提供了查看快照的功能：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/seo/02.png" alt="百度快照" /></p>
<h3 id="23-蜘蛛"><a class="header" href="#23-蜘蛛">2.3 蜘蛛</a></h3>
<p>现在有了新的问题：百度是如何知道世界上这么多网站的？</p>
<p>百度会对一些网站发送一些请求，得到这些网页内容后，会逐步查找网页内的一些 a 连接标签，并沿着这些链接逐个进入，从而能够不断的进入的世界上各个网站的各个角落，这种行为很类似蜘蛛，或者称呼为爬虫。</p>
<p>每隔一段时间，你的网站就会被各大搜索引擎的蜘蛛光临一次，蜘蛛爬取到的内容越多，也就说明你的网站的越多的内容会被收录，由于蜘蛛的本质其实是数据请求，在后台是可以完全根据请求头监控到的。</p>
<p>常见的蜘蛛有：</p>
<ul>
<li>百度：Baiduspider（抓取网页）、Baiduspider-mobile（抓取 wap）、Baiduspider-image（抓取图片）、Baiduspider-video（抓取视频）、Baiduspider-news（抓取新闻）。</li>
<li>谷歌：Googlebot</li>
<li>360：360Spider</li>
<li>必应：bingbot</li>
<li>一淘网蜘蛛：EtaoSpider</li>
</ul>
<h3 id="24-robots-协议"><a class="header" href="#24-robots-协议">2.4 robots 协议</a></h3>
<p>由于蜘蛛会通过链接无限制抓取内容，这样就会产生一定的安全隐患，如：一些隐私的页面，客户信息等数据页面不想被蜘蛛抓取收录，该如何处理？</p>
<p>合法的蜘蛛一般都会遵循 <strong>robots 协议</strong>。即在网站的根目录下放置一个 ASCII 编码的 txt 文件：<code>robots.txt</code>，蜘蛛在开始爬取网站时，会先进入该文件，读取权限信息。</p>
<p><code>robots.txt</code> 内可以设定蜘蛛不允许爬哪些内容，允许爬哪些内容：</p>
<pre><code class="language-txt">User-agent: * 这里的*代表的所有的搜索引擎种类，*是一个通配符
Disallow: /admin/ 这里定义是禁止爬寻 admin 目录下面的目录
Disallow: /require/ 这里定义是禁止爬寻 require 目录下面的目录
Disallow: /ABC/ 这里定义是禁止爬寻 ABC 目录下面的目录
Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下的所有以&quot;.htm&quot;为后缀的URL(包含子目录)。
Disallow: /*?* 禁止访问网站中所有包含问号 (?) 的网址
Disallow: /.jpg$ 禁止抓取网页所有的.jpg 格式的图片
Disallow:/ab/adc.html 禁止爬取 ab 文件夹下面的 adc.html 文件。
Allow: /cgi-bin/　这里定义是允许爬寻cgi-bin目录下面的目录
Allow: /tmp 这里定义是允许爬寻 tmp 的整个目录
Allow: .htm$ 仅允许访问以&quot;.htm&quot;为后缀的 URL。
Allow: .gif$ 允许抓取网页和 gif 格式图片
</code></pre>
<h2 id="三-前端在-seo-中的一些处理"><a class="header" href="#三-前端在-seo-中的一些处理">三 前端在 SEO 中的一些处理</a></h2>
<h3 id="31-标题标签权重高"><a class="header" href="#31-标题标签权重高">3.1 标题标签权重高</a></h3>
<p>标题标签对搜索引擎的抓取有着重要作用，因为标题往往代表了网页的内容，其中 <code>h1</code> 标签提升的权重最高，这里推荐在一个 HTML 文档中，尽量只保留一个<code>h1</code> 标签，以免引起误会。</p>
<h3 id="32-标签语义化"><a class="header" href="#32-标签语义化">3.2 标签语义化</a></h3>
<p>通过 div 与 css 能够实现合理布局，但是如果能够使用语义化的标签，则更符合蜘蛛的口味：</p>
<pre><code class="language-html">&lt;!- main 标签推荐出现一次 --&gt;
&lt;main&gt;
  &lt;article&gt;文本 1&lt;/article&gt;
  &lt;article&gt;
    &lt;section&gt;段落 1&lt;/section&gt;
    &lt;section&gt;段落 2&lt;/section&gt;
  &lt;/article&gt;
  &lt;aside&gt;附近内容&lt;/aside&gt;
&lt;/main&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="04-前后分离--2-csr-与-ssr"><a class="header" href="#04-前后分离--2-csr-与-ssr">04-前后分离 -2-CSR 与 SSR</a></h1>
<h2 id="一-界面的渲染方式"><a class="header" href="#一-界面的渲染方式">一 界面的渲染方式</a></h2>
<p>呈现给用户的界面中的元素数据，有两重呈现方式</p>
<ul>
<li>CSR：即客户端渲染，客户端接收到服务端返回的原始数据，由客户端自己拼接数据生成页面</li>
<li>SSR：即服务端渲染，服务端返回的是一个完整的已经拼接好的文本文件，客户端无需更改，直接显示即可</li>
</ul>
<p>CSR 将渲染方放在了客户端，降低了服务端的压力。现代前端一般使用 Vue、React、Angular 开发方式，是一个单页面应用，不同的页面相对搜索引擎来说其实都是同一个网页，那么就会造成 Seo 问题（如：多个新闻页面被当做一个页面被搜索引擎收录）。</p>
<p>SSR 是动态网页诞生时就出现的技术，相对古老，优点是 SEO 支持较好。</p>
<h2 id="二-csr-实践"><a class="header" href="#二-csr-实践">二 CSR 实践</a></h2>
<h3 id="21-什么是前后端分离"><a class="header" href="#21-什么是前后端分离">2.1 什么是前后端分离？</a></h3>
<p>早期的 web 开发中，大量使用模板引擎技术，如果 Java 中的 jsp，Node 中的 ejs。在具体开发中，前端只负责 html 与 css，以及简单的 js 特效，后端不但要开发 API，还要负责对页面中的数据进行渲染：</p>
<ul>
<li>1 浏览器打开一个网址</li>
<li>2 发送请求给后台</li>
<li>3 后台根据请求产生数据后，利用 ejs、jsp 等技术，生成 一个 html 文本</li>
<li>4 后台将生成的 html 文本发送给前台</li>
<li>5 浏览器获取 html 文本直接渲染</li>
</ul>
<p>这种动态文本技术，如 jsp、ejs 都属于 SSR 的范畴。</p>
<p>所谓前后端分离即摆脱之前的耦合开发方式，让属于前端的范畴交给前端（数据渲染交给前端），在这种情况下的工作方式：</p>
<ul>
<li>1 浏览器打开一个网址</li>
<li>2 发送请求给后台</li>
<li>3 后台根据请求产生数据后，直接将数据发送给前台</li>
<li>4 前台拿到数据后，进行 dom 操作，修改当前页面中的数据为后台提供的动态数据</li>
</ul>
<p>我们发现，少了一步后台拼接 html 文本的过程，这个过程交给了前端进行自己处理。前端实现该过程最常见的办法就是 SPA(Single-page application)，所有用到的展现数据都是后端通过异步接口 (AJAX/JSONP) 的方式提供的，前端只管展现。</p>
<h3 id="22-前后端分离实践"><a class="header" href="#22-前后端分离实践">2.2 前后端分离实践</a></h3>
<p>1、一般来说，要实现前后端分离，前端就需要开启一个本地的服务器来运行自己的前端代码，以此来模拟真实的线上环境，并且能更好的开发。利用 nodejs 的 express 框架来开启一个本地的服务器，然后利用 nodejs 的一个 http-proxy-middleware 插件将客户端发往 nodejs 的请求转发给真正的服务器，让 nodejs 作为一个中间层。</p>
<p>2、由于前后端分离后，前端和后台同时开发时，就可能遇到前端已经开发好一个页面了，可是却等待后台 API 接口的情况。比如说 A 是负责前端，B 是负责后台，A 可能用了一周做好了基本的结构，并且需要 API 接口联调后，才能继续开发，而此时 B 却还没有实现好所需要的接口，这种情况，怎么办呢？在我们这个项目里，我们是通过了 mock 来提供一些假数据，我们先规定好了 API 接口，设计出了一套 API 文档，然后我们就可以通过 API 文档，利用 mock(&lt;<a href="http://mockjs.com">http://mockjs.com</a>) 来返回一些假数据，这样就可以模拟发送 API&gt;到接受响应的整一个过程，因此前端也不需要依赖于后端开发了，可以独立开发。Node 在前后端分离中主要扮演了创建本地开发环境的角色，和生产环境无关。</p>
<p>3、在第二步中已经完成了前后分离。在很多场景中，一个页面会请求很多接口，多次请求自然也造成了很多网络 I/O。为了解决这些问题，一些公司额外引入了 Node 聚合层。在前端与后端之间，再部署 Node 服务器，由 Node 服务器去请求多个接口，聚合数据后为前端提供一个统一接口。</p>
<h2 id="三-ssr"><a class="header" href="#三-ssr">三 SSR</a></h2>
<h3 id="31-ssr-优缺点汇总"><a class="header" href="#31-ssr-优缺点汇总">3.1 SSR 优缺点汇总</a></h3>
<p>优点：</p>
<ul>
<li>更好的 SEO，因为传统的搜索引擎只会从 HTML 中抓取数据，这会导致前端渲染的页面无法被抓取。</li>
<li>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。页面首屏时间大概有 80% 消耗在网络上，剩下的时间在后端读取数据以及浏览器渲染，显然要优化后面的 20% 是比较困难的，优化网络时间是效果最明显的手段。传统的 Ajax 请求是先请求 js 再由 js 发起数据请求，两项时间再加上浏览器渲染时间才是首屏时间。而 SSR 能将两个请求合并为一个。</li>
</ul>
<p>缺点：</p>
<ul>
<li>更多的服务器端负载。</li>
<li>服务器端和浏览器环境差异带来的问题，例如 document 等对象找不到的问题。</li>
</ul>
<p>建议：如果注重 SEO 的新闻站点，非强交互的页面，建议用 SSR；像后台管理页面这类强交互的应用，建议使用前端渲染。</p>
<h3 id="32-ssr-实践"><a class="header" href="#32-ssr-实践">3.2 SSR 实践</a></h3>
<p>要兼顾 SEO，就需要使用服务端渲染的方式。但是 Vue、React 这些前端框架能够给前端开发者带来很大的便利，到了后端却无用武之地，前端就会回到当年刀耕火种的时代，或者说：仅仅写写简单的 HTML、CSS。</p>
<p>为了提升生产力，可以将 Vue、React 的思想引入 SSR 中。其原理以 Vue 为例：</p>
<pre><code class="language-txt">在后端服务器也创造出 Vue 的实例，使用 Vue 的开发方式开发出一个组件界面
组件界面经过服务端解析还原为纯正的 HTML 字符串文本
服务端将该文本返还给前端，前端渲染
</code></pre>
<p>这里的问题是：由于页面组件由服务端创建，那么就不可能执行一些 DOM 的 API，且与原生 Vue 也会有一些生命周期差异。</p>
<h3 id="33-vue-使用-vue-server-renderer-进行-ssr"><a class="header" href="#33-vue-使用-vue-server-renderer-进行-ssr">3.3 Vue 使用 vue-server-renderer 进行 SSR</a></h3>
<pre><code class="language-js">const express = require('express')
const Vue = require('vue')
const VueSSR = require('vue-server-renderer')

const server = express()

server.get('/demo', (req, res) =&gt; {
  const app = new Vue({
    template: `&lt;div&gt;hello world!&lt;/div&gt;`,
  })

  const renderer = VueSSR.createRenderer()

  renderer
    .renderToString(app)
    .then((html) =&gt; {
      console.log(html)
      res.send(html)
    })
    .catch((err) =&gt; {
      console.log(err)
    })
})

server.listen(3000)
</code></pre>
<h3 id="34-vue-使用-nuxt-进行-ssr"><a class="header" href="#34-vue-使用-nuxt-进行-ssr">3.4 Vue 使用 Nuxt 进行 SSR</a></h3>
<p>Nuxt 是 Vue 的综合服务端渲染框架，可以直接用于生产环境。</p>
<p>在当前目录安装 Nuxt，在选项中，必须萱蕚 Universal(SSR/SSG) 才能创建真正的 Nuxt 服务端渲染项目：</p>
<pre><code class="language-txt">npx create-nuxt-app .
</code></pre>
<p>Nuxt 生命周期：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/nuxt-01.png" alt="Nuxt 生命周期" /></p>
<p>贴士：项目运行时，Nuxt 只会初始化依次，在经历了 Nuxt 的生命周期后，会开始执行 Vue 的生命周期。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="05-接口规范--1-rest"><a class="header" href="#05-接口规范--1-rest">05-接口规范 -1-REST</a></h1>
<h2 id="一-restful-概念"><a class="header" href="#一-restful-概念">一 RESTful 概念</a></h2>
<p>REST 中文含义是表现层状态转换，符合 REST 规范的设计，都可以称呼为 RESTful。RESTful 的思想是将服务端提供和的内容实体看做资源，与 URL 进行一一对应，依据请求方式不同分别有增、删、改、查等方法。</p>
<p>比如一个用户地址：<code>/user/lisi</code>，代表了 lisi 这个用户在服务器上的个人信息相关的资源，对该资源进行操作，则请求为：</p>
<pre><code class="language-txt">增加用户 lisi    POST        /user/lisi
删除用户 lisi    DELETE      /user/lisi
修改用户 lisi    PUT         /user/lisi
查询用户 lisi    GET         /user/lisi
</code></pre>
<p>而在过去，新增一个用户，往往其接口为：<code>/user/addUser</code>。</p>
<p>在 RESTful 设计中，资源的具体格式由请求报头中的 Accept 字段和服务端的支持情况决定，比如如果客户端同时接收 JSON 和 XML 格式的响应，则其 Accept 字段的值如下：</p>
<pre><code class="language-txt">Accept: application/json,application/xml
</code></pre>
<h2 id="二-设计-node-的-restful-路由器"><a class="header" href="#二-设计-node-的-restful-路由器">二 设计 Node 的 RESTful 路由器</a></h2>
<p>在上一节中，如果 use 方法是对所有请求方法的处理，那么在 RESTful 中，需要区分请求方法进行设计：</p>
<pre><code class="language-js">const routes = {
  all: [],
}

const app = {}

app.use = function (path, action) {
  routes.all.push(pathRegexp(path), action)
}

const funcArr = ['get', 'put', 'delete', 'post']

funcArr.forEach(function (method) {
  routes[method] = []
  app[method] = function (path, action) {
    routes[method].push({
      regexp: pathRegexp(path),
      action: action,
    })
  }
})
</code></pre>
<p>上面的代码添加了 get()，put()，delete()，post() 四个方法后，现在开始完成路由映射，并能达到类似下列的请求方式：</p>
<pre><code class="language-js">app.post('/user/:username', addUser)
app.get('/user/:username', infoUser)
// ...
</code></pre>
<p>这样的路由能够识别请求方法，并将业务进行分发，为了让分发更简洁，必须将匹配的部分抽取为 match() 方法：</p>
<pre><code class="language-js">function match(pathname, routes) {
  for (var i = 0; i &lt; routes.length; i++) {
    // 正则匹配
    let matched = red.exec(pathname)
    if (!matched) {
      return false
    }

    let reg = routes[i].regexp
    let keys = route[i].keys

    let params = {}
    for (let j = 0; j &lt; kyes.length; j++) {
      let value = matched[j + 1]
      if (value) {
        params[keys[i]] = value
      }
    }

    req.params = params
    let action = routes[i].action
    action(req, res)
    return true
  }
}
</code></pre>
<p>分发部分的改进：</p>
<pre><code class="language-js">function(req, res){

    let pathname = url.parse(req.url).pathname;
    let method = req.method.toLowerCase();

    if(routes.hadOwnPerperty(method)){

        // 根据请求方法分发
        if(match(pathname, routes[method])) {
            return
        } else {
            // 如果路径没有匹配成功，尝试让 all() 来处理
            if (match(pathname, routes.all)){
                return
            }
        }

    } else {
            if (match(pathname, routes.all)){
                return
            }
    }

    // 404 处理
}
</code></pre>
<h2 id="三-rest-设计理念"><a class="header" href="#三-rest-设计理念">三 REST 设计理念</a></h2>
<p>REST 与 RPC 请求不能混为一谈。REST 不是标准，只是一种 Web 应用的架构风格，或者说一种设计模式、约束，其核心思想是 <strong>资源表述的转移</strong>，数据和功能都可以视为资源。</p>
<p>REST 对服务资源的要求应该是无状态的！请求不要求服务器需要额外检索程序的上下文、状态；在连续的请求中，客户端也不依赖于同一台服务器。</p>
<p>常用的 HTTP 动词：</p>
<ul>
<li>GET：从服务器获取资源，对应 SQL 的 select。安全且幂等读取服务器内容时使用变更时获取表示（缓存）。</li>
<li>POST：在服务器新建资源，对应 SQL 的 create。不安全且不幂等使用服务端管理的（自动产生）的实例号创建资源创建子资源部分更新资源如果没有被修改，则不更新资源（乐观锁）。</li>
<li>PUT：在服务器更新客户端提供的完整资源，对应 SQL 的 update。不安全但幂等用客户端管理的实例号创建一个资源通过替换的方式更新资源如果未被修改，则更新资源（乐观锁）</li>
<li>PATCH：在服务器更新客户端提供的属性，对应 SQL 的 update。不安全，可以是不幂等的局部更新资源与 PUT 区别：只更新少部分内容；可能根据原数据进行变化（比如基本工资加 200 元），这时就不幂等了。</li>
<li>DELETE：在服务端删除 资源，对应 SQL 的 delete。不安全但幂等删除资源 HEAD 安全且幂等递交获取资源的元数据 OPTIONS 安全且幂等获取信息，关于资源的哪些属性是客户端可以改变的。</li>
<li>HEAD：获取资源的元数据</li>
<li>OPTIONS：获取信息，即客户端可以更改资源的哪些属性</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="05-接口规范--2-graphql"><a class="header" href="#05-接口规范--2-graphql">05-接口规范 -2-GraphQL</a></h1>
<h2 id="一-graphql-概念"><a class="header" href="#一-graphql-概念">一 GraphQL 概念</a></h2>
<h3 id="11-graphql-简介"><a class="header" href="#11-graphql-简介">1.1 GraphQL 简介</a></h3>
<p>GraphQL 是 Facebook 开发的数据查询语言，于 2015 年发布。GraphQL 对 API 中的数据提供了一套完整描述，能够让客户端准确的获取需要的数据，没有冗余，也让 API 的演进更加顺利。</p>
<p>GraphQL 的特点：</p>
<ul>
<li>请求需要的数据更精准，只取得需要的字段，无冗余。</li>
<li>多个资源的获取，只需要一个请求即可实现。</li>
<li>对资源实现了更加详细的描述，能够方便的增加、删除字段，便于平滑演进。</li>
</ul>
<h3 id="12-graphql-与-restful-对比"><a class="header" href="#12-graphql-与-restful-对比">1.2 GraphQL 与 Restful 对比</a></h3>
<ul>
<li>Restful 一次只能返回一个资源，GraphQL 一次可以获取多个资源的合集</li>
<li>Restful 用不同的 url 区分资源，GraphQL 用类型区分资源</li>
</ul>
<h2 id="二-使用-graphql"><a class="header" href="#二-使用-graphql">二 使用 GraphQL</a></h2>
<h2 id="21-基础示例"><a class="header" href="#21-基础示例">2.1 基础示例</a></h2>
<pre><code class="language-js">const express = require('express')
const graphql = require('graphql')
const { graphqlHTTP } = require('express-graphql')

// 构建 schema，定义查询的语句、类型
let demoSchema = graphql.buildSchema(`

  type Info {
    sex: Int
    address: String
  }

  type Query {
    name: String
    age: Int
    info: Info
  }
`)

// 定义查询对应的处理器（resolver）
let demoRoot = {
  name: () =&gt; {
    return 'zs'
  },
  age: () =&gt; {
    return 30
  },
  info: () =&gt; {
    return {
      sex: 1,
      address: '育才路',
    }
  },
}

const app = express()

app.use(
  '/demo',
  graphqlHTTP({
    schema: demoSchema,
    rootValue: demoRoot,
    graphiql: true,
  })
)

app.listen(3000)
</code></pre>
<p>在浏览器中访问地址即可根据自定义字段访问结果：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/graphql-01.png" alt="graphql 基础" /></p>
<h3 id="22-graphql-数据类型"><a class="header" href="#22-graphql-数据类型">2.2 GraphQL 数据类型</a></h3>
<p>GraphQL 有四种基本类型，可以在 schema 声明时直接使用：</p>
<pre><code class="language-txt">Int
Float
Boolean
String
ID        # 不能重复
</code></pre>
<p>使用 <code>[类型]</code> 代表数组，如： <code>[int]</code></p>
<p>也可以自定义类型：</p>
<pre><code class="language-txt">  type Info {
    sex: Int
    address: String
  }
</code></pre>
<h3 id="23-参数传递"><a class="header" href="#23-参数传递">2.3 参数传递</a></h3>
<p>参数传递示例：</p>
<pre><code class="language-txt">type Query {
  demo(num: Int!, name: String): [Int]
}
</code></pre>
<p><code>Int!</code> 的感叹号代表必传，<code>:</code> 之后是返回值类型。</p>
<h2 id="三-前端中使用-graphql"><a class="header" href="#三-前端中使用-graphql">三 前端中使用 GraphQL</a></h2>
<pre><code class="language-js">const query = `
  query Info($sex: Int) {
    info(sex: $sex)
  }
`

const variables = {
  sex: 1,
}

fetch('/demo', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  },
  body: JSON.stringify({
    query,
    variables,
  }),
})
  .then((res) =&gt; res.json)
  .then((json) =&gt; {
    console.log(json)
  })
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="06-编程思想--1-函数式编程"><a class="header" href="#06-编程思想--1-函数式编程">06-编程思想 -1-函数式编程</a></h1>
<h2 id="一-函数式编程概述"><a class="header" href="#一-函数式编程概述">一 函数式编程概述</a></h2>
<p>和 Lisp、Haskell 不同，JS 并非真正的函数式编程语言，但是 JS 可以像操作对象一样操控函数，所以在 JS 中，可以使用函数式编程风格。</p>
<p>ES5 中数组的 map()、reduce() 等方法非常适合用于函数式编程。</p>
<h2 id="二-函数的深入使用"><a class="header" href="#二-函数的深入使用">二 函数的深入使用</a></h2>
<h3 id="21-使用函数处理数组"><a class="header" href="#21-使用函数处理数组">2.1 使用函数处理数组</a></h3>
<p>假设有一个数组，其元素都是数字，要计算平均值与标准差，非函数式编程风格如下：</p>
<pre><code class="language-js">let arr = [1, 1, 3, 5, 5]

// 求平均值
let total = 0
for (let i = 0; i &lt; arr.length; i++) {
  total += arr[i]
}
let mean = total / arr.length

// 计算标准差
let stdTotal = 0
for (let j = 0; j &lt; arr.length; j++) {
  let deviation = arr[j] - mean
  stdTotal += deviation * deviation
}
let stddev = Math.sqrt(stdTotal / (arr.length - 1))

console.log('平均值：' + mean)
console.log('标准差：' + stddev)
</code></pre>
<p>如果使用 map 和 reduce 方法：</p>
<pre><code class="language-js">let arr = [1, 1, 3, 5, 5]

// 定义两个简单函数
let sum = function (x, y) {
  return x + y
}
let square = function (x) {
  return x * x
}

// 组合计算
let mean = arr.reduce(sum) / arr.length
let deviations = arr.map(function (x) {
  return x - mean
})
let stddev = Math.sqrt(deviations.map(square).reduce(sum) / (arr.length - 1))

console.log('平均值：' + mean)
console.log('标准差：' + stddev)
</code></pre>
<h3 id="22-自定义-map-和-reduce-方法"><a class="header" href="#22-自定义-map-和-reduce-方法">2.2 自定义 map 和 reduce 方法</a></h3>
<pre><code class="language-js">let map = Array.prototype.map
  ? function (a, f) {
      // 如果 reduce 方法存在的话
      return a.map(f)
    }
  : function (a, f) {
      let results = []
      for (let i = 0, len = a.length; i &lt; len; i++) {
        if (i in a) {
          results[i] = f.call(null, a[i], i, a)
        }
      }
      return results
    }

let reduce = Array.prototype.reduce
  ? function (a, f, initial) {
      // 如果reduce方法存在的话
      if (arguments.length &gt; 2) {
        // 是否传入初始值
        return a.reduce(f, initial)
      } else {
        return a.reduce(f)
      }
    }
  : function (a, f, initial) {
      // es5 的一个算法规范
      let i = 0
      ;(len = a.len), accumulator
      // 以特定的初始值开始，否则第一个值取自 a
      if (arguments.length &gt; 2) {
        accumulator = initial
      } else {
        if (len == 0) throw TypeError()
        while (i &lt; len) {
          if (i in a) {
            accumulator = a[i++]
            break
          } else {
            i++
          }
          if (i == len) throw TypeError()
        }

        // 对于数组中剩下的元素依次调用 f()
        while (i &lt; len) {
          if (i in a) {
            accumulator = f.call(undefined, accumulator, a[i], i, a)
            i++
          }
          return accumulator
        }
      }
    }

// 测试
let arr = [1, 1, 3, 5, 5]
let sum = function (x, y) {
  return x + y
}
let square = function (x) {
  return x * x
}

let mean = reduce(arr, sum) / arr.length
let deviations = map(arr, function (x) {
  return x - mean
})
let stddev = Math.sqrt(reduce(map(deviations, square), sum) / (arr.length - 1))

console.log('平均值：' + mean)
console.log('标准差：' + stddev)
</code></pre>
<h2 id="三-高阶函数"><a class="header" href="#三-高阶函数">三 高阶函数</a></h2>
<h3 id="31-高阶函数示例"><a class="header" href="#31-高阶函数示例">3.1 高阶函数示例</a></h3>
<p>高阶函数（high-order function）就是操作函数的函数，它接收一个或者多个函数作为参数，并返回一个新函数：</p>
<pre><code class="language-js">// 高阶函数：返回实参 fn 的返回值的逻辑非
let not = function (fn) {
  return function () {
    let r = fn.apply(this, arguments) // 调用函数
    return !r
  }
}

// 判断是否为偶数的函数
let even = function (x) {
  return x % 2 === 0
}

// 获得一个新函数：所有的事情都有 even() 相反
let odd = not(even)

console.log([1, 1, 3, 5, 5].every(odd)) // true
</code></pre>
<h3 id="32-不完全函数"><a class="header" href="#32-不完全函数">3.2 不完全函数</a></h3>
<p>在前端开发中，经常用到函数的 bind() 方法，该方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用被 bind 绑定的函数。其作用即把函数绑定至对象并传入一部分参数。</p>
<p>这里其实是把一个完成的函数拆成多次函数调用，每次传入的实参都是完整实参的一部分，每个拆分开的函数即为不完全函数（partial function），这种函数变化的特点是每次调用都返回一个函数，直到最终运行结果为止。</p>
<p>简单示例：将函数 fn(1,2,3,4,5,6) 的调用修改为等价的 f(1,2)(3,4)(5,6)，后者包括了三次调用，每次调用相关的函数即不完全函数。</p>
<pre><code class="language-js">// 实现一个工具函数将类数组对象、对象转换为真正的数组

function array(a, n) {
  return Array.prototype.slice.call(a, n || 0)
}

// 该函数的实参传递至左侧
function partialLeft(f /*,... */) {
  var args = arguments
  return function () {
    var a = array(args, 1)
    a = a.concat(array(arguments))
    return f.apply(this, a)
  }
}

// 该函数的实参传递至右侧
function partialRight(f /*,... */) {
  var args = arguments
  return function () {
    var a = array(arguments)
    a = a.concat(array(args, 1))
    return f.apply(this, a)
  }
}

// 该函数实参被用作模板，实参列表中的 undefined 值都被填充
function partial(f /*,... */) {
  var args = arguments // 保存外部实参数组
  return function () {
    var a = array(args, 1)
    var i = 0,
      j = 0
    for (; i &lt; a.length; i++) {
      if (a[i] === undefined) {
        a[i] = arguments[j++]
      }
    }
    // 将剩下的内部实参追加进去
    a = a.concat(array(arguments, j))
    return f.apply(this, a)
  }
}

// 测试：带有三个实参的函数
var fn = function (x, y, z) {
  return x * (y - z)
}

// 三个不完全调用
console.log(partialLeft(fn, 2)(3, 4)) // -2 绑定的第一个实参 2*(3-4)
console.log(partialRight(fn, 2)(3, 4)) // 6  绑定的第一个实参 2*(4-2)
console.log(partial(fn, undefined, 2)(3, 4)) // -6 绑定的第一个实参 3*(2-4)
</code></pre>
<p>在上面不完全函数的基础上，可以编写出新的函数：</p>
<pre><code class="language-js">// 实现一个工具函数将类数组对象、对象转换为真正的数组

function array(a, n) {
  return Array.prototype.slice.call(a, n || 0)
}

// 该函数的实参传递至左侧
function partialLeft(f /*,... */) {
  let args = arguments
  return function () {
    let a = array(args, 1)
    a = a.concat(array(arguments))
    return f.apply(this, a)
  }
}

// 该函数的实参传递至右侧
function partialRight(f /*,... */) {
  let args = arguments
  return function () {
    let a = array(arguments)
    a = a.concat(array(args, 1))
    return f.apply(this, a)
  }
}

// 该函数实参被用作模板，实参列表中的 undefined 值都被填充
function partial(f /*,... */) {
  let args = arguments // 保存外部实参数组
  return function () {
    let a = array(args, 1)
    let i = 0,
      j = 0
    for (; i &lt; a.length; i++) {
      if (a[i] === undefined) {
        a[i] = arguments[j++]
      }
    }
    // 将剩下的内部实参追加进去
    a = a.concat(array(arguments, j))
    return f.apply(this, a)
  }
}

// 完善的函数式编程求平均数、标准差
let map = Array.prototype.map
  ? function (a, f) {
      // 如果reduce方法存在的话
      return a.map(f)
    }
  : function (a, f) {
      let results = []
      for (let i = 0, len = a.length; i &lt; len; i++) {
        if (i in a) {
          results[i] = f.call(null, a[i], i, a)
        }
      }
      return results
    }

let compose = function (f, g) {
  return function () {
    return f.call(this, g.apply(this, arguments))
  }
}

let reduce = Array.prototype.reduce
  ? function (a, f, initial) {
      // 如果reduce方法存在的话
      if (arguments.length &gt; 2) {
        // 是否传入初始值
        return a.reduce(f, initial)
      } else {
        return a.reduce(f)
      }
    }
  : function (a, f, initial) {
      // es5 的一个算法规范
      let i = 0
      ;(len = a.len), accumulator
      // 以特定的初始值开始，否则第一个值取自 a
      if (arguments.length &gt; 2) {
        accumulator = initial
      } else {
        if (len == 0) throw TypeError()
        while (i &lt; len) {
          if (i in a) {
            accumulator = a[i++]
            break
          } else {
            i++
          }
          if (i == len) throw TypeError()
        }

        // 对于数组中剩下的元素依次调用 f()
        while (i &lt; len) {
          if (i in a) {
            accumulator = f.call(undefined, accumulator, a[i], i, a)
            i++
          }
          return accumulator
        }
      }
    }
let arr = [1, 1, 3, 5, 5]
let sum = function (x, y) {
  return x + y
}
let prod = function (x, y) {
  return x * y
}
let neg = partial(prod, -1)
let square = partial(Math.pow, undefined, 2)
let sqrt = partial(Math.pow, undefined, 0.5)
let reciprocal = partial(Math.pow, undefined, -1)
let mean = prod(reduce(arr, sum), reciprocal(arr.length))
let stddev = sqrt(
  prod(
    reduce(map(arr, compose(square, partial(sum, neg(mean)))), sum),
    reciprocal(sum(arr.length, -1))
  )
)
console.log('平均值：' + mean)
console.log('标准差：' + stddev)
</code></pre>
<h2 id="33-记忆"><a class="header" href="#33-记忆">3.3 记忆</a></h2>
<p>在一些阶乘运算中，经常将上一次的结构存储起来，这种缓存技巧称为记忆。下面的 memorize() 函数接收一个函数作为实参，返回带有记忆能力的函数。</p>
<p>贴士：记忆是一种算法技巧，牺牲了空间复杂度，换取更优的时间复杂度。</p>
<p>示例：</p>
<pre><code class="language-js">// 返回 fn() 带有记忆功能的版本，只有当 fn() 的实参的字符串表示都不相同时才会工作
function memorize(fn) {
  var cache = {} // 将值保存在闭包内
  return function () {
    // 将实参转换为字符串形式，并将其作为缓存的 key
    var key = arguments.length + Array.prototype.join.call(arguments, ',')
    if (key in cache) {
      return cache[key]
    } else {
      return (cache[key] = fn.apply(this, arguments))
    }
  }
}

// 测试缓存函数：返回两个整数的最大公约数
function gcd(a, b) {
  // 暂时忽略对 a 和 b 的类型检查
  var t
  if (a &lt; b) {
    ;(t = b), (b = a), (a = t)
  }
  while (b != 0) {
    // 欧几里得算法
    ;(t = b), (b = a % b), (a = t)
  }
  return a
}
var gcdmemo = memorize(gcd)
console.log(gcdmemo(85, 187)) // 17

// 测试缓存函数：递归调用时，往往希望实现记忆功能
var factorial = memorize(function (n) {
  return n &lt;= 1 ? 1 : n * factorial(n - 1)
})
console.log(factorial(5)) // 120，对 4~1 的值也有缓存
</code></pre>
<h2 id="四-柯里化"><a class="header" href="#四-柯里化">四 柯里化</a></h2>
<h3 id="41-柯里化概念"><a class="header" href="#41-柯里化概念">4.1 柯里化概念</a></h3>
<p>柯里化是高阶函数的一个特殊用法：柯里化（Currying）把接受多个参数的函数变换成接受一个单一参数 (最初函数的第一个参数) 的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<p>白话一点就是：curry 是一个手机参数的方法，收集够了就去执行函数！</p>
<p>一个 createCuryy，接收函数 A 为参数，运行后返回一个新的函数 B，这个新函数 B 能够处理 A 的剩余参数！</p>
<pre><code class="language-js">function A(a, b, c) {
  // do...
}

function createCurry() {}

// _A 是 createCurry 返回的柯里化函数，能够处理 A 的剩余参数
var _A = createCurr(A)

// 此时下列运行结果都是等价的
A(1, 2, 3)
_A(1, 2, 3)
_A(1, 2)(3)
_A(1)(2, 3)
_A(1)(2)(3)
</code></pre>
<p>实例：</p>
<pre><code class="language-js">function add(a, b, c) {
  return a + b + c
}

// add 的柯里化函数
function _add(a) {
  return function (b) {
    return function (c) {
      return a + b + c
    }
  }
}
</code></pre>
<p>由上看出，柯里化实际上是一个参数收集过程，每一次传入的参数都会被收集，并在最里层处理。</p>
<h3 id="42-柯里化函数实现"><a class="header" href="#42-柯里化函数实现">4.2 柯里化函数实现</a></h3>
<p>==TODO==</p>
<p><a href="https://www.jianshu.com/p/fe0d80b04129">https://www.jianshu.com/p/fe0d80b04129</a></p>
<p><a href="https://blog.csdn.net/woqutechteam/article/details/80323065">https://blog.csdn.net/woqutechteam/article/details/80323065</a></p>
<p><a href="https://www.jianshu.com/p/f5033cec605e">https://www.jianshu.com/p/f5033cec605e</a></p>
<p><a href="https://www.jianshu.com/p/735cf4992db9">https://www.jianshu.com/p/735cf4992db9</a></p>
<p><a href="https://segmentfault.com/a/1190000010878974">https://segmentfault.com/a/1190000010878974</a></p>
<p><a href="https://segmentfault.com/a/1190000012145489">https://segmentfault.com/a/1190000012145489</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="06-编程思想--2-依赖注入与控制反转"><a class="header" href="#06-编程思想--2-依赖注入与控制反转">06-编程思想 -2-依赖注入与控制反转</a></h1>
<h2 id="一-控制反转和依赖注入思想"><a class="header" href="#一-控制反转和依赖注入思想">一 控制反转和依赖注入思想</a></h2>
<h3 id="11-控制反转ioc概念"><a class="header" href="#11-控制反转ioc概念">1.1 控制反转（IoC）概念</a></h3>
<p>控制反转（Inversion of control）是一种解耦的思想，其意义即字面意思：控制权转移。</p>
<p>以实际生活中的例子介绍：</p>
<pre><code class="language-txt">1、项目经理要求开发者开发新功能：控制权位于项目经理
2、开发者开始开发需求：控制权位于开发者手中
3、交付成品：控制权回到项目经理
</code></pre>
<p>在代码中，可以这样表现：假设我们获取数据都是通过一个类 A，但是类 A 内部 依赖于 B（B 是 A 的依赖），如下所示：</p>
<pre><code class="language-ts">// b.ts
class B {
  constructor() {}
}

// a.ts
class A {
  b: B
  constructor() {
    this.b = new B()
  }
}

// main.ts
const a = new A()
</code></pre>
<p>如果有一天 B 的构造函数发生了变化，可以传参：</p>
<pre><code class="language-ts">class B {
  p: number
  constructor(p: number) {
    this.p = p
  }
}
</code></pre>
<p>此时修改类 B 导致了依赖于 B 的类 A 失效，也需要对 A 进行额外修改，即我们的一个修改操作引发了另外依赖项于修改处的其他功能失效、发生错误，这是软件的耦合造成的。</p>
<p>更麻烦的是，当我们改完了 A 后，发现 B 所需要的 p 不能是一个 number，需要变更为 string，于是我们又不得不重新修改 A 中对参数 p 的类型修饰。这时我们想想，假设还有上层类依赖 A，用的也是同样的方式，那是否上层类也要经历同样的修改。这就是耦合所带来的问题，明明是修改底层类的一项参数，却需要修改其依赖链路上的所有文件，当应用程序的依赖关系复杂到一定程度时，很容易形成牵一发而动全身的现象，为应用程序的维护带来极大的困难。</p>
<p>有没有办法不去修改引发错误的地方，让 A 与 B 的耦合不再严重？</p>
<p>事实上，我们可以发现，在上述例子中，真正需要参数 p 的仅仅只有 B，而 A 完全只是因为内部依赖的对象在实例化时需要 p，才不得不定义这个参数，实际上它对 p 是什么根本不关心。于是，我们可以考虑将类所依赖对象的实例化从类本身剥离出来，比如上面的例子我们可以这样改写：</p>
<pre><code class="language-java">// b.ts
class B {
    p: number;
    constructor(p: number) {
        this.p = p;
    }
}

// a.ts
class A {
    private b:B;
    constructor(b: B) {
        this.b = b;
    }
}

// main.ts
const b = new B(10);
const a = new A(b);
console.log(a); // A =&gt; { b: B { p: 10 } }
</code></pre>
<p>以上就是一种权限的传递，最开始控制权在 A，A 内部需要 B 的实例，控制权被传递到了 B。</p>
<p>实际开发中，A 可能还会依赖于 C、D、E、F 等，那么权限都传递给 A 就会造成 A 类的工作量剧增、复杂度剧增，这时候可以引入工厂函数，将问题的解决方式交给工厂：</p>
<pre><code class="language-java">class TempFactory{
    public A createA(){
        return new A(this.createB(),this.createC(),this.createD(),this.createE());
    }
    public B createB(){
        return new B();
    }
    public C createC(){
        return new C();
    }
    public D createD(){
        return new D();
    }
    public E createE(){
        return new E();
    }
}
</code></pre>
<h3 id="12-依赖注入概念"><a class="header" href="#12-依赖注入概念">1.2 依赖注入概念</a></h3>
<p>无论是最初对 A 的改造，还是工厂函数，构建实例的本质仍然是开发这自己手动 new，如下所示：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/IoC-1.svg" alt="IoC-1" /></p>
<p>如果依赖进一步复杂，工厂模式也会变得复杂，如果有一个中间者可以给我们自动 new 出这些实例即可，这便是 依赖注入的思想，如下所示：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/IoC-2.svg" alt="IoC-2" /></p>
<p>所有依赖的类在注入器（Injector）中注册后，当类 A 需要它们的时候，注入器就会帮忙将依赖的类注入进来！</p>
<p>在这个全局容器中，预先注册好了我们所需对象的类定义以及初始化参数，每个对象有一个唯一的 key。那么当我们需要用到某个对象时，我们只需要告诉容器它对应的 key，就可以直接从容器中取出实例化好的对象，开发者就不用再关心对象的实例化过程，也不需要将依赖对象作为构造函数的参数在依赖链路上传递。</p>
<p>在注入器示例中，发生的控制反转是：类 A 需要 B，A 中就需要创建实例 B，控制权在 A 上，如果是通过注入器注入，A 需要 B 的时候，注入器注入进来，控制权移交给了注入器。不过要注意的是：注入器直接注入的，而不是 A 主动去创建的，这里 A 是被动，而注入器是主动的，注入完毕后，控制权又回到了 A 的手上。</p>
<p>现实生活中有个很鲜活的例子就是：找女朋友的事情委托给了婚介所，当婚介所有合适委托者的对象就会找到委托者，将女方资料交给委托者。</p>
<h3 id="13-容器-injector-的实现"><a class="header" href="#13-容器-injector-的实现">1.3 容器 Injector 的实现</a></h3>
<p>我们的容器必须具体两个功能：实例的注册和获取，与 Map 相似：</p>
<pre><code class="language-js">// container.ts
export class Container {
  bindMap = new Map()

  // 实例的注册
  bind(identifier: string, clazz: any, constructorArgs: Array&lt;any&gt;) {
    this.bindMap.set(identifier, {
      clazz,
      constructorArgs,
    })
  }

  // 实例的获取
  get&lt;T&gt;(identifier: string): T {
    const target = this.bindMap.get(identifier)
    const { clazz, constructorArgs } = target
    // Reflect.construct() 类似 new
    const inst = Reflect.construct(clazz, constructorArgs)
  }
}
</code></pre>
<p>使用容器后，可以抛弃之前的传参解耦：</p>
<pre><code class="language-js">// b.ts
class B {
  constructor(p: number) {
    this.p = p
  }
}

// a.ts
class A {
  b: B
  constructor() {
    this.b = container.get('b')
  }
}

// main.ts
const container = new Container()
container.bind('a', A)
container.bind('b', B, [10])

// 从容器中取出 a
const a = container.get('a')
console.log(a) // A =&gt; { b: B { p: 10 } }
</code></pre>
<p>从代码量上看似乎并没有简洁多少，关键问题在于容器的初始化以及类的注册仍然让我们觉得繁琐，如果这部分代码能被封装到框架里面，所有类的注册都能够自动进行，同时，所有类在实例化的时候可以直接拿到依赖对象的实例，而不用在构造函数中手动指定，这样就可以彻底解放开发者的双手，专注编写类内部的逻辑，而这也就是所谓的 DI（Dependency Injection）依赖注入。</p>
<h3 id="14-总结"><a class="header" href="#14-总结">1.4 总结</a></h3>
<p><strong>IoC 是一种设计原则，注重解耦，DI 则是实现 IoC 的一种技术</strong>，即将依赖注入给调用方，而不需要调用方来主动获取依赖。</p>
<p>依赖注入与控制反转，是一种低耦合设计理念，让开发者能够专注业务，而不是来来回回在依赖中 new。</p>
<p>除了解耦外，IoC 还可以给我们带来很多好处，比如基于容器快速进行单元测试，分析类与类之间的依赖关系等等。</p>
<h2 id="二-基于-typescript-的装饰器实现-di"><a class="header" href="#二-基于-typescript-的装饰器实现-di">二 基于 TypeScript 的装饰器实现 DI</a></h2>
<h3 id="20-di-的功能解决方案"><a class="header" href="#20-di-的功能解决方案">2.0 DI 的功能解决方案</a></h3>
<p>为了实现 DI，主要要解决以下两个问题：</p>
<ul>
<li>需要注册到 IoC 容器中的类能够在程序启动时自动进行注册</li>
<li>在 IoC 容器中的类实例化时可以直接拿到依赖对象的实例，而不用在构造函数中手动指定</li>
</ul>
<p>针对这两个问题其实也有不同的解决思路，Java Spring 需要开发者针对容器中的依赖关系定义一份 XML 文件，框架基于这份 XML 文件实例的注册和依赖的注入。阿里的 Midway 的 Injection 提供的思路是利用 TypeScript 具备的装饰器特性，通过对元数据的修饰来识别出需要进行注册以及注入的依赖，从而完成依赖的注入。</p>
<h3 id="21-元数据支持"><a class="header" href="#21-元数据支持">2.1 元数据支持</a></h3>
<p>TS 在 1.5 支持了 ES7 的提案：Relfect Metadata，用来在声明的时候添加和读取元数据。元数据可以理解为针对类或类里面某个属性的描述信息，它本身不影响类的行为，但你可以在随时拿到某个类上定义的元数据，并根据这些元数据进行对类进行特定的操作。</p>
<p>使用 Relfect Metadata：</p>
<pre><code class="language-js">// 安装 Relfect Metadata:npm i reflect-metadata -S
// 在 tsconfig.json 中配置:&quot;emitDecoratorMetadata&quot;: true,

// 根据 Reflect.defineMetadata 和 Reflect.getMetadata 进行元数据的定义和获取
import 'reflect-metadata'

const CLASS_KEY = 'ioc:key'

function ClassDecorator() {
  return function (target: any) {
    Reflect.defineMetadata(
      CLASS_KEY,
      {
        metaData: 'metaData',
      },
      target
    )
    return target
  }
}

@ClassDecorator()
class D {
  constructor() {}
}

console.log(Reflect.getMetadata(CLASS_KEY, D)) // =&gt; { metaData: 'metaData' }
</code></pre>
<p>这时候可以对任意类进行标记，并对标记的类进行特殊的处理。</p>
<h3 id="22-provider"><a class="header" href="#22-provider">2.2 Provider</a></h3>
<p>依赖注入的思想中，在应用全动时，自动对所有类进行定义、参数注册。但并不是所有类都需要注册到容器中，需要清楚哪些类需要注册，初始化参数是什么样子。这时候就需要源数据的帮助，只要在定义的时候为这个类的元数据添加特殊的标记，就可以在扫描的时候识别出来。按照这个思路，我们先来实现一个装饰器标记需要注册的类，这个装饰器可以命名 Provider，代表它将会作为提供者给其他类进行消费。</p>
<pre><code class="language-ts">// provider.ts
import 'reflect-metadata'

export const CLASS_KEY = 'ioc:tagged_class'

export function Provider(identifier: string, args?: Array&lt;any&gt;) {
  return function (target: any) {
    Reflect.defineMetadata(
      CLASS_KEY,
      {
        id: identifier,
        args: args || [],
      },
      target
    )
    return target
  }
}
</code></pre>
<p>可以看到，这里的标记包含了 id 和 args，其中 id 是我们准备用来注册 IoC 容器的 key，而 args 则是实例初始化时需要的参数。Provider 可以以装饰器的形式直接进行使用，使用方式如下：</p>
<pre><code class="language-ts">// b.ts
import { Provider } from 'provider'

@Provider('b', [10])
export class B {
  constructor(p: number) {
    this.p = p
  }
}
</code></pre>
<h3 id="23-解决问题一类注册"><a class="header" href="#23-解决问题一类注册">2.3 解决问题一：类注册</a></h3>
<p>标记完成后，问题又来了，如果在应用启动的时候拿到这些类的定义呢？</p>
<p>比较容易想到的思路是在启动的时候对所有文件进行扫描，获取每个文件导出的类，然后根据元数据进行绑定。简单起见，我们假设项目目录只有一级文件，实现如下：</p>
<pre><code class="language-ts">// load.ts
import * as fs from 'fs'
import { CLASS_KEY } from './provider'

export function load(container) {
  // container 为全局的 IoC 容器
  const list = fs.readdirSync('./')

  for (const file of list) {
    if (/\.ts$/.test(file)) {
      // 扫描 ts 文件
      const exports = require(`./${file}`)
      for (const m in exports) {
        const module = exports[m]
        if (typeof module === 'function') {
          const metadata = Reflect.getMetadata(CLASS_KEY, module)
          // 注册实例
          if (metadata) {
            container.bind(metadata.id, module, metadata.args)
          }
        }
      }
    }
  }
}
</code></pre>
<p>那么现在，我们只要在 main 中运行 load 即可完成项目目录下所有被修饰的类的绑定工作，值得注意的是，load 和 Container 的逻辑是完全通用的，它们完全可以被封装成包，一个简化的 IoC 框架就成型了。</p>
<pre><code class="language-ts">import { Container } from './container'
import { load } from './load'

// 初始化 IOC 容器，扫描文件
const container = new Container()
load(container)

console.log(container.get('a')) // A =&gt; { b: B { p: 10 } }
</code></pre>
<h3 id="24-解决问题二实例获取"><a class="header" href="#24-解决问题二实例获取">2.4 解决问题二：实例获取</a></h3>
<p>解决注册的问题后，我们来看上文中提到的第二个问题：如何在类初始化的时候能直接拿到它所依赖的对象的实例，而不需要手动通过构造函数进行传参。其实思路也很简单，我们已经将所有需要注册的类都放入了 IoC 容器，那么，当我们需要用到某个类时，在获取这个类的实例时可以递归遍历类上的属性，并从 IoC 容器中取出相应的对象并进行赋值，即可完成依赖的注入。</p>
<p>那么，又是类似的问题，如何区分哪些属性需要注入？同样，我们可以使用元数据来解决。只要定义一个装饰器，以此来标记哪些属性需要注入即可，这个装饰器命名为 Inject，代表该属性需要注入依赖。</p>
<pre><code class="language-ts">// inject.ts
import 'reflect-metadata'

export const PROPS_KEY = 'ioc:inject_props'

export function Inject() {
  return function (target: any, targetKey: string) {
    const annotationTarget = target.constructor
    let props = {}
    if (Reflect.hasOwnMetadata(PROPS_KEY, annotationTarget)) {
      props = Reflect.getMetadata(PROPS_KEY, annotationTarget)
    }

    props[targetKey] = {
      value: targetKey,
    }

    Reflect.defineMetadata(PROPS_KEY, props, annotationTarget)
  }
}
</code></pre>
<p>需要注意的是，这里我们虽然是对属性进行修饰，但实际元数据是要定义在类上，以维护该类需要注入的属性列表，因此我们必须取 target.constructor 作为要操作的 target。另外，为了方便起见，这里直接用了属性名（targetKey）作为从 IoC 容器中实例对应的 key。</p>
<p>然后，我们需要修改 IoC 容器的 get 方法，递归注入所有属性：</p>
<pre><code class="language-ts">// container.ts
import { PROPS_KEY } from './inject'

export class Container {
  bindMap = new Map()

  bind(identifier: string, clazz: any, constructorArgs?: Array&lt;any&gt;) {
    this.bindMap.set(identifier, {
      clazz,
      constructorArgs: constructorArgs || [],
    })
  }

  get&lt;T&gt;(identifier: string): T {
    const target = this.bindMap.get(identifier)

    const { clazz, constructorArgs } = target

    const props = Reflect.getMetadata(PROPS_KEY, clazz)
    const inst = Reflect.construct(clazz, constructorArgs)

    for (let prop in props) {
      const identifier = props[prop].value
      // 递归获取注入的对象
      inst[prop] = this.get(identifier)
    }
    return inst
  }
}
</code></pre>
<p>使用的时候，用 Inject 对需要的属性进行修饰即可：</p>
<pre><code class="language-ts">// a.ts
import { Provider } from 'provider'

@Provider('a')
export class A {
  @Inject()
  b: B
}
</code></pre>
<h3 id="25-最终代码"><a class="header" href="#25-最终代码">2.5 最终代码</a></h3>
<pre><code class="language-ts">// b.ts
@Proivder('b', [10])
class B {
  constructor(p: number) {
    this.p = p
  }
}

// a.ts
@Proivder('a')
class A {
  @Inject()
  private b: B
}

// main.ts
const container = new Container()
load(container)

console.log(container.get('a')) // =&gt; A { b: B { p: 10 } }
</code></pre>
<p>代码中不会再有手动进行实例化的情况，无论要注册多少个类，框架层都可以自动处理好一切，并在这些类实例化的时候注入需要的属性。所有类可提供的实例都由类自身来维护，即使存在修改也不需要改动其他文件。</p>
<h2 id="三-常见的依赖注入框架"><a class="header" href="#三-常见的依赖注入框架">三 常见的依赖注入框架</a></h2>
<p>市面上常用的依赖注入框架是：</p>
<ul>
<li><a href="https://github.com/inversify/InversifyJS">InversifyJS</a></li>
<li><a href="https://github.com/typestack/typedi">typedi</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="08-可维护性"><a class="header" href="#08-可维护性">08-可维护性</a></h1>
<h2 id="一-可维护代码概念"><a class="header" href="#一-可维护代码概念">一 可维护代码概念</a></h2>
<p>可维护代码特点：</p>
<pre><code class="language-txt">容易理解：无须求助原始开发者，任何人一看代码就知道它是干什么的，以它是怎么实现的。
符合常识：代码中的一切都显得顺理成章，无论操作有多么复杂。
容易适配：即使数据发生变化也不用完全重写。
容易扩展：代码架构经过认真设计，支持未来扩展核心功能。
容易调试：出问题时，代码可以给出明确的信息，通过它能直接定位问题。
</code></pre>
<h2 id="二-编码规范"><a class="header" href="#二-编码规范">二 编码规范</a></h2>
<h3 id="21-可读性"><a class="header" href="#21-可读性">2.1 可读性</a></h3>
<p>代码缩进是保证可读性的重要基础。如果所有人都使用相同的缩进，整个项目的代码就会更容易让人看懂。缩进通常要使用空格数而不是 Tab（制表符）来定义，因为后者在不同文本编辑器中的显示不同。一般来说，缩进是 4 个空格，当然具体多少个可以自己定。</p>
<p>可读性的另一方面是代码注释：</p>
<pre><code class="language-txt">函数和方法。每个函数和方法都应该有注释来描述其用途，以及完成任务所用的算法。同时，也写清使用这个函数或方法的前提（假设）、每个参数的含义，以及函数是否返回值（因为通过函数定义看不出来）。

大型代码块。多行代码但用于完成单一任务的，应该在前面给出注释，把要完成的任务写清楚。

复杂的算法。如果使用了独特的方法解决问题，要通过注释解释明白。这样不仅可以帮助别人查看代码，也可以帮助自己今后查看代码。

使用黑科技。由于浏览器之间的差异，JavaScript 代码中通常包含一些黑科技。不要假设其他人一看就能明白某个黑科技是为了解决某个浏览器的什么问题。如果某个浏览器不能使用正常方式达到目的，那要在注释里把黑科技的用途写出来。这样可以避免别人误以为黑科技没有用而把它“修复”掉，结果你已解决的问题又会出现。
</code></pre>
<h3 id="22-变量和函数名"><a class="header" href="#22-变量和函数名">2.2 变量和函数名</a></h3>
<p>命名的通用规则：</p>
<pre><code class="language-txt">变量名应该是名词，例如 car 或 person。

函数名应该以动词开始，例如 getName()。返回布尔值的函数通常以 is 开头，比如 isEnabled()。

对变量和函数都使用符合逻辑的名称，不用担心长度。长名字的问题可以通过后处理和压缩解决

变量、函数和方法应该以小写字母开头，使用驼峰大小写（camelCase）形式，如 getName() 和 isPerson。类名应该首字母大写，如 Person、RequestFactory。常量值应该全部大写并以下划线相接，比如 REQUEST_TIMEOUT。

名称要尽量用描述性和直观的词汇，但不要过于冗长。getName() 一看就知道会返回名称，而 PersonFactory 一看就知道会产生某个 Person 对象或实体。
</code></pre>
<h3 id="23-变量类型透明化"><a class="header" href="#23-变量类型透明化">2.3 变量类型透明化</a></h3>
<p>第一种标明变量类型的方式是通过初始化。定义变量时，应该立即将其初始化为一个将来要使用的类型值。</p>
<p>第二种标明变量类型的方式是使用匈牙利表示法。匈牙利表示法指的是在变量名前面前缀一个或多个字符表示数据类型。</p>
<pre><code class="language-js">// 使用匈牙利表示法标明数据类型
let bFound // 布尔值
let iCount // 整数
let sName // 字符串
let oPerson // 对象
</code></pre>
<p>第三种方式使用 TypeScript、Flow 等。</p>
<h2 id="三-松耦合"><a class="header" href="#三-松耦合">三 松耦合</a></h2>
<p>解耦 HTML/JavaScript：应该避免在 JavaScript 中创建大量 HTML。HTML 渲染应该尽可能与 JavaScript 分开</p>
<p>同样适用于 CSS 与 JS。</p>
<p>应用逻辑与事件处理程序分开：</p>
<pre><code class="language-js">function validateValue(value) {
  value = 5 * parseInt(value)
  if (value &gt; 10) {
    document.getElementById('error-msg').style.display = 'block'
  }
}
function handleKeyPress(event) {
  if (event.keyCode == 13) {
    let target = event.target
    validateValue(target.value)
  }
}
</code></pre>
<h2 id="四-编码惯例"><a class="header" href="#四-编码惯例">四 编码惯例</a></h2>
<h3 id="41-尊重对象所有权"><a class="header" href="#41-尊重对象所有权">4.1 尊重对象所有权</a></h3>
<p>在企业开发中，非常重要的编码惯例就是尊重对象所有权，这意味着不要修改不属于你的对象。简单来讲，如果你不负责创建和维护某个对象及其构造函数或方法，就不应该对其进行任何修改：</p>
<pre><code class="language-txt">尽量不要给实例或原型添加属性。
尽量不要给实例或原型添加方法。
不要重定义已有的方法
</code></pre>
<p>有个流行的 Prototype 库就发生过类似的事件。该库在 document 对象上实现了 getElementsByClassName() 方法，返回一个 Array 的实例，而这个实例上还增加了 each() 方法。jQuery 的作者 John Resig 后来在自己的博客上分析了这个问题造成的影响。他在博客中指出这个问题是由于浏览器也原生实现了相同的 getElementsByClassName() 方法造成的，Prototype 的同名方法返回的是 Array 而非 NodeList，NodeList 没有 each() 方法。使用这个库的开发者之前会写这样的代码：</p>
<pre><code class="language-js">document.getElementsByClassName('selected').each(Element.hide)
</code></pre>
<p>虽然这样写在没有原生实现 getElementsByClassName() 方法的浏览器里没有问题，但在实现它的浏览器里就会出问题。这是因为两个同名方法返回的结果不一样。我们不能预见浏览器厂商将来会怎么修改原生对象，因此不管怎么修改它们都可能在将来某个时刻出现冲突时导致问题。</p>
<p>最好的方法是永远不要修改不属于你的对象，有你自己创建的才是你的对象，包括自定义类型和对象字面量。Array、document 等对象都不是你的，因为在你的代码执行之前它们已经存在了。可以按如下这样为对象添加新功能：</p>
<pre><code class="language-js">创建包含想要功能的新对象，通过它与别人的对象交互。
创建新自定义类型继承本来想要修改的类型，可以给自定义类型添加新功能。
</code></pre>
<h3 id="42-少使用声明全局变量"><a class="header" href="#42-少使用声明全局变量">4.2 少使用声明全局变量</a></h3>
<p>最多可以创建一个全局变量，作为其他对象和函数的命名空间。来看下面的例子：</p>
<pre><code class="language-js">// 两个全局变量：不要！
var name = 'Nicholas'
function sayName() {
  console.log(name)
}

// 以上代码声明了两个全局变量：name 和 sayName()。可以像下面这样把它们包含在一个对象中：
// 一个全局变量：推荐
var MyApplication = {
  name: 'Nicholas',
  sayName: function () {
    console.log(this.name)
  },
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="07-web-安全"><a class="header" href="#07-web-安全">07-Web 安全</a></h1>
<h2 id="一-网络安全概述"><a class="header" href="#一-网络安全概述">一 网络安全概述</a></h2>
<h2 id="二-xss"><a class="header" href="#二-xss">二 XSS</a></h2>
<h3 id="20-xss-概述"><a class="header" href="#20-xss-概述">2.0 XSS 概述</a></h3>
<p>XSS 安全包括：反射型 XSS、存储型 XSS。</p>
<h3 id="21-反射型-xss"><a class="header" href="#21-反射型-xss">2.1 反射型 XSS</a></h3>
<p>反射型 XSS 过程：</p>
<pre><code class="language-txt">黑客将带有 url 地址发送给用户，但是该地址中携带着特殊参数：恶意脚本
用户点击此链接，请求信息被发送到服务端
服务端使用恶意参数后，黑客需要的数据被响应到前台
</code></pre>
<p>示例：</p>
<pre><code class="language-js">// 反射型 XSS：/goods?category=&lt;script&gt;alert(1)&lt;/script&gt;
app.get('/goods', (req, res) =&gt; {
  let { category } = req.query

  let goods = {
    books: [{ name: '木许传' }, { name: '金平没' }],
    tools: [{ name: 'ipad' }, { name: 'iphone' }],
  }
  let currentGoods = goods[category]

  let detail = ''
  if (currentGoods) {
    detail = currentGoods.map((item) =&gt; `&lt;li&gt;${item.name}&lt;/li&gt;`).join('')
  } else {
    detail = `此分类下没有商品`
  }
  res.setHeader('Content-Type', 'text/html;charset=utf8')
  res.send(`
        &lt;h1&gt;商品分类：${category}&lt;/h1&gt;
        &lt;ul&gt;${detail}&lt;/ul&gt;
    `)
})
</code></pre>
<p>反射型 XSS 必须听过用户点击才能发起，其本质其实是服务端没有对恶意的用户输入内容进行安全处理，导致响应了不改响应的内容。</p>
<p>现代浏览器一般内置了 XSS 过滤器，可以防止大部分反射型 XSS 攻击。</p>
<h3 id="22-存储型-xss"><a class="header" href="#22-存储型-xss">2.2 存储型 XSS</a></h3>
<p>存储型 XSS 过程：</p>
<pre><code class="language-txt">黑客将恶意脚本代码上传到了服务端
当用户访问视，服务端读取恶意数据并直接使用（如：返回含有恶意脚本的页面）
</code></pre>
<p>示例：</p>
<pre><code class="language-js">// 持久型 XSS：常见于用户评论
app.get('/comments', (req, res) =&gt; {
  // 假设用户提交了一个评论如下：
  let commont = '你好啊&lt;script&gt;alert(1)&lt;/script&gt;'
  // 后台渲染该评论
  res.send(`
        &lt;h1&gt;评论列表&lt;/h1&gt;
        &lt;ul&gt;
            &lt;li&gt;${commont}&lt;/li&gt;
        &lt;/ul&gt;
    `)
})
</code></pre>
<h3 id="23-dom-based-型-xss"><a class="header" href="#23-dom-based-型-xss">2.3 DOM-Based 型 XSS</a></h3>
<p>该类型 XSS 由于是修改 DOM 结构导致，所以不需要服务端支持。过程如下：</p>
<pre><code class="language-txt">用户打开带有恶意的链接
浏览器在解析 DOM 时，使用恶意数据
</code></pre>
<p>DOM-Based 型 XSS 常见触发场景是：修改 <code>innerHTML</code>、<code>outerHTML</code>、<code>document.write()</code> 。</p>
<h3 id="24-xss-解决方案"><a class="header" href="#24-xss-解决方案">2.4 XSS 解决方案</a></h3>
<p>方案一：设置 cookie 为 http-only</p>
<p>可以让本地无法获取 cookie：</p>
<pre><code class="language-js">// 服务端设置
res.cookie('sid', '10002343&amp;^&amp;*%21212e&amp;', { httpOnly: true })

// 本地无法获取，值为空字符串
document.cookie
</code></pre>
<p>但不能从根本上解决 XSS，只是不能让本地获取 cookie。</p>
<p>方案二：对提交的数据进行转义，当然前后台都需要进行过滤</p>
<pre><code class="language-js">function encode(str) {
  return String(str)
    .replace(/&gt;/g, '&amp;gt;')
    .replace(/&lt;/g, '&amp;lt;')
    .replace(/'/g, '&amp;#39')
    .replace(/&quot;/g, '&amp;quot;')
    .replace(/$/g, '&amp;amp;')
}
</code></pre>
<h2 id="三-跨站请求伪造-csrf"><a class="header" href="#三-跨站请求伪造-csrf">三 跨站请求伪造 CSRF</a></h2>
<h3 id="31-原理"><a class="header" href="#31-原理">3.1 原理</a></h3>
<p>跨站请求伪造 CSRF（Cross Site Request Forgery），一般是用户点开了一个比较吸引人的网站，其内部内嵌了一个没有宽高不会被发现的内容，过程如下：</p>
<pre><code class="language-txt">用户 A 登录网站，登录成功后设置 cookie
用户 A 点击了黑客站点，返回一个页面，该页面伪造一个请求到目的网站（如银行）
</code></pre>
<p>示例：</p>
<pre><code class="language-html">&lt;div&gt;吸引人的内容&lt;/div&gt;
&lt;iframe src=&quot;http://hack.com&quot; style=&quot;width:0;height:0&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p><code>http://hack.com</code> 在等待一定时间后向正规网站提交数据（如向正规转账页面提供用户数据，此时 cookie 是有效的）</p>
<h3 id="32-解决方案"><a class="header" href="#32-解决方案">3.2 解决方案</a></h3>
<p>第一道防线：验证码，每次提交都要提交新的验证码，用户体验较差</p>
<p>第二道防线：服务端检查 refer，不可靠，容易被绕过</p>
<pre><code class="language-js">let referer = req.headers['referer']
if(referer == ){

}
</code></pre>
<p>第三种：token，是目前主流方案。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="09-oauth2-授权服务"><a class="header" href="#09-oauth2-授权服务">09-OAuth2 授权服务</a></h1>
<h2 id="一-oauth2-概念"><a class="header" href="#一-oauth2-概念">一 OAuth2 概念</a></h2>
<p>案例：假如现在要访问百度文库内的文章信息，但是该文章信息需要登录后才能访问，用户在弹出的登录界面中使用 QQ 快速登录，即采用了 Auth2。</p>
<p>这里的登录中，通过授权，百度获取了 QQ 用户的账户信息、头像信息等，从而使用该信息进行百度系统的登录。</p>
<p>不过要注意的是，百度获的 QQ 账户只是临时令牌，而不是真实的用户账号密码。Auth2 最大的好处是：用户授权了多个应用后，可以防止因为某一个应用被破解导致所有应用信息都被窃取的状况。</p>
<p>弹出的授权地址类似：</p>
<pre><code class="language-txt">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc
&amp;client_id=100312028
&amp;response_type=code
&amp;redirect_uri=https%3A%2F%2Fpassport.baidu.com%2Fphoenix%2Faccount%2Fafterauth%3Fmkey%3D62bfd19b1fafe
&amp;display=page
&amp;scope=get_user_info%2Cadd_share%2Cget_other_info%2Cget_fanslist%2Cget_idollist%2Cadd_idol%2Cget_simple_userinfo
</code></pre>
<h2 id="二-oauth2-实现思路"><a class="header" href="#二-oauth2-实现思路">二 OAuth2 实现思路</a></h2>
<p>OAuth 在客户端与服务提供商之间，设置一个授权层（authorization layer），客户端不能直接登录服务提供商，只能登录该授权层，以此将用户与客户端区分开。</p>
<p>客户端登录授权层获取令牌后，服务提供商根据令牌的权限、有效期，向客户端开放用户在此存储的资料。</p>
<p>具体步骤：</p>
<pre><code class="language-txt">1、用户打开客户端后，客户端要求用户给予授权
2、用户同意给客户端授权
3、客户端使用上一步获得授权，向认证服务器申请令牌
4、客户端使用令牌，向资源服务器申请获取资源
5、资源服务器校验令牌，同意开放资源
</code></pre>
<p>示例名词：</p>
<pre><code class="language-txt">client：客户端，即第一节中所述的百度，百度使用 QQ 信息登录，百度作为了客户端
Resource Owner：资源持有者，即第一节所述的 QQ 用户 user
User Agent：用户代理，即第一节所述的浏览器
http service：服务提供商，即第一节所述的 QQ 服务器
Authorization server：认证服务器，即 QQ 提供的专门处理认证的服务器
Resource Server：资源服务器，即服务提供商存放用户资源的服务器

贴士：http service、Authorization server、Resource Server 可以是同一台服务器。
</code></pre>
<p>如图所示：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/node/OAuth2-1.svg" alt="OAuth2" /></p>
<h2 id="三-代码示例"><a class="header" href="#三-代码示例">三 代码示例</a></h2>
<pre><code class="language-js">let state = Date.now()

router.get('/login', function (req, res, next) {
  let grantUrl = 'https://graph.qq.com/oauth2.0/authorize?'
  let options = {
    response_type: 'code', //响应类型 固定为 code
    client_id: AppId, //客户端的 ID，这个 ID 是由 QQ 授权服务器分配的
    redirect_uri, // 'http://www.demo.com/user/callback'
    state,
    scope: 'get_user_info,list_album',
  }
  let query = querystring.stringify(options)
  grantUrl += query
  res.render('login', { title: '登录', grantUrl })
})

//http://www.demo.com/user/callback?code=9A5F06AF&amp;state=test
router.get('/callback', function (req, res) {
  let { code, state } = req.query
  res.send(code)
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-微前端架构"><a class="header" href="#10-微前端架构">10-微前端架构</a></h1>
<h2 id="一-大型项目迭代问题"><a class="header" href="#一-大型项目迭代问题">一 大型项目迭代问题</a></h2>
<p>对公共逻辑的抽象是软件工程不可绕开的话题，前端也不例外。在前端开发中，组件抽取、公共模块抽取是最常见的业务解耦方式。随着企业业务的发展，这些抽象的模块可能需要运用到许多不同的工程中，这就需要考虑如何组织、使用这些技术积累。</p>
<p>我们通常采取的技术方案是：将公共模块打包为 npm 包，在各个项目、模块中导入使用，但这很容易带来以下缺点：</p>
<ul>
<li>（1）发布效率不高：如果公共模块的逻辑出现变化，需要重新打包、发版，使用该模块的项目都要进行更新。若 npm 包内涉及的业务较多，就会让维护该包的精力不断放大。</li>
<li>（2）多团队协作不规范：不同团队的 npm 包容易出现不同包规范不同现象。</li>
</ul>
<h2 id="二-微前端架构的引入"><a class="header" href="#二-微前端架构的引入">二 微前端架构的引入</a></h2>
<h3 id="21-微前端解决迭代问题思路"><a class="header" href="#21-微前端解决迭代问题思路">2.1 微前端解决迭代问题思路</a></h3>
<p>我们现在面临的问题是：工程相当庞大，引入模块很多；不同工程使用的技术栈也千差万别。这样的项目、工程在迭代上需要支出的额外成本相当庞大。</p>
<p>微前端的主要目的就是让不同工程在迭代阶段解耦，所有的工程都能独立迭代，互不干涉，即使这些工程在一个页面中都被使用到，也能够独立交付。</p>
<p>微前端的实现思路：将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品。</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/micro-01.svg" alt="微前端架构迭代思路" /></p>
<h3 id="22-微前端架构的特点"><a class="header" href="#22-微前端架构的特点">2.2 微前端架构的特点</a></h3>
<p>微前端架构只是一种由独立交付的多个前端应用组成整体的架构风格，并非具体实践，在理论上，该风格可以将庞大的整体拆成可控的小块，并明确它们之间的依赖关系，关键优势在于：</p>
<ul>
<li>代码的应用级解耦：微前端架构下的代码库倾向于更小/简单、更容易开发，避免模块间不合理的隐式耦合造成的复杂度上升。通过界定清晰的应用边界来降低意外耦合的可能性，增加子应用间逻辑耦合的成本，促使开发者明确数据和事件在应用程序中的流向。</li>
<li>增量升级：微前端架构可以让新旧代码和谐共存，再逐步转化旧代码，直到整个重构完成</li>
<li>独立部署：每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），并且要能独立部署，不必过多考虑其它代码库和交付流水线的当前状态。</li>
<li>团队自治：由不同团队各自负责一块产品功能从构思到发布的整个过程，团队能够完全拥有为客户提供价值所需的一切，从而快速高效地运转</li>
</ul>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/micro-02.svg" alt="微前端架构迭代思路" /></p>
<h3 id="23-微前端架构应用场景"><a class="header" href="#23-微前端架构应用场景">2.3 微前端架构应用场景</a></h3>
<p>这里需要区分微前端与微服务的理解方式：微前端主要目的是聚合，即将不同子系统聚合成一个大系统，而微服务架构目前更多是解耦，即解耦不同服务间的依赖。
所以当一个工程采用了多种技术栈，内部引入了多个项目，需要将其聚合时，且依然能实现增量开发时，微前端架构是最好的选择。</p>
<h2 id="三-微前端架构中面临的技术问题"><a class="header" href="#三-微前端架构中面临的技术问题">三 微前端架构中面临的技术问题</a></h2>
<h3 id="30-微前端需要解决的关键问题"><a class="header" href="#30-微前端需要解决的关键问题">3.0 微前端需要解决的关键问题</a></h3>
<p>微前端需要解决的关键问题：</p>
<ul>
<li>子应用集成问题</li>
<li>子应用隔离方案</li>
<li>子应用间通信问题</li>
</ul>
<p>微前端常见技术问题如图所示：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/micro-03.svg" alt="微前端架构迭代思路" /></p>
<h3 id="31-子应用集成问题"><a class="header" href="#31-子应用集成问题">3.1 子应用集成问题</a></h3>
<p>集成方式分为 3 类：</p>
<ul>
<li>服务端集成：如 SSR 拼装模板</li>
<li>构建时集成：如 Code Splitting</li>
<li>运行时集成：如通过 iframe、JS、Web Components 等方式</li>
</ul>
<p>在实践中我们看到，基座模式的子应用通过容器进行集成、加载，模块联邦模式采用 webpack 工具进行注入。他们互有利弊，整体而言，笔者偏向后者。</p>
<h3 id="32-子应用隔离方案"><a class="header" href="#32-子应用隔离方案">3.2 子应用隔离方案</a></h3>
<p>子应用之间，以及子应用与主应用间的样式、作用域隔离是必须要考虑的问题，常见解决方案如下：</p>
<ul>
<li>样式隔离：开发规范（如 BEM）、CSS 预处理（如 SASS）、模块定义（如 CSS Module）、用 JS 来写（CSS-in-JS）、以及 shadow DOM 特性</li>
<li>作用域隔离：各种模块定义（如 ES Module、AMD、Common Module、UMD）</li>
</ul>
<h3 id="33-子应用间通信问题"><a class="header" href="#33-子应用间通信问题">3.3 子应用间通信问题</a></h3>
<p>通过自定义事件间接通信是一种避免直接耦合的常用方式，此外，React 的单向数据流模型也能让依赖关系更加明确，对应到微前端中，从容器应用向子应用传递数据与回调函数</p>
<p>另外，路由参数除了能用于分享、书签等场景外，也可以作为一种通信手段，并且具有诸多优势：</p>
<ul>
<li>其结构遵从定义明确的开放标准</li>
<li>页面级共享，能够全局访问</li>
<li>长度限制促使只传递必要的少量数据</li>
<li>面向用户的，有助于依照领域建模</li>
<li>声明式的，语义上更通用（&quot;this is where we are&quot;, rather than &quot;please do this thing&quot;）</li>
<li>迫使子应用之间间接通信，而不直接依赖对方</li>
</ul>
<p>原则上，无论采用哪种方式，都应该尽可能减少子应用间的通信，以避免大量弱依赖造成的强耦合。</p>
<h2 id="四-微前端架构实践"><a class="header" href="#四-微前端架构实践">四 微前端架构实践</a></h2>
<h3 id="41-自由组织模式"><a class="header" href="#41-自由组织模式">4.1 自由组织模式</a></h3>
<blockquote>
<p>自由组织模式：使用过基础模块框架构架符合业务需求的自建微前端模式。</p>
</blockquote>
<p>常见的基础模块框架是 SystemJS，该库用于实现一个不同于 CMD/ESModule 的模块化规范，不过通过 webpack 可以将 ES 模块转化为支持 SystemJS 的模块。</p>
<p>webpack 中使用方式如下所示：</p>
<pre><code class="language-js">module.exports = {
  // 其他配置

  // 打包格式
  output: {
    libraryTarget: 'system',
  },

  // 引入的库需要忽略，采用 systemjs 方式引入
  externals: ['react', 'react-dom', 'react-router-dom'],
}
</code></pre>
<p>react 中使用 SystemJS 示例：</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;script type=&quot;systemjs-importmap&quot;&gt;
      {
        &quot;imports&quot;: {
          &quot;react&quot;: &quot;./libs/react.min.js&quot;,
          &quot;react-dom&quot;: &quot;./libs/react-dom.min.js&quot;,
          &quot;react-router-dom&quot;: &quot;./libs/react-router-dom.min.js&quot;
        }
      }
    &lt;/script&gt;
    &lt;script src=&quot;./libs/system.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
      System.import('./index.js')
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>由于该模式缺乏通信、隔离、加载方案，架构较为原始，一般不采用，而是在该框架基础上进行衍生，如：基座模式。</p>
<h3 id="42-基座模式应用容器模式"><a class="header" href="#42-基座模式应用容器模式">4.2 基座模式（应用容器模式）</a></h3>
<blockquote>
<p>基座模式：微前端的顶级父应用作为容器，子应用由容器来根据业务进行加载。</p>
</blockquote>
<p>基座模式由于父容器的存在，很好的实现了应用的通讯问题，但是也随之带来了新问题：由于需要中心化的容器，项目接入成本高。</p>
<p>目前常见的基座模式实践有：single-spa、qiankun 等，其中大部分框架均基于 single-spa，包括 qiankun。</p>
<p>single-spa 支持三种微前端应用：</p>
<ul>
<li>parcel：常见的多子应用架构，可以使用 vue、react、angular 等多种框架进行开发</li>
<li>root-config：用于创建微前端容器应用</li>
<li>utility modules：公共模块应用，用于跨应用共享 js 逻辑的微应用。</li>
</ul>
<p>singel-spa 的整个基座：</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt; &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
      System.import('@demo/root-config')
    &lt;/script&gt;
    &lt;import-map-overrides-full
      show-when-local-storage=&quot;devtolls&quot;
      dev-libs
    &gt;&lt;/import-map-overrides-full&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在基座中配置子应用：</p>
<pre><code class="language-js">// demo-root-config.js
import { registerApplication, start } from 'single-spa'

registerApplication({
  name: '@demo/demo1',
  app: () =&gt; {
    System.import('./dist/demo1.js')
  },
  activeWhen: ['/'],
})
</code></pre>
<h3 id="43-去中心化模式模块联邦"><a class="header" href="#43-去中心化模式模块联邦">4.3 去中心化模式（模块联邦）</a></h3>
<blockquote>
<p>模块联邦：为了解决基座模式中引入容器造成的中心化耦合问题，webpack5 中引入了模块联邦的功能，一个应用可以导出、导入任意的模块。</p>
</blockquote>
<p>模块联邦原理图：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/zen/micro-04.svg" alt="微前端架构迭代思路" /></p>
<h2 id="五-webpack5-中的模块联邦使用实践"><a class="header" href="#五-webpack5-中的模块联邦使用实践">五 webpack5 中的模块联邦使用实践</a></h2>
<p>使用模块联邦导出模块：</p>
<pre><code class="language-js">const MFP = require('webpack').container.ModuleFederationPlugin

modules.exports = {
    plugins: {
        new MFP({
            name: 'microApp',               // 微应用名字，类似 single-spa 的组织名
            filename: 'user.js',            // 对外提供的打包文件
            // 导出多个组件：key 为导入者使用名，value 为导出的文件路径
            exposes: {
                './infoComponent': './src/components/info.js',
                './iconComponent': './src/components/icon.js'
            }
        })
    }
}
</code></pre>
<p>在其他项目使用模块联邦引入模块：</p>
<pre><code class="language-js">const MFP = require('webpack').container.ModuleFederationPlugin
modules.exports = {
    plugins: {
        new MFP({
            name: 'roots',
            remotes: {
                // 固定写法：微应用名 @ webpack 服务地址 导出的 filename
                microUser: 'microApp@http://localhost:3001/user.js',
            }
        })
    }
}
</code></pre>
<p>在 React 项目中具体使用该模块（注意是异步的）：</p>
<pre><code class="language-js">const Info = React.lazy(() =&gt; import('microUser/infoComponent'))
const Icon = React.lazy(() =&gt; import('microUser/iconComponent'))

const App = &gt; () =&gt; {
    return (
        &lt;div&gt;
           &lt;React.Suspense fallback='loading'&gt;
            &lt;Icon /&gt;
            &lt;Info /&gt;
           &lt;/React.Suspense&gt;
        &lt;/div&gt;
    )
}
</code></pre>
<p>在 Vue 项目总具体使用该模块 (同样需要是异步)：</p>
<pre><code class="language-js">import { defineAsyncComponent } from 'vue'

const Info = defineAsyncComponent(() =&gt; import('microUser/infoComponent'))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="09-前端中的测试"><a class="header" href="#09-前端中的测试">09-前端中的测试</a></h1>
<h2 id="一-测试定义"><a class="header" href="#一-测试定义">一 测试定义</a></h2>
<h3 id="11-常见测试分类"><a class="header" href="#11-常见测试分类">1.1 常见测试分类</a></h3>
<p>针对小型项目，手动运行查看错误，是最为快捷的方式。但是对一个整合了很多结构、系统的项目来说，手动测试为极大增加排错负担，自动化测试可以在一定程度上减少拍错时间。</p>
<p>一些常见的自动化测试有：编写自动测试脚本、调用应用程序中的函数、对比程序渲染结果等等。自动化测试最大的好处是：检测应用程序是否能够正常工作。</p>
<p>对应用程序执行的正确性进行测试的常见方式有：</p>
<ul>
<li>端到端测试：对整个应用程序及其依赖进行测试</li>
<li>单元测试：对程序模块进行测试</li>
<li>快照测试：传统的快照测试方式是在浏览器中启动程序后获取其渲染页面的屏幕截图，新截图与旧截图进行比较。</li>
</ul>
<p>对应用程序的性能进行测试的常见方式有：</p>
<ul>
<li>基准测试：用来统计多少时间内执行了多少次某个方法</li>
<li>压力测试：压测一般是对网络接口进行压力测试</li>
</ul>
<h3 id="12-测试覆盖率"><a class="header" href="#12-测试覆盖率">1.2 测试覆盖率</a></h3>
<p>测试覆盖率是度量自动化测试的指标之一，使用百分比表示，100% 代码覆盖率即代表执行测试期间每行代码都会被运行，0% 意味着测试时任何一行代码都未被执行。</p>
<p>大多数情况下，100% 覆盖率完全没有意义，100% 覆盖率会让开发进度变得极度缓慢，获得的收益远不能抵消时间的流式。同样，为前端的组件编写单元测试很重要，但是如果组件的每个属性都编写测试，就会创建一个低效的、减缓开发速度的测试套件。</p>
<p>一个好的组件的单元测试应该始终可以触发一个输入，并断言组件产生正确的输出，要做到这样，应该：从开发者使用组件又不知道组件内部实现的角度编写测试。</p>
<p>组件的输入一般指用户的操作，如：单机按钮。输出一般指 DOM 的变化，如：生成 DOM 节点。
输入：</p>
<pre><code class="language-txt">组件的 props
用户操作
事件
store 数据
</code></pre>
<p>输出：</p>
<pre><code class="language-txt">发射出去的事件
外部函数引用
</code></pre>
<p>示例：一个授权组件，接收是否已授权 prop 参数 flag，flag 为 true，则渲染：<code>已被授权</code>，否则渲染：<code>未被授权</code>。flag 即是输入，渲染的信息即输出。</p>
<h3 id="13-测试风格"><a class="header" href="#13-测试风格">1.3 测试风格</a></h3>
<ul>
<li>TDD（Test Driven Development）：测试驱动开发，关注所有功能是否被正确实现，每一个功能具备对应的测试用例。TDD 的表达方式偏向于功能说明书。倡导先写测试程序，然后编码实现其功能。</li>
<li>BDD（Behavior Driven Development）：行为驱动开发，鼓励软件开发中的相关人员进行协作，书写非程序员刻度的测试用例扩展 TDD。关注整体行为是否符合预期，适合自顶向下的设计方式。BDD 的表达方式接近于自然语言。</li>
</ul>
<p>一些实践：并不一定要严格按照 TDD 等风格来进行开发，比如开发 Vue 组件的顺序：</p>
<pre><code class="language-txt">1 为每个组件编写单元测试、源码
2 调整组件直到满足需求
3 为已完成组件添加快照测试
4 在浏览器中手动调试
5 编写端到端测试
</code></pre>
<h2 id="二-单元测试-1"><a class="header" href="#二-单元测试-1">二 单元测试</a></h2>
<h3 id="21-单元测试概念"><a class="header" href="#21-单元测试概念">2.1 单元测试概念</a></h3>
<p>单元测试（模块测试），用来实现对程序模块的检验。在编写可测试代码时，可以遵循以下原则：</p>
<ul>
<li>单一职责：代码段的职业越多，单元测试就需要构造更多的输入，同时也会影响代码的后期维护</li>
<li>接口抽象：通过对程序代码进行接口抽象后，可以针对接口进行测试，而具体代码的变化则不会影响为接口编写的单元测试</li>
<li>层次分离：层次分离其实是单一职责原则在项目上的一个整体实现，单元测试应该保证可以逐层测试，逐层保证。</li>
</ul>
<p>单元测试主要包含：断言、测试框架、测试用例、测试覆盖率、mock 模拟异常、持续集成等几个方面。</p>
<h3 id="22-测试框架-mocha"><a class="header" href="#22-测试框架-mocha">2.2 测试框架 Mocha</a></h3>
<p>流行的单元测试框架有 Mocha。Mocha 并不是关注测试本身，需要配合 Chai 这样的断言库来编写，Mocha 提供了一套单元测试的输出规范。</p>
<pre><code class="language-txt">npm i mocha -g
</code></pre>
<p>mocha 对 TDD 方式的支持：采用 suite 和 test 完成，suite 实现了多层级描述，测试用例使用 test。提供的钩子函数有 setup、teardown，分别表示 suite 前、suit 后执行。</p>
<pre><code class="language-js">suite('Array', function () {
  setup(function () {
    // ...
  })

  suite('#indexOf()', function () {
    test('should return -1 when not present', function () {
      assert.equal(-1, [1, 2, 3].indexOf(4))
    })
  })
})
</code></pre>
<p>mocha 对 BDD 方式的支持：主要采用 describe 和 it 进行组织，describe 可以描述多层级结构，具体到测试用例时，可以使用 it。另外内部提供了 before、after、beforeEache、afterEach 这 4 个钩子函数，用于协助 describe 中测试用例的准备、安装、卸载、回收工作。before 和 after 分别在进入和退出 describe 时触发，beforeEach 和 afterEach 分别在 describe 中每一个测试用例（it）执行前、执行后触发。</p>
<pre><code class="language-js">describe('Array', function () {
  before(function () {
    // ...
  })

  describe('#indexOf()', function () {
    it('should return -1 when not present', function () {})
  })
})
</code></pre>
<p>mocha 框架与断言之间是解耦的，既可以使用 Node 原生的 assert 模块，也可以使用 should.js、chai 等第三方断言库。</p>
<p>mocha 导出测试报告也支持多种格式，一般使用 json 格式。</p>
<p>mocha 对异步的支持：</p>
<pre><code class="language-js">it('fs.readFile should be ok', function (done) {
  fs.readFile('file_path', 'utf-8', function (err, data) {
    should.not.exist(err)
    done()
  })
})
</code></pre>
<h2 id="三-测试框架-jest"><a class="header" href="#三-测试框架-jest">三 测试框架 jest</a></h2>
<h3 id="31-jest-简介与安装"><a class="header" href="#31-jest-简介与安装">3.1 jest 简介与安装</a></h3>
<p>jest 由 facebook 出品，集成了企业级开发中常用的测试需求工具，是一款简便、强大的综合测试框架。集成了大部分测试需要的功能：</p>
<ul>
<li>断言：jest 内置了断言，而 mocha 则需要安装 chai 或者其他断言库</li>
<li>异步支持：jest 支持异步代码的测试</li>
<li>mock：jest 内置了 mock 服务，mocha 需要安装 sinon</li>
<li>代码覆盖率测试：jest 内置了覆盖率测试服务，mocha 需要安装 istanbul</li>
</ul>
<h3 id="32-todo"><a class="header" href="#32-todo">3.2 TODO</a></h3>
<h2 id="四-性能测试"><a class="header" href="#四-性能测试">四 性能测试</a></h2>
<h3 id="41-基准测试"><a class="header" href="#41-基准测试">4.1 基准测试</a></h3>
<p>基准测试用来统计多少时间内执行了多少次某个方法。假设要测试 ES5 中的 Array.prototype.map 和循环提取值两种方式，他们都是迭代一个数组，根据回调函数执行的返回值得到的一个新的数组，相关代码如下：</p>
<pre><code class="language-js">var nativeMap = function (arr, callback) {
  return arr.map(callback)
}

var customMap = function (arr, callback) {
  var ret = []
  for (var i = 0; i &lt; arr.length; i++) {
    ret.push(callback(arr[i], i, arr))
  }
  return ret
}
</code></pre>
<p>比较简单直接的方式就是构造相同的输入数据，然后执行相同的次数，最后比较时间，所以可以写一个方法来执行：</p>
<pre><code class="language-js">var run = function (name, times, fn, arr, callback) {
    var start = (new Date()).getTime();
    for (var i = 0; i &lt; times; i++) {
        fn(arr, callback);
    }
    var end = (new Date()).getTime();
    console.log('Running s d times cost d ms', name, times, end % % % - start);
};
</code></pre>
<p>最后分别调用 1000000 次：</p>
<pre><code class="language-js">var callback = function (item) {
  return item
}
run('nativeMap', 1000000, nativeMap, [0, 1, 2, 3, 5, 6], callback)
run('customMap', 1000000, customMap, [0, 1, 2, 3, 5, 6], callback)
</code></pre>
<p>由上看出，执行相同的任务，map 耗费的时间大约是直接 for 循环的 5-7 倍以上。</p>
<p>比较好的基准测试框架式 benchmark 第三方模块。</p>
<h3 id="42-压力测试"><a class="header" href="#42-压力测试">4.2 压力测试</a></h3>
<p>基准测试一般是对基本的方法进行测试，压测一般是对网络接口进行压力测试。压测需要考察的指标有：吞吐率、响应时间、并发数。</p>
<p>常用的压测工具有：ab、http_load，使用 ab 工具如下：</p>
<pre><code class="language-txt"># 10 个并发用户持续 3 秒向服务端发送请求
ab -c 10 -t 3 http://localhost:8001/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-项目集成---持续集成与持续部署"><a class="header" href="#11-项目集成---持续集成与持续部署">11-项目集成 - 持续集成与持续部署</a></h1>
<h2 id="一-软件开发模型"><a class="header" href="#一-软件开发模型">一 软件开发模型</a></h2>
<h3 id="11-瀑布模型"><a class="header" href="#11-瀑布模型">1.1 瀑布模型</a></h3>
<p>瀑布模型是软件开发的常用模型，类似生产线的案例，按照结构流程在一个方向上流动。</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/cicd/cicd-01.png" alt="瀑布模型" /></p>
<p>瀑布模型简单易用，完成当前阶段后只需要关注后续阶段即可，项目也根据阶段的划分提供了检查点。</p>
<p>瀑布模型也有着极大缺点：</p>
<ul>
<li>由于是线性开发模型，只有开发末期才能见到开发结果，增加了项目风险</li>
<li>不能适应快速的用户需求变化，这也是瀑布模型最大缺点</li>
</ul>
<h3 id="12-敏捷开发"><a class="header" href="#12-敏捷开发">1.2 敏捷开发</a></h3>
<p>敏捷开发的核心是：</p>
<ul>
<li>迭代式：传统开发采用一个大周期进行开发，如一年，迭代式开发将开发周期划分为多个小周期，即一次大开发变成多次小开发，每次小开发都是同样的流程，所以看上去就像重复在做同样的步骤</li>
<li>增量式：软件的每个版本，都会新增一个用户可以感知的可用版本，其实也是按照新增功能进行迭代式开发</li>
</ul>
<p>敏捷开发虽然将软件开发划分成多个周期进行迭代，但是每个迭代周期都必须是完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。</p>
<p>如图所示：</p>
<p><img src="10-%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%A6%85/../images/cicd/cicd-02.png" alt="敏捷开发" /></p>
<p>敏捷开发好处：</p>
<ul>
<li>早期交付</li>
<li>降低风险</li>
</ul>
<h2 id="二-持续集成与持续交付"><a class="header" href="#二-持续集成与持续交付">二 持续集成与持续交付</a></h2>
<h3 id="21-cicd-概念"><a class="header" href="#21-cicd-概念">2.1 CI/CD 概念</a></h3>
<p>所谓集成，其实就是一些孤立的事务经过某种方式集中在了一起，产生了联系，从而构成一个整体的过程。</p>
<p>持续集成和持续交付的概念：</p>
<ul>
<li>持续集成（CI：Continuous intergration）：将所有开发者的工作副本合并到主干的过程。一般在合并前，需要经过集成系统进行自动构建、自动测试等流程进行验证。</li>
<li>持续交付（CD：Continuous delivery）：完成 CI 中的构建、测试等自动化流程后，将已经验证的代码发布。CD 的目标是建立一个可随时部署到生产环境的代码库。</li>
<li>持续部署（Continuous deployment）：是 CD 的延伸，用于自动将应用发布到生产环境。由于其与生产强关联，持续部署在很大程度上依赖于精心设计的测试自动化。</li>
</ul>
<h3 id="22-持续集成流程"><a class="header" href="#22-持续集成流程">2.2 持续集成流程</a></h3>
<p>持续集成强调开发人员在提交新代码后，立刻进行构建、测试，以确定新代码与旧代码是否能够正确的集成在一起，这样才能让产品实现快速迭代的同时保持高质量。所以，持续集成也是敏捷开发的具体实现方案之一。</p>
<p>持续集成的步骤：</p>
<ul>
<li>提交：向代码仓库提交代码，后续所有步骤都开始于本次的提交</li>
<li>测试：代码仓库对 commit 操作配置钩子（hook），只要提交代码就会跑自动化测试</li>
<li>交付：测试没有问题，可以合并到主干，同时也会触发主干的测试钩子</li>
<li>构建：源码转换为可运行的实际代码，如配置各种资源、依赖等</li>
<li>二测：如果在上一次测试中没有涵盖全部测试，则构建的结果要进行第二轮测试。如果在第一伦测试中已经完成全部测试，则需要将构建移在第一轮测试前</li>
<li>部署：当前代码已经是可部署的版本，进行存档打包发送到生产服务器</li>
<li>回滚：如果当前版本在生产环境发生问题，则需要回滚，回滚最简单的做法就是修改符号链接，指向上一个版本的目录</li>
</ul>
<p>持续集成的优点：</p>
<ul>
<li>降低风险：不断的构建可以在早起发现问题，减少修复代价</li>
<li>减少重复性工作</li>
<li>持续部署，持续交付了可供使用的版本</li>
</ul>
<p>注意：持续集成中交付的结果必须是个可用的产品！</p>
<h3 id="22-持续继承系统的组成要素"><a class="header" href="#22-持续继承系统的组成要素">2.2 持续继承系统的组成要素</a></h3>
<p>一个最小化的持续集成系统需要以下要素：</p>
<ul>
<li>版本管理系统：源码的版本管理平台，如：基于 git 的 github、gitlab 等。</li>
<li>构建工具：使用脚本或者工具实现项目的自动构建，如：java 的 gradle。构建中实现：编译、静态扫描、运行测试、样式检查、打包、发布等。</li>
<li>CI 服务器：CI 服务器用于检测项目中代码的变动，依据变动通过构建工具及时进行构建，并将集成结果反馈给开发团队。</li>
</ul>
<h2 id="三-常见的持续集成工具"><a class="header" href="#三-常见的持续集成工具">三 常见的持续集成工具</a></h2>
<p>常见的构建工具：</p>
<ul>
<li>Jenkins：老牌构建工具，源自于 Sun 公司的 Hudson。Jenkins 开源，功能完善，也有丰富的插件系统，但是需要专用服务器，有一定的运维成本。</li>
<li>Travis CI：基于云的系统，无需专用服务器，基于 YAML 进行配置，开源且开箱即用，也无需专用服务器，但是没有免费版本。</li>
<li>Circle CI：通过 github 或者 bitbucket 库进行授权，添加到 circleci.com 之后，每个代码更改都会在干净的容器中触发自动测试，当然也有本地、私有云解决方案，拥有免费计划。</li>
<li>GithubAction：Github 出版的基于 github 系统的持续集成工具。</li>
</ul>
<h2 id="四-jekins"><a class="header" href="#四-jekins">四 Jekins</a></h2>
<h3 id="40-jekins-相关概念"><a class="header" href="#40-jekins-相关概念">4.0 Jekins 相关概念</a></h3>
<ul>
<li>流水线（pipeline）：是一套插件，将持续交付的实现、实施集成到 Jekins 中，其定义被写入到文件 Jekinsfile 中</li>
<li>节点：即机器，用于执行 jekins 任务</li>
<li>阶段：定义不同的执行任务，比如：构建、测试、部署</li>
<li>步骤：相当于告诉 jekins 做什么，如 shell 命令</li>
</ul>
<h3 id="41-jekins-安装"><a class="header" href="#41-jekins-安装">4.1 Jekins 安装</a></h3>
<p>安装地址：<a href="https://www.jenkins.io/doc/book/installing/docker/#setup-wizard/">https://www.jenkins.io/doc/book/installing/docker/#setup-wizard/</a>，推荐使用 docker 方式安装：</p>
<pre><code class="language-txt"># 下载镜像
docker pull jenkinsci/blueocean

# 创建网络
docker network create jenkins

# 运行容器
docker run --name jenkins-docker --rm --detach \
  --privileged --network jenkins --network-alias docker \
  --env DOCKER_TLS_CERTDIR=/certs \
  --volume jenkins-docker-certs:/certs/client \
  --volume jenkins-data:/var/jenkins_home \
  --publish 2376:2376 docker:dind --storage-driver overlay2

# 获取管理员密码
docker exec -u 0 -it 容器名 /bin/bash
cat /var/jenkins_home/secrets/initialAdminPassword
</code></pre>
<h3 id="42-jenkins-常见插件"><a class="header" href="#42-jenkins-常见插件">4.2 Jenkins 常见插件</a></h3>
<p>Jenkins 加速：</p>
<pre><code class="language-txt"># 在 系统管理 - 插件管理 - 高级 - 升级站点中，修改 URL 为：
https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json
</code></pre>
<p>在 系统管理-插件管理 - 可选插件中，搜索安装以下常用插件：</p>
<pre><code class="language-txt">GitHub Integration
GitLab
SSH
SSH Agent
SSH Pipeline Steps
Publish Over SSH
</code></pre>
<h3 id="43-docker-安装-gitlab"><a class="header" href="#43-docker-安装-gitlab">4.3 docker 安装 gitlab</a></h3>
<p>第一步：创建基础环境：</p>
<pre><code class="language-txt"># 需要提前确保关闭 SELinux
export GITLAB_HOME=/srv/gitlab
mkdir -p $GITLAB_HOME/config
mkdir -p $GITLAB_HOME/logs
mkdir -p $GITLAB_HOME/data
</code></pre>
<p>第二步：启动容器，这里使用非标准的端口，因为 80 端口往往是被占用的。</p>
<pre><code class="language-txt"># 这里原本是 8880:80，若不采用非标准的 8880，则 gitlab 的 nginx 代理为 80 端口，仓库提供的 clone 地址不带 8880，而是默认的 80
sudo docker run --detach \
  --hostname 192.168.*.* \
  --publish 8443:443 --publish 8880:8880 --publish 8222:22 \
  --privileged=true \
  --name gitlab \
  --restart no \
  --volume $GITLAB_HOME/config:/etc/gitlab\
  --volume $GITLAB_HOME/logs:/var/log/gitlab\
  --volume $GITLAB_HOME/data:/var/opt/gitlab \
  gitlab/gitlab-ce:latest

# 查询安装进度
sudo docker logs -f gitlab
</code></pre>
<p>第三步：配置非标准端口</p>
<pre><code class="language-txt">sudo vim $GITLAB_HOME/config/gitlab.rb

# 添加内容为
external_url 'http://192.168.*.*'
nginx['redirect_http_to_https_port'] = 8880
nginx['listen_port'] = 8880
</code></pre>
<p>第四步：加载配置</p>
<pre><code class="language-txt"># 进入容器，刷新配置并重启 gitlab
docker exec -ti gitlab /bin/bash

# 更换 ip 需要重启加载容器
gitlab-ctl reconfigure

# 重启
gitlab-ctl restart
gitlab-ctl status
</code></pre>
<p>第五步：访问网页 8880 端口，并使用 root 以下命令中打印的用户名和密码登录：</p>
<pre><code class="language-txt">sudo docker exec -it gitlab grep 'Password:' /etc/gitlab/initial_root_password
</code></pre>
<p>注意：docker 的 gitlab 镜像与容器直接删除，容易导致缓存数据错误，建议进入容器卸载后再删除容器，如下所示：</p>
<pre><code class="language-txt">gitlab-ctl uninstall # 删除服务
gitlab-ctl cleanse # 清楚生成数据
gitlab-ctl remove-accounts # 删除配置账户
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-canvas-简单使用"><a class="header" href="#011-canvas-简单使用">01.1-Canvas 简单使用</a></h1>
<h2 id="一-canvas-简介"><a class="header" href="#一-canvas-简介">一 Canvas 简介</a></h2>
<p>canvas 是 html5 提供的画布标签，该标签内会形成一个矩形区域，开发者可以控制该区域内每一个像素，从而实现在网页绘制图像的功能。</p>
<p>与 Flash 相比，Canvas 更加轻量，使用 Canvas 绘制图形，在绘制成功后，canvas 元素 就会像素化，无法修改，只能通过 API 得到画布的内容再次绘制。所以 canvas 图形如果要实现动画，需要的编程逻辑是：清屏 - 更新 - 重新渲染。</p>
<p>注意：<strong>IE8 不支持 canvas！</strong>，此时会显示<code>后备文本</code>，即只会显示 canvas 标签内的文本。如果需要 IE8 以下浏览器支持 canvas，可以使用：</p>
<ul>
<li>explorecanvas</li>
<li>Google Chrome Frame</li>
</ul>
<h2 id="二-基本用法"><a class="header" href="#二-基本用法">二 基本用法</a></h2>
<p>示例代码：</p>
<pre><code class="language-html">&lt;canvas id=&quot;mycanvas&quot; width=&quot;600&quot; height=&quot;600&quot;&gt;不兼容时显示该文字！&lt;/canvas&gt;
&lt;script&gt;
  // 获得 canvas 上下文
  const ctx = document.querySelector('#mycanvas').getContext('2d')
  // ctx 保存绘制环境，使用 ctx 绘制
  ctx.fillStyle = 'rgb(0,0,200)'
  ctx.fillRect(0, 0, 100, 100)
  setTimeout(() =&gt; {
    // 清除画布：0,0 代表从何处开始清除，600,600 代表清除的位置和高度
    ctx.clearRect(0, 0, 600, 600)
  }, 5000)
&lt;/script&gt;
</code></pre>
<p>canvas 元素本身拥有属性 width、height，不推荐使用 css 控制，会引起形变、失真，这是因为 canvas 元素实际上有两套尺寸：</p>
<ul>
<li>元素本身大小：由 CSS 控制</li>
<li>元素绘制表面的大小：CSS 无法控制</li>
</ul>
<p>canvas 的 width、height 属性会同时修改了该元素本身的大小和元素绘制表面的大小，而 CSS 修改则只修改元素本身大小，绘制面大小不变，浏览器会对绘图面进行缩放，从而产生了失真。</p>
<h2 id="四-canvas-元素-api"><a class="header" href="#四-canvas-元素-api">四 canvas 元素 API</a></h2>
<p>canvas 元素只提供了 2 个属性，3 个方法：</p>
<ul>
<li>width、height：元素的宽高。是个非负整数，不能给数值添加 px 后缀</li>
<li>getContext()：返回与该 canvas 元素相关的绘图环境对象。每个 canvas 元素均有且有一个这样的环境对象。</li>
<li>toDataURL(type, quality)：返回数据地址，可以将其设置为 img 元素的 src 属性值。type 表示图像类型，如 image/jpeg 或者 image/png(默认)。第二个参数是 0~1.0 之间的 double 值，表示 JPEG 图像的显示质量。</li>
<li>toBlob(callback, type, quality...)：创建一个用于表示此 canvas 元素图像文件的 Blob。浏览器会调用参数一（this 为 blob）。</li>
</ul>
<h2 id="五-绘图环境"><a class="header" href="#五-绘图环境">五 绘图环境</a></h2>
<p>canvas 元素仅仅是个容器，其内部的绘图环境真正提供了全部的绘制功能，包括：</p>
<ul>
<li>2d 绘图环境：getContext('2d') 获取。</li>
<li>3d 绘图环境：基于 WebGL 实现。</li>
</ul>
<h2 id="六-绘图原理"><a class="header" href="#六-绘图原理">六 绘图原理</a></h2>
<p>canvas 绘制图形步骤：</p>
<ul>
<li>1、将图形/图像绘制到一个透明位图中。绘制时遵从当前的填充模式、描边模式、线条样式。</li>
<li>2、将图形/图像的每一个像素颜色分量，乘以绘图环境对象的 globalAlpha 属性值。</li>
<li>3、将绘有图形/图像的位图，合成到当前经过剪辑区剪辑且过的 canvas 位图上，在曹组时使用当前的合成操作符（composition operator）。</li>
</ul>
<p>如果要启用引用效果，则会在 1、3 步骤之间加入：</p>
<ul>
<li>将图形/图像的阴影绘制到另一幅位图中，在绘制时使用当前绘图环境的阴影设定</li>
<li>将阴影中每一个像素的 alpha 分量乘以绘图环境对象的 globalAlpha 属性值</li>
<li>将绘有阴影的位图与经过剪辑区域剪切过的 canvas 进行图像和成，操作时使用当前的合成模式参数</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="02-2d-绘图环境属性"><a class="header" href="#02-2d-绘图环境属性">02-2d 绘图环境属性</a></h1>
<h2 id="一-api-简介"><a class="header" href="#一-api-简介">一 API 简介</a></h2>
<h3 id="11-api-简介"><a class="header" href="#11-api-简介">1.1 API 简介</a></h3>
<p>2D 绘图上下文提供了绘制 2D 图形的方法，包括矩形、弧形和路径。 2D 上下文的坐标原点(0, 0)在 <code>&lt;canvas&gt;</code> 元素的左上角。所有坐标值都相对于该点计算，因此 x 坐标向右增长， y 坐标向下增长。默认情况下， width 和 height 表示两个方向上像素的最大值。</p>
<p>2d 绘图环境的具体属性的用法，可以查看网止：[https://developer.mozilla.org/zh-cn/docs/Web/API/CanvasRenderingContext2D]</p>
<h3 id="12-2d-绘图环境成员"><a class="header" href="#12-2d-绘图环境成员">1.2 2D 绘图环境成员</a></h3>
<p>2D 绘图环境中的成员：</p>
<ul>
<li>canvas：指向绘图换将的 canvas 对象，一般可以通过该成员获取 canvas 的宽高，如：<code>ctx.canvas.width</code></li>
<li>fillstyle：指定绘图环境在后续的图形填充中使用的颜色、渐变色、图案</li>
<li>font：fillText() 与 strokeText() 时使用的字体类型</li>
<li>globalAlpha：全局透明设定，值为 0~1.0（透明到完全不透明），浏览器会将每个像素的 alpha 值与该值相乘</li>
<li>globalCompsiteOperation：决定浏览器将某个物体绘制在其他物体之上时的绘制方式</li>
<li>lineCap：绘制线段端点的方式，包括：butt(默认)、round、square</li>
<li>lineWidth：线段像素宽度，默认值为 1.0</li>
<li>lineJoin：绘制两条线段相交时，焦点的绘制方式，包括：mitter（默认）、bevel、round</li>
<li>miterLimit：绘制 miter 形式线段的方式</li>
<li>shadowBlur：阴影的延伸度。值越高，阴影延伸越远，默认值为 0</li>
<li>shadowColor：阴影的颜色</li>
<li>shadowOffsetX：指定阴影效果水平方向偏移量，单位为像素</li>
<li>shadowOffsetY：指定阴影效果垂直方向偏移量，单位为像素</li>
<li>strokeStyle：路径描边时的绘制风格，值可设定为：颜色、渐变色、图案</li>
<li>textAlign：以 fillText()、strokeText() 绘制时，文本的水平对齐方式</li>
<li>textBaseline：以 fillText()、strokeText() 绘制时，文本的垂直对齐方式</li>
</ul>
<h3 id="13-cavans-状态的保存与恢复"><a class="header" href="#13-cavans-状态的保存与恢复">1.3 cavans 状态的保存与恢复</a></h3>
<p>canvas 提供了 <code>save()</code>、<code>restore()</code> 两个方法，用于保存、恢复当前 canvas 绘图环境的所有属性。其实现原理的是 canvas 的状态被维护在了一个栈中。</p>
<h2 id="二-基础图形绘制"><a class="header" href="#二-基础图形绘制">二 基础图形绘制</a></h2>
<h3 id="21-填充和描边"><a class="header" href="#21-填充和描边">2.1 填充和描边</a></h3>
<p>2D 上下文有两个基本绘制操作：</p>
<ul>
<li>填充：以指定样式（颜色、渐变或图像）自动填充形状</li>
<li>描边：为图形边界着色</li>
</ul>
<p>填充和描边的显示效果取决于两个属性：fillStyle 和 strokeStyle。这两个属性可以是字符串、渐变对象或图案对象，默认值都为&quot;#000000&quot;。字符串表示颜色值，可以是 CSS 支持的任意格式：名称、十六进制代码、 rgb、 rgba、 hsl 或 hsla，比如：</p>
<pre><code class="language-js">const context = document.querySelector('#container').getContext('2d')
context.strokeStyle = 'red'
context.fillStyle = '#0000ff'
</code></pre>
<h3 id="22-绘制矩形"><a class="header" href="#22-绘制矩形">2.2 绘制矩形</a></h3>
<p>矩形是唯一一个可以直接在 2D 绘图上下文中绘制的形状，有三个相关绘制方法，这些方法都接收 4 个参数：矩形 x 坐标、矩形 y 坐标、矩形宽度和矩形高度，且参数的单位都是像素：</p>
<ul>
<li>填充：<code>fillRect(double x, double y, double w, double h)</code>，对应绘制的颜色 <code>ctx.fillStyle = 'green'</code></li>
<li>描边：<code>strokeRect(double x, double y, double w, double h)</code>，对应绘制的颜色 <code>ctx.strokStyle = 'green'</code></li>
<li>清除：<code>clearRect(double x, double y, double w, double h)</code>，擦除画布中某个区域，使其变透明</li>
</ul>
<p>绘制两个拥有填充色的矩形示例：</p>
<pre><code class="language-js">// 绘制红色矩形
context.fillStyle = '#ff0000'
context.fillRect(10, 10, 50, 50)

// 绘制半透明蓝色矩形
context.fillStyle = 'rgba(0,0,255,0.5)'
context.fillRect(30, 30, 50, 50)
</code></pre>
<p>绘制两个只有描边色的矩形示例：</p>
<pre><code class="language-js">// 绘制红色轮廓的矩形
context.strokeStyle = '#ff0000'
context.strokeRect(10, 10, 50, 50)
// 绘制半透明蓝色轮廓的矩形
context.strokeStyle = 'rgba(0,0,255,0.5)'
context.strokeRect(30, 30, 50, 50)
</code></pre>
<p>贴士：颜色值默认都是不透明的黑色（opaque），其值可以是任意 CSS 颜色字符串，如：<code>rgba(0, 0, 255, 0.5)</code>。</p>
<p>描边宽度由 lineWidth 属性控制，它可以是任意整数值。类似地， lineCap 属性控制线条端点的形状［ &quot;butt&quot;（平头）、 &quot;round&quot;（出圆头）或&quot;square&quot;（出方头）］，而 lineJoin 属性控制线条交点的形状［ &quot;round&quot;（圆转）、 &quot;bevel&quot;（取平）或&quot;miter&quot;（出尖）］。</p>
<h3 id="23-绘制路径"><a class="header" href="#23-绘制路径">2.3 绘制路径</a></h3>
<p>通过路径可以创建复杂的形状和线条，比如绘制路径可以实现一个不规则的多边形，不过要注意路径都是闭合的：</p>
<pre><code class="language-js">// 必须创建一个路径表示要开始绘制新路径
ctx.beginPath()

// 描述绘制点
ctx.moveTo(100, 100)
// 描述行进的路径
ctx.lineTo(200, 200)
ctx.lineTo(400, 180)
ctx.lineTo(380, 50)

// 闭合路径：绘制一条返回起点的线
ctx.closePath()

// 绘制该图形
ctx.strokeStyle = 'red'
ctx.stroke() // 绘制不规则图形
// 填充该图形
ctx.fillStyle = 'green'
ctx.fill()
</code></pre>
<p>调用开始绘制后常用的绘制路径方法有：</p>
<ul>
<li>arc(x, y, radius, startAngle, endAngle, counterclockwise)：以坐标(x, y)为圆心，以 radius 为半径绘制一条弧线，起始角度为 startAngle，结束角度为 endAngle（都是弧度）。最后一个参数 counterclockwise 表示是否逆时针计算起始角度和结束角度（默认为顺时针）。</li>
<li>arcTo(x1, y1, x2, y2, radius)：以给定半径 radius，经由(x1, y1)绘制一条从上一点到(x2, y2)的弧线。</li>
<li>bezierCurveTo(c1x, c1y, c2x, c2y, x, y)：以(c1x, c1y)和(c2x, c2y)为控制点，绘制一条从上一点到(x, y)的弧线（三次贝塞尔曲线）。</li>
<li>lineTo(x, y)：绘制一条从上一点到(x, y)的直线。</li>
<li>moveTo(x, y)：不绘制线条，只把绘制光标移动到(x, y)。</li>
<li>quadraticCurveTo(cx, cy, x, y)：以(cx, cy)为控制点，绘制一条从上一点到(x, y)的弧线（二次贝塞尔曲线）。</li>
<li>rect(x, y, width, height)：以给定宽度和高度在坐标点(x, y)绘制一个矩形。这个方法与 strokeRect()和 fillRect()的区别在于，它创建的是一条路径，而不是独立的图形</li>
</ul>
<p>绘制圆弧示例：</p>
<pre><code class="language-js">// 创建一个路径
ctx.beginPath()
// 描述绘制点：200,200 为起始坐标，100 为半径，0,1 为弧度，默认值 false 为顺时针
ctx.arc(200, 200, 0, 1, 100, false) // 0,1 改为  0 2*Math.PI 则为 1 个圆
// 绘制该图形
ctx.strokeStyle = 'red'
ctx.stroke() // 绘制不规则图形
</code></pre>
<p>在某一时刻，canvas 只能有一条路径存在，称为“当前路径”（currentpath），不过这条路径内可以包含许多子路（subpath）：</p>
<pre><code class="language-js">ctx.beginPath()
ctx.rect(10, 10, 100, 100)
ctx.stroke()

ctx.beginPath()
ctx.rect(50, 50, 100, 100)
ctx.stroke()
</code></pre>
<p>如果当前路径是循环的，或者包含多个相交的子路径，那么当 fill() 方法被调用时，应该判断如何对当前路径进行填充，即“非零环绕规则”：假定区域内有一条足够长的线段，其终点完全在路径范围之外，此时在一个值为 0 的计数器，每当这条线段与路径上的线相交，就会改变其值，比如与路径顺时针相交，则加 1，与路径逆时针相交则减 1，若计数器始终不为 0，则此区域就在路径里面，调用 fill() 时，浏览器会对其进行填充，如果其最终值为 0，那么此区域不在路径内部，浏览器不会对齐进行填充。</p>
<p>isPointInPath()方法用于确定指定的点是否在路径上，可以在关闭路径前随时调用，该方法接收 x 轴和 y 轴坐标作为参数：</p>
<pre><code class="language-js">if (context.isPointInPath(100, 100)) {
  alert('Point (100, 100) is in the path.')
}
</code></pre>
<h3 id="24-绘制文本"><a class="header" href="#24-绘制文本">2.4 绘制文本</a></h3>
<p>有两个绘制文本的方法，他们都接收 4 个参数：要绘制的字符串、 x 坐标、 y 坐标和可选的最大像素宽度：</p>
<ul>
<li>fillText()：使用 fillStyle 属性绘制文本，是经常使用的方法，因为它模拟了在网页中渲染文本</li>
<li>strokeText()：使用 strokeStyle 属性</li>
</ul>
<p>这两个方法最终绘制的结果都取决于以下 3 个属性：</p>
<ul>
<li>font：以 CSS 语法指定的字体样式、大小、字体族等，比如&quot;10px Arial&quot;。</li>
<li>textAlign：指定文本的对齐方式，可能的值包括&quot;start&quot;、 &quot;end&quot;、 &quot;left&quot;、 &quot;right&quot;和&quot;center&quot;。推荐使用&quot;start&quot;和&quot;end&quot;，不使用&quot;left&quot;和&quot;right&quot;，因为前者无论在从左到右书写的语言还是从右到左书写的语言中含义都更明确。</li>
<li>textBaseLine ： 指 定 文 本 的 基 线 ， 可 能 的 值 包 括 &quot;top&quot; 、 &quot;hanging&quot; 、 &quot;middle&quot; 、&quot;alphabetic&quot;、 &quot;ideographic&quot;和&quot;bottom&quot;。</li>
</ul>
<p>这些属性都有相应的默认值，因此没必要每次绘制文本时都设置它们。</p>
<p>示例：</p>
<pre><code class="language-js">context.font = 'bold 14px Arial'
context.textAlign = 'center'
context.textBaseline = 'middle'
context.fillText('12', 100, 20)
</code></pre>
<p>fillText()和 strokeText()方法的第四个参数，即文本的最大宽度是可选的，如果调用 fillText()和 strokeText()时提供了此参数，但要绘制的字符串超出了最大宽度限制，则文本会以正确的字符高度绘制，这时字符会被水平压缩，以达到限定宽度。</p>
<p>由于绘制文本很复杂，特别是想把文本绘制到特定区域的时候，因此 2D 上下文提供了用于辅助确定文本大小的 measureText()方法。这个方法接收一个参数，即要绘制的文本，然后返回一个 TextMetrics 对象。这个返回的对象目前只有一个属性 width，不过将来应该会增加更多度量指标。</p>
<p>measureText()方法使用 font、 textAlign 和 textBaseline 属性当前的值计算绘制指定文本后的大小。例如，假设要把文本&quot;Hello world!&quot;放到一个 140 像素宽的矩形中，可以使用以下代码，从 100 像素的字体大小开始计算，不断递减，直到文本大小合适：</p>
<pre><code class="language-js">let fontSize = 100
context.font = fontSize + 'px Arial'
while (context.measureText('Hello world!').width &gt; 140) {
  fontSize--
  context.font = fontSize + 'px Arial'
}
context.fillText('Hello world!', 10, 10)
context.fillText('Font size is ' + fontSize + 'px', 10, 50)
</code></pre>
<h3 id="25-绘制图像"><a class="header" href="#25-绘制图像">2.5 绘制图像</a></h3>
<p>如果想把现有图像绘制到画布上，可以使用 drawImage()方法。这个方法可以接收 3 组不同的参数，并产生不同的结果。最简单的调用是传入一个 HTML 的 <code>&lt;img&gt;</code> 元素，以及表示绘制目标的 x 和 y 坐标，结果是把图像绘制到指定位置。比如：</p>
<pre><code class="language-js">let image = document.images[0]
// 在画布上的坐标(10, 10)处将它绘制了出来
context.drawImage(image, 10, 10)
</code></pre>
<p>以上代码绘制出来的图像与原来的图像一样大。如果想改变所绘制图像的大小，可以再传入另外两个参数：目标宽度和目标高度。这里的缩放只影响绘制的图像，不影响上下文的变换矩阵。比如下面的例子：</p>
<pre><code class="language-js">// 图像会缩放到 20 像素宽、 30 像素高
context.drawImage(image, 50, 10, 20, 30)
</code></pre>
<p>还可以只把图像绘制到上下文中的一个区域，此时需要给 drawImage()提供 9 个参数：要绘制的图像、源图像 x 坐标、源图像 y 坐标、源图像宽度、源图像高度、目标区域 x 坐标、目标区域 y 坐标、目标区域宽度和目标区域高度。这个重载后的 drawImage()方法可以实现最大限度的控制，比如：</p>
<pre><code class="language-js">// 原始图像中只有一部分会绘制到画布上。这一部分从(0, 10)开始， 50 像素宽、 50 像素高。
// 而绘制到画布上时，会从(0, 100)开始，变成 40 像素宽、 60 像素高。
context.drawImage(image, 0, 10, 50, 50, 0, 100, 40, 60)
</code></pre>
<p>第一个参数除了可以是 HTML 的 <code>&lt;img&gt;</code> 元素，还可以是另一个 <code>&lt;canvas&gt;</code> 元素，这样就会把另一个
画布的内容绘制到当前画布上。</p>
<p>结合其他一些方法， drawImage()方法可以方便地实现常见的图像操作。操作的结果可以使用 toDataURL()方法获取。不过有一种情况例外：如果绘制的图像来自其他域而非当前页面，则不能获取其数据。此时，调用 toDataURL()将抛出错误。比如，如果来自 www.demo1.com 的页面上绘制的是来自 www.demo2.com 的图像，则上下文就是“脏的”，获取数据时会抛出错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="022-2d-绘图环境-变换阴影渐变"><a class="header" href="#022-2d-绘图环境-变换阴影渐变">02.2-2d 绘图环境-变换、阴影、渐变</a></h1>
<h2 id="一-变换"><a class="header" href="#一-变换">一 变换</a></h2>
<h3 id="11-变换示例"><a class="header" href="#11-变换示例">1.1 变换示例</a></h3>
<p>上下文变换可以操作绘制在画布上的图像。在创建绘制上下文时，会以默认值初始化变换矩阵，从而让绘制操作如实应用到绘制结果上。对绘制上下文应用变换，可以导致以不同的变换矩阵应用绘制操作，从而产生不同的结果。</p>
<p>以下方法可用于改变绘制上下文的变换矩阵：</p>
<ul>
<li>rotate(angle)：围绕原点把图像旋转 angle 弧度。</li>
<li>scale(scaleX, scaleY)：通过在 x 轴乘以 scaleX、在 y 轴乘以 scaleY 来缩放图像。 scaleX 和 scaleY 的默认值都是 1.0。</li>
<li>translate(x, y)：把原点移动到(x, y)。执行这个操作后，坐标(0, 0)就会变成(x, y)。</li>
<li>transform(m1_1, m1_2, m2_1, m2_2, dx, dy)：像下面这样通过矩阵乘法直接修改矩阵。
<pre><code class="language-txt">m1_1 m1_2 dx
m2_1 m2_2 dy
0 0 1
</code></pre>
</li>
<li>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)：把矩阵重置为默认值，再以传入的参数调用 transform()。</li>
</ul>
<p>绘制表针示例：</p>
<pre><code class="language-js">// 创建路径
context.beginPath()
// 绘制外圆
context.arc(100, 100, 99, 0, 2 * Math.PI, false)
// 绘制内圆
context.moveTo(194, 100)
context.arc(100, 100, 94, 0, 2 * Math.PI, false)
// 移动原点到表盘中心
context.translate(100, 100)
// 旋转表针
context.rotate(1)
// 绘制分针
context.moveTo(0, 0)
context.lineTo(0, -85)
// 绘制时针
context.moveTo(0, 0)
context.lineTo(-65, 0)
// 描画路径
context.stroke()
</code></pre>
<h3 id="12-变换状态保存"><a class="header" href="#12-变换状态保存">1.2 变换状态保存</a></h3>
<p>变换以及 fillStyle 和 strokeStyle 属性，会一直保留在上下文中，直到再次修改它们。虽然没有办法明确地将所有值都重置为默认值，但有两个方法可以帮我们跟踪变化。如果想着什么时候再回到当前的属性和变换状态，可以调用 save()方法。调用这个方法后，所有这一时刻的设置会被放到一个暂存栈中。保存之后，可以继续修改上下文。而在需要恢复之前的上下文时，可以调用 restore()方法。这个方法会从暂存栈中取出并恢复之前保存的设置。多次调用 save()方法可以在暂存栈中存储多套设置，然后通过 restore()可以系统地恢复。</p>
<pre><code class="language-js">context.fillStyle = '#ff0000'
context.save()
context.fillStyle = '#00ff00'
context.translate(100, 100)
context.save()
context.fillStyle = '#0000ff'
context.fillRect(0, 0, 100, 200) // 在(100, 100)绘制蓝色矩形
context.restore()
context.fillRect(10, 10, 100, 200) // 在(100, 100)绘制绿色矩形
context.restore()
context.fillRect(0, 0, 100, 200) // 在(0, 0)绘制红色矩形
</code></pre>
<p>注意， save()方法只保存应用到绘图上下文的设置和变换，不保存绘图上下文的内容。</p>
<h2 id="二-阴影"><a class="header" href="#二-阴影">二 阴影</a></h2>
<p>2D 上下文可以根据以下属性的值自动为已有形状或路径生成阴影。</p>
<ul>
<li>shadowColor： CSS 颜色值，表示要绘制的阴影颜色，默认为黑色。</li>
<li>shadowOffsetX：阴影相对于形状或路径的 x 坐标的偏移量，默认为 0。</li>
<li>shadowOffsetY：阴影相对于形状或路径的 y 坐标的偏移量，默认为 0。</li>
<li>shadowBlur：像素，表示阴影的模糊量。默认值为 0，表示不模糊。</li>
</ul>
<p>这些属性都可以通过 context 对象读写。只要在绘制图形或路径前给这些属性设置好适当的值，阴影就会自动生成：</p>
<pre><code class="language-js">// 设置阴影
context.shadowOffsetX = 5
context.shadowOffsetY = 5
context.shadowBlur = 4
context.shadowColor = 'rgba(0, 0, 0, 0.5)'
// 绘制红色矩形
context.fillStyle = '#ff0000'
context.fillRect(10, 10, 50, 50)
// 绘制蓝色矩形
context.fillStyle = 'rgba(0,0,255,1)'
context.fillRect(30, 30, 50, 50)
</code></pre>
<h2 id="三-渐变"><a class="header" href="#三-渐变">三 渐变</a></h2>
<h3 id="30-渐变的基础使用"><a class="header" href="#30-渐变的基础使用">3.0 渐变的基础使用</a></h3>
<p>要创建一个新的线性渐变，可以调用上下文的 createLinearGradient()方法。这个方法接收 4 个参数：起点 x 坐标、起点 y 坐标、终点 x 坐标和终点 y 坐标。调用之后，该方法会以指定大小创建一个新的 CanvasGradient 实例表示渐变。</p>
<p>有了 gradient 对象后，接下来要使用 addColorStop()方法为渐变指定色标。这个方法接收两个参数：色标位置和 CSS 颜色字符串。色标位置通过 0 ～ 1 范围内的值表示， 0 是第一种颜色， 1 是最后一种颜色。比如：</p>
<pre><code class="language-js">// 在画布上从(30, 30)到(70, 70)绘制一个渐变
let gradient = context.createLinearGradient(30, 30, 70, 70)
gradient.addColorStop(0, 'white')
gradient.addColorStop(1, 'black')
</code></pre>
<p>可以把 gradient 对象赋值给 fillStyle 或 strokeStyle 属性，从而以渐变填充或描画绘制的图形：</p>
<pre><code class="language-js">// 绘制红色矩形
context.fillStyle = '#ff0000'
context.fillRect(10, 10, 50, 50)
// 绘制渐变矩形
context.fillStyle = gradient
context.fillRect(30, 30, 50, 50)
</code></pre>
<p>如果矩形没有绘制到渐变的范围内，则只会显示部分渐变。比如：</p>
<pre><code class="language-js">context.fillStyle = gradient
context.fillRect(50, 50, 50, 50)
</code></pre>
<p>canvas 元素支持线性渐变（linear）和 径向渐变（radial），fillStyle 和 strokStyle 可以指定渐变色与图案。</p>
<h3 id="31-线性渐变"><a class="header" href="#31-线性渐变">3.1 线性渐变</a></h3>
<p>3.0 示例代码执行之后绘制的矩形只有左上角有一部分白色。这是因为矩形的起点在渐变的中间，此时颜色的过渡几乎要完成了。结果矩形大部分地方是黑色的，因为渐变不会重复。保持渐变与形状的一致非常重要，有时候可能需要写个函数计算相应的坐标。比如：</p>
<pre><code class="language-js">function createRectLinearGradient(context, x, y, width, height) {
  return context.createLinearGradient(x, y, x + width, y + height)
}
</code></pre>
<p>这个函数会基于起点的 x、 y 坐标和传入的宽度、高度创建渐变对象，之后调用 fillRect()方法时可以使用相同的值：</p>
<pre><code class="language-js">let gradient = createRectLinearGradient(context, 30, 30, 50, 50)
gradient.addColorStop(0, 'white')
gradient.addColorStop(1, 'black')
// 绘制渐变矩形
context.fillStyle = gradient
context.fillRect(30, 30, 50, 50)
</code></pre>
<p>计算坐标是使用画布时重要而复杂的问题。使用类似 createRectLinearGradient()这样的辅助函数能让计算坐标简单一些。</p>
<h3 id="32-径向渐变"><a class="header" href="#32-径向渐变">3.2 径向渐变</a></h3>
<p>径向渐变也称为放射渐变，径向渐变（或放射性渐变）要使用 createRadialGradient()方法来创建。这个方法接收 6 个参数，分别对应两个圆形圆心的坐标和半径。前 3 个参数指定起点圆形中心的 x、 y 坐标和半径，后 3 个参数指定终点圆形中心的 x、 y 坐标和半径。在创建径向渐变时，可以把两个圆形想象成一个圆柱体的两个圆形表面。把一个表面定义得小一点，另一个定义得大一点，就会得到一个圆锥体。然后，通过移动两个圆形的圆心，就可以旋转这个圆锥体。要创建起点圆心在形状中心并向外扩散的径向渐变，需要将两个圆形设置为同心圆。比如，要在前面例子中矩形的中心创建径向渐变，则渐变的两个圆形的圆心都必须设置为(55, 55)。这是因为矩形的起点是(30, 30)，终点是(80, 80)。代码如下：</p>
<pre><code class="language-js">let gradient = context.createRadialGradient(55, 55, 10, 55, 55, 30)
gradient.addColorStop(0, 'white')
gradient.addColorStop(1, 'black')
// 绘制红色矩形
context.fillStyle = '#ff0000'
context.fillRect(10, 10, 50, 50)
// 绘制渐变矩形
context.fillStyle = gradient
context.fillRect(30, 30, 50, 50)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="023-2d-绘图环境-图片基础操作"><a class="header" href="#023-2d-绘图环境-图片基础操作">02.3-2d 绘图环境-图片基础操作</a></h1>
<h2 id="一-canvas-导出图片"><a class="header" href="#一-canvas-导出图片">一 canvas 导出图片</a></h2>
<p>toDataURL()方法导出 <code>&lt;canvas&gt;</code> 元素上的图像。这个方法接收一个参数：要生成图像的 MIME 类型（与用来创建图形的上下文无关）。例如，要从画布上导出一张 PNG 格式的图片，可以这样做：</p>
<pre><code class="language-js">let drawing = document.getElementById('drawing')
// 确保浏览器支持&lt;canvas&gt;
if (drawing.getContext) {
  // 取得图像的数据 URI
  let imgURI = drawing.toDataURL('image/png')
  // 显示图片
  let image = document.createElement('img')
  image.src = imgURI
  document.body.appendChild(image)
}
</code></pre>
<h2 id="二-canvas-使用图案填充描边"><a class="header" href="#二-canvas-使用图案填充描边">二 canvas 使用图案填充描边</a></h2>
<p>canvas 元素也可以使用图案来对图形、文字进行描边、填充，图案可以是：image 元素、canvas 元素、video 元素。</p>
<pre><code class="language-js">let image = new Image()
image.src = 'demo.jpeg'
image.onload = function () {
  //参数 可以是：repeat、repeat-x，repeat-y，no-repeat
  let pattern = ctx.createPattern(image, 'repeat')
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  ctx.fillStyle = pattern
  ctx.fillRect(0, 0, canvas.width, canvas.height)
  ctx.fill()
}
</code></pre>
<p>传给 createPattern()方法的第一个参数也可以是 <code>&lt;video&gt;</code> 元素或者另一个 <code>&lt;canvas&gt;</code> 元素。</p>
<h2 id="三-获取图像数据"><a class="header" href="#三-获取图像数据">三 获取图像数据</a></h2>
<p>getImageData()方法可以获取原始图像数据。这个方法接收 4 个参数：要取得数据中第一个像素的左上角坐标和要取得的像素宽度及高度。例如，要从(10, 5)开始取得 50 像素宽、 50 像素高的区域对应的数据，可以这样写：</p>
<pre><code class="language-js">let imageData = context.getImageData(10, 5, 50, 50)
</code></pre>
<p>返回的对象是一个 ImageData 的实例。每个 ImageData 对象都包含 3 个属性： width、 height 和 data，其中， data 属性是包含图像的原始像素信息的数组。每个像素在 data 数组中都由 4 个值表示，分别代表红、绿、蓝和透明度值。换句话说，第一个像素的信息包含在第 0 到第 3 个值中，比如：</p>
<pre><code class="language-js">let data = imageData.data,
  red = data[0],
  green = data[1],
  blue = data[2],
  alpha = data[3]
</code></pre>
<p>这个数组中的每个值都在 0~255 范围内（包括 0 和 255）。对原始图像数据进行访问可以更灵活地操作图像。例如，通过更改图像数据可以创建一个简单的灰阶过滤器：</p>
<pre><code class="language-js">let image = document.images[0],
  imageData,
  data,
  i,
  len,
  average,
  red,
  green,
  blue,
  alpha

// 绘制图像
context.drawImage(image, 0, 0)
// 取得图像数据
imageData = context.getImageData(0, 0, image.width, image.height)
data = imageData.data
for (i = 0, len = data.length; i &lt; len; i += 4) {
  red = data[i]
  green = data[i + 1]
  blue = data[i + 2]
  alpha = data[i + 3]
  // 取得 RGB 平均值
  average = Math.floor((red + green + blue) / 3)
  // 设置颜色，不管透明度
  data[i] = average
  data[i + 1] = average
  data[i + 2] = average
}

// 将修改后的数据写回 ImageData 并应用到画布上显示出来
imageData.data = data
context.putImageData(imageData, 0, 0)
</code></pre>
<p>这个例子首先在画布上绘制了一个图像，然后又取得了其图像数据。 for 循环遍历了图像数据中的每个像素，注意每次循环都要给 i 加上 4。每次循环中取得红、绿、蓝的颜色值，计算出它们的平均值。然后再把原来的值修改为这个平均值，实际上相当于过滤掉了颜色信息，只留下类似亮度的灰度信息。之后将 data 数组重写回 imageData 对象。最后调用 putImageData()方法，把图像数据再绘制到画布上。结果就得到了原始图像的黑白版。</p>
<p>当然，灰阶过滤只是基于原始像素值可以实现的其中一种操作。要了解基于原始图像数据还可以实现哪些操作，可以参考 Ilmari Heikkinen 的文章“Making Image Filters with Canvas”。</p>
<p>注意 只有在画布没有加载跨域内容时才可以获取图像数据。如果画布上绘制的是跨域内容，则尝试获取图像数据会导致 JavaScript 报错。</p>
<h2 id="三-图形合成"><a class="header" href="#三-图形合成">三 图形合成</a></h2>
<p>2D 上下文中绘制的所有内容都会应用两个属性： globalAlpha 和 globalComposition Operation，其中， globalAlpha 属性是一个范围在 0~1 的值（包括 0 和 1），用于指定所有绘制内容的透明度，默认值为 0。如果所有后来的绘制都需要使用同样的透明度，那么可以将 globalAlpha 设置为适当的值，执行绘制，然后再把 globalAlpha 设置为 0。比如：</p>
<pre><code class="language-js">// 绘制红色矩形
context.fillStyle = '#ff0000'
context.fillRect(10, 10, 50, 50)
// 修改全局透明度
context.globalAlpha = 0.5
// 绘制蓝色矩形
context.fillStyle = 'rgba(0,0,255,1)'
context.fillRect(30, 30, 50, 50)
// 重置
context.globalAlpha = 0
</code></pre>
<p>在这个例子中，蓝色矩形是绘制在红色矩形上面的。因为在绘制蓝色矩形前 globalAlpha 被设置成了 0.5，所以蓝色矩形就变成半透明了，从而可以透过它看到下面的红色矩形。</p>
<p>globalCompositionOperation 属性表示新绘制的形状如何与上下文中已有的形状融合。这个属性是一个字符串，可以取下列值。</p>
<ul>
<li>source-over：默认值，新图形绘制在原有图形上面。</li>
<li>source-in：新图形只绘制出与原有图形重叠的部分，画布上其余部分全部透明。</li>
<li>source-out：新图形只绘制出不与原有图形重叠的部分，画布上其余部分全部透明。</li>
<li>source-atop：新图形只绘制出与原有图形重叠的部分，原有图形不受影响。</li>
<li>destination-over： 新图形绘制在原有图形下面，重叠部分只有原图形透明像素下的部分可见。</li>
<li>destination-in：新图形绘制在原有图形下面，画布上只剩下二者重叠的部分，其余部分完全透明。</li>
<li>destination-out：新图形与原有图形重叠的部分完全透明，原图形其余部分不受影响。</li>
<li>destination-atop：新图形绘制在原有图形下面，原有图形与新图形不重叠的部分完全透明。</li>
<li>lighter：新图形与原有图形重叠部分的像素值相加，使该部分变亮。</li>
<li>copy：新图形将擦除并完全取代原有图形。</li>
<li>xor：新图形与原有图形重叠部分的像素执行“异或”计算。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">// 绘制红色矩形
context.fillStyle = '#ff0000'
context.fillRect(10, 10, 50, 50)
// 设置合成方式
context.globalCompositeOperation = 'destination-over'
// 绘制蓝色矩形
context.fillStyle = 'rgba(0,0,255,1)'
context.fillRect(30, 30, 50, 50)
</code></pre>
<p>虽然后绘制的蓝色矩形通常会出现在红色矩形上面， 但将 globalCompositeOperation 属性的值修改为&quot;destination-over&quot;意味着红色矩形会出现在蓝色矩形上面。</p>
<p>使用 globalCompositeOperation 属性时，一定记得要在不同浏览器上进行测试。不同浏览器在实现这些选项时可能存在差异。这些操作在 Safari 和 Chrome 中仍然有些问题，可以参考 MDN 文档上的 CanvasRenderingContext2D.globalCompositeOperation，比较它们与 IE 或 Firefox 渲染的差异。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-图形绘制---线段绘制"><a class="header" href="#031-图形绘制---线段绘制">03.1-图形绘制 - 线段绘制</a></h1>
<h2 id="一-绘制基础线段"><a class="header" href="#一-绘制基础线段">一 绘制基础线段</a></h2>
<p>在 canvas 中绘制 2 条线段代码示例：</p>
<pre><code class="language-js">// 将线段宽度设置为 1 像素
ctx.lineWidth = 1

// 绘制第一条线段
ctx.beginPath()
ctx.moveTo(50, 10) // 起点
ctx.lineTo(450, 10) // 绘制到终点
ctx.stroke() // 创建路径之后必须调用 stroke() 方法

// 绘制第二条线段
ctx.beginPath()
ctx.moveTo(50.5, 50.5)
ctx.lineTo(450.5, 50.5)
ctx.stroke()
</code></pre>
<p>贴士：moveTo() 方法不会清除子路径，而 lineTo() 则会将指定的点加入子路径中。若当前路径没有子路径，则 lineTo() 与 moveTo() 一致。</p>
<h2 id="二-线段像素边界"><a class="header" href="#二-线段像素边界">二 线段像素边界</a></h2>
<p>在 1.1 的案例开始处，已经设置了线段的像素宽为 1，但是第一条线宽度却占据了 2 个像素，这是因为如果在像素边界绘制一条 1 像素宽的垂直线段，则 canvas 的绘图环境对象会试着将半个像素画在边界中线的右边，将另外半个像素花在边界中线的左边。</p>
<p>如果线段绘制在某 2 个像素之间的像素中，则不会出现延伸现象。</p>
<p><img src="%E9%99%84%E5%BD%95-Canvas/../images/canvas/01.svg" alt="线段边界" /></p>
<h2 id="三-绘制网格"><a class="header" href="#三-绘制网格">三 绘制网格</a></h2>
<p>基于 canvas 的边界原理，现在可以实现一个线宽为 0.5 像素的网格：</p>
<pre><code class="language-js">const drawGrid = (ctx, color, lineWidth, stepX, stepY) =&gt; {
  ctx.strokeStyle = color
  ctx.lineWidth = lineWidth

  for (let i = stepX + 0.5; i &lt; ctx.canvas.width; i += stepX) {
    ctx.beginPath()
    ctx.moveTo(i, 0)
    ctx.lineTo(i, ctx.canvas.height)
    ctx.stroke()
  }

  for (let i = stepY + 0.5; i &lt; ctx.canvas.height; i += stepY) {
    ctx.beginPath()
    ctx.moveTo(0, i)
    ctx.lineTo(ctx.canvas.width, i)
    ctx.stroke()
  }
}

drawGrid(ctx, 'yellowgreen', 0.5, 10, 10)
</code></pre>
<h2 id="四-绘制坐标系"><a class="header" href="#四-绘制坐标系">四 绘制坐标系</a></h2>
<pre><code class="language-js">const AXIS_MARGIN = 40,
  AXIS_ORIGIN = { x: AXIS_MARGIN, y: canvas.height - AXIS_MARGIN },
  AXIS_TOP = AXIS_MARGIN,
  AXIS_RIGHT = canvas.width - AXIS_MARGIN,
  HORIZONTAL_TICK_SPACING = 10,
  VERTICAL_TICK_SPACING = 10,
  AXIS_WIDTH = AXIS_RIGHT - AXIS_ORIGIN.x,
  AXIS_HEIGHT = AXIS_ORIGIN.y - AXIS_TOP,
  NUM_VERTICAL_TICKS = AXIS_HEIGHT / VERTICAL_TICK_SPACING,
  NUM_HORIZONTAL_TICKS = AXIS_WIDTH / HORIZONTAL_TICK_SPACING,
  TICK_WIDTH = 10,
  TICKS_LINEWIDTH = 0.5,
  TICKS_COLOR = 'navy',
  AXIS_LINEWIDTH = 1.0,
  AXIS_COLOR = 'blue'

const drawGrid = (ctx, lineWidth, color, stepx, stepy) =&gt; {
  ctx.save()

  ctx.fillStyle = 'white'
  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)

  ctx.lineWidth = lineWidth
  ctx.strokeStyle = color

  for (let i = stepx + 0.5; i &lt; ctx.canvas.width; i += stepx) {
    ctx.beginPath()
    ctx.moveTo(i, 0)
    ctx.lineTo(i, ctx.canvas.height)
    ctx.stroke()
  }

  for (let i = stepy + 0.5; i &lt; ctx.canvas.height; i += stepy) {
    ctx.beginPath()
    ctx.moveTo(0, i)
    ctx.lineTo(ctx.canvas.width, i)
    ctx.stroke()
  }

  ctx.restore()
}

const drawAxes = (ctx) =&gt; {
  ctx.save()
  ctx.strokeStyle = AXIS_COLOR
  ctx.lineWidth = AXIS_LINEWIDTH

  drawHorizontalAxis(ctx)
  drawVerticalAxis(ctx)

  ctx.lineWidth = 0.5
  ctx.lineWidth = TICKS_LINEWIDTH
  ctx.strokeStyle = TICKS_COLOR

  drawVerticalAxisTicks(ctx)
  drawHorizontalAxisTicks(ctx)

  ctx.restore()
}

const drawHorizontalAxis = (ctx) =&gt; {
  ctx.beginPath()
  ctx.moveTo(AXIS_ORIGIN.x, AXIS_ORIGIN.y)
  ctx.lineTo(AXIS_RIGHT, AXIS_ORIGIN.y)
  ctx.stroke()
}

const drawVerticalAxis = (ctx) =&gt; {
  ctx.beginPath()
  ctx.moveTo(AXIS_ORIGIN.x, AXIS_ORIGIN.y)
  ctx.lineTo(AXIS_ORIGIN.x, AXIS_TOP)
  ctx.stroke()
}

const drawVerticalAxisTicks = (ctx) =&gt; {
  let deltaY

  for (let i = 1; i &lt; NUM_VERTICAL_TICKS; ++i) {
    ctx.beginPath()

    if (i % 5 === 0) deltaX = TICK_WIDTH
    else deltaX = TICK_WIDTH / 2

    ctx.moveTo(
      AXIS_ORIGIN.x - deltaX,
      AXIS_ORIGIN.y - i * VERTICAL_TICK_SPACING
    )

    ctx.lineTo(
      AXIS_ORIGIN.x + deltaX,
      AXIS_ORIGIN.y - i * VERTICAL_TICK_SPACING
    )

    ctx.stroke()
  }
}

const drawHorizontalAxisTicks = (ctx) =&gt; {
  let deltaY

  for (let i = 1; i &lt; NUM_HORIZONTAL_TICKS; ++i) {
    ctx.beginPath()

    if (i % 5 === 0) deltaY = TICK_WIDTH
    else deltaY = TICK_WIDTH / 2

    ctx.moveTo(
      AXIS_ORIGIN.x + i * HORIZONTAL_TICK_SPACING,
      AXIS_ORIGIN.y - deltaY
    )

    ctx.lineTo(
      AXIS_ORIGIN.x + i * HORIZONTAL_TICK_SPACING,
      AXIS_ORIGIN.y + deltaY
    )

    ctx.stroke()
  }
}

drawGrid(ctx, 0.5, 'lightgray', 10, 10)
drawAxes(ctx)
</code></pre>
<h2 id="五-动态绘制"><a class="header" href="#五-动态绘制">五 动态绘制</a></h2>
<p>利用鼠标按下事件、鼠标移动坐标，可以实现动态绘制一个图形：</p>
<pre><code class="language-js">let surfaceImageData
const pos = { x: 0, y: 0 }
const rubberbandRect = {}
let isDragging = false

// 绘图监听
canvas.onmousedown = function (e) {
  isDragging = true
  e.preventDefault() // prevent cursor change

  let loc = fitCanvas(e.clientX, e.clientY)
  pos.x = loc.x
  pos.y = loc.y

  // 保存当前数据
  saveSurfaceData()
}

canvas.onmousemove = function (e) {
  if (!isDragging) {
    return
  }
  e.preventDefault() // prevent selections

  // 回放初始数据，用于清除鼠标移动中绘制的重复线条
  restoreSurfaceData()

  // 执行绘制
  let loc = fitCanvas(e.clientX, e.clientY)
  drawLine(loc)
  drawGuidewires(loc.x, loc.y)
}

canvas.onmouseup = function (e) {
  isDragging = false

  // 回放初始数据
  restoreSurfaceData()

  // 执行绘制
  let loc = fitCanvas(e.clientX, e.clientY)
  drawLine(loc)
}

// 位置算法
const fitCanvas = (x, y) =&gt; {
  const bbox = canvas.getBoundingClientRect()
  return {
    x: x - bbox.left * (canvas.width / bbox.width),
    y: y - bbox.top * (canvas.height / bbox.height),
  }
}

// 保存画布数据
const saveSurfaceData = () =&gt; {
  surfaceImageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
}
// 回放画布数据
const restoreSurfaceData = () =&gt; {
  ctx.putImageData(surfaceImageData, 0, 0)
}

// 绘图工具：线条工具
const drawLine = (loc) =&gt; {
  ctx.beginPath()
  ctx.moveTo(pos.x, pos.y)
  ctx.lineTo(loc.x, loc.y)
  ctx.stroke()
}

// 绘图工具：十字工具
const drawGuidewires = (x, y) =&gt; {
  ctx.save()
  ctx.strokeStyle = 'rgba(0,0,230,0.4)'
  ctx.lineWidth = 0.5

  // drawVerticalLine
  ctx.beginPath()
  ctx.moveTo(x + 0.5, 0)
  ctx.lineTo(x + 0.5, ctx.canvas.height)
  ctx.stroke()

  // drawHorizontalLine
  ctx.beginPath()
  ctx.moveTo(0, y + 0.5)
  ctx.lineTo(ctx.canvas.width, y + 0.5)
  ctx.stroke()

  ctx.restore()
}

// 绘图工具：擦除
const drawEraser = () =&gt; {
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  saveSurfaceData()
}
</code></pre>
<h2 id="六-线段端点"><a class="header" href="#六-线段端点">六 线段端点</a></h2>
<p>线段端点样式使用属性 lineCap 控制，默认值为 butt，即原模原样绘制，round、square 则是线段的端点添加帽子：</p>
<ul>
<li>round：端点多画一个半圆</li>
<li>suare：端点多画一个矩形</li>
</ul>
<p>两条线段连接处的拐弯称为连接点，使用 lineJoin 属性控制。miter 为默认值，接合处为一个矩形，bevel 值表示接合处为一个三角形，round 则表示接合处为圆弧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="032-图形绘制---圆形绘制"><a class="header" href="#032-图形绘制---圆形绘制">03.2-图形绘制 - 圆形绘制</a></h1>
<h2 id="一-圆形绘制"><a class="header" href="#一-圆形绘制">一 圆形绘制</a></h2>
<p>canvas 提供了 2 个绘制圆的方法：</p>
<ul>
<li>arc(x,y, radius, startAngle, endAngle, counterClockwise):参数分别为圆心坐标、半径、圆弧的起始角度和终结角度，counterClockwise 参数可选，用于代表绘制方向，默认值为 false，表示顺时针。注意该方法如果不清除子路径，则会将子路径的重点与圆弧的起点用线段连接起来。</li>
<li>arcTo(x1,y1,x2,y2,radius):代表两个点以及半径，用于绘制一个与 (x2,y2) 到 (x1,y1) 连线相切的圆弧。</li>
</ul>
<p>arc() 示例：</p>
<pre><code class="language-js">// 绘制一个纯粹的圆弧
ctx.beginPath() // 清除子路径
ctx.arc(canvas.width / 2, canvas.height / 4, 80, Math.PI / 4, Math.PI)
ctx.stroke()

// 绘制一个连接子路径的圆弧
ctx.beginPath() // 清除子路径
ctx.moveTo(10, 10) // 向当前路径中加入一条进包含一个点的子路径
ctx.arc(canvas.width / 2, canvas.height / 4, 80, Math.PI / 4, Math.PI)
ctx.stroke()
</code></pre>
<h2 id="二-arcto-方法实现切角"><a class="header" href="#二-arcto-方法实现切角">二 arcTo() 方法实现切角</a></h2>
<pre><code class="language-js">const roundedRect = (cornerX, cornerY, width, height, cornerRadius) =&gt; {
  if (width &gt; 0) ctx.moveTo(cornerX + cornerRadius, cornerY)
  else ctx.moveTo(cornerX - cornerRadius, cornerY)

  ctx.arcTo(
    cornerX + width,
    cornerY,
    cornerX + width,
    cornerY + height,
    cornerRadius
  )

  ctx.arcTo(
    cornerX + width,
    cornerY + height,
    cornerX,
    cornerY + height,
    cornerRadius
  )

  ctx.arcTo(cornerX, cornerY + height, cornerX, cornerY, cornerRadius)

  if (width &gt; 0) {
    ctx.arcTo(cornerX, cornerY, cornerX + cornerRadius, cornerY, cornerRadius)
  } else {
    ctx.arcTo(cornerX, cornerY, cornerX - cornerRadius, cornerY, cornerRadius)
  }
}

const drawRoundedRect = (
  strokeStyle,
  fillStyle,
  cornerX,
  cornerY,
  width,
  height,
  cornerRadius
) =&gt; {
  ctx.beginPath()

  roundedRect(cornerX, cornerY, width, height, cornerRadius)

  ctx.strokeStyle = strokeStyle
  ctx.fillStyle = fillStyle

  ctx.stroke()
  ctx.fill()
}

drawRoundedRect('blue', 'yellow', 50, 40, 100, 100, 10)
drawRoundedRect('purple', 'green', 275, 40, -100, 100, 20)
drawRoundedRect('red', 'white', 300, 140, 100, -100, 30)
drawRoundedRect('white', 'blue', 525, 140, -100, -100, 40)
</code></pre>
<h2 id="三-实现一个仪表盘"><a class="header" href="#三-实现一个仪表盘">三 实现一个仪表盘</a></h2>
<pre><code class="language-js">const circle = { x: canvas.width / 2, y: canvas.height / 2, radius: 150 },
  CENTROID_RADIUS = 10,
  CENTROID_STROKE_STYLE = 'rgba(0, 0, 0, 0.5)',
  CENTROID_FILL_STYLE = 'rgba(80, 190, 240, 0.6)',
  RING_INNER_RADIUS = 35,
  RING_OUTER_RADIUS = 55,
  ANNOTATIONS_FILL_STYLE = 'rgba(0, 0, 230, 0.9)',
  ANNOTATIONS_TEXT_SIZE = 12,
  TICK_WIDTH = 10,
  TICK_LONG_STROKE_STYLE = 'rgba(100, 140, 230, 0.9)',
  TICK_SHORT_STROKE_STYLE = 'rgba(100, 140, 230, 0.7)',
  TRACKING_DIAL_STROKING_STYLE = 'rgba(100, 140, 230, 0.5)',
  GUIDEWIRE_STROKE_STYLE = 'goldenrod',
  GUIDEWIRE_FILL_STYLE = 'rgba(250, 250, 0, 0.6)'

const drawGrid = (color, stepx, stepy) =&gt; {
  ctx.save()

  ctx.shadowColor = undefined
  ctx.shadowOffsetX = 0
  ctx.shadowOffsetY = 0

  ctx.strokeStyle = color
  ctx.fillStyle = '#ffffff'
  ctx.lineWidth = 0.5
  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)

  for (let i = stepx + 0.5; i &lt; ctx.canvas.width; i += stepx) {
    ctx.beginPath()
    ctx.moveTo(i, 0)
    ctx.lineTo(i, ctx.canvas.height)
    ctx.stroke()
  }

  for (let i = stepy + 0.5; i &lt; ctx.canvas.height; i += stepy) {
    ctx.beginPath()
    ctx.moveTo(0, i)
    ctx.lineTo(ctx.canvas.width, i)
    ctx.stroke()
  }

  ctx.restore()
}

const drawDial = () =&gt; {
  const loc = { x: circle.x, y: circle.y }

  drawCentroid()
  drawCentroidGuidewire(loc)

  drawRing()
  drawTickInnerCircle()
  drawTicks()
  drawAnnotations()
}

const drawCentroid = () =&gt; {
  ctx.beginPath()
  ctx.save()
  ctx.strokeStyle = CENTROID_STROKE_STYLE
  ctx.fillStyle = CENTROID_FILL_STYLE
  ctx.arc(circle.x, circle.y, CENTROID_RADIUS, 0, Math.PI * 2, false)
  ctx.stroke()
  ctx.fill()
  ctx.restore()
}

const drawCentroidGuidewire = (loc) =&gt; {
  let angle = -Math.PI / 4,
    radius,
    endpt

  radius = circle.radius + RING_OUTER_RADIUS

  if (loc.x &gt;= circle.x) {
    endpt = {
      x: circle.x + radius * Math.cos(angle),
      y: circle.y + radius * Math.sin(angle),
    }
  } else {
    endpt = {
      x: circle.x - radius * Math.cos(angle),
      y: circle.y - radius * Math.sin(angle),
    }
  }

  ctx.save()

  ctx.strokeStyle = GUIDEWIRE_STROKE_STYLE
  ctx.fillStyle = GUIDEWIRE_FILL_STYLE

  ctx.beginPath()
  ctx.moveTo(circle.x, circle.y)
  ctx.lineTo(endpt.x, endpt.y)
  ctx.stroke()

  ctx.beginPath()
  ctx.strokeStyle = TICK_LONG_STROKE_STYLE
  ctx.arc(endpt.x, endpt.y, 5, 0, Math.PI * 2, false)
  ctx.fill()
  ctx.stroke()

  ctx.restore()
}

const drawRing = () =&gt; {
  drawRingOuterCircle()

  ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)'
  ctx.arc(
    circle.x,
    circle.y,
    circle.radius + RING_INNER_RADIUS,
    0,
    Math.PI * 2,
    false
  )

  ctx.fillStyle = 'rgba(100, 140, 230, 0.1)'
  ctx.fill()
  ctx.stroke()
}

const drawRingOuterCircle = () =&gt; {
  ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'
  ;(ctx.shadowOffsetX = 3),
    (ctx.shadowOffsetY = 3),
    (ctx.shadowBlur = 6),
    (ctx.strokeStyle = TRACKING_DIAL_STROKING_STYLE)
  ctx.beginPath()
  ctx.arc(
    circle.x,
    circle.y,
    circle.radius + RING_OUTER_RADIUS,
    0,
    Math.PI * 2,
    true
  )
  ctx.stroke()
}

function drawTickInnerCircle() {
  ctx.save()
  ctx.beginPath()
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)'
  ctx.arc(
    circle.x,
    circle.y,
    circle.radius + RING_INNER_RADIUS - TICK_WIDTH,
    0,
    Math.PI * 2,
    false
  )
  ctx.stroke()
  ctx.restore()
}

const drawTick = (angle, radius, cnt) =&gt; {
  let tickWidth = cnt % 4 === 0 ? TICK_WIDTH : TICK_WIDTH / 2

  ctx.beginPath()

  ctx.moveTo(
    circle.x + Math.cos(angle) * (radius - tickWidth),
    circle.y + Math.sin(angle) * (radius - tickWidth)
  )

  ctx.lineTo(
    circle.x + Math.cos(angle) * radius,
    circle.y + Math.sin(angle) * radius
  )

  ctx.strokeStyle = TICK_SHORT_STROKE_STYLE
  ctx.stroke()
}

const drawTicks = () =&gt; {
  let radius = circle.radius + RING_INNER_RADIUS,
    ANGLE_MAX = 2 * Math.PI,
    ANGLE_DELTA = Math.PI / 64,
    tickWidth

  ctx.save()

  for (var angle = 0, cnt = 0; angle &lt; ANGLE_MAX; angle += ANGLE_DELTA, cnt++) {
    drawTick(angle, radius, cnt++)
  }

  ctx.restore()
}

const drawAnnotations = () =&gt; {
  let radius = circle.radius + RING_INNER_RADIUS

  ctx.save()
  ctx.fillStyle = ANNOTATIONS_FILL_STYLE
  ctx.font = ANNOTATIONS_TEXT_SIZE + 'px Helvetica'

  for (let angle = 0; angle &lt; 2 * Math.PI; angle += Math.PI / 8) {
    ctx.beginPath()
    ctx.fillText(
      ((angle * 180) / Math.PI).toFixed(0),
      circle.x + Math.cos(angle) * (radius - TICK_WIDTH * 2),
      circle.y - Math.sin(angle) * (radius - TICK_WIDTH * 2)
    )
  }
  ctx.restore()
}

ctx.shadowOffsetX = 2
ctx.shadowOffsetY = 2
ctx.shadowBlur = 4

ctx.textAlign = 'center'
ctx.textBaseline = 'middle'
drawGrid('lightgray', 10, 10)
drawDial()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="033-图形绘制---贝塞尔曲线"><a class="header" href="#033-图形绘制---贝塞尔曲线">03.3-图形绘制 - 贝塞尔曲线</a></h1>
<h2 id="一-贝塞尔曲线概念"><a class="header" href="#一-贝塞尔曲线概念">一 贝塞尔曲线概念</a></h2>
<p>贝塞尔曲线多用于计算机图形学中，分为两种：平方贝塞尔曲线、立方贝塞尔曲线。</p>
<ul>
<li>平方贝塞尔曲线（quadratic）：是一种二次曲线（second degree curve），由三个点定义，包括：2 个锚点（anchor point）、1 个控制点（control point）</li>
<li>立方贝塞尔曲线（cubic）：是一种三次曲线（third-degree curve），由四个点定义，包含 2 个锚点、2 个控制点</li>
</ul>
<h2 id="二-平方贝塞尔曲线"><a class="header" href="#二-平方贝塞尔曲线">二 平方贝塞尔曲线</a></h2>
<p>平方贝塞尔曲线是只向一个方向弯曲的简单曲线，可以用来实现一些特殊曲线形状。</p>
<p>在 canvas 中通过 queadraticCurveTo(x1,y1, x2, y2) 方法绘制，参数分别代表两个点的坐标。第 1 个点表示曲线的控制点，用于就决定该曲线的形状，第二个点是锚点，绘制时会将锚点与当前路径中的最后一个点连接起来：</p>
<pre><code class="language-js">context.fillStyle = 'cornflowerblue'
context.strokeStyle = 'yellowgreen'

context.shadowColor = 'rgba(50, 50, 50, 1.0)'
context.shadowOffsetX = 2
context.shadowOffsetY = 2
context.shadowBlur = 4

context.lineWidth = 20
context.lineCap = 'round'

context.beginPath()
context.moveTo(120.5, 130)
context.quadraticCurveTo(150.8, 130, 160.6, 150.5)
context.quadraticCurveTo(190, 250.0, 210.5, 160.5)
context.quadraticCurveTo(240, 100.5, 290, 70.5)
context.stroke()
</code></pre>
<h2 id="三-立方贝塞尔曲线"><a class="header" href="#三-立方贝塞尔曲线">三 立方贝塞尔曲线</a></h2>
<p>平方贝塞尔曲线只能向一个方向弯曲，是二维的，立方贝塞尔曲线能够向两个方向弯曲：</p>
<pre><code class="language-js">const canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  endPoints = [
    { x: 130, y: 70 },
    { x: 430, y: 270 },
  ],
  controlPoints = [
    { x: 130, y: 250 },
    { x: 450, y: 70 },
  ]

const drawBezierCurve = () =&gt; {
  context.strokeStyle = 'blue'
  context.fillStyle = 'yellow'

  context.beginPath()
  context.moveTo(endPoints[0].x, endPoints[0].y)
  context.bezierCurveTo(
    controlPoints[0].x,
    controlPoints[0].y,
    controlPoints[1].x,
    controlPoints[1].y,
    endPoints[1].x,
    endPoints[1].y
  )
  context.stroke()
}

const drawEndPoints = () =&gt; {
  context.strokeStyle = 'blue'
  context.fillStyle = 'red'

  endPoints.forEach(function (point) {
    context.beginPath()
    context.arc(point.x, point.y, 5, 0, Math.PI * 2, false)
    context.stroke()
    context.fill()
  })
}

const drawControlPoints = () =&gt; {
  context.strokeStyle = 'yellow'
  context.fillStyle = 'blue'

  controlPoints.forEach(function (point) {
    context.beginPath()
    context.arc(point.x, point.y, 5, 0, Math.PI * 2, false)
    context.stroke()
    context.fill()
  })
}

drawControlPoints()
drawEndPoints()
drawBezierCurve()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="034-图形绘制---多边形绘制"><a class="header" href="#034-图形绘制---多边形绘制">03.4-图形绘制 - 多边形绘制</a></h1>
<h2 id="一-实现多边形绘制"><a class="header" href="#一-实现多边形绘制">一 实现多边形绘制</a></h2>
<p>使用 moveTo() 与 lineTo() 方法，结合三角函数，可以绘制出任意边数的多变形：</p>
<p><img src="%E9%99%84%E5%BD%95-Canvas/../images/canvas/02.png" alt="多边形顶点坐标计算" /></p>
<p>实现代码：</p>
<pre><code class="language-js">/**
 * 绘制必要对象
 */
// 定义一个点对象
class Point {
  constructor(x, y) {
    this.x = x
    this.y = y
  }
}
// 绘制起始点
const startPoint = new Point(0, 0),
  rubberbandRect = {}

// 绘制参数
let drawingSurfaceImageData = null,
  isDragging = false,
  sides = 6,
  startAngle = 0, // 起始绘制时的角度
  currentAngle = 45 // 绘制某个点时新方向角度

// 获取鼠标位置
const fitCanvas = (e) =&gt; {
  const x = e.x || e.clientX
  const y = e.y || e.clientY
  const bbox = canvas.getBoundingClientRect()

  return new Point(
    x - bbox.left * (canvas.width / bbox.width),
    y - bbox.top * (canvas.height / bbox.height)
  )
}

/**
 * 画布事件
 */
// 鼠标按下
canvas.onmousedown = function (e) {
  // 保存初始数据
  saveDrawingSurface()

  // 准备执行绘制
  isDragging = true
  e.preventDefault() // prevent cursor change

  let loc = fitCanvas(e)

  startPoint.x = loc.x
  startPoint.y = loc.y
}
// 鼠标移动
canvas.onmousemove = function (e) {
  if (!isDragging) {
    return
  }

  e.preventDefault() // prevent selections

  let loc = fitCanvas(e)
  restoreDrawingSurface()
  updateRubberband(loc, sides)
  drawGuidewires(startPoint.x, startPoint.y)
}
// 鼠标抬起
canvas.onmouseup = function (e) {
  isDragging = false
  let loc = fitCanvas(e)
  restoreDrawingSurface()
  updateRubberband(loc, sides)
}

/**
 *   绘图数据设置
 */
// 保存绘制数据
const saveDrawingSurface = () =&gt; {
  drawingSurfaceImageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
}
// 重置绘图数据
const restoreDrawingSurface = () =&gt; {
  ctx.putImageData(drawingSurfaceImageData, 0, 0)
}

/**
 * 绘制方法
 */
const updateRubberbandRectangle = (loc) =&gt; {
  rubberbandRect.width = Math.abs(loc.x - startPoint.x)
  rubberbandRect.height = Math.abs(loc.y - startPoint.y)

  if (loc.x &gt; startPoint.x) rubberbandRect.left = startPoint.x
  else rubberbandRect.left = loc.x

  if (loc.y &gt; startPoint.y) rubberbandRect.top = startPoint.y
  else rubberbandRect.top = loc.y
}

const drawRubberbandShape = (sides) =&gt; {
  // 获取点数据
  const points = []
  for (let i = 0; i &lt; sides; ++i) {
    points.push(
      new Point(
        startPoint.x + rubberbandRect.width * Math.sin(currentAngle),
        startPoint.y - rubberbandRect.width * Math.cos(currentAngle)
      )
    )
    currentAngle += (2 * Math.PI) / sides
  }

  // 执行绘制多边形
  ctx.beginPath()
  ctx.moveTo(points[0].x, points[0].y)
  for (let i = 1; i &lt; sides; ++i) {
    ctx.lineTo(points[i].x, points[i].y)
  }
  ctx.closePath()
  ctx.stroke()
}

const updateRubberband = (loc, sides) =&gt; {
  updateRubberbandRectangle(loc)
  drawRubberbandShape(sides)
}

/**
 * 绘制十字
 */
// 绘制竖线
const drawHorizontalLine = (y) =&gt; {
  ctx.beginPath()
  ctx.moveTo(0, y + 0.5)
  ctx.lineTo(ctx.canvas.width, y + 0.5)
  ctx.stroke()
}
// 绘制横线
const drawVerticalLine = (x) =&gt; {
  ctx.beginPath()
  ctx.moveTo(x + 0.5, 0)
  ctx.lineTo(x + 0.5, ctx.canvas.height)
  ctx.stroke()
}
// 绘制横线
const drawGuidewires = (x, y) =&gt; {
  ctx.save()
  ctx.strokeStyle = 'rgba(0,0,230,0.4)'
  ctx.lineWidth = 0.5
  drawVerticalLine(x)
  drawHorizontalLine(y)
  ctx.restore()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="035-图形绘制---坐标变换"><a class="header" href="#035-图形绘制---坐标变换">03.5-图形绘制 - 坐标变换</a></h1>
<h2 id="一-坐标系的转换"><a class="header" href="#一-坐标系的转换">一 坐标系的转换</a></h2>
<p>通常将坐标原点设置为屏幕的左上角，通过移动该原点坐标，可以简化计算过程。以下代码可以在 canvas 的中心绘制一个矩形：</p>
<pre><code class="language-js">const rect_w = 100
const rect_h = 100
crx.strokeRect(
  canvas.widt / 2 - rect_w / 2,
  canvas.height / 2 - rect_h / 2,
  rect_w,
  rect_h
)
</code></pre>
<p>上述代码在计算矩形左上角的 X，Y 坐标时，分别从 canvas 的中心点坐标之中减去该举行的一半宽度及一半高度。入股我们将坐标原点移动到刚才算出来的地方，就可以简化对 strokeRect() 方法的调用了：</p>
<pre><code class="language-js">const rect_w = 100
const rect_h = 100

crx.translate(canvas.widt / 2 - rect_w / 2, canvas.height / 2 - rect_h / 2)

crx.strokeRect(0, 0, rect_w, rect_h)
</code></pre>
<p>在绘制多个图形时，上述操作就可以极大简化绘制所需要的计算了。</p>
<h2 id="二-坐标系的平移缩放旋转"><a class="header" href="#二-坐标系的平移缩放旋转">二 坐标系的平移、缩放、旋转</a></h2>
<p>示例：</p>
<pre><code class="language-js">var canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  eraseAllButton = document.getElementById('eraseAllButton'),
  strokeStyleSelect = document.getElementById('strokeStyleSelect'),
  startAngleSelect = document.getElementById('startAngleSelect'),
  fillStyleSelect = document.getElementById('fillStyleSelect'),
  fillCheckbox = document.getElementById('fillCheckbox'),
  editCheckbox = document.getElementById('editCheckbox'),
  sidesSelect = document.getElementById('sidesSelect'),
  CENTROID_RADIUS = 10,
  CENTROID_STROKE_STYLE = 'rgba(0, 0, 0, 0.8)',
  CENTROID_FILL_STYLE = 'rgba(255, 255, 255, 0.2)',
  CENTROID_SHADOW_COLOR = 'rgba(255, 255, 255, 0.4)',
  DEGREE_RING_MARGIN = 35,
  TRACKING_RING_MARGIN = 55,
  DEGREE_ANNOTATIONS_FILL_STYLE = 'rgba(0, 0, 230, 0.8)',
  DEGREE_ANNOTATIONS_TEXT_SIZE = 11,
  DEGREE_OUTER_RING_MARGIN = DEGREE_RING_MARGIN,
  TICK_WIDTH = 10,
  TICK_LONG_STROKE_STYLE = 'rgba(100, 140, 230, 0.9)',
  TICK_SHORT_STROKE_STYLE = 'rgba(100, 140, 230, 0.7)',
  TRACKING_RING_STROKING_STYLE = 'rgba(100, 140, 230, 0.3)',
  drawingSurfaceImageData,
  mousedown = {},
  rubberbandRect = {},
  dragging = false,
  draggingOffsetX,
  draggingOffsetY,
  sides = 8,
  startAngle = 0,
  guidewires = true,
  editing = false,
  rotatingLockEngaged = false,
  rotatingLockAngle,
  polygonRotating,
  polygons = []

// Functions.....................................................

function drawGrid(color, stepx, stepy) {
  context.save()

  context.shadowColor = undefined
  context.shadowBlur = 0
  context.shadowOffsetX = 0
  context.shadowOffsetY = 0

  context.strokeStyle = color
  context.fillStyle = '#ffffff'
  context.lineWidth = 0.5
  context.fillRect(0, 0, context.canvas.width, context.canvas.height)

  for (var i = stepx + 0.5; i &lt; context.canvas.width; i += stepx) {
    context.beginPath()
    context.moveTo(i, 0)
    context.lineTo(i, context.canvas.height)
    context.stroke()
  }

  for (var i = stepy + 0.5; i &lt; context.canvas.height; i += stepy) {
    context.beginPath()
    context.moveTo(0, i)
    context.lineTo(context.canvas.width, i)
    context.stroke()
  }

  context.restore()
}

function windowToCanvas(e) {
  var x = e.x || e.clientX,
    y = e.y || e.clientY,
    bbox = canvas.getBoundingClientRect()

  return {
    x: x - bbox.left * (canvas.width / bbox.width),
    y: y - bbox.top * (canvas.height / bbox.height),
  }
}

// Save and restore drawing surface..............................

function saveDrawingSurface() {
  drawingSurfaceImageData = context.getImageData(
    0,
    0,
    canvas.width,
    canvas.height
  )
}

function restoreDrawingSurface() {
  context.putImageData(drawingSurfaceImageData, 0, 0)
}

// Rubberbands...................................................

function updateRubberbandRectangle(loc) {
  rubberbandRect.width = Math.abs(loc.x - mousedown.x)
  rubberbandRect.height = Math.abs(loc.y - mousedown.y)

  if (loc.x &gt; mousedown.x) rubberbandRect.left = mousedown.x
  else rubberbandRect.left = loc.x

  if (loc.y &gt; mousedown.y) rubberbandRect.top = mousedown.y
  else rubberbandRect.top = loc.y
}

function drawRubberbandShape(loc, sides, startAngle) {
  var polygon = new Polygon(
    mousedown.x,
    mousedown.y,
    rubberbandRect.width,
    parseInt(sidesSelect.value),
    (Math.PI / 180) * parseInt(startAngleSelect.value),
    context.strokeStyle,
    context.fillStyle,
    fillCheckbox.checked
  )
  drawPolygon(polygon)

  if (!dragging) {
    polygons.push(polygon)
  }
}

function updateRubberband(loc, sides, startAngle) {
  updateRubberbandRectangle(loc)
  drawRubberbandShape(loc, sides, startAngle)
}

// Guidewires....................................................

function drawHorizontalLine(y) {
  context.beginPath()
  context.moveTo(0, y + 0.5)
  context.lineTo(context.canvas.width, y + 0.5)
  context.stroke()
}

function drawVerticalLine(x) {
  context.beginPath()
  context.moveTo(x + 0.5, 0)
  context.lineTo(x + 0.5, context.canvas.height)
  context.stroke()
}

function drawGuidewires(x, y) {
  context.save()
  context.strokeStyle = 'rgba(0,0,230,0.4)'
  context.lineWidth = 0.5
  drawVerticalLine(x)
  drawHorizontalLine(y)
  context.restore()
}

// Drawing functions.............................................

function drawPolygons() {
  polygons.forEach(function (polygon) {
    polygon.stroke(context)
    if (polygon.filled) {
      polygon.fill(context)
    }
  })
}

function drawCentroid(polygon) {
  context.beginPath()
  context.save()
  context.strokeStyle = CENTROID_STROKE_STYLE
  context.fillStyle = CENTROID_FILL_STYLE
  context.shadowColor = CENTROID_SHADOW_COLOR
  context.arc(polygon.x, polygon.y, CENTROID_RADIUS, 0, Math.PI * 2, false)
  context.stroke()
  context.fill()
  context.restore()
}

function drawCentroidGuidewire(loc, polygon) {
  var angle = Math.atan((loc.y - polygon.y) / (loc.x - polygon.x)),
    radius,
    endpt

  radius = polygon.radius + TRACKING_RING_MARGIN
  angle = angle - rotatingLockAngle

  if (loc.x &gt;= polygon.x) {
    endpt = {
      x: polygon.x + radius * Math.cos(angle),
      y: polygon.y + radius * Math.sin(angle),
    }
  } else {
    endpt = {
      x: polygon.x - radius * Math.cos(angle),
      y: polygon.y - radius * Math.sin(angle),
    }
  }

  context.save()
  context.beginPath()
  context.moveTo(polygon.x, polygon.y)
  context.lineTo(endpt.x, endpt.y)
  context.stroke()

  context.beginPath()
  context.arc(endpt.x, endpt.y, 5, 0, Math.PI * 2, false)
  context.stroke()
  context.fill()

  context.restore()
}

function drawDegreeOuterDial(polygon) {
  context.strokeStyle = 'rgba(0, 0, 0, 0.1)'
  context.arc(
    polygon.x,
    polygon.y,
    polygon.radius + DEGREE_OUTER_RING_MARGIN,
    0,
    Math.PI * 2,
    true
  )
}

function drawDegreeAnnotations(polygon) {
  var radius = polygon.radius + DEGREE_RING_MARGIN

  context.save()
  context.fillStyle = DEGREE_ANNOTATIONS_FILL_STYLE
  context.font = DEGREE_ANNOTATIONS_TEXT_SIZE + 'px Helvetica'

  for (var angle = 0; angle &lt; 2 * Math.PI; angle += Math.PI / 8) {
    context.beginPath()
    context.fillText(
      ((angle * 180) / Math.PI).toFixed(0),
      polygon.x + Math.cos(angle) * (radius - TICK_WIDTH * 2),
      polygon.y + Math.sin(angle) * (radius - TICK_WIDTH * 2)
    )
  }
  context.restore()
}

function drawDegreeDialTicks(polygon) {
  var radius = polygon.radius + DEGREE_RING_MARGIN,
    ANGLE_MAX = 2 * Math.PI,
    ANGLE_DELTA = Math.PI / 64

  context.save()

  for (var angle = 0, cnt = 0; angle &lt; ANGLE_MAX; angle += ANGLE_DELTA, ++cnt) {
    context.beginPath()

    if (cnt % 4 === 0) {
      context.moveTo(
        polygon.x + Math.cos(angle) * (radius - TICK_WIDTH),
        polygon.y + Math.sin(angle) * (radius - TICK_WIDTH)
      )
      context.lineTo(
        polygon.x + Math.cos(angle) * radius,
        polygon.y + Math.sin(angle) * radius
      )
      context.strokeStyle = TICK_LONG_STROKE_STYLE
      context.stroke()
    } else {
      context.moveTo(
        polygon.x + Math.cos(angle) * (radius - TICK_WIDTH / 2),
        polygon.y + Math.sin(angle) * (radius - TICK_WIDTH / 2)
      )
      context.lineTo(
        polygon.x + Math.cos(angle) * radius,
        polygon.y + Math.sin(angle) * radius
      )
      context.strokeStyle = TICK_SHORT_STROKE_STYLE
      context.stroke()
    }

    context.restore()
  }
}

function drawDegreeTickDial(polygon) {
  context.save()
  context.strokeStyle = 'rgba(0, 0, 0, 0.1)'
  context.beginPath()
  context.arc(
    polygon.x,
    polygon.y,
    polygon.radius + DEGREE_RING_MARGIN - TICK_WIDTH,
    0,
    Math.PI * 2,
    false
  )
  context.stroke()
  context.restore()
}

function drawTrackingDial(polygon) {
  context.save()
  context.shadowColor = 'rgba(0, 0, 0, 0.7)'
  ;(context.shadowOffsetX = 3),
    (context.shadowOffsetY = 3),
    (context.shadowBlur = 6),
    (context.strokeStyle = TRACKING_RING_STROKING_STYLE)
  context.beginPath()
  context.arc(
    polygon.x,
    polygon.y,
    polygon.radius + TRACKING_RING_MARGIN,
    0,
    Math.PI * 2,
    false
  )
  context.stroke()
  context.restore()
}

function drawRotationAnnotations(loc) {
  drawCentroid(polygonRotating)
  drawCentroidGuidewire(loc, polygonRotating)

  drawTrackingDial(polygonRotating)
  drawDegreeOuterDial(polygonRotating)
  context.fillStyle = 'rgba(100, 140, 230, 0.1)'
  context.fill()

  context.beginPath()
  drawDegreeOuterDial(polygonRotating)
  context.stroke()

  drawDegreeDialTicks(polygonRotating)
  drawDegreeTickDial(polygonRotating)
  drawDegreeAnnotations(polygonRotating)
}

function redraw() {
  context.clearRect(0, 0, canvas.width, canvas.height)
  drawGrid('lightgray', 10, 10)
  drawPolygons()
}

// Polygons......................................................

function drawPolygon(polygon, angle) {
  var tx = polygon.x,
    ty = polygon.y

  context.save()

  context.translate(tx, ty)

  if (angle) {
    context.rotate(angle)
  }

  polygon.x = 0
  polygon.y = 0

  polygon.createPath(context)
  context.stroke()

  if (fillCheckbox.checked) {
    context.fill(context)
  }

  context.restore()

  polygon.x = tx
  polygon.y = ty
}

function getSelectedPolygon(loc) {
  for (var i = 0; i &lt; polygons.length; ++i) {
    var polygon = polygons[i]

    polygon.createPath(context)
    if (context.isPointInPath(loc.x, loc.y)) {
      startDragging(loc)
      draggingOffsetX = loc.x - polygon.x
      draggingOffsetY = loc.y - polygon.y
      return polygon
    }
  }
  return undefined
}

function stopRotatingPolygon(loc) {
  angle =
    Math.atan((loc.y - polygonRotating.y) / (loc.x - polygonRotating.x)) -
    rotatingLockAngle

  polygonRotating.startAngle += angle

  polygonRotating = undefined
  rotatingLockEngaged = false
  rotatingLockAngle = 0
}

function startDragging(loc) {
  saveDrawingSurface()
  mousedown.x = loc.x
  mousedown.y = loc.y
}

// Event handlers................................................

canvas.onmousedown = function (e) {
  var loc = windowToCanvas(e),
    angle,
    radius,
    trackingRadius

  e.preventDefault() // prevent cursor change

  if (editing) {
    if (polygonRotating) {
      stopRotatingPolygon(loc)
      redraw()
    }

    polygonRotating = getSelectedPolygon(loc)

    if (polygonRotating) {
      drawRotationAnnotations(loc)

      if (!rotatingLockEngaged) {
        rotatingLockEngaged = true
        rotatingLockAngle = Math.atan(
          (loc.y - polygonRotating.y) / (loc.x - polygonRotating.x)
        )
      }
    }
  } else {
    startDragging(loc)
    dragging = true
  }
}

canvas.onmousemove = function (e) {
  var loc = windowToCanvas(e),
    radius = Math.sqrt(
      Math.pow(loc.x - dragging.x, 2) + Math.pow(loc.y - dragging.y, 2)
    ),
    angle

  e.preventDefault() // prevent selections

  if (rotatingLockEngaged) {
    angle =
      Math.atan((loc.y - polygonRotating.y) / (loc.x - polygonRotating.x)) -
      rotatingLockAngle

    redraw()

    drawPolygon(polygonRotating, angle)
    drawRotationAnnotations(loc)
  } else if (dragging) {
    restoreDrawingSurface()
    updateRubberband(loc, sides, startAngle)

    if (guidewires) {
      drawGuidewires(mousedown.x, mousedown.y)
    }
  }
}

canvas.onmouseup = function (e) {
  var loc = windowToCanvas(e)

  dragging = false

  if (!editing) {
    restoreDrawingSurface()
    updateRubberband(loc)
  }
}

eraseAllButton.onclick = function (e) {
  context.clearRect(0, 0, canvas.width, canvas.height)
  drawGrid('lightgray', 10, 10)
  saveDrawingSurface()
}

strokeStyleSelect.onchange = function (e) {
  context.strokeStyle = strokeStyleSelect.value
}

fillStyleSelect.onchange = function (e) {
  context.fillStyle = fillStyleSelect.value
}

function startEditing() {
  canvas.style.cursor = 'pointer'
  editing = true
}

function stopEditing() {
  canvas.style.cursor = 'crosshair'
  editing = false
  polygonRotating = undefined
  rotatingLockEngaged = false
  rotatingLockAngle = 0
  context.clearRect(0, 0, canvas.width, canvas.height)
  drawGrid('lightgray', 10, 10)
  drawPolygons()
}

editCheckbox.onchange = function (e) {
  if (editCheckbox.checked) {
    startEditing()
  } else {
    stopEditing()
  }
}

// Initialization................................................

context.strokeStyle = strokeStyleSelect.value
context.fillStyle = fillStyleSelect.value

drawGrid('lightgray', 10, 10)

if (navigator.userAgent.indexOf('Opera') === -1)
  context.shadowColor = 'rgba(0, 0, 0, 0.4)'

context.shadowOffsetX = 2
context.shadowOffsetY = 2
context.shadowBlur = 4

context.textAlign = 'center'
context.textBaseline = 'middle'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="035-图形绘制---高级路径操作"><a class="header" href="#035-图形绘制---高级路径操作">03.5-图形绘制 - 高级路径操作</a></h1>
<p>用户一般通过点击鼠标或者触碰屏幕来选择当前显示的物体，为了方便选择功能的开发，CanvasApi 提供了一个名为 pointPath() 的方法，如果某个点在当前路径中，那么该方法就返回 true。</p>
<h2 id="一-拖动多边形对象"><a class="header" href="#一-拖动多边形对象">一 拖动多边形对象</a></h2>
<pre><code class="language-js">var canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  eraseAllButton = document.getElementById('eraseAllButton'),
  strokeStyleSelect = document.getElementById('strokeStyleSelect'),
  startAngleSelect = document.getElementById('startAngleSelect'),
  fillStyleSelect = document.getElementById('fillStyleSelect'),
  fillCheckbox = document.getElementById('fillCheckbox'),
  editCheckbox = document.getElementById('editCheckbox'),
  sidesSelect = document.getElementById('sidesSelect'),
  drawingSurfaceImageData,
  mousedown = {},
  rubberbandRect = {},
  dragging = false,
  draggingOffsetX,
  draggingOffsetY,
  sides = 8,
  startAngle = 0,
  guidewires = true,
  editing = false,
  polygons = []

// Functions..........................................................

function drawGrid(color, stepx, stepy) {
  context.save()

  context.shadowColor = undefined
  context.shadowBlur = 0
  context.shadowOffsetX = 0
  context.shadowOffsetY = 0

  context.strokeStyle = color
  context.fillStyle = '#ffffff'
  context.lineWidth = 0.5
  context.fillRect(0, 0, context.canvas.width, context.canvas.height)

  context.beginPath()

  for (var i = stepx + 0.5; i &lt; context.canvas.width; i += stepx) {
    context.moveTo(i, 0)
    context.lineTo(i, context.canvas.height)
  }
  context.stroke()

  context.beginPath()

  for (var i = stepy + 0.5; i &lt; context.canvas.height; i += stepy) {
    context.moveTo(0, i)
    context.lineTo(context.canvas.width, i)
  }
  context.stroke()

  context.restore()
}

function windowToCanvas(x, y) {
  var bbox = canvas.getBoundingClientRect()
  return {
    x: x - bbox.left * (canvas.width / bbox.width),
    y: y - bbox.top * (canvas.height / bbox.height),
  }
}

// Save and restore drawing surface...................................

function saveDrawingSurface() {
  drawingSurfaceImageData = context.getImageData(
    0,
    0,
    canvas.width,
    canvas.height
  )
}

function restoreDrawingSurface() {
  context.putImageData(drawingSurfaceImageData, 0, 0)
}

// Draw a polygon.....................................................

function drawPolygon(polygon) {
  context.beginPath()
  polygon.createPath(context)
  polygon.stroke(context)

  if (fillCheckbox.checked) {
    polygon.fill(context)
  }
}

// Rubberbands........................................................

function updateRubberbandRectangle(loc) {
  rubberbandRect.width = Math.abs(loc.x - mousedown.x)
  rubberbandRect.height = Math.abs(loc.y - mousedown.y)

  if (loc.x &gt; mousedown.x) rubberbandRect.left = mousedown.x
  else rubberbandRect.left = loc.x

  if (loc.y &gt; mousedown.y) rubberbandRect.top = mousedown.y
  else rubberbandRect.top = loc.y
}

function drawRubberbandShape(loc, sides, startAngle) {
  var polygon = new Polygon(
    mousedown.x,
    mousedown.y,
    rubberbandRect.width,
    parseInt(sidesSelect.value),
    (Math.PI / 180) * parseInt(startAngleSelect.value),
    context.strokeStyle,
    context.fillStyle,
    fillCheckbox.checked
  )
  drawPolygon(polygon)

  if (!dragging) {
    polygons.push(polygon)
  }
}

function updateRubberband(loc, sides, startAngle) {
  updateRubberbandRectangle(loc)
  drawRubberbandShape(loc, sides, startAngle)
}

// Guidewires.........................................................

function drawHorizontalLine(y) {
  context.beginPath()
  context.moveTo(0, y + 0.5)
  context.lineTo(context.canvas.width, y + 0.5)
  context.stroke()
}

function drawVerticalLine(x) {
  context.beginPath()
  context.moveTo(x + 0.5, 0)
  context.lineTo(x + 0.5, context.canvas.height)
  context.stroke()
}

function drawGuidewires(x, y) {
  context.save()
  context.strokeStyle = 'rgba(0,0,230,0.4)'
  context.lineWidth = 0.5
  drawVerticalLine(x)
  drawHorizontalLine(y)
  context.restore()
}

function drawPolygons() {
  polygons.forEach(function (polygon) {
    drawPolygon(polygon)
  })
}

// Dragging...........................................................

function startDragging(loc) {
  saveDrawingSurface()
  mousedown.x = loc.x
  mousedown.y = loc.y
}

function startEditing() {
  canvas.style.cursor = 'pointer'
  editing = true
}

function stopEditing() {
  canvas.style.cursor = 'crosshair'
  editing = false
}

// Event handlers.....................................................

canvas.onmousedown = function (e) {
  var loc = windowToCanvas(e.clientX, e.clientY)

  e.preventDefault() // prevent cursor change

  if (editing) {
    polygons.forEach(function (polygon) {
      polygon.createPath(context)
      if (context.isPointInPath(loc.x, loc.y)) {
        startDragging(loc)
        dragging = polygon
        draggingOffsetX = loc.x - polygon.x
        draggingOffsetY = loc.y - polygon.y
        return
      }
    })
  } else {
    startDragging(loc)
    dragging = true
  }
}

canvas.onmousemove = function (e) {
  var loc = windowToCanvas(e.clientX, e.clientY)

  e.preventDefault() // prevent selections

  if (editing &amp;&amp; dragging) {
    dragging.x = loc.x - draggingOffsetX
    dragging.y = loc.y - draggingOffsetY

    context.clearRect(0, 0, canvas.width, canvas.height)
    drawGrid('lightgray', 10, 10)
    drawPolygons()
  } else {
    if (dragging) {
      restoreDrawingSurface()
      updateRubberband(loc, sides, startAngle)

      if (guidewires) {
        drawGuidewires(mousedown.x, mousedown.y)
      }
    }
  }
}

canvas.onmouseup = function (e) {
  var loc = windowToCanvas(e.clientX, e.clientY)

  dragging = false

  if (editing) {
  } else {
    restoreDrawingSurface()
    updateRubberband(loc)
  }
}

eraseAllButton.onclick = function (e) {
  context.clearRect(0, 0, canvas.width, canvas.height)
  drawGrid('lightgray', 10, 10)
  saveDrawingSurface()
}

strokeStyleSelect.onchange = function (e) {
  context.strokeStyle = strokeStyleSelect.value
}

fillStyleSelect.onchange = function (e) {
  context.fillStyle = fillStyleSelect.value
}

editCheckbox.onchange = function (e) {
  if (editCheckbox.checked) {
    startEditing()
  } else {
    stopEditing()
  }
}

// Initialization.....................................................

context.strokeStyle = strokeStyleSelect.value
context.fillStyle = fillStyleSelect.value

drawGrid('lightgray', 10, 10)

if (navigator.userAgent.indexOf('Opera') === -1)
  context.shadowColor = 'rgba(0, 0, 0, 0.4)'

context.shadowOffsetX = 2
context.shadowOffsetY = 2
context.shadowBlur = 4
</code></pre>
<h2 id="二-编辑贝塞尔曲线"><a class="header" href="#二-编辑贝塞尔曲线">二 编辑贝塞尔曲线</a></h2>
<p>通过拖动端点与控制点来编辑贝塞尔曲线：</p>
<pre><code class="language-js">var canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  eraseAllButton = document.getElementById('eraseAllButton'),
  strokeStyleSelect = document.getElementById('strokeStyleSelect'),
  guidewireCheckbox = document.getElementById('guidewireCheckbox'),
  instructions = document.getElementById('instructions'),
  instructionsOkayButton = document.getElementById('instructionsOkayButton'),
  instructionsNoMoreButton = document.getElementById(
    'instructionsNoMoreButton'
  ),
  showInstructions = true,
  GRID_STROKE_STYLE = 'lightblue',
  GRID_SPACING = 10,
  CONTROL_POINT_RADIUS = 5,
  CONTROL_POINT_STROKE_STYLE = 'blue',
  CONTROL_POINT_FILL_STYLE = 'rgba(255, 255, 0, 0.5)',
  END_POINT_STROKE_STYLE = 'navy',
  END_POINT_FILL_STYLE = 'rgba(0, 255, 0, 0.5)',
  GUIDEWIRE_STROKE_STYLE = 'rgba(0,0,230,0.4)',
  drawingImageData, // Image data stored on mouse down events
  mousedown = {}, // Cursor location for last mouse down event
  rubberbandRect = {}, // Constantly updated for mouse move events
  dragging = false, // If true, user is dragging the cursor
  draggingPoint = false, // End- or control-point the user is dragging
  endPoints = [{}, {}], // end point locations (x, y)
  controlPoints = [{}, {}], // control point locations (x, y)
  editing = false, // If true, user is editing the curve
  guidewires = guidewireCheckbox.checked

// Functions..........................................................

function drawGrid(color, stepx, stepy) {
  context.save()

  context.strokeStyle = color
  context.lineWidth = 0.5
  context.clearRect(0, 0, context.canvas.width, context.canvas.height)

  for (var i = stepx + 0.5; i &lt; context.canvas.width; i += stepx) {
    context.beginPath()
    context.moveTo(i, 0)
    context.lineTo(i, context.canvas.height)
    context.stroke()
  }

  for (var i = stepy + 0.5; i &lt; context.canvas.height; i += stepy) {
    context.beginPath()
    context.moveTo(0, i)
    context.lineTo(context.canvas.width, i)
    context.stroke()
  }

  context.restore()
}

function windowToCanvas(x, y) {
  var bbox = canvas.getBoundingClientRect()

  return {
    x: x - bbox.left * (canvas.width / bbox.width),
    y: y - bbox.top * (canvas.height / bbox.height),
  }
}

// Save and restore drawing surface...................................

function saveDrawingSurface() {
  drawingImageData = context.getImageData(0, 0, canvas.width, canvas.height)
}

function restoreDrawingSurface() {
  context.putImageData(drawingImageData, 0, 0)
}

// Rubberbands........................................................

function updateRubberbandRectangle(loc) {
  rubberbandRect.width = Math.abs(loc.x - mousedown.x)
  rubberbandRect.height = Math.abs(loc.y - mousedown.y)

  if (loc.x &gt; mousedown.x) rubberbandRect.left = mousedown.x
  else rubberbandRect.left = loc.x

  if (loc.y &gt; mousedown.y) rubberbandRect.top = mousedown.y
  else rubberbandRect.top = loc.y
}

function drawBezierCurve() {
  context.beginPath()
  context.moveTo(endPoints[0].x, endPoints[0].y)
  context.bezierCurveTo(
    controlPoints[0].x,
    controlPoints[0].y,
    controlPoints[1].x,
    controlPoints[1].y,
    endPoints[1].x,
    endPoints[1].y
  )
  context.stroke()
}

function updateEndAndControlPoints() {
  endPoints[0].x = rubberbandRect.left
  endPoints[0].y = rubberbandRect.top

  endPoints[1].x = rubberbandRect.left + rubberbandRect.width
  endPoints[1].y = rubberbandRect.top + rubberbandRect.height

  controlPoints[0].x = rubberbandRect.left
  controlPoints[0].y = rubberbandRect.top + rubberbandRect.height

  controlPoints[1].x = rubberbandRect.left + rubberbandRect.width
  controlPoints[1].y = rubberbandRect.top
}

function drawRubberbandShape(loc) {
  updateEndAndControlPoints()
  drawBezierCurve()
}

function updateRubberband(loc) {
  updateRubberbandRectangle(loc)
  drawRubberbandShape(loc)
}

// Guidewires.........................................................

function drawHorizontalGuidewire(y) {
  context.beginPath()
  context.moveTo(0, y + 0.5)
  context.lineTo(context.canvas.width, y + 0.5)
  context.stroke()
}

function drawVerticalGuidewire(x) {
  context.beginPath()
  context.moveTo(x + 0.5, 0)
  context.lineTo(x + 0.5, context.canvas.height)
  context.stroke()
}

function drawGuidewires(x, y) {
  context.save()
  context.strokeStyle = GUIDEWIRE_STROKE_STYLE
  context.lineWidth = 0.5
  drawVerticalGuidewire(x)
  drawHorizontalGuidewire(y)
  context.restore()
}

// End points and control points......................................

function drawControlPoint(index) {
  context.beginPath()
  context.arc(
    controlPoints[index].x,
    controlPoints[index].y,
    CONTROL_POINT_RADIUS,
    0,
    Math.PI * 2,
    false
  )
  context.stroke()
  context.fill()
}

function drawControlPoints() {
  context.save()
  context.strokeStyle = CONTROL_POINT_STROKE_STYLE
  context.fillStyle = CONTROL_POINT_FILL_STYLE

  drawControlPoint(0)
  drawControlPoint(1)

  context.stroke()
  context.fill()
  context.restore()
}

function drawEndPoint(index) {
  context.beginPath()
  context.arc(
    endPoints[index].x,
    endPoints[index].y,
    CONTROL_POINT_RADIUS,
    0,
    Math.PI * 2,
    false
  )
  context.stroke()
  context.fill()
}

function drawEndPoints() {
  context.save()
  context.strokeStyle = END_POINT_STROKE_STYLE
  context.fillStyle = END_POINT_FILL_STYLE

  drawEndPoint(0)
  drawEndPoint(1)

  context.stroke()
  context.fill()
  context.restore()
}

function drawControlAndEndPoints() {
  drawControlPoints()
  drawEndPoints()
}

function cursorInEndPoint(loc) {
  var pt

  endPoints.forEach(function (point) {
    context.beginPath()
    context.arc(point.x, point.y, CONTROL_POINT_RADIUS, 0, Math.PI * 2, false)

    if (context.isPointInPath(loc.x, loc.y)) {
      pt = point
    }
  })

  return pt
}

function cursorInControlPoint(loc) {
  var pt

  controlPoints.forEach(function (point) {
    context.beginPath()
    context.arc(point.x, point.y, CONTROL_POINT_RADIUS, 0, Math.PI * 2, false)

    if (context.isPointInPath(loc.x, loc.y)) {
      pt = point
    }
  })

  return pt
}

function updateDraggingPoint(loc) {
  draggingPoint.x = loc.x
  draggingPoint.y = loc.y
}

// Canvas event handlers..............................................

canvas.onmousedown = function (e) {
  var loc = windowToCanvas(e.clientX, e.clientY)

  e.preventDefault() // prevent cursor change

  if (!editing) {
    saveDrawingSurface()
    mousedown.x = loc.x
    mousedown.y = loc.y
    updateRubberbandRectangle(loc)
    dragging = true
  } else {
    draggingPoint = cursorInControlPoint(loc)

    if (!draggingPoint) {
      draggingPoint = cursorInEndPoint(loc)
    }
  }
}

canvas.onmousemove = function (e) {
  var loc = windowToCanvas(e.clientX, e.clientY)

  if (dragging || draggingPoint) {
    e.preventDefault() // prevent selections
    restoreDrawingSurface()

    if (guidewires) {
      drawGuidewires(loc.x, loc.y)
    }
  }

  if (dragging) {
    updateRubberband(loc)
    drawControlAndEndPoints()
  } else if (draggingPoint) {
    updateDraggingPoint(loc)
    drawControlAndEndPoints()
    drawBezierCurve()
  }
}

canvas.onmouseup = function (e) {
  loc = windowToCanvas(e.clientX, e.clientY)

  restoreDrawingSurface()

  if (!editing) {
    updateRubberband(loc)
    drawControlAndEndPoints()
    dragging = false
    editing = true
    if (showInstructions) {
      instructions.style.display = 'inline'
    }
  } else {
    if (draggingPoint) drawControlAndEndPoints()
    else editing = false

    drawBezierCurve()
    draggingPoint = undefined
  }
}

// Control event handlers.............................................

eraseAllButton.onclick = function (e) {
  context.clearRect(0, 0, canvas.width, canvas.height)
  drawGrid(GRID_STROKE_STYLE, GRID_SPACING, GRID_SPACING)

  saveDrawingSurface()

  editing = false
  dragging = false
  draggingPoint = undefined
}

strokeStyleSelect.onchange = function (e) {
  context.strokeStyle = strokeStyleSelect.value
}

guidewireCheckbox.onchange = function (e) {
  guidewires = guidewireCheckbox.checked
}

// Instructions event handlers........................................

instructionsOkayButton.onclick = function (e) {
  instructions.style.display = 'none'
}

instructionsNoMoreButton.onclick = function (e) {
  instructions.style.display = 'none'
  showInstructions = false
}

// Initialization.....................................................

context.strokeStyle = strokeStyleSelect.value
drawGrid(GRID_STROKE_STYLE, GRID_SPACING, GRID_SPACING)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-图片操作---绘制图片"><a class="header" href="#041-图片操作---绘制图片">04.1-图片操作 - 绘制图片</a></h1>
<h2 id="一-canvas-提供的图像绘制-api"><a class="header" href="#一-canvas-提供的图像绘制-api">一 canvas 提供的图像绘制 api</a></h2>
<p>canvas 的绘图环境对象提供了 4 个绘制、操作图像方法：</p>
<ul>
<li><code>drawImage()</code>：把图像绘制到 canvas 中，也能把 canvas 的内容或某个视频中的某一帧绘制到当前 canvas 中</li>
<li><code>getImageData()</code>：获取图像中的底层相似</li>
<li><code>putImageData()</code>：将修改的像素值放回到图像中去</li>
<li><code>createImageData()</code>：创建一个空白图像的数据对象，可以将以 CSS 像素为单位的宽度与高度值传递给该方法，作为图像数据大小，也可以传递一个已经存在的 ImageData 对象</li>
</ul>
<h2 id="二-图像绘制-drawimage"><a class="header" href="#二-图像绘制-drawimage">二 图像绘制 drawImage()</a></h2>
<h3 id="21-图片绘制示例"><a class="header" href="#21-图片绘制示例">2.1 图片绘制示例</a></h3>
<p>drawImage() 方法可以将一幅图像的整体、部分绘制到 canvas 内的任何位置上，并且允许在绘制过程中对图像进行缩放，也可以将图像绘制在离屏 canvas 中，这样可以实现如图像查看器、淡入淡出 canvas 中。</p>
<p>将图像绘制到 canvas 示例：</p>
<pre><code class="language-js">const image = new Image()
image.src = 'demo.png'

// 必须在加载完毕后的回调函数中
image.onload = function (e) {
  ctx.drawImage(image, 0, 0)
}
</code></pre>
<h3 id="22-drawimage-方法解析"><a class="header" href="#22-drawimage-方法解析">2.2 drawImage() 方法解析</a></h3>
<p><code>drawImage()</code>方法需要绘制的图像称为源图像（source image），绘制到的地方称为目标 canvas（destination canvas），下列参数中 s 开头为源图像，d 开头为目标 canvas：</p>
<ul>
<li><code>drawImage(image, dx, dy)</code>：将整个图片绘制在 canvas 指定位置上</li>
<li><code>drawImage(image, dx, dy, dw, dh)</code>：将图像完整的 UI 之到指定的位置上（会根据目标区域的宽度与高度进行缩放）</li>
<li><code>drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)</code>：可以将一整幅图或者一部分绘制到 canvas 上，且在绘制时根据目标区域的宽度与高度对图像进行缩放。</li>
</ul>
<p>如图所示：</p>
<p><img src="%E9%99%84%E5%BD%95-Canvas/./../images/canvas/03.svg" alt="图像绘制参数" /></p>
<p>贴士：image 对象是 HTMLImageElement 图片对象，也可以是 HTMLCanvasElement 类型的 canvas 对象，也可以是 HTMLVideoElement 视频对象，如果是视频对象会将视频的当前帧绘制出来</p>
<h3 id="23-图像的缩放"><a class="header" href="#23-图像的缩放">2.3 图像的缩放</a></h3>
<p>缩放后将图像绘制于 canvas 的中心：</p>
<pre><code class="language-js">const drawImage = () =&gt; {
  let w = canvas.width,
    h = canvas.height,
    sw = w * scale,
    sh = h * scale

  ctx.clearRect(0, 0, canvas.width, canvas.height)
  ctx.drawImage(image, -sw / 2 + w / 2, -sh / 2 + h / 2, sw, sh)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="042-离屏-canvas"><a class="header" href="#042-离屏-canvas">04.2 离屏 canvas</a></h1>
<p>离屏 canvas 使用步骤：创建离屏 canvas 的元素，设置该 canvas 的宽高，在离屏 canvas 中进行绘制。</p>
<p>使用离屏 canvas 会额外占据一定的内存，但是也能显著提升绘图效率：</p>
<pre><code class="language-js">const canvas = document.getElementById('canvas')
const context = canvas.getContext('2d')

// 离屏 canvas
let offscreenCanvas = document.createElement('canvas')
;(offscreenContext = offscreenCanvas.getContext('2d')),
  (image = new Image()),
  (scaleOutput = document.getElementById('scaleOutput'))
scaleSlider = document.getElementById('scaleSlider')
;(canvasRadio = document.getElementById('canvasRadio')),
  (imageRadio = document.getElementById('imageRadio')),
  (scale = scaleSlider.value),
  (scale = 1.0),
  (MINIMUM_SCALE = 1.0),
  (MAXIMUM_SCALE = 3.0)

// Functions.....................................................

function drawScaled() {
  var w = canvas.width,
    h = canvas.height,
    sw = w * scale,
    sh = h * scale

  context.drawImage(
    offscreenCanvas,
    0,
    0,
    offscreenCanvas.width,
    offscreenCanvas.height,
    -sw / 2 + w / 2,
    -sh / 2 + h / 2,
    sw,
    sh
  )
}

function drawScaleText(value) {
  const text = parseFloat(value).toFixed(2)
  let percent =
    parseFloat(value - MINIMUM_SCALE) /
    parseFloat(MAXIMUM_SCALE - MINIMUM_SCALE)

  scaleOutput.innerText = text
  percent = percent &lt; 0.35 ? 0.35 : percent
  scaleOutput.style.fontSize = (percent * MAXIMUM_SCALE) / 1.5 + 'em'
}

function drawWatermark(context) {
  let lineOne = 'Copyright',
    lineTwo = 'Acme, Inc.',
    textMetrics = null,
    FONT_HEIGHT = 128

  context.save()
  context.fillStyle = 'rgba(100,140,230,0.5);'
  context.strokeStyle = 'yellow'
  context.shadowColor = 'rgba(50, 50, 50, 1.0)'
  context.shadowOffsetX = 5
  context.shadowOffsetY = 5
  context.shadowBlur = 10

  context.font = FONT_HEIGHT + 'px Arial'
  textMetrics = context.measureText(lineOne)
  context.translate(canvas.width / 2, canvas.height / 2)
  context.fillText(lineOne, -textMetrics.width / 2, 0)
  context.strokeText(lineOne, -textMetrics.width / 2, 0)

  textMetrics = context.measureText(lineTwo)
  context.fillText(lineTwo, -textMetrics.width / 2, FONT_HEIGHT)
  context.strokeText(lineTwo, -textMetrics.width / 2, FONT_HEIGHT)
  context.restore()
}

// Event Handlers................................................

scaleSlider.onchange = function (e) {
  scale = e.target.value

  if (scale &lt; MINIMUM_SCALE) scale = MINIMUM_SCALE
  else if (scale &gt; MAXIMUM_SCALE) scale = MAXIMUM_SCALE

  drawScaled()
  drawScaleText(scale)
}

// Initialization................................................

offscreenCanvas.width = canvas.width
offscreenCanvas.height = canvas.height

image.src = '../../shared/images/lonelybeach.png'
image.onload = function (e) {
  context.drawImage(image, 0, 0, canvas.width, canvas.height)
  offscreenContext.drawImage(image, 0, 0, canvas.width, canvas.height)
  drawWatermark(context)
  drawWatermark(offscreenContext)
  drawScaleText(scaleSlider.value)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="043-图片操作---操作像素"><a class="header" href="#043-图片操作---操作像素">04.3-图片操作 - 操作像素</a></h1>
<h2 id="一-imagedata-对象"><a class="header" href="#一-imagedata-对象">一 ImageData 对象</a></h2>
<p>getImageData() 与 putImageData() 可以分别用来获取图像的像素信息、向图像中插入像素，能够实现图像像素的任何操作。</p>
<p>调用 getImageData() 可以获取一个指向 ImageData 对象的引用，该对象包含三个属性：</p>
<ul>
<li>width：以设备像素（device pixel）为单位的图像数据宽度</li>
<li>height：以设备像素为单位的图像数据高度</li>
<li>data：包含各个设备像素数值的数组</li>
</ul>
<p>贴士：width 与 height 均是只读的无符号长证书，data 中的每个数组元素均表示图像数据中的相应像素值，每个值所含的颜色分量都是含有 8 个二进制位的证书。</p>
<p>图像的 data 数据遍历方式：</p>
<pre><code class="language-js">// 遍历每个像素
for (let i = 0; i &lt; length; i++) {}

// 只处理 alpha 值，不修改色值
for (let i = 3; i &lt; length - 4; i += 4) {
  data[i] = 0.1
}

// 只处理色值，不修改 alpha
for (let i = 0; i &lt; length - 4; i += 4) {
  data[i] = '' // 红色
  data[i + 1] = '' // 绿色
  data[i + 2] = '' // 蓝色
}
</code></pre>
<h2 id="二-示例-1"><a class="header" href="#二-示例-1">二 示例</a></h2>
<p>示例：类似 AI 标注系统，用户使用橡皮筋式选取图片一部分区域，在拖动鼠标时不断计算选取框大小，捕捉该范围内的像素，选取完毕后将橡皮筋式选取框绘制出来。这里的问题是：用户很容易出现拖拽了一个宽或者高为 0 的选择框，这时候 getImageData() 方法会抛出异常。</p>
<pre><code class="language-js">var canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  resetButton = document.getElementById('resetButton'),
  image = new Image(),
  imageData,
  mousedown = {},
  rubberbandRectangle = {},
  dragging = false

// Functions.....................................................

function windowToCanvas(canvas, x, y) {
  var canvasRectangle = canvas.getBoundingClientRect()

  return {
    x: x - canvasRectangle.left,
    y: y - canvasRectangle.top,
  }
}

function captureRubberbandPixels() {
  imageData = context.getImageData(
    rubberbandRectangle.left,
    rubberbandRectangle.top,
    rubberbandRectangle.width,
    rubberbandRectangle.height
  )
}

function restoreRubberbandPixels() {
  var deviceWidthOverCSSPixels = imageData.width / rubberbandRectangle.width,
    deviceHeightOverCSSPixels = imageData.height / rubberbandRectangle.height

  context.putImageData(
    imageData,
    rubberbandRectangle.left * deviceWidthOverCSSPixels,
    rubberbandRectangle.top * deviceHeightOverCSSPixels
  )
}

function drawRubberband() {
  context.strokeRect(
    rubberbandRectangle.left + context.lineWidth,
    rubberbandRectangle.top + context.lineWidth,
    rubberbandRectangle.width - 2 * context.lineWidth,
    rubberbandRectangle.height - 2 * context.lineWidth
  )
}

function setRubberbandRectangle(x, y) {
  rubberbandRectangle.left = Math.min(x, mousedown.x)
  rubberbandRectangle.top = Math.min(y, mousedown.y)
  ;(rubberbandRectangle.width = Math.abs(x - mousedown.x)),
    (rubberbandRectangle.height = Math.abs(y - mousedown.y))
}

function updateRubberband() {
  captureRubberbandPixels()
  drawRubberband()
}

function rubberbandStart(x, y) {
  mousedown.x = x
  mousedown.y = y

  rubberbandRectangle.left = mousedown.x
  rubberbandRectangle.top = mousedown.y

  dragging = true
}

function rubberbandStretch(x, y) {
  if (
    rubberbandRectangle.width &gt; 2 * context.lineWidth &amp;&amp;
    rubberbandRectangle.height &gt; 2 * context.lineWidth
  ) {
    if (imageData !== undefined) {
      restoreRubberbandPixels()
    }
  }

  setRubberbandRectangle(x, y)

  if (
    rubberbandRectangle.width &gt; 2 * context.lineWidth &amp;&amp;
    rubberbandRectangle.height &gt; 2 * context.lineWidth
  ) {
    updateRubberband()
  }
}

function rubberbandEnd() {
  // Draw and scale image to the on screen canvas.
  context.drawImage(
    canvas,
    rubberbandRectangle.left + context.lineWidth * 2,
    rubberbandRectangle.top + context.lineWidth * 2,
    rubberbandRectangle.width - 4 * context.lineWidth,
    rubberbandRectangle.height - 4 * context.lineWidth,
    0,
    0,
    canvas.width,
    canvas.height
  )
  dragging = false
  imageData = undefined
}

// Event handlers...............................................

canvas.onmousedown = function (e) {
  var loc = windowToCanvas(canvas, e.clientX, e.clientY)
  e.preventDefault()
  rubberbandStart(loc.x, loc.y)
}

canvas.onmousemove = function (e) {
  var loc

  if (dragging) {
    loc = windowToCanvas(canvas, e.clientX, e.clientY)
    rubberbandStretch(loc.x, loc.y)
  }
}

canvas.onmouseup = function (e) {
  rubberbandEnd()
}

// Initialization..............................................

image.src = '../../shared/images/arch.png'
image.onload = function () {
  context.drawImage(image, 0, 0, canvas.width, canvas.height)
}

resetButton.onclick = function (e) {
  context.clearRect(0, 0, canvas.width, canvas.height)

  context.drawImage(image, 0, 0, canvas.width, canvas.height)
}

context.strokeStyle = 'yellow'
context.lineWidth = 2.0
</code></pre>
<h2 id="三-示例优化"><a class="header" href="#三-示例优化">三 示例优化</a></h2>
<p>在上一节示例中，每次鼠标移动都会运行 getImageData 方法，该方法运行速度较慢，会导致在手机等设备上出现性能瓶颈。优化方案是：只在每次检测到鼠标按下事件时，才调用一次 getImageData() 方法，用以捕捉 canvas 内的全部像素，然后每次在处理鼠标移动事件时，才调用一次 getImageData() 方法，用以捕捉 canvas 内的全部像素。然后，每次在处理鼠标移动事件时，则调用 putImageData() 方法，仅仅将框选矩形所占据的那一小部分图像数据复制到 canvas，这种实现方式更为显著的提升性能。</p>
<p>本方案中采用了 4 个可选参数的 putImageData 方法，这 4 个参数可以确定一个脏矩形（dirty rectangle），指的是浏览器将要复制到 canvas 中的那部分图像数据所占据的区域。dx，dy 代表绘制的图像距离 canvas 左上角的 x、y 偏移量。</p>
<p>注意：在指定 canvas 偏移量时，需要使用 css 像素单位，在指定图像数据中的脏矩形区域时，需要使用设备像素单位。</p>
<pre><code class="language-js">var canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  resetButton = document.getElementById('resetButton'),
  image = new Image(),
  imageData,
  imageDataCopy = context.createImageData(canvas.width, canvas.height),
  mousedown = {},
  rubberbandRectangle = {},
  dragging = false

// Functions.....................................................

function windowToCanvas(canvas, x, y) {
  var canvasRectangle = canvas.getBoundingClientRect()

  return {
    x: x - canvasRectangle.left,
    y: y - canvasRectangle.top,
  }
}

function copyCanvasPixels() {
  var i = 0

  // Copy red, green, and blue components of the first pixel

  for (i = 0; i &lt; 3; i++) {
    imageDataCopy.data[i] = imageData.data[i]
  }

  // Starting with the alpha component of the first pixel,
  // copy imageData, and make the copy more transparent

  for (i = 3; i &lt; imageData.data.length - 4; i += 4) {
    imageDataCopy.data[i] = imageData.data[i] / 2 // Alpha: more transparent
    imageDataCopy.data[i + 1] = imageData.data[i + 1] // Red
    imageDataCopy.data[i + 2] = imageData.data[i + 2] // Green
    imageDataCopy.data[i + 3] = imageData.data[i + 3] // Blue
  }
}

function captureCanvasPixels() {
  imageData = context.getImageData(0, 0, canvas.width, canvas.height)
  copyCanvasPixels()
}

function restoreRubberbandPixels() {
  var deviceWidthOverCSSPixels = imageData.width / canvas.width,
    deviceHeightOverCSSPixels = imageData.height / canvas.height

  // Restore the Canvas to what it looked like when the mouse went down

  context.putImageData(imageData, 0, 0)

  // Put the more transparent image data into the rubberband rectangle

  context.putImageData(
    imageDataCopy,
    0,
    0,
    rubberbandRectangle.left + context.lineWidth,
    rubberbandRectangle.top + context.lineWidth,
    (rubberbandRectangle.width - 2 * context.lineWidth) *
      deviceWidthOverCSSPixels,
    (rubberbandRectangle.height - 2 * context.lineWidth) *
      deviceHeightOverCSSPixels
  )
}

function setRubberbandRectangle(x, y) {
  rubberbandRectangle.left = Math.min(x, mousedown.x)
  rubberbandRectangle.top = Math.min(y, mousedown.y)
  ;(rubberbandRectangle.width = Math.abs(x - mousedown.x)),
    (rubberbandRectangle.height = Math.abs(y - mousedown.y))
}

function drawRubberband() {
  var deviceWidthOverCSSPixels = imageData.width / canvas.width,
    deviceHeightOverCSSPixels = imageData.height / canvas.height

  context.strokeRect(
    rubberbandRectangle.left + context.lineWidth,
    rubberbandRectangle.top + context.lineWidth,
    rubberbandRectangle.width - 2 * context.lineWidth,
    rubberbandRectangle.height - 2 * context.lineWidth
  )
}

function rubberbandStart(x, y) {
  mousedown.x = x
  mousedown.y = y

  rubberbandRectangle.left = mousedown.x
  rubberbandRectangle.top = mousedown.y
  rubberbandRectangle.width = 0
  rubberbandRectangle.height = 0

  dragging = true

  captureCanvasPixels()
}

function rubberbandStretch(x, y) {
  if (
    rubberbandRectangle.width &gt; 2 * context.lineWidth &amp;&amp;
    rubberbandRectangle.height &gt; 2 * context.lineWidth
  ) {
    if (imageData !== undefined) {
      restoreRubberbandPixels()
    }
  }

  setRubberbandRectangle(x, y)

  if (
    rubberbandRectangle.width &gt; 2 * context.lineWidth &amp;&amp;
    rubberbandRectangle.height &gt; 2 * context.lineWidth
  ) {
    drawRubberband()
  }
}

function rubberbandEnd() {
  context.putImageData(imageData, 0, 0)

  // Draw the canvas back into itself, scaling along the way

  context.drawImage(
    canvas,
    rubberbandRectangle.left + context.lineWidth * 2,
    rubberbandRectangle.top + context.lineWidth * 2,
    rubberbandRectangle.width - 4 * context.lineWidth,
    rubberbandRectangle.height - 4 * context.lineWidth,
    0,
    0,
    canvas.width,
    canvas.height
  )

  dragging = false
  imageData = undefined
}

// Event handlers...............................................

canvas.onmousedown = function (e) {
  var loc = windowToCanvas(canvas, e.clientX, e.clientY)
  e.preventDefault()
  rubberbandStart(loc.x, loc.y)
}

canvas.onmousemove = function (e) {
  var loc

  if (dragging) {
    loc = windowToCanvas(canvas, e.clientX, e.clientY)
    rubberbandStretch(loc.x, loc.y)
  }
}

canvas.onmouseup = function (e) {
  rubberbandEnd()
}

// Initialization..............................................

image.src = '../../shared/images/arch.png'
image.onload = function () {
  context.drawImage(image, 0, 0, canvas.width, canvas.height)
}

resetButton.onclick = function (e) {
  context.clearRect(0, 0, canvas.width, canvas.height)

  context.drawImage(image, 0, 0, canvas.width, canvas.height)
}

context.strokeStyle = 'navy'
context.lineWidth = 1.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="044-图片操作---滤镜操作"><a class="header" href="#044-图片操作---滤镜操作">04.4-图片操作 - 滤镜操作</a></h1>
<h2 id="一-图像滤镜的实现"><a class="header" href="#一-图像滤镜的实现">一 图像滤镜的实现</a></h2>
<h3 id="10-滤镜算法"><a class="header" href="#10-滤镜算法">1.0 滤镜算法</a></h3>
<p>图像滤镜（iamge filtering）操作需要对图像数据进行遍历，每个循环处理 4 个整数值，即每次循环结束后，数组下标总是会指向某个像素的红色分量值。在循环体中，滤镜的代码会修改每个像素的红绿蓝分量值，但是不改变 alpha 值。</p>
<h3 id="11-负片滤镜"><a class="header" href="#11-负片滤镜">1.1 负片滤镜</a></h3>
<p>负片滤镜（）：从 255 之中减去每个像素的红绿蓝平均值，然后将三个分量都设置为这一均值，即将图像由彩色变成黑白。</p>
<pre><code class="language-js">var image = new Image(),
  canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  negativeButton = document.getElementById('negativeButton')

negativeButton.onclick = function () {
  var imagedata = context.getImageData(0, 0, canvas.width, canvas.height),
    data = imagedata.data

  for (i = 0; i &lt;= data.length - 4; i += 4) {
    data[i] = 255 - data[i]
    data[i + 1] = 255 - data[i + 1]
    data[i + 2] = 255 - data[i + 2]
  }
  context.putImageData(imagedata, 0, 0)
}

image.src = '../../shared/images/curved-road.png'
image.onload = function () {
  context.drawImage(
    image,
    0,
    0,
    image.width,
    image.height,
    0,
    0,
    context.canvas.width,
    context.canvas.height
  )
}
</code></pre>
<h3 id="12-黑白滤镜"><a class="header" href="#12-黑白滤镜">1.2 黑白滤镜</a></h3>
<p>黑白滤镜：</p>
<pre><code class="language-js">var image = new Image(),
  canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  colorToggleCheckbox = document.getElementById('colorToggleCheckbox')

function drawInBlackAndWhite() {
  var data = undefined,
    i = 0

  imagedata = context.getImageData(0, 0, canvas.width, canvas.height)
  data = imagedata.data

  for (i = 0; i &lt; data.length - 4; i += 4) {
    average = (data[i] + data[i + 1] + data[i + 2]) / 3
    data[i] = average
    data[i + 1] = average
    data[i + 2] = average
  }
  context.putImageData(imagedata, 0, 0)
}

function drawInColor() {
  context.drawImage(
    image,
    0,
    0,
    image.width,
    image.height,
    0,
    0,
    context.canvas.width,
    context.canvas.height
  )
}

colorToggleCheckbox.onclick = function () {
  if (colorToggleCheckbox.checked) {
    drawInColor()
  } else {
    drawInBlackAndWhite()
  }
}

image.src = '../../shared/images/curved-road.png'
image.onload = function () {
  drawInColor()
}
</code></pre>
<h3 id="13-浮雕滤镜"><a class="header" href="#13-浮雕滤镜">1.3 浮雕滤镜</a></h3>
<p>浮雕滤镜（embossing filter）需要获取图像数据的宽度，如：如果滤镜需要根据一个简单的等式来计算某个像素值，而该等式要到当前像素右方以及下一行的对应像素值，那么此时必须知道图像的宽度，才能计算出下一行的那个像素在数组中的位置。</p>
<p>以下示例会将所有像素都会染成泥灰色，并且私用了“边缘检测”使其颜色边界处（像素自发生突变的地方）的像素灰度更浓。这里还需要考虑边界条件（boundary condition）。所有位于最后一行的像素，它的下方都不会再有其他像素了，而梅昂最右边的像素，其右方也不会有别的像素出现。</p>
<pre><code class="language-js">// sunglassFilter.js

onmessage = function (event) {
  var imagedata = event.data,
    data = imagedata.data,
    length = data.length,
    width = imagedata.width

  for (i = 0; i &lt; length; ++i) {
    if ((i + 1) % 4 != 0) {
      if ((i + 4) % (width * 4) == 0) {
        // last pixel in a row
        data[i] = data[i - 4]
        data[i + 1] = data[i - 3]
        data[i + 2] = data[i - 2]
        data[i + 3] = data[i - 1]
        i += 4
      } else {
        data[i] = 2 * data[i] - data[i + 4] - 0.5 * data[i + 4]
      }
    }
  }

  postMessage(imagedata)
}

// 业务代码 js 文件
var image = new Image(),
  canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  embossButton = document.getElementById('embossButton'),
  embossed = false

// Functions.....................................................

function emboss() {
  var imagedata,
    data,
    length,
    width,
    index = 3

  imagedata = context.getImageData(0, 0, canvas.width, canvas.height)
  data = imagedata.data
  width = imagedata.width
  length = data.length

  for (i = 0; i &lt; length; i++) {
    // loop through every pixel

    // if we won't overrun the bounds of the array
    if (i &lt;= length - width * 4) {
      // if it's not an alpha
      if ((i + 1) % 4 !== 0) {
        // if it's the last pixel in the row, there is
        // no pixel to the right, so copy previous pixel's
        // values.

        if ((i + 4) % (width * 4) == 0) {
          data[i] = data[i - 4]
          data[i + 1] = data[i - 3]
          data[i + 2] = data[i - 2]
          data[i + 3] = data[i - 1]
          i += 4
        } else {
          // not the last pixel in the row
          data[i] =
            255 / 2 + // Average value
            2 * data[i] - // current pixel
            data[i + 4] - // next pixel
            data[i + width * 4] // pixel underneath
        }
      }
    } else {
      // last row, no pixels underneath,
      // so copy pixel above
      if ((i + 1) % 4 !== 0) {
        data[i] = data[i - width * 4]
      }
    }
  }
  context.putImageData(imagedata, 0, 0)
}

function drawOriginalImage() {
  context.drawImage(
    image,
    0,
    0,
    image.width,
    image.height,
    0,
    0,
    canvas.width,
    canvas.height
  )
}

embossButton.onclick = function () {
  if (embossed) {
    embossButton.value = 'Emboss'
    drawOriginalImage()
    embossed = false
  } else {
    embossButton.value = 'Original image'
    emboss()
    embossed = true
  }
}

// Initialization................................................

image.src = '../../shared/images/curved-road.png'
image.onload = function () {
  drawOriginalImage()
}
</code></pre>
<p>使用线程技术优化：</p>
<pre><code class="language-js">var image = new Image(),
  canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  sunglassButton = document.getElementById('sunglassButton'),
  sunglassesOn = false,
  sunglassFilter = new Worker('sunglassFilter.js')

function putSunglassesOn() {
  sunglassFilter.postMessage(
    context.getImageData(0, 0, canvas.width, canvas.height)
  )

  sunglassFilter.onmessage = function (event) {
    context.putImageData(event.data, 0, 0)
  }
}

function drawOriginalImage() {
  context.drawImage(
    image,
    0,
    0,
    image.width,
    image.height,
    0,
    0,
    canvas.width,
    canvas.height
  )
}

sunglassButton.onclick = function () {
  if (sunglassesOn) {
    sunglassButton.value = 'Sunglasses'
    drawOriginalImage()
    sunglassesOn = false
  } else {
    sunglassButton.value = 'Original picture'
    putSunglassesOn()
    sunglassesOn = true
  }
}

image.src = '../../shared/images/curved-road.png'
image.onload = function () {
  drawOriginalImage()
}
</code></pre>
<h2 id="二-结合剪辑区域绘制图像"><a class="header" href="#二-结合剪辑区域绘制图像">二 结合剪辑区域绘制图像</a></h2>
<p>以下示例中：工作者对图像信息进行处理，使每个像素的颜色变深，并增高其对比度。处理完毕后，将数据投递出去，浏览器此时会回调工作现成的 onmessage() 方法。</p>
<p>drawLenses() 方法会将当前绘图环境的状态保存起来，创建新的路径，向路径中增加两个表示镜片的圆形，并将该路径设置为剪辑区域，再把离屏 canvas 的内容绘制到屏幕 canvas 中。由于剪辑区域被设定为这 2 个圆形所在范围，所以在离屏 canvas 中，只有此范围的图像才会被绘制到屏幕中。</p>
<pre><code class="language-js">// sunglassFilter.js
onmessage = function emboss(event) {
  var imagedata = event.data,
    data = imagedata.data,
    length = data.length,
    width = imagedata.width

  for (i = 0; i &lt; length; ++i) {
    if ((i + 1) % 4 != 0) {
      if ((i + 4) % (width * 4) == 0) {
        // last pixel in a row
        data[i] = data[i - 4]
        data[i + 1] = data[i - 3]
        data[i + 2] = data[i - 2]
        data[i + 3] = data[i - 1]
        i += 4
      } else {
        data[i] = 2 * data[i] - data[i + 4] - 0.5 * data[i + 4]
      }
    }
  }

  postMessage(imagedata)
}

// 业务代码 js 文件
var image = new Image(),
  canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  offscreenCanvas = document.createElement('canvas'),
  offscreenContext = offscreenCanvas.getContext('2d'),
  sunglassButton = document.getElementById('sunglassButton'),
  sunglassesOn = false,
  sunglassFilter = new Worker('sunglassFilter.js'),
  LENS_RADIUS = canvas.width / 5

function drawLenses(leftLensLocation, rightLensLocation) {
  context.save()
  context.beginPath()

  context.arc(
    leftLensLocation.x,
    leftLensLocation.y,
    LENS_RADIUS,
    0,
    Math.PI * 2,
    false
  )
  context.stroke()

  moveTo(rightLensLocation.x, rightLensLocation.y)

  context.arc(
    rightLensLocation.x,
    rightLensLocation.y,
    LENS_RADIUS,
    0,
    Math.PI * 2,
    false
  )
  context.stroke()

  context.clip()

  context.drawImage(offscreenCanvas, 0, 0, canvas.width, canvas.height)
  context.restore()
}

function drawWire(center) {
  context.beginPath()
  context.moveTo(center.x - LENS_RADIUS / 4, center.y - LENS_RADIUS / 2)

  context.quadraticCurveTo(
    center.x,
    center.y - LENS_RADIUS + 20,
    center.x + LENS_RADIUS / 4,
    center.y - LENS_RADIUS / 2
  )
  context.stroke()
}

function drawConnectors(center) {
  context.beginPath()

  context.fillStyle = 'silver'
  context.strokeStyle = 'rgba(0,0,0,0.4)'
  context.lineWidth = 2

  context.arc(
    center.x - LENS_RADIUS / 4,
    center.y - LENS_RADIUS / 2,
    4,
    0,
    Math.PI * 2,
    false
  )
  context.fill()
  context.stroke()

  context.beginPath()
  context.arc(
    center.x + LENS_RADIUS / 4,
    center.y - LENS_RADIUS / 2,
    4,
    0,
    Math.PI * 2,
    false
  )
  context.fill()
  context.stroke()
}

function putSunglassesOn() {
  var imagedata,
    center = {
      x: canvas.width / 2,
      y: canvas.height / 2,
    },
    leftLensLocation = {
      x: center.x - LENS_RADIUS - 10,
      y: center.y,
    },
    rightLensLocation = {
      x: center.x + LENS_RADIUS + 10,
      y: center.y,
    },
    imagedata = context.getImageData(0, 0, canvas.width, canvas.height)

  sunglassFilter.postMessage(imagedata)

  sunglassFilter.onmessage = function (event) {
    offscreenContext.putImageData(event.data, 0, 0)
    drawLenses(leftLensLocation, rightLensLocation)
    drawWire(center)
    drawConnectors(center)
  }
}

function drawOriginalImage() {
  context.drawImage(
    image,
    0,
    0,
    image.width,
    image.height,
    0,
    0,
    canvas.width,
    canvas.height
  )
}

sunglassButton.onclick = function () {
  if (sunglassesOn) {
    sunglassButton.value = 'Sunglasses'
    drawOriginalImage()
    sunglassesOn = false
  } else {
    sunglassButton.value = 'Original picture'
    putSunglassesOn()
    sunglassesOn = true
  }
}

offscreenCanvas.width = canvas.width
offscreenCanvas.height = canvas.height

image.src = '../../shared/images/curved-road.png'
image.onload = function () {
  drawOriginalImage()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="045-图片操作---图像制作动画"><a class="header" href="#045-图片操作---图像制作动画">04.5-图片操作 - 图像制作动画</a></h1>
<h2 id="一-图像制作动画示例"><a class="header" href="#一-图像制作动画示例">一 图像制作动画示例</a></h2>
<p>在某段时间内持续向一幅图运用滤镜，就可以实现动画效果了，比如滤镜文档中最后一个代码示例中使用 setInterval() 来持续降低每个像素的 alpha 值。</p>
<p>淡出动画的难点自安于：每个像素的初始 alpha 值各不相同，所以在每一帧中，应用程序都必须根据其初始值来降低每个像素的 alpha 值，即：动态降低 alpha 值（alpha-channel reduction）。具体做法是：getImageData() 方法返回的所有原始图像像素数据保存起来，在其后的每一帧动画之中，程序都会根据每个像素的初始值来决定当前这一步要减少的 alpha 值。</p>
<pre><code class="language-js">var image = new Image(),
  canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  fadeButton = document.getElementById('fadeButton'),
  originalImageData = null,
  interval = null

// Functions.....................................................

function increaseTransparency(imagedata, steps) {
  var alpha,
    currentAlpha,
    step,
    length = imagedata.data.length

  for (var i = 3; i &lt; length; i += 4) {
    // For every alpha component
    alpha = originalImageData.data[i]

    if (alpha &gt; 0 &amp;&amp; imagedata.data[i] &gt; 0) {
      // not totally transparent yet
      currentAlpha = imagedata.data[i]
      step = Math.ceil(alpha / steps)

      if (currentAlpha - step &gt; 0) {
        // not too close to the end
        imagedata.data[i] -= step // increase transparency
      } else {
        imagedata.data[i] = 0 // end: totally transparent
      }
    }
  }
}

function fadeOut(context, imagedata, x, y, steps, millisecondsPerStep) {
  var frame = 0,
    length = imagedata.data.length

  interval = setInterval(function () {
    // Once every millisecondsPerStep ms
    frame++

    if (frame &gt; steps) {
      // animation is over
      clearInterval(interval) // end animation
      animationComplete() // put picture back in 1s
    } else {
      increaseTransparency(imagedata, steps)
      context.putImageData(imagedata, x, y)
    }
  }, millisecondsPerStep)
}

// Animation.....................................................

function animationComplete() {
  setTimeout(function () {
    context.drawImage(image, 0, 0, canvas.width, canvas.height)
  }, 1000)
}

// Initialization................................................

fadeButton.onclick = function () {
  fadeOut(
    context,
    context.getImageData(0, 0, canvas.width, canvas.height),
    0,
    0,
    20,
    1000 / 60
  )
}

image.src = '../../shared/images/log-crossing.png'
image.onload = function () {
  context.drawImage(image, 0, 0, canvas.width, canvas.height)
  originalImageData = context.getImageData(0, 0, canvas.width, canvas.height)
}
</code></pre>
<p>优化：除了通过修改每个像素的 alpha 值实现淡出效果之外，可以在绘制每帧动画前，先修改绘图环境对象的 globalAlpha 值，然后再绘制图像，这样也能实现淡出效果。</p>
<h2 id="二-离屏-canvas-制作动画"><a class="header" href="#二-离屏-canvas-制作动画">二 离屏 canvas 制作动画</a></h2>
<p>同样的算法也可以用来制作淡入效果。先将图像的像素值保存到一份快照中，然后根据像素的初始 alpha 值，计算在动画的每一帧总各个像素的 alpha 值的增量。但是，在播放淡入动画时，图像一开始是不会显示出来的，所以不能直接从屏幕 canvas 中捕获其像素值，所以需要先把图像绘制到离屏 canvas 中，从该 canvas 捕获像素值。</p>
<pre><code class="language-js">var image = new Image(),
  canvas = document.getElementById('canvas'),
  context = canvas.getContext('2d'),
  offscreenCanvas = document.createElement('canvas'),
  offscreenContext = offscreenCanvas.getContext('2d'),
  fadeButton = document.getElementById('fadeButton'),
  imagedata,
  imagedataOffscreen,
  interval = null

// Functions.....................................................

function increaseTransparency(imagedata, steps) {
  var alpha,
    currentAlpha,
    step,
    length = imagedata.data.length

  for (var i = 3; i &lt; length; i += 4) {
    // For every alpha component
    alpha = imagedataOffscreen.data[i]

    if (alpha &gt; 0) {
      currentAlpha = imagedata.data[i]
      step = Math.ceil(alpha / steps)

      if (currentAlpha + step &lt;= alpha) {
        // Not at original alpha setting yet
        imagedata.data[i] += step // increase transparency
      } else {
        imagedata.data[i] = alpha // end: original transparency
      }
    }
  }
}

function fadeIn(context, imagedata, steps, millisecondsPerStep) {
  var frame = 0

  for (var i = 3; i &lt; imagedata.data.length; i += 4) {
    // For every alpha component
    imagedata.data[i] = 0
  }

  interval = setInterval(function () {
    // Every millisecondsPerStep
    frame++

    if (frame &gt; steps) {
      clearInterval(interval)
      //animationComplete();
    } else {
      increaseTransparency(imagedata, steps)
      context.putImageData(imagedata, 0, 0)
    }
  }, millisecondsPerStep)
}

// Animation.....................................................

function animationComplete() {
  setTimeout(function () {
    context.clearRect(0, 0, canvas.width, canvas.height)
  }, 1000)
}

fadeButton.onclick = function () {
  imagedataOffscreen = offscreenContext.getImageData(
    0,
    0,
    canvas.width,
    canvas.height
  )

  fadeIn(
    context,
    offscreenContext.getImageData(0, 0, canvas.width, canvas.height),
    50,
    1000 / 60
  )
}

// Initialization................................................

image.src = '../../shared/images/log-crossing.png'
image.onload = function () {
  offscreenCanvas.width = canvas.width
  offscreenCanvas.height = canvas.height
  offscreenContext.drawImage(image, 0, 0)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="046-图片操作---安全与性能"><a class="header" href="#046-图片操作---安全与性能">04.6-图片操作 - 安全与性能</a></h1>
<h2 id="一-安全问题"><a class="header" href="#一-安全问题">一 安全问题</a></h2>
<p>图像操作经常会带来安全问题，如需要对图片进行加密以保持不外泄。所以 canvas 虽然允许绘制不属于自己域中的图像，但不能对齐进行保存与修改。</p>
<p>canvas 的绘图安全机制如下：</p>
<p>每个 canvas 都以一个名为<code>rigin-clean</code>的标志位，初始值为 true。如果使用<code>drawImage()</code>绘制了一幅其他域中的图像，那么<code>origin-clean</code>的值就会设置为 false，如果此时在该 canvas 上调用<code>toDataURL()</code>，<code>getImageData()</code>等方法，浏览器会抛出 <code>SECURITY_ERR</code> 异常。</p>
<p>贴士：canvas 会将用户的文件系统与运行程序所在的环境视为 2 个不同的域，所以默认不能保存修改文件系统中的图像。如果要绕过该阻碍，通过在命令行中指定 <code>--allow-file-access-from-files</code> 参数来启动 chrome 浏览器。这个参数会让浏览器绕开绘图安全机制，以让开发者保存、修改其他域中的图像。</p>
<h2 id="二-性能问题"><a class="header" href="#二-性能问题">二 性能问题</a></h2>
<p>一般情况下，drawImage() 要比 putImageData() 快很多。</p>
<p>如果在绘制时还要对 canvas 进行缩放，则会更加耗时。</p>
<p>此外遍历图片的像素数据是极度耗时的，可以采取以下方法优化效率：</p>
<ul>
<li>避免在循环体内直接访问对象属性，而是将其存放在局部变量中</li>
<li>应该用循环计数器的方式来遍历完整的像素，而非像素分量</li>
<li>逆向遍历与位移（bit-shifting）技巧的效果并不好。</li>
<li>不要频繁的调用 getImageData() 来获取少量数据</li>
</ul>
<p>贴士：图像上护具每个像素都是 4 个 8 位二进制整数保存的，每个分量取值范围是 0-255，所以循环计数器每次进步都是像素个数的 4 倍。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-视频处理"><a class="header" href="#051-视频处理">05.1-视频处理</a></h1>
<h2 id="一-canvas-实现视频播放"><a class="header" href="#一-canvas-实现视频播放">一 canvas 实现视频播放</a></h2>
<p>canvas 的 drawImage() 方法也可以用来绘制视频的某一帧：</p>
<pre><code class="language-js">ctx.drawImage(video, 0, 0)
</code></pre>
<p>如果要实现视频播放，则需要先利用 video 标签播放不可见的视频文件，接着以播放动画循环形式将其绘制出来。每次循环利用<code>requesetNextAnimationFrame()</code> 函数将视频中的当前帧绘制到 canvas 中，以此来实现视频播放功能。</p>
<pre><code class="language-js">// html 部分
    &lt;video id='video' poster&gt;
       &lt;source src='Chrome_starts_fast_hammock.mp4'/&gt;
       &lt;source src='Chrome_starts_fast_hammock.ogg'/&gt;
    &lt;/video&gt;

    &lt;canvas id='canvas' width='720' height='405'&gt;
      Canvas not supported
    &lt;/canvas&gt;

window.requestNextAnimationFrame =
   (function () {
      var originalWebkitRequestAnimationFrame = undefined,
          wrapper = undefined,
          callback = undefined,
          geckoVersion = 0,
          userAgent = navigator.userAgent,
          index = 0,
          self = this;

      // Workaround for Chrome 10 bug where Chrome
      // does not pass the time to the animation function

      if (window.webkitRequestAnimationFrame) {
         // Define the wrapper

         wrapper = function (time) {
           if (time === undefined) {
              time = +new Date();
           }
           self.callback(time);
         };

         // Make the switch

         originalWebkitRequestAnimationFrame = window.webkitRequestAnimationFrame;

         window.webkitRequestAnimationFrame = function (callback, element) {
            self.callback = callback;

            // Browser calls the wrapper and wrapper calls the callback

            originalWebkitRequestAnimationFrame(wrapper, element);
         }
      }

      // Workaround for Gecko 2.0, which has a bug in
      // mozRequestAnimationFrame() that restricts animations
      // to 30-40 fps.

      if (window.mozRequestAnimationFrame) {
         // Check the Gecko version. Gecko is used by browsers
         // other than Firefox. Gecko 2.0 corresponds to
         // Firefox 4.0.

         index = userAgent.indexOf('rv:');

         if (userAgent.indexOf('Gecko') != -1) {
            geckoVersion = userAgent.substr(index + 3, 3);

            if (geckoVersion === '2.0') {
               // Forces the return statement to fall through
               // to the setTimeout() function.

               window.mozRequestAnimationFrame = undefined;
            }
         }
      }

      return window.requestAnimationFrame   ||
         window.webkitRequestAnimationFrame ||
         window.mozRequestAnimationFrame    ||
         window.oRequestAnimationFrame      ||
         window.msRequestAnimationFrame     ||

         function (callback, element) {
            var start,
                finish;

            window.setTimeout( function () {
               start = +new Date();
               callback(start);
               finish = +new Date();

               self.timeout = 1000 / 60 - (finish - start);

            }, self.timeout);
         };
      }
   )
();

var canvas = document.getElementById('canvas'),
    context = canvas.getContext('2d'),
    video = document.getElementById('video');

function animate() {
   if (!video.ended) {
     context.drawImage(video, 0, 0, canvas.width, canvas.height);
     window.requestNextAnimationFrame(animate);
   }
}

video.onload = function (e) {
   video.play();
   window.requestNextAnimationFrame(animate);
};

alert('This example plays a video, but due to copyright restrictions and size limitations, the video is not included in the code for this example. To make this example work, download a video, and replace the two source elements in example.html to refer to your video.');

</code></pre>
<h2 id="二-视频处理"><a class="header" href="#二-视频处理">二 视频处理</a></h2>
<pre><code class="language-js">window.requestNextAnimationFrame = (function () {
  var originalWebkitRequestAnimationFrame = undefined,
    wrapper = undefined,
    callback = undefined,
    geckoVersion = 0,
    userAgent = navigator.userAgent,
    index = 0,
    self = this

  // Workaround for Chrome 10 bug where Chrome
  // does not pass the time to the animation function

  if (window.webkitRequestAnimationFrame) {
    // Define the wrapper

    wrapper = function (time) {
      if (time === undefined) {
        time = +new Date()
      }
      self.callback(time)
    }

    // Make the switch

    originalWebkitRequestAnimationFrame = window.webkitRequestAnimationFrame

    window.webkitRequestAnimationFrame = function (callback, element) {
      self.callback = callback

      // Browser calls the wrapper and wrapper calls the callback

      originalWebkitRequestAnimationFrame(wrapper, element)
    }
  }

  // Workaround for Gecko 2.0, which has a bug in
  // mozRequestAnimationFrame() that restricts animations
  // to 30-40 fps.

  if (window.mozRequestAnimationFrame) {
    // Check the Gecko version. Gecko is used by browsers
    // other than Firefox. Gecko 2.0 corresponds to
    // Firefox 4.0.

    index = userAgent.indexOf('rv:')

    if (userAgent.indexOf('Gecko') != -1) {
      geckoVersion = userAgent.substr(index + 3, 3)

      if (geckoVersion === '2.0') {
        // Forces the return statement to fall through
        // to the setTimeout() function.

        window.mozRequestAnimationFrame = undefined
      }
    }
  }

  return (
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function (callback, element) {
      var start, finish

      window.setTimeout(function () {
        start = +new Date()
        callback(start)
        finish = +new Date()

        self.timeout = 1000 / 60 - (finish - start)
      }, self.timeout)
    }
  )
})()

var canvas = document.getElementById('canvas'),
  offscreenCanvas = document.createElement('canvas'),
  offscreenContext = offscreenCanvas.getContext('2d'),
  context = canvas.getContext('2d'),
  video = document.getElementById('video'),
  controlButton = document.getElementById('controlButton'),
  flipCheckbox = document.getElementById('flipCheckbox'),
  colorCheckbox = document.getElementById('colorCheckbox'),
  imageData,
  poster = new Image()

// Functions.....................................................

function removeColor() {
  var data, width, average

  imageData = offscreenContext.getImageData(
    0,
    0,
    offscreenCanvas.width,
    offscreenCanvas.height
  )

  data = imageData.data
  width = data.width

  for (i = 0; i &lt; data.length - 4; i += 4) {
    average = (data[i] + data[i + 1] + data[i + 2]) / 3
    data[i] = average
    data[i + 1] = average
    data[i + 2] = average
  }

  offscreenContext.putImageData(imageData, 0, 0)
}

function drawFlipped() {
  context.save()

  context.translate(canvas.width / 2, canvas.height / 2)
  context.rotate(Math.PI)
  context.translate(-canvas.width / 2, -canvas.height / 2)
  context.drawImage(offscreenCanvas, 0, 0)

  context.restore()
}

function nextVideoFrame() {
  if (video.ended) {
    controlButton.value = 'Play'
  } else {
    offscreenContext.drawImage(video, 0, 0)

    if (!colorCheckbox.checked) removeColor()

    if (flipCheckbox.checked) drawFlipped()
    else context.drawImage(offscreenCanvas, 0, 0)

    requestNextAnimationFrame(nextVideoFrame)
  }
}

function startPlaying() {
  requestNextAnimationFrame(nextVideoFrame)
  video.play()
}

function stopPlaying() {
  video.pause()
}

// Event handlers...............................................

controlButton.onclick = function (e) {
  if (controlButton.value === 'Play') {
    startPlaying()
    controlButton.value = 'Pause'
  } else {
    stopPlaying()
    controlButton.value = 'Play'
  }
}

poster.onload = function () {
  context.drawImage(poster, 0, 0)
}

// Initialization................................................

poster.src = '../../shared/images/smurfposter.png'

offscreenCanvas.width = canvas.width
offscreenCanvas.height = canvas.height

alert(
  'This example plays a video, but due to copyright restrictions and size limitations, the video is not included in the code for this example. To make this example work, download a video, and replace the two source elements in example.html to refer to your video.'
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-elecron-简介"><a class="header" href="#011-elecron-简介">01.1-Elecron 简介</a></h1>
<h2 id="一-electron-简介"><a class="header" href="#一-electron-简介">一 Electron 简介</a></h2>
<p>桌面客户端开发常用的库是：QT、GTK、MFC，他们都是基于 C++开发的，开发效率较低，虽然现在也有基于 Go、Py 的 QT，但是仍然存在一定的缺陷。</p>
<p>2011 年，中国英特尔的王文睿开发了 node-webkit 库，用来操作 Webkit，后开该项目失败，却衍生出了跨平台开发框架 NW.js，node-webkit 团队成员赵成到了 Github 团队后开发出了类 node-webkit 项目：Atom Shell，即 Electron 的前身。</p>
<p>NW.js 与 Electron 都是基于 Node、Webkit 这 2 种技术的跨平台（Win、Mac、Linux）桌面应用开发框架，通过该框架可以利用 HTML、CSS、JavaScript 等 web 前端技术来开发跨平台桌面应用，其理念是将 Chromium、Node 进行结合：</p>
<ul>
<li>Chromium Content Module：Chromium 的核心组件，包含浏览器核心功能：Blink 渲染引擎、JS 的 V8 引擎，以及提供在单独进程渲染 Web 页面、加速 GPU 等功能</li>
<li>Node.js 运行时：可以访问本地文件系统、创建服务器、从外部模块加载文件</li>
</ul>
<p>前者可以负责图形的渲染，后者可以实现对本地文件、网络的访问，互相补充，框架再封装一些系统对话框、托盘、菜单、剪切板等功能，就能基本上满足桌面客户端的所有功能。</p>
<p>但是这 2 个框架在整合 Chromium、Node 也有区别：</p>
<ul>
<li>NW.js：NW.js 修改了源码合并了 Chromium 和 Node 的事件循环机制，所以只有一个进程，所有窗口共享一个 Node.js 环境。</li>
<li>Electron：Electron 利用操作系统的消息循环机制打通 Chromium 和 Node，所以包含主进程、渲染进程，利用 ipc 实现进程间通信。</li>
</ul>
<p>Electron 现在社区更加活跃，库也更加丰富，其著名实现案例是 VSCode、Skype、国内的飞书。</p>
<h2 id="二-electron-的优劣"><a class="header" href="#二-electron-的优劣">二 Electron 的优劣</a></h2>
<p>Electron 的优势：</p>
<ul>
<li>可以很好的结合 Web 技术，以很快的速度开发出现代应用。如：css3、Html5、Vue、React。</li>
<li>Electron 也提供了很多官方、非官方的方案，如：实时 NoSQL 数据库 rxdb</li>
<li>无需关注 C++开发时需要注意的垃圾回收问题、繁多特性</li>
</ul>
<p>Electron 的劣势：</p>
<ul>
<li>打包体积大。</li>
<li>跨进程通信带来了开发上的难度</li>
<li>Chromium 带来的资源占用较大问题</li>
<li>一些安全性模块默认不可用，在不得不开启后，会引起一些安全隐患</li>
</ul>
<p>此外，Electron 不支持旧版系统，如 WindowsXP。</p>
<p>Electron 也有一些竞争者，不乏理念上不同的开发方式，如 PWA，PWA 无需像 Electron 这样还需要安装软件安装包，而是利用浏览器直接就能缓存一个本地客户端。但是 PWA 在不同操作系统支持度不同，其推广方 Google 目前也并未投入过多资源。</p>
<h2 id="三-electron-安装"><a class="header" href="#三-electron-安装">三 Electron 安装</a></h2>
<p>安装 Electron 需要确保电脑上已经安装 Node.js，最好是 8 版本以上</p>
<pre><code class="language-txt"># 由于国内环境，偶尔需要设置 electron 的代理
npm config set ELECTRON_MIRROR https://cdn.npm.taobao.org/dist/electron/

# 全局安装：全局安装后 electron 提供了 electron 命令。当然也可以本地项目中安装，需要借助 npm 脚本或者 npx 启用 electron
npm i electron -g
</code></pre>
<blockquote>
<p>贴士：笔者推荐在项目本地安装，所以此处全局安装可以忽略，只用注意代理即可。</p>
</blockquote>
<h2 id="三-electron-初体验"><a class="header" href="#三-electron-初体验">三 Electron 初体验</a></h2>
<h3 id="31-手动书写一个-helloworld重要"><a class="header" href="#31-手动书写一个-helloworld重要">3.1 手动书写一个 HelloWorld【重要】</a></h3>
<p>第一步：初始化一个项目：</p>
<pre><code class="language-txt"># 初始化项目
npm init

# 本地安装 electron
npm config set ELECTRON_MIRROR https://cdn.npm.taobao.org/dist/electron/
npm i electron -D

# 如果一直安装失败，则可以在 node_modules/electron 目录，创建一个 path.txt 文本文件
    Win 上，该文本文件输入内容：electron.exe
    Mac 上，该文本文件输入内容：Electron.app/Contents/MacOS/Electron
  然后手动从阿里镜像网站下载对应版本的 Electron 压缩包，解压到 node_modules/electron/dist
</code></pre>
<p>第二步：初始化项目中的文件</p>
<ul>
<li><code>main.js</code>：项目入口文件</li>
<li><code>index.html</code>：软件打开时默认显示的页面，该文件内容书写一个 <code>hello world</code> 即可</li>
<li><code>package.json</code>：node 项目初始化后默认配置文件</li>
</ul>
<p>第三步：书写 main.js 内容，用来创建窗口</p>
<pre><code class="language-js">const { app, BrowserWindow } = require('electron')

let mainWindow

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1024,
    height: 680,
    webPreferences: {
      nodeIntegration: true,
    },
  })

  // 根据开发环境设置加载地址，build 模式下直接加载 build 文件中的 index.html 即可
  // 生产打包文件地址：file://${path.join(__dirname, './build/index.html')}
  const urlLocation = 'http://localhost:3000'
  mainWindow.loadURL(urlLocation)
  mainWindow.webContents.openDevTools()

  if (process.platform !== 'darwin') {
    app.quit()
  }
}

app.on('ready', createWindow)

app.on('activate', function () {
  // macOS 中点击 Dock 图标时没有已打开的其余应用窗口时，则通常在应用中重建一个窗口
  if (mainWindow === null) {
    createWindow()
  }
})
app.on('window-all-closed', () =&gt; {
  app.quit()
})
</code></pre>
<p>第四步：运行</p>
<pre><code class="language-txt"># 直接运行 npx electron . # 为了简便，也可以使用 npm 脚本运行 #
在 package.json 中的 script 内添加一行脚本： &quot;start&quot;: &quot;electron .&quot; npm start
</code></pre>
<h3 id="32-js-脚本的引入"><a class="header" href="#32-js-脚本的引入">3.2 js 脚本的引入</a></h3>
<p>在 index.html 中可以像普通的前端开发一样，直接使用 script 脚本引入其他的 js 文件即可：</p>
<pre><code class="language-html">&lt;!-- 在根本目创建一个 lib.js，内容如下：  --&gt;
window.data = { key: 'value' }

&lt;!-- 在 index.html 中使用：  --&gt;
&lt;script src=&quot;./lib.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  alert(data.key)
&lt;/script&gt;

&lt;!-- ctrl+c 停止运行后重新运行：  --&gt;
npm start
</code></pre>
<p>但是这里也可以直接利用 Node 的能力来引入，需要提前做配置：main.js 中如下创建：</p>
<pre><code class="language-js">mainWindow = new BrowserWindow({
  webPreferences: { nodeIntegration: true }, // 该配置会让页面继承 Node 环境，网页中的 js 可以使用 Node,Web 网页不推荐，会引起安全问题
})
</code></pre>
<p>lib.js 的文件内容：</p>
<pre><code class="language-js">module.exports = {
  key: 'value',
}
</code></pre>
<p>此时其他的 js 文件在 index.html 就可以使用如下方式引入：</p>
<pre><code class="language-html">&lt;script&gt;
  let data = require('./lib')
  alert(data.key)
&lt;/script&gt;
</code></pre>
<p>贴士：</p>
<ul>
<li>开启 <code>nodeIntegration</code> 后 jQuery 的引入方式为：<code>window.$ = window.jQuery = require('./jquery.js')</code></li>
<li>Electron 项目不推荐使用 jQuery，和性能优化有关！</li>
</ul>
<h3 id="33-使用官方示例"><a class="header" href="#33-使用官方示例">3.3 使用官方示例</a></h3>
<p>也可以直接使用官网的 quick start 案例：</p>
<pre><code class="language-txt">git clone https://github.com/electron/electron-quick-start cd
electron-quick-start npm install &amp;&amp; npm start
</code></pre>
<h2 id="四-electron-electron-api"><a class="header" href="#四-electron-electron-api">四 Electron Electron API</a></h2>
<p>Electron API 项目集成了大量官方的 API 演示案例，<a href="https://github.com/electron/electron-api-demos">网址</a>为：<a href="https://github.com/electron/electron-api-demos">https://github.com/electron/electron-api-demos</a></p>
<h2 id="五-electron-集成现代框架"><a class="header" href="#五-electron-集成现代框架">五 Electron 集成现代框架</a></h2>
<h3 id="51-electron-集成-vue"><a class="header" href="#51-electron-集成-vue">5.1 Electron 集成 Vue</a></h3>
<p>Vue 集成 Electron，不需要使用示例项目，其 cli 工具直接支持：</p>
<pre><code class="language-txt"># 安装 vue cli 工具
npm i @vue/cli -g

# 创建项目
vue create project

# 进入项目后，集成 electron
vue add electron-builder  # 添加 background.js 为主进程入口，main.js 是渲染进程入口

# 贴士：该步骤容易因为网络原因卡住，可以切换源，或者使用 yarn -add -D electron-chromedriver

# 启动 npm run
electron:serve
</code></pre>
<p>bug 解决：此时国内环境是无法直接启动的，是因为要安装 dev-tools，这个需要翻墙，可以暂时注释</p>
<pre><code class="language-js">// 注释掉 src / background.js 中的以下代码就行了;
// if (isDevelopment &amp;&amp; !process.env.IS_TEST) {
//   // Install Vue Devtools
//   try {
//     await installVueDevtools();
//   } catch (e) {
//     console.error(&quot;Vue Devtools failed to install:&quot;, e.toString());
//   }
// }
</code></pre>
<p>其他 bug 解决：<a href="https://www.psvmc.cn/article/2019-11-05-vue-cli3-electron.html">https://www.psvmc.cn/article/2019-11-05-vue-cli3-electron.html</a></p>
<h3 id="52-electron-与-vue-element-admin-的集成示例"><a class="header" href="#52-electron-与-vue-element-admin-的集成示例">5.2 Electron 与 vue-element-admin 的集成示例</a></h3>
<p>该示例可以直接启动，在 .vscode 目录中创建了调试工具环境：
<a href="https://github.com/ry-cli/electron-vue-element-admin">https://github.com/ry-cli/electron-vue-element-admin</a></p>
<h3 id="53-electron-集成-react"><a class="header" href="#53-electron-集成-react">5.3 Electron 集成 React</a></h3>
<p>原生继承示例：使用 create-react-app 工具创建 react 项目，进入该项目手动后集成 electron：</p>
<pre><code class="language-txt"># 第一步：安装 electron，以及一些需要的软件
npm i electron -D

# 第二步：项目根目录（src 同级目录）创建 main.js，内容与 3.1 相同

# 第三步：增加 package.json 键值对：此时当 yarn start 后，再运行 electron . 项目初级结构已经完成
&quot;main&quot;: &quot;main.js&quot;,          // 设定入口文件
&quot;homepage&quot;: &quot;./&quot;,           // 解决 electron file 协议导致生产环境加载 index.html 资源 404 问题

# 第四步：配置 electron 的启动项脚本。如果想要启动时开启浏览器，则可以移除 cross-env BROWSER=none
npm i concurrently -D    用来运行跨平台脚本，并支持一个 npm 脚本中运行多个命令
npm i wait-on -D         用来等待 web 服务启动后才启动 electron
npm i cross-env -D       用来执行一些跨平台命令
&quot;dev&quot;: &quot;concurrently \&quot;wait-on http://localhost:3000 &amp;&amp; electron .\&quot; \&quot;cross-env BROWSER=none npm start\&quot;&quot;,
</code></pre>
<p>目前较为活跃的集成示例是：<a href="https://github.com/electron-react-boilerplate/electron-react-boilerplate">https://github.com/electron-react-boilerplate/electron-react-boilerplate</a></p>
<p>当然为了规避 Electron 打包体积大，提升性能，推荐使用：ProtonNative(<a href="https://github.com/kusti8/proton-native)">https://github.com/kusti8/proton-native)</a>，该项目优点：</p>
<ul>
<li>与 ReactNative 语法一直，可以使用 React 生态，如 Redux</li>
<li>也可以使用 Node.js 生态中的包</li>
<li>组件为系统原生组件，不再是浏览器</li>
</ul>
<h3 id="54-electron-集成-angular"><a class="header" href="#54-electron-集成-angular">5.4 Electron 集成 Angular</a></h3>
<p>目前较为活跃的集成示例是：<a href="https://github.com/maximegris/angular-electron">https://github.com/maximegris/angular-electron</a></p>
<h3 id="55-electron-集成-webpack"><a class="header" href="#55-electron-集成-webpack">5.5 Electron 集成 Webpack</a></h3>
<p>很少用到单独集成 Webpack 的项目，为了以防万一，直接按照该示例操作即可：<a href="https://github.com/ry-cli/electron-webpack">https://github.com/ry-cli/electron-webpack</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-electron-进程"><a class="header" href="#021-electron-进程">02.1-Electron 进程</a></h1>
<h2 id="一-electron-中的主进程与渲染进程"><a class="header" href="#一-electron-中的主进程与渲染进程">一 Electron 中的主进程与渲染进程</a></h2>
<p>一个 Electron 应用只有一个主进程，但可以有多个渲染进程：</p>
<ul>
<li>主进程：由 Electron 创建，并从口文件开始执行代码的进程。主进程用来监听程序的生命周期事件、管理窗口（渲染进程）、加载页面、程序关闭后回收资源等。</li>
<li>渲染进程：一个 BrowserWindow 实例代表一个渲染进程，若该实例被销毁，则渲染进程也会终结。渲染界面负责完成界面渲染、接收用户输入、响应用户交互。</li>
</ul>
<p><img src="%E9%99%84%E5%BD%95-Electron/./../images/node/electron-00.svg" alt="electron 应用架构" /></p>
<p>在 HelloWorld 示例中，<code>electron .</code> 的入口文件是 <code>main.js</code> 文件中的代码，即启动了一个进程，并且执行该代码，创建了窗口、加载了<code>index.html</code>，而<code>index.html</code>中的代码则会运行在 Electron 的渲染进程中。</p>
<p>贴士：</p>
<ul>
<li>主进程负责管理所有窗口及其对应的渲染进程，开启 <code>nodeIntegration</code> 后，渲染进程也有能力访问 Node 的 API。</li>
<li>GUI 的操作，如：创建窗口、创建菜单只能在主进程中完成，如果需要渲染进程来执行创建，必须让渲染进程发送消息给主进程，主进程接收到消息后执行创建，也可以使用 remote 模块来完成。</li>
</ul>
<p>Electron 中模块的归属：</p>
<pre><code class="language-txt">主进程模块：app、BrowserView、autoUpdater、contentTracing、dialog、gloablShortcut、ipcMainMenu、
            MenuItem、net、netLog、Notification、powerMonitor、powerSaveBlocker、protocol、screen、session、systemPreferences、TouchBar、Tray、webContents

渲染进程模块：desktopCapturer。ipcRenderer、remote、webFrame

公用模块：clipboard、crashReporter、nativeImage、shell
</code></pre>
<h2 id="二-进程调试"><a class="header" href="#二-进程调试">二 进程调试</a></h2>
<h3 id="21-调试主进程"><a class="header" href="#21-调试主进程">2.1 调试主进程</a></h3>
<p>点击 vscode 的左侧 debug 图标，接着点击 <code>create a launch.json file</code>，选择弹出的 <code>Node</code> 选项，此时会在根目录创建文件：<code>.vscode/launch.json</code>，内容可以修改为如下所示：</p>
<pre><code class="language-json">{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      &quot;type&quot;: &quot;node&quot;,
      &quot;request&quot;: &quot;launch&quot;,
      &quot;name&quot;: &quot;调试主进程&quot;,
      &quot;skipFiles&quot;: [&quot;&lt;node_internals&gt;/**&quot;],
      &quot;program&quot;: &quot;${workspaceFolder}/main.js&quot;,
      &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
      &quot;runtimeExecutable&quot;: &quot;${workspaceRoot}/node_modules/.bin/electron&quot;,
      &quot;windows&quot;: {
        &quot;runtimeExecutable&quot;: &quot;${workspaceRoot}/node_modules/.bin/electron.cmd&quot;
      },
      &quot;args&quot;: [&quot;.&quot;],
      &quot;outputCapture&quot;: &quot;std&quot;
    }
  ]
}
</code></pre>
<p>配置解释：</p>
<pre><code class="language-txt">name：用于识别启动项目 type：调试环境，这里是 Node
runtimeExecutable：指向批处理文件，用于启动 Electron
${workspaceRoot}：正在进行调试的程序的工作目录的绝对路径
args：启动参数，这里简写为 . ，其实是 index.js
</code></pre>
<p>配置完毕后，设置一个端点，在 debug 界面，即可点击绿色三角开始调试，如图所示：<br />
<img src="%E9%99%84%E5%BD%95-Electron/../images/electron/01.png" alt="electron debug 1" /></p>
<p>调试结果如图所示，鼠标移入对象时，可以显示其属性，也可以在底部的调试栏中输入对象（示例中是 mainWindow）：</p>
<p><img src="%E9%99%84%E5%BD%95-Electron/../images/electron/02.png" alt="electron debug 2" /></p>
<h3 id="22-调试渲染进程"><a class="header" href="#22-调试渲染进程">2.2 调试渲染进程</a></h3>
<p>渲染进程的调试工机具其实就是 Chrome 开发者工具，使用命令：<code>Ctrl+Shift+I</code>可以打开，Mac 下为：<code>Command+Option+I</code>。</p>
<p>也可以在<code>main.js</code>的代码中手动添加打开代码：</p>
<pre><code class="language-js">// 打开开发者工具，书写在 loadFile 函数之后
mainWindow.webContents.openDevTools()
</code></pre>
<h3 id="23-浏览器-debug-主进程"><a class="header" href="#23-浏览器-debug-主进程">2.3 浏览器 debug 主进程</a></h3>
<p>浏览器也可以用来调试主进程。在启动脚本中添加如下参数：</p>
<pre><code class="language-txt">&quot;dev&quot;: &quot;electron --inspect=5858 .&quot;
</code></pre>
<p>Electron 项目启动后，打开 Chrome 浏览器，输入 <code>chrome://inspect</code>，点击 <code>Configure</code> 后，输入配置的端口 <code>localhost:5858</code> 即可，此时浏览器会连接该程序。</p>
<h2 id="三-进程间的消息传递"><a class="header" href="#三-进程间的消息传递">三 进程间的消息传递</a></h2>
<h3 id="30-electron-进程通信机制"><a class="header" href="#30-electron-进程通信机制">3.0 Electron 进程通信机制</a></h3>
<p>Electron 使用 IPC（interprocess communication）在进程之间进行通信。</p>
<p><img src="%E9%99%84%E5%BD%95-Electron/../images/electron/03.png" alt="electron debug 2" /></p>
<h3 id="31-渲染进程向主进程发送消息"><a class="header" href="#31-渲染进程向主进程发送消息">3.1 渲染进程向主进程发送消息</a></h3>
<p><code>index.html</code>中发送数据：</p>
<pre><code class="language-html">&lt;button id=&quot;btn&quot;&gt;操作&lt;/button&gt;
&lt;script&gt;
  const { ipcRenderer } = require('electron')
  document.querySelector('#btn').addEventListener('click', function () {
    ipcRenderer.send('msg_renderUsers', { name: 'lisi' }, { age: 30 }) // 参数可以是多个
  })
&lt;/script&gt;
</code></pre>
<p>注意：<strong>如果出现类似 fs. 错误，则使用 window.require() 即可</strong></p>
<p>主进程 <code>main.js</code>中接收数据：</p>
<pre><code class="language-js">// 主进程添加的消息处理代码
let { ipcMain } = require('electron')
ipcMain.on('msg_renderUsers', (event, param1, param2) =&gt; {
  // event.sender 是渲染进程的 webContents 实例
  console.log('param1：', param1)
  console.log('param2：', param2)
})
</code></pre>
<p>上述示例在 vscode 的调试模式下，即可在控制台看到打印。这里第一个参数即消息管道的名称，渲染进程的发送管道与主进程的接收管道必须一致，才能进行通信。当然也可以多处监听同一管道的代码，此时若该管道消息发来，则会触发多处监听事件。</p>
<p>无论是渲染进程和主进程谁主动发送，其背后的原理都是进程间通信：<strong>发送的 json 对象被序列化，然后反序列化！所以发送对象原型链上的数据不会被发送</strong>。</p>
<p>上述传递消息的方式是异步的，使用<code>ipcRenderer.sendSyc</code>可以同步发送，但是会阻塞渲染进程。</p>
<h3 id="32-主进程向渲染进程发送消息"><a class="header" href="#32-主进程向渲染进程发送消息">3.2 主进程向渲染进程发送消息</a></h3>
<p>主进程 <code>main.js</code> 代码：</p>
<pre><code class="language-js">let { ipcMain } = require('electron')
ipcMain.on('msg_renderUsers', (event, param1, param2) =&gt; {
  console.log('param1：', param1)
  console.log('param2：', param2)
  param2.age += 100
  mainWindow.webContents.send('msg_main2View', param1, param2)
})
</code></pre>
<p>渲染进程中接收：</p>
<pre><code class="language-html">&lt;button id=&quot;btn&quot;&gt;操作&lt;/button&gt;
&lt;script&gt;
  const { ipcRenderer } = require('electron')
  document.querySelector('#btn').addEventListener('click', function () {
    ipcRenderer.send('msg_renderUsers', { name: 'lisi' }, { age: 30 })
  })
  ipcRenderer.on('msg_main2View', (event, param1, param2) =&gt; {
    console.log('param1：', param1)
    console.log('param2：', param2)
  })
&lt;/script&gt;
</code></pre>
<p>上述代码完成了主进程向渲染进程发送消息，渲染进程监听的效果。</p>
<h3 id="33-多个渲染窗口响应主进程消息"><a class="header" href="#33-多个渲染窗口响应主进程消息">3.3 多个渲染窗口响应主进程消息</a></h3>
<p>如果打开了新的窗口，新窗口加载同样的页面，设置同样的监听函数，如果主进程再次发送消息，这个新窗口是不会触发监听事件的，因为主进程中使用的是<code>mainWindow.webContents.send</code>。</p>
<p>主进程接收消息事件的<code>event.sender</code>代表发送消息的渲染进程的<code>webContents</code>，可以通过该对象来给对应窗口发送消息：</p>
<pre><code class="language-js">ipcMain.on('msg_renderUsers', (event, param1, param2) =&gt; {
  console.log('param1：', param1)
  console.log('param2：', param2)
  param2.age += 100
  event.sender.send('msg_main2View', param1, param2) // 也可以同理使用：event.reply(&quot;msg_main2View&quot;, param1, param2)
})
</code></pre>
<p>贴士：对于同步消息来说，其发送的返回值即是主进程响应的消息，如：<code>let res = ipcRenderer.sendSync('msg', {name: &quot;lisi&quot;})</code></p>
<h3 id="34-渲染进程之间消息传递"><a class="header" href="#34-渲染进程之间消息传递">3.4 渲染进程之间消息传递</a></h3>
<p>多个窗口之间进行消息传递，最常见的方式是：通过主进程进行中转。因为往往需要传递的时候，正式窗口新建立的时候。</p>
<p>如果已经得知要接收消息的窗口的<code>webContents</code>的 id，也可以直接传递：</p>
<pre><code class="language-js">ipcRenderer.sendTo(win.webContents.id, 'msg', { name: 'lisi' }) // win 即目标窗口
</code></pre>
<h2 id="四-remote-模块"><a class="header" href="#四-remote-模块">四 remote 模块</a></h2>
<h3 id="41-remote-模块访问主进程"><a class="header" href="#41-remote-模块访问主进程">4.1 remote 模块访问主进程</a></h3>
<p>remote 模块可以帮助开发者在渲染进程中访问主进程对象。</p>
<p>在<code>index.html</code>中增加如下代码：</p>
<pre><code class="language-html">&lt;button id=&quot;openView&quot;&gt;打开百度&lt;/button&gt;
&lt;script&gt;
  const { remote } = require('electron')
  const BrowserWindow = remote.BrowserWindow
  document.querySelector('#openView').addEventListener('click', function () {
    let win = new BrowserWindow({ width: 800, height: 600 })
    win.loadURL('https://www.baidu.com')
  })
&lt;/script&gt;
</code></pre>
<p>重启或者重新调试，即可看到界面。但是这里要注意的是<strong>由于安全原因，Electron10 默认关闭了 remote，需要开启</strong>，开启方式是在<code>main.js</code>中添加：</p>
<pre><code class="language-js">mainWindow = new BrowserWindow({
  webPreferences: {
    nodeIntegration: true, // 允许界面使用 node
    enableRemoteModule: true, // 开启 remote 模块，Electron10 这里默认是 false
  },
})
</code></pre>
<p>remote 对象的属性和方法都是主进程的属性和方法的映射，使用 remote 访问主进程时，Electron 内部会构造一个消息，这个消息从渲染进程传送给主进程，主进程完成操作后，再以远程对象的形式传递给渲染进程。</p>
<p>上述代码中，新的 <code>BrowserWindow</code> 并不是渲染进程创建的，remote 模块通知主进程，主进程完成窗口实例的创建后，以实例以远程对象的形式返回给渲染进程。这些工作是 Electron 内部完成的！</p>
<h3 id="42-remote-模块局限性"><a class="header" href="#42-remote-模块局限性">4.2 remote 模块局限性</a></h3>
<p>remote 模块可以降低主进程与渲染进程之间访问的难度，但是也带来了相当多的问题，在 Electron10 中，该模块已经被默认关闭：</p>
<ul>
<li>性能损耗很大：跨进程操作的性能损耗是计算机中最严重的性能消耗点之一。</li>
<li>容易产生错误：</li>
<li>如：remote 模块使用了主进程某个对象，该对象在某一时刻会触发事件，但是事件处理程序位于渲染进程，这时候消息传递造成的延时很容易让渲染进程中一些代码失效，如：<code>event.preventDefault()</code></li>
<li>如：remote 模块的对象其实是代理对象，并不是真实的原始对象。代理对象原型链上的属性不会映射到渲染进程的代理对象上。其次，类似 NaN、Infinity 这些值不能被正确的映射到渲染进程，如果一个主进程方法返回 NaN，则渲染进程 remote 模块获取的是 undefined。</li>
<li>安全问题：IPC 管道通信时，如果要加载第三方网页，恶意代码能够通过原型污染攻击来模拟 remote 模块的远程消息，以获取访问主进程模块的权利，从而逃离沙箱。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-electron-数据存储"><a class="header" href="#031-electron-数据存储">03.1-Electron 数据存储</a></h1>
<h2 id="一-electron-数据存储"><a class="header" href="#一-electron-数据存储">一 Electron 数据存储</a></h2>
<h3 id="11-本地文件存储"><a class="header" href="#11-本地文件存储">1.1 本地文件存储</a></h3>
<p>Electron 操作本地数据采用了 Node.js 的 API，利用 <code>fs</code> 包可以直接操作文件，但是该包删除子目录需要递归，这里有个第三方库 <code>fs-extra</code> 操作文件的 API 封装的更好。</p>
<p>在桌面系统中，客户端的本地文件有系统默认的位置：</p>
<pre><code class="language-txt">Win：   C:\Users\[user name]\AppData\Roaming\
Linux： /home/[user name]/.config/
Mac：   /Users/[user name]/Library/Appication Support/
</code></pre>
<p>获取该路径的 API 为：</p>
<pre><code class="language-js">// 根据参数不同获取不同的路径，参数 userData 用来获取操作系统默认数据存储目录地址 + 应用名 (package.json 中的 name)
app.getPath('userData')

// 其他参数都是获取对应路径：desktop、documents、downloads、video、music、appData（自定义数据目录）、temp、exe（当前程序执行路径）

// 也可以允许用户自定义数据存储路径，同理第一个参数也可以选择上述参数
app.setPath('appData', 'D:\\mydata')
</code></pre>
<p>当然获取目录也可以借助 Node.js 的能力：</p>
<pre><code class="language-js">require('os').homedir() // 返回当前用户主目录：C:\Users\[user name]
require('os').tpmdir() // 返回默认临时文件夹：C:\Users\[user name]\AppData\Local\Temp
</code></pre>
<p>本地文件如果是 JSON 格式，则可以使用第三方库 <a href="https://github.com/typicode/lowdb)">https://github.com/typicode/lowdb)</a></p>
<h3 id="12-利用浏览器存储机制"><a class="header" href="#12-利用浏览器存储机制">1.2 利用浏览器存储机制</a></h3>
<p>浏览器的存储机制主要有四个：</p>
<ul>
<li>cookie：最多只能存储 4KB 数据，数据有过期时间，数据也会被传递到服务端</li>
<li>LocalStorage：最多只能存储 10M 数据，数据没有过期时间，数据不会自动随浏览器传递到服务端</li>
<li>SessionStorage：特性与 LocalStorage 相同，但是只是会话存储，浏览器关闭后，数据也会清除</li>
<li>IndexDB：基于 JavaScript 的面向对象数据库存储，可以用于存储大量数据，推荐使用第三方库：<a href="https://github.com/dfahlander/Dexie.js">Dexie.js</a>、<a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a>、<a href="https://pouchdb.com/">https://pouchdb.com/</a>(类似 CouchDB 的强大数据库，上手成本高)</li>
</ul>
<p>浏览器原生的 document 可以访问 cookie，但是一旦 cookie 受限，则无法继续操作。Electron 提供了独立的 cookie 操作 API，可以用来访问受限的 cookie：</p>
<pre><code class="language-js">const { remote } = require(&quot;electron&quot;);

// 获取 cookie
let getCookie = async function (key) {
  let cookies = await remote.session.defaultSession.cookies.get({ key });
  if (cookies.length &gt; 0) {
    return cookies[0].value;
  } else {
    return &quot;&quot;;
  }
};

// 设置 cookie：参数是 cookie 对象，包含 cookie 常见属性，以及 HttpOnly、secure 等
// 这两个属性可以保护 cookie，secure 只允许 https 方式，以防止第三方嗅探。HttpOnly 用来防止 XSS 跨站脚本攻击
  await remote.session.defaultSession.cookies.set(cookie);
};

// 清空浏览器缓存
let clearCookie = async function(){
    remote.session.defaultSession.clearStorageData({
        storage: 'cookies, localstorage'
    });
}
</code></pre>
<p>上述代码运行在渲染进程中，defaultSession 是当前浏览器的会话实例。获取当前页面的 session 方式如下：</p>
<pre><code class="language-js">let session = win.webContents.session
</code></pre>
<h3 id="13-第三方存储"><a class="header" href="#13-第三方存储">1.3 第三方存储</a></h3>
<p>一些轻量级的第三方数据库也可以直接安装在 Electron 内：</p>
<ul>
<li>SQLite：轻量关系型数据库，常用于客户端存储方案。推荐驱动为 knex.js</li>
<li>rxdb：可以运行在浏览器中的实时数据库！支持订阅数据变更事件。在 Electron 中，操作一个窗口数据，无需发消息给另外一个窗口，那个窗口可以通过数据变更事件获悉变更的内容！git 仓库为：<a href="https://github.com/pubkey/rxdb">https://github.com/pubkey/rxdb</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-electron-通信"><a class="header" href="#041-electron-通信">04.1-Electron 通信</a></h1>
<h2 id="一-electron-中的一些通信常识"><a class="header" href="#一-electron-中的一些通信常识">一 Electron 中的一些通信常识</a></h2>
<p>Electron 的通信可以依赖于浏览器的 Ajax 能力，也可以依赖 Node.js 的能力，但是在使用 Ajax 时会遇到跨域问题，Electron 可以实现禁用同源策略：</p>
<pre><code class="language-js">let win = new BrowserWindow({
  webPreferences: {
    // ... 其他配置
    webSecurity: false, // 禁用当前窗口的同源策略
    // 此外还可以在 HTTPS 页面内访问 HTTP 协议服务
    allowRunningInsecureContent: true,
  },
})
</code></pre>
<p>贴士：大部分数据请求都发生在渲染进程，所以可以尽量避免使用 Node.js 的能力。此外 Electron 也封装了 net 模块用来进行网络请求。</p>
<p>笔者这里建议使用<strong>axios</strong>，它同时支持 Node 与浏览器环境！有条件的，也推荐使用 H5 提供 Fetch。</p>
<p>在一些场景中，还需要截获并修改网络请求，比如为第三方网页注入一个脚本，让这个脚本修改 XMLHttpRequest 对象，并获取第三方网页 Ajax 请求后的数据：</p>
<pre><code class="language-js">// 先将原始的 open 方法保存起来
let open = window.XMLHttpRequest.prototype.open

window.XMLHttpRequest.prototype.open = function (method, url, params) {
  this.addEventListener(
    'readystatechange',
    () =&gt; {
      if (this.readyState === 4 &amp;&amp; this.status === 200) {
        console.log(this.responseText) // 打印截获的服务端数据
      }
    },
    false
  )
  // 自定义的 open 调用完毕后，再用原来的 open 方法再次调用
  open.apply(this, arguments)
}
</code></pre>
<p>上述方法也有局限性：无法截获静态文件请求、无法修改响应数据，此时可以使用 Electron 提供的方法：</p>
<pre><code class="language-js">this.wind.webContents.session.webRequest.onBeforeRequest(
  { urls: ['https://*/*'] },
  (details, cb) =&gt; {
    if (details.url === 'https://demo.com/demo.css') {
      cb({ redirectURL: 'http://redirectdemo.com/demo.css' })
    } else {
      cb(null)
    }
  }
)
</code></pre>
<h2 id="二-electron-与系统其他应用通信"><a class="header" href="#二-electron-与系统其他应用通信">二 Electron 与系统其他应用通信</a></h2>
<p>Electron 没有提供与操作系统内其他应用通信的 API，需要借助 IPC 命名管道来实现：</p>
<p>lectron 内创建一个命名管道，用来接收数据示例：</p>
<pre><code class="language-js">const net = require('net')

const PIPE_NAME = '\\\\.\\ pipe\\ mypipe'

const server = net.createServer((conn) =&gt; {
  conn.on('data', (r) =&gt; {
    console.log('receive:', r.toString())
  })

  conn.on('end', () =&gt; {
    console.log('client close')
  })

  conn.write('client ready, starting to send data!')
})

server.on('end', () =&gt; {
  console.log('server close')
})

// 创建一个命名管道 server，一旦有客户端连接此管道，则触发 createServer 的回调函数
server.listen(PIPE_NAME, () =&gt; {
  console.log('Server is ready')
})
</code></pre>
<p>Electron 应用向其他应用开启的管道发送数据示例：</p>
<pre><code class="language-js">const net = require('net')

const PIPE_NAME = '\\\\.\\ pipe\\ mypipe'

const client = net.connect(PIPE_NAME, () =&gt; {
  console.log('connect success')
  client.write('send data...')
})

client.on('data', (r) =&gt; {
  console.log('receive:', r.toString())
  client.end('close client')
})

client.on('end', () =&gt; {
  console.log('Client end...')
})
</code></pre>
<h2 id="三-electron-与-网页通信"><a class="header" href="#三-electron-与-网页通信">三 Electron 与 网页通信</a></h2>
<p>网页环境是一个沙箱环境，无法使用命名管道方式来实现通信，这里其实可以曲线救国：可以在 Electron 内启动一个 HTTP 服务、Websocket 服务来和网页通信。</p>
<h2 id="四-自定义协议"><a class="header" href="#四-自定义协议">四 自定义协议</a></h2>
<p>在 Electron 内部开启 http 服务器会产生额外的消耗，FTP 协议在使用上不能很好支持路径查找，这时候往往需要自定义协议。Electron 允许开发者自定义一个类似 HTTP、FTP 的协议，一旦应用内出现该协议请求，则可以进行拦截、处理、响应请求：</p>
<pre><code class="language-js">// 以下代码需要在程序启动前设置（ready 前）
const { protocol } = require('electron')

const option = [
  {
    scheme: 'app', // 协议名称
    privileges: { secure: true, standard: true },
  },
]

protocol.registerSchemesAsprivileged(option)
</code></pre>
<p>注册该协议：</p>
<pre><code class="language-js">const { protocol } = require('electron')
const path = require('path')
const fs = require('fs')

// 主持一个基于缓冲区的协议：当用户发起类似”app://”开头的请求时，此回调函数会截获用户的请求，完成一个静态服务
protocol.registerBufferProtocol(
  'app',
  (req, respond) =&gt; {
    let pathName = new URL(req.url).pathname
    let fullName = path.join(__dirname, pathName)
    fs.readFile(fullName, (err, data) =&gt; {
      if (err) {
        console.log(err)
        return
      }
      let ext = path.extname(pathName).toLowerCase()
      let mimeType = ''
      if (ext === '.js') {
        mimeType = 'text/javascript'
      } else if (ext === '.html') {
        mimeType = 'text/html'
      } else if (ext === '.css') {
        mimeType = 'text/css'
      }
      respond({ mimeType, data })
    })
  },
  (error) =&gt; {
    if (error) {
      console.log(error)
    }
  }
)
</code></pre>
<h2 id="五-代理"><a class="header" href="#五-代理">五 代理</a></h2>
<p>假如在一个域内，有电脑 A 和电脑 B，电脑 A 不能访问外网，但是电脑 B 可以，如果要实现电脑 A 也能访问外网，那么只需要将电脑 A 的网络代理到电脑 B 即可，常用的代理有 HTTP 代理、HTTPS 代理、socks 代理。socks 代理隐蔽性更高、效率更高，推荐使用。</p>
<p>socks5 的适用性更强，使用方式如下：</p>
<pre><code class="language-js">let result = await win.webContents.session.setProxy({
  proxyRules: 'socks5://192.168.1.101',
})
</code></pre>
<p>如果要给整个应用程序设置代理，则可以如下设置：</p>
<pre><code class="language-js">app.commandLine.appendSwitch('proxy-server', 'socks://192.168.1.101')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-electron-界面"><a class="header" href="#051-electron-界面">05.1-Electron 界面</a></h1>
<p>窗口类似于整个客户端软件的框架结构，界面则是框架内内容区域。</p>
<h2 id="一-页面内容-webcontents"><a class="header" href="#一-页面内容-webcontents">一 页面内容 webContents</a></h2>
<h3 id="11-获取-webcontents-实例"><a class="header" href="#11-获取-webcontents-实例">1.1 获取 webContents 实例</a></h3>
<p>webContents 是 Electron 内真正渲染展示 Web 界面的地方，也即内容区域，大量的交互都在此处。</p>
<p>获取方式：</p>
<pre><code class="language-js">// 通过窗口可以直接获取 webContents 实例
const webContent = win.webContent

// 获取处于激活状态的 webContents
const actWebContent = electron.webContents.getFocusedWebContents()

// 通过渲染进程获取 webContents
webContent = remote.getCurrentWebContents()

// 每次创建窗口时，窗口都有一个制度的整型 id 值，也可以获取页面内容
webContent = electron.webContents.fromId(yourID)

// 下策：还可以通过遍历所有内容，一一对比方式
const webContentArr = electron.webContents.getAllWebContents()
</code></pre>
<h3 id="12-事件的加载与触发顺序"><a class="header" href="#12-事件的加载与触发顺序">1.2 事件的加载与触发顺序</a></h3>
<p>Electron 中页面加载的事件顺序：</p>
<pre><code class="language-txt">id-start-loading：页面加载中的第一个事件，浏览器的 tab 页图标开始旋转
page-title-update：页面标题更新。处理函数的第二个参数为当前页面标题
dom-ready：页面中的 dom 加载完毕。其本质是网页的事件 DOMContentLoaded。
                        该事件与页面中的 iframe 无关，但是如果有 script 标签则需要等待脚本加载完毕后触发，
                        若 script 标签之前还有 css 资源，则还需要等待 CSS 资源的加载。
                        若没有 script 标签，则无需等待 CSS 资源加载会直接触发事件。
did-frame-finish-load：框架加载完成。页面中可能有多个 iframe，所以该事件会触发多次，当前页面为 mainFramedid
</code></pre>
<h3 id="13-页面跳转事件"><a class="header" href="#13-页面跳转事件">1.3 页面跳转事件</a></h3>
<p>页面的跳转事件有两种类型：</p>
<ul>
<li>以 navigate 命名的事件：一般是由客户端控制的跳转</li>
<li>以 redirect 命名的事件：一般是由服务端控制的跳转</li>
</ul>
<p>webContents 的跳转事件有：</p>
<pre><code class="language-txt">will-redirect：服务端返回 301、302 后，浏览器准备跳转时触发。
                        Electron 可以通过 event.preventDefault() 取消该事件，阻止跳转
did-redirect-navigation：will-redirect 事件之后，跳转发生时触发
will-navigation：用户点击了跳转连接或者 使用了 window.location.href 属性，跳转发生前触发
                        不会触发该事件的场景：webContents.loadURL、webContents.back、更新 window.location.hash、用户点击锚点
did-start-navigation：一般发生在 will-navigation 之后，跳转发生时触发
did-navigate-in-page：更新 window.location.hash 时，或者 用户点击锚点 时触发
did-frame-navigate：主页面和子页面跳转完成时触发，更新 window.location.hash、用户点击锚点 不会触发
did-navigate：主页面跳转完成时触发（子页面不会），更新 window.location.hash、用户点击锚点 不会触发
</code></pre>
<p>注意：目前前端项目大多使用 MVVM 框架开发，其路由模式无论是 hash 还是 history，一般情况都是业内跳转，会触发：<code>did-start-navigation</code>、<code>did-navigate-in-page</code>。</p>
<h3 id="14-渲染海量数据元素"><a class="header" href="#14-渲染海量数据元素">1.4 渲染海量数据元素</a></h3>
<p>与传统桌面开发相比，在渲染海量数据时，Electron 的 Web 开发方式需要另辟蹊径，比如使用分页，比如使用 canvas 绘图方式渲染大量数据，因为浏览器的绘制能力非常强悍。</p>
<p>这里在使用 canva 时，推荐 PixiJS 库<a href="https://github.com/pixijs">https://github.com/pixijs</a>，该库对 WebGL 进行的二次封装，且兼容 canvas，得到了 Youtube、Adobe 等公司的应用。</p>
<p>如果超过了 canvas 的承载能力呢？</p>
<p>一个可行的方案是：界面加载完成后，只渲染一屏数据，且同时制作一个足够长的滚动条，监听滚动条的滚动事件。当滚动条向下滚动时，更新这一屏数据，把头部内容丢弃！推荐开源项目：<a href="https://github.com/TonyGermaneri/canvas0datagrid">https://github.com/TonyGermaneri/canvas0datagrid</a></p>
<h2 id="二-页面容器"><a class="header" href="#二-页面容器">二 页面容器</a></h2>
<h3 id="21-webframe"><a class="header" href="#21-webframe">2.1 webFrame</a></h3>
<p>一般情况下，webContents 能够满足多数场景，如果需要在窗口内包含更多子页面，则需要用到 webFrame。在 Electron 中，一个 iframe 对应一个 webFrame，即使一个页面中没有任何子页面，其本身也是一个 webFrame 实例，即 mainFrame。</p>
<p>webFrame 的实例只能在渲染进程中使用：</p>
<pre><code class="language-js">const { webFrame } = require('electron') // 这里的 webFrame 其实就是 mainFrame
</code></pre>
<p>在获得 mainFrame 后，可以通过下列方式查找自己所需要的 webFrame：</p>
<pre><code class="language-js">webFrame.findFrameByName(name)
webFrame.findFramebyRoutingId(routingId) // routingId 是 webFrame 的整型属性，webFrame.routingId
webFrame.firstChild()
</code></pre>
<p>注意：子页面无法使用 require 等，可以在 Electron 应用中添加如下配置：</p>
<pre><code class="language-js">let win = new BrowserWindow({
  // ... 一系列配置
  nideIntegrationSubFrames: true,
})
</code></pre>
<p>当然也有其他解决方案，在父页面中：</p>
<pre><code class="language-js">let myIframe = document.querySelectro(&quot;#iframeID&quot;);
myIframe.onload = function(){
    let iframeWin = myIframe.contentWindow;
    let iframe.require = myIframe.require;          // 也可以采用该方式：在子页面中获取父窗口的 require
}
</code></pre>
<h3 id="22-webview"><a class="header" href="#22-webview">2.2 webview</a></h3>
<p>Electron 额外提供了一个专有标签 webview，可以在网页中实现直接嵌入另外一个网页的内容（可以是第三方网页），但是该功能貌似 Electron 官方不推荐使用，后续版本很可能删除！</p>
<p>使用该标签需要提前开启：</p>
<pre><code class="language-js">let win = new BrowserWindow({
  // ... 一系列配置
  webviewTag: true,
})
</code></pre>
<p>使用方式：</p>
<pre><code class="language-html">&lt;webview
  id=&quot;myview&quot;
  src=&quot;https://www.baidu.com&quot;
  style=&quot;width:100px; height:100px;&quot;
&gt;&lt;/webview&gt;
</code></pre>
<h3 id="23-browserview"><a class="header" href="#23-browserview">2.3 BrowserView</a></h3>
<p>webFrame 与 webview 都有其缺陷，BrowserView 可以满足很多更复杂的场景，如应用中内嵌一个浏览器。</p>
<p>BrowserView 完全依托于 BrowserWindow 存在，可以绑定在 BrowserWindow 的一个具体区域，可以看做其内部的一个元素，可以随着 BrowserWindow 的放大缩小而放大缩小。</p>
<pre><code class="language-js">let view = new BrowserView({
  webPreferences: { preload },
})

win.setBrowserView(view) // win 是 BrowserWindow 对象，这里为自己设置一个 BrowserView 容器

let size = win.getSize()
// 设定绑定区域
view.setBounds({
  x: 0,
  y: 80,
  width: size[0],
  height: size[1] - 80,
})
// 自适应
view.setAutoResize({
  width: true,
  heigth: true,
})
view.webContents.loadURL(url)
</code></pre>
<p>如果开发的内嵌浏览器需要支持多标签页，则不能使用 setBrowserView()，因为该方法会为当前窗口设置，属于替换效果！需要使用 addBrowserView 方法。移除 BrowserView 的方法是：<code>win.removeBrowserView(view)</code>，这里其实只是隐藏，再次显示不会造成重新渲染，此外还有如下方法：</p>
<pre><code class="language-js">// 显示
view.webContents.insertCSS('html{display: block}')
// 隐藏
view.webContents.insertCSS('html{display: none}')
</code></pre>
<h2 id="三-脚本注入"><a class="header" href="#三-脚本注入">三 脚本注入</a></h2>
<p>开发者可以利用 Electron 提供的脚本注入功能，把一段 JS 代码注入到目标网页中，这段代码可以访问该网页的内容，如：DOM、Cookie、服务端资源、Node 能力等。</p>
<h3 id="31-preload-参数注入脚本"><a class="header" href="#31-preload-参数注入脚本">3.1 preload 参数注入脚本</a></h3>
<p>注入方式：</p>
<pre><code class="language-js">let win = new BrowserWindow({
    webPreferences: {
        // ...其他配置
        preload: jsFileSrc;           // 这里是绝对路径
    }
})
</code></pre>
<p>绝对路径获取方式：</p>
<pre><code class="language-js">const { app } = require('electron')
const path = require('path')
let jsFileSrc = path.join(app.getAppPath(), 'yourPreload.js')
</code></pre>
<p>preload.js 文件示例：</p>
<pre><code class="language-js">window.onload = function () {
  alert(&quot;I'm watching u&quot;)
}
</code></pre>
<p>注意：如果使用的是 vue-electron 构建，则 <code>app.getAppPath()</code> 指向应用程序的编译路径。如果需要使用 Vue 下的 public 静态文件目录，则可以使用 <code>__static</code> 全局变量，该目录不会被 webpakc 打包！</p>
<p>如果使用 BrowserView、webview 标签来嵌入第三方页面，他们都能通过类似机制都可以给第三方页面注入脚本。注入的脚本无论是否配置了 Node 访问能力，都可以访问 Node，不同之处在于，一旦开启支持 Node 访问能力，第三方网页在被注入脚本后，也能访问 Node，这会造成很大的安全问题，因为第三方网页此时可以完全访问 Electron 应用。</p>
<h3 id="32-executejavascript-注入简单脚本"><a class="header" href="#32-executejavascript-注入简单脚本">3.2 executeJavaScript 注入简单脚本</a></h3>
<p>如果只是要注入很短的几句脚本，直接使用 webContents 的 executeJavaScript 即可。</p>
<pre><code class="language-js">await win.webContents.executeJavaScript(&quot;document.alert('hello world!')&quot;)
// 贴士：也可以使用类似方式注入 css
await win.webContents.insertCSS('html, body{ background-color: red }')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-electron-窗口"><a class="header" href="#061-electron-窗口">06.1-Electron 窗口</a></h1>
<h2 id="一-electron-窗口"><a class="header" href="#一-electron-窗口">一 Electron 窗口</a></h2>
<p>窗口（Browser Window）是桌面应用非常重要的部分。</p>
<p>控制窗口位置：</p>
<pre><code class="language-txt">属性：x y center movable 说明：x 与 y 控制窗口在屏幕的位置，窗口默认位于屏幕正中
应用：经常用于创建新窗口时，新窗口与当前窗口交错显示
</code></pre>
<p>控制窗口大小：</p>
<pre><code class="language-txt">属性：width height minWidth/maxWidth minHeight/maxHeight resizable minimizabel
maximizable 说明：用来设置窗口大小，以及是否允许用户控制窗口大小
应用：用户拖动窗口可以改变大小，如果不想让用户主动改变，可以在设置 width、height 后，设置 resizable 为 false 即可，max/min 可以控制用户能够放大缩小的最大程度
</code></pre>
<pre><code class="language-txt">属性：title icon frame autoHideMenuBar titleBarStyle
说明：用来设置窗口的边框、标题栏、菜单栏
应用：窗口默认的 title 为网页 title，icon 默认为可执行文件的图标。frame 设置为 false，才能自定义系统标题栏，实现自定义窗口
</code></pre>
<pre><code class="language-txt">属性：nodeIntegration nodeIntegrationInWorker nodeIntegrationInSubFrames
说明：控制窗口加载的网页是否集成 Node 环境
应用：这三个配置的默认选项都是 false，因为会引起安全问题
</code></pre>
<pre><code class="language-txt">属性：preload webSecurity contextIsolation
说明：允许最大限度控制渲染进程加载的页面
应用：preload 配置项可以实现渲染进程加载的页面注入脚本，该脚本也能访问 Node 环境，webSecurity 用来控制同源策略
</code></pre>
<h2 id="二-示例自定义窗口"><a class="header" href="#二-示例自定义窗口">二 示例：自定义窗口</a></h2>
<h3 id="21-关闭默认窗口"><a class="header" href="#21-关闭默认窗口">2.1 关闭默认窗口</a></h3>
<p>很多时候默认的窗口样式需要自定义，首先需要关闭默认窗口：</p>
<pre><code class="language-js">mainWin = new BrowserWindow({
  frame: false,
  webPreferences: { nodeIntegration: true },
})
</code></pre>
<h3 id="22-监听窗口变化事件"><a class="header" href="#22-监听窗口变化事件">2.2 监听窗口变化事件</a></h3>
<p>APP.vue 或者 主页面中自定义 缩小、放大、关闭 三个按钮后，绑定下列函数</p>
<pre><code class="language-js">const { remote } = require('electron')

const currentWin = remote.getCurrentWindow()

// 最小化
function minisize() {
  currentWin.minisize()
}

// 最大化
function maxsize() {
  currentWin.maxsize()
}

// 重置窗口
function restore() {
  currentWin.resotre()
}

// 关闭窗口
function close() {
  currentWin.close()
}
</code></pre>
<p>此外还要在生命周期钩子函数中监听窗口是否变化为最大值、最小值，值的变化等：</p>
<pre><code class="language-js">mounted(){

    currentWin.on('maximize', ()=&gt;{
        this.isMaxSize = true;          // 记录窗口是否最大的值，用来记录最大化图标显示状态
        this.setWindState();            // 用来记录当前窗口状态
    });

    currentWin.on('unmaximize', ()=&gt;{
        this.isMaxSize = false;
        this.setWindState();
    });

    currentWin.on('move', this.debounce(
        ()=&gt;{
            this.setWindState();
        }
    ));

    currentWin.on('resize', this.debounce(
        ()=&gt;{
            this.setWindState();
        }
    ));

    // 每次重启应用时，都能恢复窗口状态
    this.isMaxSize = win.isMaximized();
    this.getWinState();
}
</code></pre>
<p>注意：上述四个监听窗口变化的函数位于渲染进程，会有潜在 BUG。当用户按下 Ctrl+R 刷新页面后，再次操作窗口来触发最大最小，主进程会出现异常！！原因是 <code>currentWin</code> 是通过 <code>remote</code> 获得远程对象，这个远程对象位于主进程中，页面刷新后，注册在渲染进程中的事件被再次执行，由于以前安装的回调的上下文已经被释放，在此事件发生时，泄露的回调函数找不到执行体，在主进程引发异常。</p>
<p>处理方案：</p>
<ul>
<li>方案一：将上述逻辑放在主进程中</li>
<li>方案二：禁止页面刷新</li>
</ul>
<p>禁止刷新代码：</p>
<pre><code class="language-js">mainWin.onkeydown = function (e) {
  if (e.keyCode == 82 &amp;&amp; (e.ctrlKey || e.metaKey)) {
    return false
  }
}
</code></pre>
<p>debounce 是防抖函数：</p>
<pre><code class="language-js">// 由于会短时间内触发多次，这里可以使用防抖函数：短时间内大量事件被触发，只执行最后一次关联任务
debounce(fn){
    let timeout = null;
    return function(){
        clearTimeout(timeout);
        timeout = setTimeout(()=&gt;{
            fn.apply(this, arguments);
        }, 300);
    }
}

// 附限流函数：短时间大量事件被触发，只执行第一次触发的事件
debounce(fn){
    let timeout = null;
    return function(){
        if(timeout){
            return;
        }
        timeout = setTimeout(()=&gt;{
            fn.apply(this, arguments);
            timeout = null;
        }, 300);
    }
}
</code></pre>
<h3 id="23-记录窗口变化状态"><a class="header" href="#23-记录窗口变化状态">2.3 记录窗口变化状态</a></h3>
<p><code>setState()</code> 把窗口的大小、位置、是否最大化记录在 LocalStorage 中，推荐根据需要自定义：</p>
<pre><code class="language-js">    setWindState(){
        let currentWin = remote.getCurrentWindow();
        let rect = currentWin.getBounds();
        let isMaxSize = currentWin.isMaxSized();
        let obj = {rect, isMaxSize};
        localStorage.setItem(&quot;winState&quot;, JSON.stringify(obj));
    }

    // 每次打开应用，就可以恢复这些觳觫
    getWinState(){
        let currentWin = remote.getCurrentWindow();
        let winState = localStorage.getItem(&quot;winState&quot;);
        if(!winState){
            return;
        }
        winState = JSON.parse(winState);
        if(winState.isMaxSize){
            win.maximize();
        } else {
            win.setBounds(winState.rect);
        }

        let rect = currentWin.getBounds();
        let isMaxSize = currentWin.isMaxSized();
        let obj = {rect, isMaxSize};
        localStorage.setItem(&quot;winState&quot;, JSON.stringify(obj));
    }
</code></pre>
<h3 id="24-打开窗口时位置优化"><a class="header" href="#24-打开窗口时位置优化">2.4 打开窗口时位置优化</a></h3>
<p>软件在打开时，窗口默认位于屏幕中间，然后才会移动到记录的状态位置，这样的用户体验极度不佳：</p>
<pre><code class="language-js">// 创建窗口时，不显示窗口
mainWin = new BrowserWindow({
  // 其他配置...
  show: false,
})
</code></pre>
<p><code>getState()</code> 方法中应该在数据准备完毕后显示窗口：</p>
<pre><code class="language-js">// 末尾加入 show
currentWin.show()
</code></pre>
<p>但是这里官方推荐通过这种方式实现：监听 <code>BrowserWindow</code> 的 <code>ready-to-show</code> 事件。但是这样做有缺陷：窗口可以显示时，JS 的代码可能尚未准备完毕。</p>
<h3 id="25-阻止窗口关闭"><a class="header" href="#25-阻止窗口关闭">2.5 阻止窗口关闭</a></h3>
<p>若用户在完成大量操作后，误关了窗口，就会有很多数据未提交，所以应用一般需要在关闭时提醒用户。</p>
<p>Electron 无法像网页那样监听 <code>onbeforeunload</code> 阻止关闭，但是可以在该事件中操作 DOM，创建一个浮动 div 来提示用户，用户确定后：</p>
<pre><code class="language-js">currentWin.onbeforeunload = function () {
  currentWin.destroy() // 不能使用 close()，因为该函数会再次触发 onbeforeunload 事件，造成死循环
}
</code></pre>
<p>还有一个方案是，使用 close 事件阻止：</p>
<pre><code class="language-js">currentWin.on('close', (e) =&gt; {
  // 由渲染进程显示提示信息，根据用户选择发送消息给主进程
  e.preventDefault()
})
</code></pre>
<p>注意：使用 onbeforeunload 事件方式来实现阻止窗口关闭时，如果 Electron 加载了一个注册了 onbeforeunload 事件的第三方网页，则该窗口无法关闭！这时候可以监听 webContents 的 <code>will-prevent-unload</code> 事件：</p>
<pre><code class="language-js">win.webContents.on('will-prevent-unload', (event) =&gt; {
  event.preventDefault()
})
</code></pre>
<h2 id="三-窗口使用的注意点"><a class="header" href="#三-窗口使用的注意点">三 窗口使用的注意点</a></h2>
<h3 id="31-多窗口资源竞争"><a class="header" href="#31-多窗口资源竞争">3.1 多窗口资源竞争</a></h3>
<p>多个渲染窗口同时对一个本地文件进行更新，就会造成资源竞争（类似多进程同步问题、多线程同步问题）。</p>
<p>解决方案一：窗口之间通过渲染进程之间的消息通信来保证读写顺序。即当一个渲染进程准备更新文件，需要先广播消息给其他渲染进程，禁止其他渲染进程访问该文件，等待当前渲染进程更新完毕后，再广播消息给其他渲染进程说明可以更新。</p>
<p>解决方案二：利用 Node 的 <code>fs.watch</code> 监听文件变化，一旦文件发生改变，加载最新文件，无论哪个窗口拿到的文件都是最新的。当窗口需要保存文件时，渲染进程向主进程发送更新文件的消息，多个更新消息就会入驻主进程的队列。</p>
<p>解决方案三：在主进程设置一个令牌 <code>global.fileLock = false;</code> 然后在渲染进程中读取该令牌 <code>remote.getGlobal('fileLock')</code>。这里看上去简便很多，但是当需要更新文件时，仍然需要发送消息给主进程。</p>
<p>推荐方案二：因为方案二利用了 JS 单线程特性，队列保证了有序，程序结构上更加解耦。</p>
<h3 id="32-模态框"><a class="header" href="#32-模态框">3.2 模态框</a></h3>
<p>用户在操作窗口 A 时，需要的打开窗口 B，在窗口 B 完成一系列操作后需要关闭窗口 B 才能操作窗口 A，此时，窗口 B 就是窗口 A 的模态框。</p>
<p>一旦模态框出现，就不能再操作父窗口，打开模态框的示例</p>
<pre><code class="language-js">const remote = require(&quot;electron&quot;).remote;

this.win = new remote.BrowserWindow({
    parent: remote.getCurrentWindow();
    modal: true,
    webPreferences: {
        nodeIntegration: true
    }
})
</code></pre>
<p>贴士：虽然父窗口此时无法使用，但并不代表其已经被禁用，仍然可以接收点击事件、完成用户输入。</p>
<p>贴士：窗口不但有父子也有激活与否的判断，获取当前激活的窗口方法：<code>BrowserWindow.getFocusedWindow()</code>，这里与<code>currentWindow</code>不是一个概念，后者只是当前渲染进程关联的窗口。</p>
<h3 id="33-mac-系统注意点"><a class="header" href="#33-mac-系统注意点">3.3 Mac 系统注意点</a></h3>
<p>Mac 上应用程序在关闭后，仍然会保留在 Docker 栏上，方便快速启动，Electron 项目也可以这样实现，以保证 Mac 上的用户体验：</p>
<pre><code class="language-js">app.on('window-all-closed', () =&gt; {
  if (process.platform !== 'darwin') {
    // 如果不是 Mac 系统，才会退出，是 Mac 系统则什么都不做！
    app.quit()
  }
})

// Mac 专用事件，Docker 上的应用激活时触发
app.on('activate', () =&gt; {
  if (win == null) {
    createWindow()
  }
})
</code></pre>
<p>Mac 下还有 DarkMode，可以通过如下方式获取系统是否处于深色模式 (这是主进程中只读的属性)：</p>
<pre><code class="language-js">// 6.X 及之前，已废弃
const isDarkMode = electron.remote.systemPreferences.isDarkMode()

// 7.X 及之后
const currentMode = electron.nativeTheme.shouldUseDarkColors
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="071-electron-交互-与系统交互"><a class="header" href="#071-electron-交互-与系统交互">07.1-Electron 交互-与系统交互</a></h1>
<h2 id="一-系统对话框"><a class="header" href="#一-系统对话框">一 系统对话框</a></h2>
<h3 id="11-文件对话框"><a class="header" href="#11-文件对话框">1.1 文件对话框</a></h3>
<p>软件大部分具备打开本地目录的功能，示例如下：</p>
<pre><code class="language-js">async function() {
      let filePath = await remote.dialog.showOpenDialog({       // 执行打开对话框
        title: &quot;I need to open a file&quot;,
        buttonLabel: &quot;click here to open&quot;,
        defaultPath: remote.app.getPath(&quot;pictures&quot;),            // 默认打开路径
        properties: [],
        filters: [                                              // 过滤显示文件
          {name: &quot;images&quot;, extensions: [&quot;jpg&quot;, &quot;png&quot;, &quot;gif&quot;] },
          {name: &quot;videos&quot;, extensions: [&quot;mp4&quot;, &quot;avi&quot;, &quot;mkv&quot;] },
        ],
      });
    }
</code></pre>
<h3 id="12-关于-对话框"><a class="header" href="#12-关于-对话框">1.2 关于 对话框</a></h3>
<p>软件一般都有 <code>关于</code> 这个选项，Electron 应用默认从 <code>package.json</code> 中生成，也可以在手动设置：</p>
<pre><code class="language-js">// 手动设置 关于
app.setAboutPanelOptions({})

// 在其他地方显示 关于 对话框
app.showAboutPanel()
</code></pre>
<h2 id="二-菜单"><a class="header" href="#二-菜单">二 菜单</a></h2>
<h3 id="21-窗口菜单"><a class="header" href="#21-窗口菜单">2.1 窗口菜单</a></h3>
<p>窗口菜单基本上不符合需要，可以使用 <code>autoHideMenuBar:true</code> 隐藏，但是隐藏后的菜单在打开窗口后还会显示，尤其是 Mac 平台，其菜单是位于系统标题栏，更加需要自定义：</p>
<pre><code class="language-js">// 创建菜单
const { Mennu } = require('electron')
let menuTemplates = [
  {
    label: '菜单 1',
    submenu: [{ label: '子菜单 1-1' }, { label: '子菜单 1-2' }],
  },
  {
    label: '菜单 2',
    submenu: [
      {
        label: '子菜单 2-1',
        click() {
          console.log(111)
        },
      },
      // role 表示行为，有：undo、redo、cut、copy、paste、selectAll、reload、minimize、close、quit 等
      // 拥有 role 行为的菜单 click 无效
      // Mac 系统必须设置 role，否则窗口不具备 复制、剪切、粘贴功能
      { label: '粘贴', role: 'paste' },
      { label: '菜单 2-3', type: 'separator' }, // 设置菜单空格，值还有 checkbox、radio
      { label: '菜单 2-4' },
    ],
  },
]
if (process.platform == 'darwin') {
  menuTemplates.unshift({ label: '' }) // 第一个菜单不做任何设置，直接由应用名默认替代
}

let menu = Menu.buildFromTemplate(menuTemplates)
Menu.setApplicationMenu(menu)
</code></pre>
<h3 id="22-html-右键菜单"><a class="header" href="#22-html-右键菜单">2.2 HTML 右键菜单</a></h3>
<p>使用系统原生菜单：</p>
<pre><code class="language-js">const { Menu } = window.require('electron').remote
let menu = Menu.buildFromTemplate([
  {
    label: '右键菜单 1',
    click() {
      console.log(111)
    },
  },
  { label: '右键菜单 2' },
])
window.oncontextmenu = function (e) {
  e.preventDefault()
  menu.popup()
}
</code></pre>
<p>右键菜单可以是使用 HTML 原生实现，但是会有 bug，如果鼠标移动的到 Electron 应用的边缘，那么右键菜单仍然是在右侧出现，会让应用底部出现滚动条：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;div id=&quot;menu-list&quot;&gt;
      &lt;div class=&quot;menu-item&quot;&gt;右键菜单 1&lt;/div&gt;
      &lt;div class=&quot;menu-item&quot;&gt;右键菜单 2&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
const { screen } = window.require('electron').remote
window.oncontextmenu = function (e) {
  e.preventDefault()
  let menu = document.querySelector('#menu-list')
  let point = screen.getCursorScreenPoint()
  // 菜单窗口的位置应该是相对于窗口的，而不应该相对于鼠标
  console.log('e.clientX: ' + e.clientX + ', e.clientY: ' + e.clientY)
  console.log('point.x: ' + point.x + ',point.y: ' + e.clientY)
  menu.style.left = point.x + 'px'
  menu.style.top = point.y + 'px'
  menu.style.display = 'block'
}

window.onclick = function (e) {
  document.querySelector('#menu-list').style.display = 'none'
}
&lt;/script&gt;

&lt;style scoped&gt;
#menu-list {
  width: 125px;
  overflow: hidden;
  border: 0px solid #ccc;
  box-shadow: 3px 3px 3px #ccc;
  position: absolute;
  display: none;
}
#menu-list .menu-item {
  height: 36px;
  line-height: 36px;
  text-align: center;
  border-bottom: 1px solid #ccc;
  background: #fff;
}
&lt;/style&gt;
</code></pre>
<h2 id="三-监听快捷键"><a class="header" href="#三-监听快捷键">三 监听快捷键</a></h2>
<p>快捷键的操作直接使用 HTML 原生技术即可：</p>
<pre><code class="language-js">window.onkeydown = function (e) {
  // Ctrl + S      e.metaKey 是 mac 上的花键
  if ((e.ctrKey || e.metaKey) &amp;&amp; e.keyCode == 83) {
    console.log(111)
  }
}
</code></pre>
<p>如果需要在窗口处于非激活也能监听按键：</p>
<pre><code class="language-js">const { globalShorcut } = window.require('electron')
// 全局监听 Ctrl + K
globalShorcut.register('CommandOrCControl+K', () =&gt; {
  console.log(111)
})
</code></pre>
<h2 id="四-托盘图标"><a class="header" href="#四-托盘图标">四 托盘图标</a></h2>
<pre><code class="language-js">import { app, protocol, BrowserWindow, Tray } from 'electron'

let win;
let tray;   // 托盘图标

createWindow(){

  // 其他代码....


  tray = new Tray(iconPath);    // iconPath 是图标地址
  // 还可以通过定时器 tray.setImage() 来实现通知效果
  tray.on('click', ()=&gt;{
    win.show();
  })

  // 还可以注册托盘图标的彩蛋
  let menu = Menu.buildFromTemplate([
    {label:'显示窗口', type: 'normal', click(){win.show()} },
    {label:'退出应用', type: 'normal', click(){app.quit()} },
  ]);
  tray.setContextMenu(menu);
}
}
</code></pre>
<h2 id="五-剪切板"><a class="header" href="#五-剪切板">五 剪切板</a></h2>
<p>剪切板模块 clipboard 是主进程、渲染进程都可以使用的模块。</p>
<p>写入数据 API：</p>
<pre><code class="language-js">const { clipboard, nativeImage } = window.require('electron')
const path = window.require('path')

// 图像的写入需要额外的操作
let imagePath = path.join(__static, 'icon.png')
let img = nativeImage.createFromPath(imagePath)
clipboard.writeImage(img) // 还有：writeText  writeHTML

clipboard.clear() // 清除数据
</code></pre>
<p>读取数据 API：</p>
<pre><code class="language-js">// readText  readHTML
// 读取图片 imgSrc 就可以作为 image 标签的的 src 属性
let imgSrc = clipboard.readImg().toDataURL()
</code></pre>
<p>在一些场景中，如：读取系统文件夹中的图片，会出现错误，可以利用第三方包：<a href="https://github.com/alex8088/clipboard-files">https://github.com/alex8088/clipboard-files</a></p>
<h2 id="六-系统通知"><a class="header" href="#六-系统通知">六 系统通知</a></h2>
<p>网页中使用系统通知，需要先请求用户授权，其 HTML5 的原生 API 为：</p>
<pre><code class="language-js">Notification.requestPermission( status =&gt; {
  if(status !== 'granted'){
    console.log(&quot;用户拒绝了请求&quot;);
    return
  }

  let notify = new Notification('新消息内容'， {
    body: '消息正文'
  });
})
</code></pre>
<p>系统显示通知后，如果用户点击通知，则会触发 Notification 的实例事件 click：</p>
<pre><code class="language-js">notify.onlick = function () {
  console.log('用户点击了消息')
}
</code></pre>
<p>如果要在主进程内发送通知，Electron 提供了和 H5 API 相似的类 Notification，区别是 H5 的通知在实例化后立即显示，而 Electron 的通知则需要调用 <code>show()</code>。</p>
<h2 id="七-应用内打开文件"><a class="header" href="#七-应用内打开文件">七 应用内打开文件</a></h2>
<p>Electron 的 shell 模块可以在 Electron 应用中打开 Word 文档等应用：</p>
<pre><code class="language-js">const { shell } = require('electron')
shell.openExternal('https://www.baidu.com') // 使用默认浏览器打开网页，该方法是异步的
shell.openItem('D:\\files\\demo.docx') // 打开 word 文档，该方法是同步的
shell.moveToTrash('D:\\files\\demo.docx') // 删除到回收站，该方法是同步的
</code></pre>
<h2 id="八-使用系统字体"><a class="header" href="#八-使用系统字体">八 使用系统字体</a></h2>
<p>使用系统字体可以利用 CSS3 直接实现：</p>
<pre><code class="language-html">&lt;div style=&quot;font:caption&quot;&gt;使用系统默认标题字体&lt;/div&gt;
&lt;div style=&quot;font:menu&quot;&gt;使用系统默认菜单字体&lt;/div&gt;
&lt;div style=&quot;font:message-box&quot;&gt;使用系统默认消息提示字体&lt;/div&gt;
&lt;div style=&quot;font:status-bar&quot;&gt;使用系统默认状态栏字体&lt;/div&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="072-electron-交互-与硬件交互"><a class="header" href="#072-electron-交互-与硬件交互">07.2-Electron 交互-与硬件交互</a></h1>
<p>H5 虽然新增了对计算机硬件设备的访问，但其限制极多，Electron 却可以自由的使用这些技术，因为其 API 提供者为原生的 C++。</p>
<h2 id="一-音视频设备"><a class="header" href="#一-音视频设备">一 音视频设备</a></h2>
<h3 id="11-访问摄像头麦克风"><a class="header" href="#11-访问摄像头麦克风">1.1 访问摄像头、麦克风</a></h3>
<pre><code class="language-js">// 该配置用来确定是否从流中获取音频、视频
let option = {
  audio: true,
  video: true,
  // width: 1280, height: 720,     // 视频大小
  // facingMode: &quot;user&quot;             // 获取前置摄像头，值 enviroment 表示后置摄像头
}

// 获取用户的音视频流
let mediaStream = await navigator.mediaDevices.getUserMedia(option)

videoDom.srcObject = mediaStream // videoDom 为 HTML 中的 video 标签
videoDom.onloadedmetadata = function (e) {
  video.play()
}
</code></pre>
<h3 id="12-录屏"><a class="header" href="#12-录屏">1.2 录屏</a></h3>
<p>Electron desktopCapturer 模块可以用来获取桌面的屏幕视频流：</p>
<pre><code class="language-js">const { desktopCapturer } = require('electron')

// 获取所有桌面信息，根据参数进行过滤
let sources = await desktopCapturer.getSources({
  types: ['window', 'screen'],
})

let target = sources.find((v) =&gt; v.name == '微信')

let mediaStream = await navigator.mediaDevices.getUserMedia({
  audio: false,
  video: {
    mandatory: {
      chromeMediaSource: 'desktop',
      chromeMediaSrouceId: target.id,
    },
  },
})
</code></pre>
<h2 id="二-电源"><a class="header" href="#二-电源">二 电源</a></h2>
<p>电源模块可以使用 HTML5 的模块：</p>
<pre><code class="language-js">let batterManager = await navigator.getBattery()
</code></pre>
<p>也可以使用 Electron 封装的模块：</p>
<pre><code class="language-js">const { powerMonitor } = require('electron').remote

// 该模块可以用于监控系统是否挂起、恢复
powerMonitor.on('suspend', () =&gt; {
  console.log('中断...')
})

powerMonitor.on('resume', () =&gt; {
  console.log('恢复...')
})
</code></pre>
<h2 id="三-打印机与导出-pdf"><a class="header" href="#三-打印机与导出-pdf">三 打印机与导出 PDF</a></h2>
<p>Electron 支持把 webContents 的内容发送至打印机：</p>
<pre><code class="language-js">let { remote } = require('electron')

let webContents = remote.getCurrentWebContents()
webContents.print(
  {
    silent: false,
    printBackground: true,
    deviceName: '',
  },
  (success, erroType) =&gt; {}
)
</code></pre>
<p>如何找出打印机：</p>
<pre><code class="language-js">let printers = webContents.getPrinters()
</code></pre>
<p>导出 PDF 示例：</p>
<pre><code class="language-js">const { remote } = require('electron')
const path = require('path')
const fs = reuqire('fs')

let webContents = remote.getCurrentWebContents()
let data = await webContents.printToPDF({}) // 返回一个 Buffer 缓存
let filePaht = path.join(__static, 'demo.pdf')
fs.writeFile(filePath, data, (error) =&gt; {})
</code></pre>
<h2 id="四-显示器与自助机"><a class="header" href="#四-显示器与自助机">四 显示器与自助机</a></h2>
<h3 id="41-多显示器获取"><a class="header" href="#41-多显示器获取">4.1 多显示器获取</a></h3>
<p>Electron 获取主显示器、外接显示器信息，主显示器</p>
<pre><code class="language-js">const { remote } = require('electron')
let mainScreen = remote.screen.getPrimaryDisplay() // 主显示器包括显示器 id，bounds 绑定区域，据此判断是否为外接
</code></pre>
<p>让窗口显示在外接显示器上：</p>
<pre><code class="language-js">const { screen } = require('electron') // ready 事件后才可以使用

let displays = screen.getAllDisplay()
let externalDisplay = displays.find((display) =&gt; {
  return display.bounds.x !== 0 || display.bounds.y !== 0
})

if (externalDisplay) {
  win = new BrowserWindow({
    x: externalDisplay.bounds.x + 50,
    y: externalDisplay.bounds.y + 50,
    // ... 其他配置
  })
  win.loadURL('https://www.qq.com')
}
</code></pre>
<p>注意：显示器对象的 internal 属性用来说明是否是主显示器，但是目前无论是主显示器还是外接显示器，其值均为 false，所以判断是否是主显示器最好使用 <code>display.bounds</code> 判断。</p>
<h3 id="42-自助机"><a class="header" href="#42-自助机">4.2 自助机</a></h3>
<p>自助机的操作系统一般为 Win、Linux、Android，如果是 PC 系统，则可以使用 Electron 开发，但是这类应用一般有以下特点：</p>
<ul>
<li>大部分不允许用户退出</li>
<li>大部分支持触屏</li>
</ul>
<p>在 <code>new BrowserWindow()</code> 时，Electron 为自助机提供了专用参数 kiosk。若该参数为 true，则窗口自动处于全屏状态，操作系统任务栏、窗口的默认标题都不再显示，窗口的高度与宽度设置也会失效。</p>
<p>触屏时，一般需要隐藏鼠标：</p>
<pre><code class="language-css">body {
  cursor: none;
}
</code></pre>
<p>或者直接将鼠标锁定在可视区：</p>
<pre><code class="language-js">document.body.requestPointerLock()
</code></pre>
<p>自助机的软键盘需要子进程配合：</p>
<pre><code class="language-js">const { exec } = require('child_process')

exec('osk.exe')
</code></pre>
<h2 id="五-硬件信息"><a class="header" href="#五-硬件信息">五 硬件信息</a></h2>
<h3 id="51-获取硬件信息"><a class="header" href="#51-获取硬件信息">5.1 获取硬件信息</a></h3>
<pre><code class="language-js">// 获取系统内存信息
let memoryUseage = process.getSystemMemoryInfo()

// 获取 CPU 信息
let cpuUseage = process.getCPUUseage()
</code></pre>
<p>更多的硬件信息，推荐使用第三方库<a href="https://github.com/sebhildebrandt/systeminformation">https://github.com/sebhildebrandt/systeminformation</a></p>
<h3 id="52-商业应用的授权问题"><a class="header" href="#52-商业应用的授权问题">5.2 商业应用的授权问题</a></h3>
<p>基础的授权方式为：获取用户设备的专有硬件信息（串号，全球唯一），将该信息、用户信息、付费信息绑定在一起，保存在服务端。</p>
<p>该授权方式有缺陷：必须联网才能验证，离线应用不可取；仍然可以通过代理请求破解验证。</p>
<p>针对离线应用，在第一次启动时，可以通过安全算法在本地生成一个与硬件匹配的激活码发送给用户，由用户保存，以后每次启动使用该激活码授权。该算法如果被破解，则可以无限分发激活码！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="081-electron-安全问题"><a class="header" href="#081-electron-安全问题">08.1-Electron 安全问题</a></h1>
<h2 id="一-常见保护应用手法"><a class="header" href="#一-常见保护应用手法">一 常见保护应用手法</a></h2>
<h3 id="11-生产环境关闭开发者工具"><a class="header" href="#11-生产环境关闭开发者工具">1.1 生产环境关闭开发者工具</a></h3>
<pre><code class="language-js">new BrowserWindow({
  // 其他配置
  webPreferces: {
    devTools: false,
  },
})
</code></pre>
<p>上述方式会让任何手段都无法打开开发者工具。而在传统 web 项目中，则会变得复杂，需要禁用 F12，禁用右键，禁用 Ctrl+Shift+I。</p>
<h3 id="12-源码压缩与混淆"><a class="header" href="#12-源码压缩与混淆">1.2 源码压缩与混淆</a></h3>
<p>常用的压缩工具为：uglify-js<a href="https://github.com/mishoo/UglifyJS">https://github.com/mishoo/UglifyJS</a></p>
<p>Webpack 同时也自带了压缩功能。</p>
<p>Electron 提供了工具 asar 用来保护前端源码。在 Electron 开发者工具控制台中输入 <code>__filename</code> 就可以看到资源目录，但是在资源目录却只有 <code>.asar</code> 的文件（非文件夹）。Electron 无需解压该文件即可读取文件内容，只有在一些特殊场景，如处理依赖真实文件路径的底层系统方法时，才会解压，如：<code>child_process.execFile</code>。</p>
<p>此外，该库还能解决 Win 下路径名过长的问题。</p>
<p>使用方式：</p>
<pre><code class="language-txt">npm i asar -D
npx asar pack your-app app.asar
</code></pre>
<p>对一些核心代码，我们可以考虑将其直接编译为 V8 字节码文件，工具为：<a href="https://github.com/OsamaAbbas/bytenode">https://github.com/OsamaAbbas/bytenode</a></p>
<h2 id="二-客户信息保护"><a class="header" href="#二-客户信息保护">二 客户信息保护</a></h2>
<h3 id="21-禁用-nodejs-集成"><a class="header" href="#21-禁用-nodejs-集成">2.1 禁用 Node.js 集成</a></h3>
<p>如果在 webContent 中加载的是不受控的内容，必须要禁用 Node 集成，因为会造成第三方利用 Node 访问到操作系统。</p>
<p>涉及的相关配置位于创建 BrowserWindow、当前 BrowserView 加载第三方内容、webview 标签加载第三方内容。</p>
<h3 id="22-启用同源策略"><a class="header" href="#22-启用同源策略">2.2 启用同源策略</a></h3>
<p>与集成 Node 的安全限制相同，在加载不受信 内容时，也应该 <strong>启用同源策略</strong></p>
<h3 id="23-启用沙箱环境"><a class="header" href="#23-启用沙箱环境">2.3 启用沙箱环境</a></h3>
<p>如果想让 Electron 客户端拥有与 web 系统一样的安全沙箱环境，无需控制 webecurity、node 集成等，则在创建窗口、webview 时，可以启用沙箱隔离特性：</p>
<pre><code class="language-js">let win = new BrowserWindow({
  webPreferences: {
    sandbox: true,
  },
})
</code></pre>
<h3 id="24-禁用-webview"><a class="header" href="#24-禁用-webview">2.4 禁用 webview</a></h3>
<p>在 Electron 项目中，BrowserView 默认是不能使用 webview 标签的，除非在创建窗口时启用 <code>webviewTag:true</code>, 但是并不推荐这样做，因为大多数场景中 webview 可以使用 BrowserView 代替。</p>
<p>一旦开启该属性，webview 内部的第三方内容可以在其自身内部创建一个 webview 标签，此时会相继引发不安全问题。为了解决该问题，需要监听 webContents 的 will-attach-webview 事件：</p>
<pre><code class="language-js">app.on('web-contents-created', (event, contents) =&gt; {
  // 一旦有 webview 被创建则触发该事件
  contents.on('will-attach-webview', (event, webPreferences, params) =&gt; {
    delete webPreferences.preload
    delete webPreferences.preloadURL
    webPreferences.nodeIntegration = false
    if (!params.src.startsWith('https://demo.com/')) {
      event.preventDefault()
    }
  })
})
</code></pre>
<h2 id="三-网络保护"><a class="header" href="#三-网络保护">三 网络保护</a></h2>
<h3 id="31-虚假证书"><a class="header" href="#31-虚假证书">3.1 虚假证书</a></h3>
<p>可以使用 session 模块提升与服务端交互的安全性，可以在一定程度上屏蔽恶意用户同归伪造客户端证书来分析 Electron 应用的网络数据：</p>
<pre><code class="language-js">let session = win.webContents.session

// 当前会话的钩子函数
session.setCertificateVerifyProc((request, callback) =&gt; {
  if (request.certificate.issuer.commonName == 'DO_NOT_TRUST_FiddlerRoot') {
    // 假设现在安装的是 Fiddler 的证书
    callback(-2) // 如果不符合预期，传入 -2 驳回
  } else {
    callback(-3) // -3 表示使用 Chromium 的验证结果，0 表示成功并禁止使用证书透明度验证
  }
})
</code></pre>
<h3 id="32-防盗链"><a class="header" href="#32-防盗链">3.2 防盗链</a></h3>
<p>一般情况下，采用识别请求头 Referer 方式防盗链，那么如果我们还要为本地 Electron 应用提供静态服务，就需要如下设置：</p>
<pre><code class="language-js">let session = win.webContents.session

let requestFilter = {
  urls: ['http://*/*', 'https://*/*'],
}

session.webRequest.onBeforeSendHeaders(requestFilter, (details, callback) =&gt; {
  if (details.resourceType == 'image' &amp;&amp; details.method == 'GET') {
    delete details.requestHeades['Referer']
  }
  callback({
    requestHeades: details.requestHeades6t,
  })
})
</code></pre>
<h3 id="33-数据加密"><a class="header" href="#33-数据加密">3.3 数据加密</a></h3>
<p>可以利用 Node 的数据加密功能对一些敏感数据进行加密后传输。</p>
<p>electron-store 模块内置了加密解密功能：</p>
<pre><code class="language-js">const Store = require('electron-store')

const schema = {
  foo: {
    type: 'number',
    default: 100,
  },
}

const store = new Store({ schema, encryptionKey: 'myKey' })
</code></pre>
<h3 id="34-屏幕保护"><a class="header" href="#34-屏幕保护">3.4 屏幕保护</a></h3>
<p>窗口的鼠标等操作可以被黑客截货，保护方式：</p>
<pre><code class="language-js">win.setContentProtection('true') // 当使用工具捕捉窗口时，会显示黑色区域
</code></pre>
<h2 id="四-稳定性"><a class="header" href="#四-稳定性">四 稳定性</a></h2>
<h3 id="41-全局异常捕获"><a class="header" href="#41-全局异常捕获">4.1 全局异常捕获</a></h3>
<p>Electron 捕获全局异常方式：</p>
<pre><code class="language-js">process.on('uncaughtException', (err, origin) =&gt; {
  // 执行日志收集，显示异常信息并重新加载界面
})
</code></pre>
<h3 id="42-崩溃恢复"><a class="header" href="#42-崩溃恢复">4.2 崩溃恢复</a></h3>
<p>监听渲染进程的 crashed 事件可以知道渲染进程何时发生了崩溃：</p>
<pre><code class="language-js">const { dialog } = require('electron')

win.webContents.on('crashed', async (e, killed) =&gt; {
  // 加入日志收集
  let result = await dialog.showMessageBox({
    type: 'error',
    title: '应用程序崩溃',
    message: '当前应用程序发生异常，是否退出？',
    buttons: ['是', '否'],
  })
})
</code></pre>
<p>模拟崩溃的方式：</p>
<pre><code class="language-js">process.crash() // 模拟崩溃
process.hang() // 模拟挂起
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="091-electron-测试"><a class="header" href="#091-electron-测试">09.1-Electron 测试</a></h1>
<h2 id="一-应用测试"><a class="header" href="#一-应用测试">一 应用测试</a></h2>
<h3 id="11-单元测试"><a class="header" href="#11-单元测试">1.1 单元测试</a></h3>
<p>Electron 应用本身可以使用 Mocha 作为单元测试用工具。</p>
<h3 id="12-界面测试"><a class="header" href="#12-界面测试">1.2 界面测试</a></h3>
<p>Electron 提供了界面测试框架 Spectron，内部封装了 ChromeDriver WebdriverIO。</p>
<p>安装</p>
<pre><code class="language-txt"># 注意：spectron9  对应 Electron7，依次递增类推
npm i spectron -D
</code></pre>
<p>在 test 文件夹内创建 test.js 测试文件：</p>
<pre><code class="language-js">const { Application } = require('spection')
const assert = require('assert')
const electronPath = require('electron')
const path = require('path')

describe('开始执行界面测试', () =&gt; {
  this.timeout(10000)

  beforeEach(() =&gt; {
    this.app = new Application({
      path: electronPath, // 导入 electron，其实是导出了本项目下 Electron 的课执行文件安装路径
      args: [path.join(__dirname, '..')],
    })
    return this.app.start()
  })

  afterEach(() =&gt; {
    if (this.app &amp;&amp; this.app.isRunning()) {
      return this.app.stop()
    }
  })

  it('测试窗口是否启动', async function () {
    let count = await this.app.client.getWindowCount()
    assert.equal(count, 1)
  })
})
</code></pre>
<p>运行测试：</p>
<pre><code class="language-txt">mocha
</code></pre>
<h2 id="二-应用调试"><a class="header" href="#二-应用调试">二 应用调试</a></h2>
<h3 id="21-性能监控工具"><a class="header" href="#21-性能监控工具">2.1 性能监控工具</a></h3>
<p>Electron 应用的性能监控可以直接利用 Chrome 开发者工具中的 Performance 工具，但是当页面很多，且需要精细化观察一个操作的性能问题时，可以使用官方提供的 contentTracing 模块。</p>
<p>在 app 的 ready 事件中，写入以下示例代码：</p>
<pre><code class="language-js">;(async () =&gt; {
  const { contentTracing } = require('electron')

  // 启动性能监控
  await contentTracing.startRecording({
    include_categories: ['*'],
  })

  // 等待运行 6 秒
  await new Promise((resolve) =&gt; {
    setTimeout(resolve, 6000)
  })

  // 关闭监控，查看日志位置
  const path = await contentTracing.stopRecording()
  console.log('日志地址：', path)
  createWindow()
})()
</code></pre>
<p>使用 Chrome 浏览器的 <code>chrome://tracing</code> 后，点击 Load 加载上述日志文件，即可查看性能状况。</p>
<h3 id="22-开发环境调试工具"><a class="header" href="#22-开发环境调试工具">2.2 开发环境调试工具</a></h3>
<p>Electron 官方专门提供了 Devtron 工具用来在开发环境下进行调试，该工具是浏览器插件：</p>
<pre><code class="language-txt"># 安装包文件
npm i devtron -D

# 启动窗口后，在开发者工具的命令行输入命令安装插件
require('devtron').install

# 安装完毕后，开发者工具会新增一个 Devtron 面板
</code></pre>
<h3 id="23-生产环境调试工具"><a class="header" href="#23-生产环境调试工具">2.3 生产环境调试工具</a></h3>
<p>Electron 应用打包后，就很难直接调试了，这时候可以使用字节跳动的第三方工具<a href="https://github.com/bytedance/debugtron">https://github.com/bytedance/debugtron</a>，该工具可以发现系统中安装的 Electron 应用。</p>
<h3 id="24-日志工具"><a class="header" href="#24-日志工具">2.4 日志工具</a></h3>
<p>推荐的日志工具为：<a href="https://github.com/megahertz/electron-log">https://github.com/megahertz/electron-log</a></p>
<p>对于网络请求的监控，Electron 提供了 netLog 模块，用来以日志文件形式记录请求数据。</p>
<h3 id="25-崩溃报告"><a class="header" href="#25-崩溃报告">2.5 崩溃报告</a></h3>
<p>目前没有很好的崩溃报告工具，Electron 官方的 mini-bareakpad-server 已经很久没更新。但是开发者可以利用 Electron 内置的崩溃报告模块 crashReporter 来定制：</p>
<pre><code class="language-js">// 启动崩溃服务，会向地址发送 POST 请求
electron.crashReporter.start({
  productName: 'demo',
  submitURL: 'www.demo.com',
  uploadToServer: true,
  extra: '',
})

// 手动发送崩溃原因
electron.crashReporter.addExtraParameter(key, value)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="101-electron-应用发版"><a class="header" href="#101-electron-应用发版">10.1-Electron 应用发版</a></h1>
<h2 id="一-打包说明"><a class="header" href="#一-打包说明">一 打包说明</a></h2>
<p>Electron 应用打包出的软件与计算机系统有关，在 Win 下打包的软件则是 Windows 平台的安装包，在 Mac 下打包的出的软件则是 Mac 平台的安装包。</p>
<h2 id="二-应用图标"><a class="header" href="#二-应用图标">二 应用图标</a></h2>
<p>图标建议准备 1024*1024 大小的 png 格式，存放在 public 目录下：</p>
<pre><code class="language-txt"># 安装 electron-icon-builder 组件
npm i -D electron-icon-builder

# 在 package.json 中增加如下 script 指令
&quot;build-icon&quot;: &quot;electron-icon-builder&quot; --input=./public/icon.png --output=buil --flatten

# 执行，会在 build/icons 目录生成各种大小的图标文件
npm run build-icon
</code></pre>
<h2 id="三-打包"><a class="header" href="#三-打包">三 打包</a></h2>
<h3 id="31-打包工具"><a class="header" href="#31-打包工具">3.1 打包工具</a></h3>
<p>Electron 支持在 package.json 中设置 build 的配置、针对操作系统重写：</p>
<pre><code class="language-json">&quot;main&quot;: &quot;main.js&quot;,          // 设定入口文件
&quot;homepage&quot;: &quot;./&quot;,           // 解决 electron file 协议导致生产环境加载 index.html
&quot;build&quot;: {
    &quot;appid&quot;:&quot;demo&quot;,
    &quot;productName&quot;: &quot;示例软件&quot;,
    &quot;copyright&quot;:&quot;@copyright2021&quot;,
    &quot;mac&quot;: {
        &quot;productName&quot;: &quot;示例软件-MAC 版&quot;,
    }
}
</code></pre>
<p>常用的打包工具有：electron-packager、electron-builder，后者内置了自动升级配置，只要将打包的文件随意放置在 web 服务中即可完成自动升级，推荐后者。</p>
<p><strong>vue 的打包</strong>：</p>
<p>使用 <code>Vue CLI Plugin Electron Builder</code> 创建的项目，直接使用 <code>npm run electron:build</code> 即可打包，且会依据打包系统的不同产生不同平台的安装包。</p>
<p><strong>react 的打包</strong>：</p>
<p>额外添加：</p>
<pre><code class="language-js">&quot;build&quot;: {
    &quot;extends&quot;:null,
    &quot;files&quot;: [                          // 解决文件未被识别打包
        &quot;build/**/*&quot;,
        &quot;node_modules/**/*&quot;,
        &quot;config/**/*&quot;,
        &quot;package.json&quot;,
        &quot;main.js&quot;,
        &quot;./src/.....js&quot;,              // 这里要导入所有 main.js 中使用的 js 文件
        &quot;./src/.....js&quot;,
    ],
},
&quot;scripts&quot;: {
    &quot;predist&quot;: &quot;npm run build&quot;,         // node 特性：pre 前缀会在 dist 前自动执行
    &quot;dist&quot;: &quot;electron-builder&quot;,         // 生成安装包
    &quot;prepack&quot;: &quot;npm run build&quot;,         // node 特性：pre 前缀会在 pack 前自动执行
    &quot;pack&quot;: &quot;electron-builder --dir&quot;    // 生成绿色安装文件
},
</code></pre>
<h3 id="32-签名"><a class="header" href="#32-签名">3.2 签名</a></h3>
<p>为了避免包被串改，默认情况下，Mac 只允许从 Store 中下载，Win 下安装未签名的程序会出现风险提示。</p>
<p>给 Windows 应用签名，需要购买签名证书，可以在 digicert、godaddy 等平台购买。</p>
<p>如果使用了 electron-builder 打包，购买证书后可以按照 <a href="https://www.electron.build/configuration/win">https://www.electron.build/configuration/win</a> 中的文档配置。</p>
<p>如果使用了 <code>Vue CLI Plugin Electron Builder</code> 创建的项目打包，则配置信息将放置在 vue.config.js 中：</p>
<pre><code class="language-js">module.exports = {
  productionSourceMap: false,
  pluginOptions: {
    electronBuilder: {
      builderOptions: {
        win: {
          signingHashAlgorithms: ['sha1', 'sha256'],
          certificateFile: '证书文件',
          certificatePassword: '证书密码',
          certificateSubjectName: '',
          // ...
        },
      },
      mainProcessFile: 'public/background/start.js',
    },
  },
}
</code></pre>
<p>在 Mac 中打包时，无需额外配置，electron-builder 会自动加载钥匙串证书，但是该证书必须加入苹果开发者计划获取。</p>
<h3 id="33-打包优化"><a class="header" href="#33-打包优化">3.3 打包优化</a></h3>
<p>electron 遵守 node 规范，打包时是不会将 dev 依赖打包的。主要能优化的生成文件为 asr 文件，其本质是代码文件+node_modules 文件的压缩文件，优化的核心是正确放置开发依赖，生产依赖。</p>
<p>如果在 main.js 中使用了过多的依赖包，也会造成打包体积过大，优化方式是引入 webpack.config.js：</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
  target: 'electron-main',
  entry: './main.js',
  output: {
    path: path.resolve(__dirname, './build'),
    filename: 'main.js',
  },
  node: {
    __dirname: fale,
  },
}
</code></pre>
<p>打包脚本：</p>
<pre><code class="language-json">&quot;scripts&quot;: {
    &quot;predist&quot;: &quot;npm run build &amp;&amp; npm run buildMain&quot;,
    &quot;prepack&quot;: &quot;npm run build &amp;&amp; npm run buildMain&quot;,
}
&quot;buildMain&quot;: 'webpack ',
&quot;build&quot;: {
    &quot;files&quot;: [            // 可以删除根目录与 main 相关的 js 文件了

    ],
    &quot;extraMetadata&quot;:{
        &quot;main&quot;: &quot;./build/main.js&quot;   // 此时 main 被打包在了该文件
    },
}
</code></pre>
<p>注意：此时 main.js 中 load 的地址是： <code>file://${path.join(__dirname, './index.html')}</code>。做完这些配置后，就可以将 main.js 中相关不需要的依赖移入到 dev 依赖。</p>
<h2 id="四-版本更新"><a class="header" href="#四-版本更新">四 版本更新</a></h2>
<h3 id="41-自动发布"><a class="header" href="#41-自动发布">4.1 自动发布</a></h3>
<p>首先可以配置代码、安装包发布地址，比如发布到 github 上：<code>publish: ['github']</code>，详细示例为：</p>
<pre><code class="language-js">scripts: {
    &quot;prerelease&quot;: &quot;npm run build &amp;&amp; npm run buildMain&quot;,
    // electron-builder 会为 release 命令添加 publish，即不但要打包，还要将其 push 到远端，GH_TOKEN 为 githubtoken
    &quot;release&quot;: &quot;cross-env GH_TOKEN=wqewjkhjad21enj2 electron-builder&quot;,
},
publish: [
    {
        provider: 'generio',
        url: 'http://dowload.demo.com',
    },
]
</code></pre>
<h3 id="42-自动更新"><a class="header" href="#42-自动更新">4.2 自动更新</a></h3>
<p>url 是升级的地址在哪儿，还需要在主进程加入：</p>
<pre><code class="language-js">const { autoUpdater } = require('electron-updater')

app.on('ready', () =&gt; {
  // 其他代码

  // 自动升级代码
  autoUpdater.autoDownload = false
  autoUpdater.checkForUpdates()
  autoUpdater.on('error', (error) =&gt; {
    dialog.showErrorBox('更新失败')
    console.log('更新失败：', error)
  })
  autoUpdater.on('update-available', () =&gt; {
    dialog.showMessageBox(
      {
        type: 'info',
        title: '应用有新版本',
        message: '应用有新版本，是否现在更新',
        buttons: ['是', '否'],
      },
      (buttonIndex) =&gt; {
        if (buttonIndex === 0) {
          autoUpdater.downloadUpdate()
        }
      }
    )
  })
  autoUpdater.on('update-not-available', () =&gt; {
    dialog.showMessageBox({
      title: '没有新版本',
      message: '当前没有版本',
    })
  })

  // 其他代码
})

autoUpdater.on('update-download', () =&gt; {
  this.mainWin.webContents.send('updateDownLoaded')
})

ipcMain.on('quitAndInstall', (event) =&gt; {
  autoUpdater.quitAndInstall()
})
</code></pre>
<p>上述代码尽量保持在窗口启动后适当时机运行，以不占用窗口启动时间。autoUpdater 模块负责管理程序的升级，<code>checkForUpdates()</code> 则会检查服务端的配置文件是否存在更新的安装程序（对比 package 中的 version），如果有，则开始下载，下载后会给渲染进程发送消息，由渲染进程提示用户“当前有新版本，是否需要升级”，用户选择升级后，由渲染进程发送 'quitAndInstall' 给主进程，主进程自动升级，退出程序，安装完毕后重启。</p>
<p>注意：如果使用的是 <code>Vue CLI Plugin Electron Builder</code> 创建的项目打包，则此配置位于 vue.config.js 的 builderOptions 节点中。</p>
<h3 id="43-开发环境调试升级功能"><a class="header" href="#43-开发环境调试升级功能">4.3 开发环境调试升级功能</a></h3>
<p>在自动更新时，需要一个 app-update.yml 文件，该文件在 release 时会自动生成，开发环境不可能有该文件，此时需要手动创建 dev-app-update.yml 文件：</p>
<pre><code class="language-yml">owner: ryj
repo: demo
provider: github
</code></pre>
<p>修改开发环境下的 main.js</p>
<pre><code class="language-js">app.on('ready', () =&gt; {
  if (isDev) {
    autoUpdater.updateConfigPaht = path.join(__dirname, 'dev-app-update.yml')
  }
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-electron-优化"><a class="header" href="#111-electron-优化">11.1-Electron 优化</a></h1>
<h2 id="一-优化建议"><a class="header" href="#一-优化建议">一 优化建议</a></h2>
<h3 id="11-包体积问题优化"><a class="header" href="#11-包体积问题优化">1.1 包体积问题优化</a></h3>
<p>Electron 与 Web 项目不同，其部署环境比较多维复杂，需要尽量节省内存。而 Electron 由于使用 Chrome 内核，其对 W3C 的标准支持足够，多数兼容性要求并不在 Electron 项目的考虑之中。比如 axios 库中做了大量的用户环境判断，这在 Electron 中是完全不需要的！</p>
<p>Electron 由于是本地应用，不存在网络下载速度问题，所以本地文件如 JS 模块，应该尽量合并，避免不必要的加载工作，当然这在单页面应用流行的当下，该问题并不突出。</p>
<p>Node.js 的 web 项目往往会在头部 require 大量模块，这是因为 web 环境不太需要担心初始化时候的资源消耗问题，Electron 应用应该尽量在使用时 require！</p>
<h3 id="12-性能优化的建议"><a class="header" href="#12-性能优化的建议">1.2 性能优化的建议</a></h3>
<p>应当尽量规避同步方法的应用，比如主进程中使用会造成整个系统的停顿，用户体验极差。可以使用 Web Worker 标准来处理，或者判断系统是否空闲来处理：</p>
<pre><code class="language-js">powerMoitor.getSystemIdleState(idleThreshold)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-html-html-概念"><a class="header" href="#011-html-html-概念">01.1-HTML-HTML 概念</a></h1>
<h2 id="一-网页标准"><a class="header" href="#一-网页标准">一 网页标准</a></h2>
<h3 id="11-网页的构成要素"><a class="header" href="#11-网页的构成要素">1.1 网页的构成要素</a></h3>
<p>网页的内容主要由三部分组成：<strong>结构</strong>、<strong>表现</strong>、<strong>行为</strong>。</p>
<blockquote>
<p>结构：通过 HTML 实现，即 <code>Hyper text markup language</code> ，超文本标记语言，负责网页中各种标签内容的显示
表现：通过 CSS 实现，即 <code>Cascading Style Sheets</code>，层叠样式表，负责网页中各种样式的显示
行为：通过 JavaScript 实现，负责网页中各种行为的显示</p>
</blockquote>
<h3 id="12-网页规范"><a class="header" href="#12-网页规范">1.2 网页规范</a></h3>
<p>HTML 标准由 W3C 组织制定，经过多年发展，现在的标准版本为 HTML5，当然其兼容性仍然较差，市面上现有的 HTML 标准有：</p>
<ul>
<li>HTML4：被大多数浏览器所兼容</li>
<li>XHTML：是 HTML4 与 XML 的过渡版本，不推荐使用</li>
<li>XML：可以自定义标签，但是未被浏览器标准接受，被广泛应用于通信协议领域</li>
<li>HTML5：具备划时代意义的 HTML 版本，已经被 Chrome、FireFox 等浏览器接受，但是很多场合兼容度较低，需要做兼容处理</li>
</ul>
<h3 id="13-html-网页结构"><a class="header" href="#13-html-网页结构">1.3 HTML 网页结构</a></h3>
<p>标准 HTML4 网页结构：</p>
<pre><code class="language-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    hello world!
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>HTML 文档整体两部分组成：</p>
<ul>
<li>文档声明：<code>&lt;!DOCTYPE html&gt;</code>。用于帮助浏览器正确显示网页，即指示浏览器使用的是哪个 HTML 版本，声明必须放在第一行。</li>
<li>文档文本：由 <code>&lt;html&gt; &lt;/html&gt;</code> 标签包裹，是 HTML 文档的内容展示区。其中 header 用于描述文档基本信息，body 是文档内容</li>
</ul>
<p>文档声明现在默认使用 H5 标准即可，浏览器大多支持向下兼容，标准的 H5 网页如下所示：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    hello world!
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="二-html-的基本结构"><a class="header" href="#二-html-的基本结构">二 HTML 的基本结构</a></h2>
<h3 id="21-header"><a class="header" href="#21-header">2.1 header</a></h3>
<p>header 标签是网页头部，用于描绘网页的基础信息，其内部包含的标签有：</p>
<ul>
<li>link：网页中引入的样式表、标题小图标</li>
<li>meta：网页的元信息</li>
<li>title：网页标题</li>
</ul>
<p>link 用来引入外部资源，如浏览器标题小图标、css：</p>
<pre><code class="language-html">&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; /&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot; /&gt;
</code></pre>
<p>meta 标签用来设置字符集、关键字、描述、重定向等，这些元信息并不是给用户看的，而是告诉浏览器、爬虫等如何显示等：</p>
<pre><code class="language-html">&lt;!-- 网页字符集 --&gt;
&lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;!-- 网页关键字 --&gt;
&lt;meta name=&quot;keywords&quot; content=&quot;流行资讯&quot; /&gt;
&lt;!-- 网页描述 --&gt;
&lt;meta name=&quot;description&quot; content=&quot;最新服装设计流行信息&quot; /&gt;
&lt;!-- 2 秒后跳转到 1.html --&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2; url=1.html&quot; /&gt;
</code></pre>
<h3 id="22-body"><a class="header" href="#22-body">2.2 body</a></h3>
<p>body 标签内的内容是网页的肢体信息，网页内容在这个地方显示：</p>
<pre><code class="language-html">&lt;body&gt;
  网页内容....
&lt;/body&gt;
</code></pre>
<h2 id="三-html-网页代码优化"><a class="header" href="#三-html-网页代码优化">三 HTML 网页代码优化</a></h2>
<h3 id="31-常见规范"><a class="header" href="#31-常见规范">3.1 常见规范</a></h3>
<p>CSS 推荐在 head 标签中引入，以让浏览器在输出 HTML 之前获取到样式信息，正确展示。</p>
<p>JS 推荐在 body 标签末尾引入，即页面显示后再载入脚本，可以加快页面呈现给用户的速度，也能正确让 js 操作页面中的元素。</p>
<p>开发中使用代码检查工具，如 ESLint 能够很好的检验代码规范。</p>
<p>一些常见贴士：</p>
<pre><code class="language-txt">标题标签推荐使用 h1-h6
table 一定要使用 caption 设置表格题目
br 标签一般只用于文本内换行
</code></pre>
<h3 id="32-标签嵌套规范"><a class="header" href="#32-标签嵌套规范">3.2 标签嵌套规范</a></h3>
<p>块级元素可以包含内联元素或者某些块级元素，但是内联元素不能包含块级元素，只能包含其他内联元素。</p>
<p>一些特殊的标签只能包含内联元素：<code>h1-h6</code>、<code>p</code>、<code>dt</code>。</p>
<p>ul 与 li，ol 与 li，dl 与 dt、dd 等有父子关系，父级下只能有其对应子标签。</p>
<p>a 标签不能嵌套 a 标签。</p>
<pre><code class="language-html">&lt;!--正确写法--&gt;
&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

&lt;!--正确写法--&gt;
&lt;a&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt;

&lt;!--错误写法--&gt;
&lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt;

&lt;!--错误写法--&gt;
&lt;p&gt;&lt;ol&gt;&lt;/ol&gt;&lt;/p&gt;

&lt;!--错误写法--&gt;
&lt;ul&gt;&lt;div&gt;&lt;/div&gt;&lt;li&gt;&lt;/li&gt;&lt;/p&gt;
</code></pre>
<h2 id="四-html-中的实体与实体编号"><a class="header" href="#四-html-中的实体与实体编号">四 HTML 中的实体与实体编号</a></h2>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/html/01.png" alt="HTML 中的实体" /></p>
<h2 id="五-编辑器的-emmet-语法"><a class="header" href="#五-编辑器的-emmet-语法">五 编辑器的 emmet 语法</a></h2>
<p>emmet 语法用于提升编辑器的操作速度，笔者这里是 vscode：</p>
<ul>
<li>输入 div，tab 键可以直接输入完整的 div 标签</li>
<li>输入 html，tab 键可以直接输入完整的 html 文档</li>
<li>输入 <code>div*3</code>，tab 键可以直接输入 3 个 div</li>
<li>输入 <code>ul&gt;li*3</code>，tab 键可以输入 ul/li，并有 3 个 li</li>
<li>输入 div+p，tab 键可以输入 div 与 p 两个兄弟节点</li>
<li>输入 .demo，tab 键可以直接输入 <code>&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;</code>，类似的也支持 #</li>
<li>输入 <code>.demo\$*3</code>，tab 键可以为 class 类名做自增，class=demo1</li>
</ul>
<h2 id="六-其他语法"><a class="header" href="#六-其他语法">六 其他语法</a></h2>
<h3 id="61-特殊字符"><a class="header" href="#61-特殊字符">6.1 特殊字符</a></h3>
<p>Html 中的特殊字符需要使用转义字符书写：</p>
<div class="table-wrapper"><table><thead><tr><th>特殊字符</th><th>HTML 中的表示</th></tr></thead><tbody>
<tr><td>空格</td><td><code>&amp;nbsp;</code></td></tr>
<tr><td>&lt;</td><td><code>&amp;lt;</code></td></tr>
<tr><td>&gt;</td><td><code>&amp;gt</code></td></tr>
<tr><td>&amp;</td><td><code>&amp;amp;</code></td></tr>
</tbody></table>
</div>
<h3 id="62-注释"><a class="header" href="#62-注释">6.2 注释</a></h3>
<pre><code class="language-html">&lt;!-- 这里书写注释 --&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="012-html-h5-的变化"><a class="header" href="#012-html-h5-的变化">01.2-HTML-H5 的变化</a></h1>
<h2 id="一-html5-概念"><a class="header" href="#一-html5-概念">一 HTML5 概念</a></h2>
<p>HTML5 是一个很宽泛的概念，他不再是简单的 HTML4 标签规范的升级，而是泛指浏览器生态中的 DOM 相关的新规范。HTML5 制定了 Web 应用的标准：更多的语义化标签，新的表单，多媒体，canvas，数据存储，地理应用等等。</p>
<p>HTML5 特性验证地址：<a href="https://validator.w3.org/">https://validator.w3.org/</a></p>
<p>HTML5 语法变化：</p>
<pre><code class="language-txt">HTML 文档结构更加简洁清晰
标签不再区分大小写
单标签可统一写为&lt;img /&gt;，常见的有：area，base，br，col，hr，img，input，link，mata
省略结束标签元素：dt，dd，li，option，p，thead，tbody，tr，td，t
可省略全部标签元素：html，head，body，tbdy
允许省略属性名
允许省略属性值的引号
删除了少量的元素和属性，如 font，HTML5 推荐使用 CSS 来控制
</code></pre>
<h2 id="二-html5-的文档"><a class="header" href="#二-html5-的文档">二 HTML5 的文档</a></h2>
<h3 id="21-html5-文档结构"><a class="header" href="#21-html5-文档结构">2.1 HTML5 文档结构</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="22-html5-中的-meta-标签"><a class="header" href="#22-html5-中的-meta-标签">2.2 HTML5 中的 meta 标签</a></h3>
<p>H5 可以设置多个 meta 标签：</p>
<pre><code class="language-html">&lt;!--过期时间--&gt;
&lt;meta http-equiv=&quot;Expires&quot; content=&quot;Sat Sep 27 16:12:33 CST 2009&quot; /&gt;
&lt;!--禁止从缓存中读取页面--&gt;
&lt;meta http-equiv=&quot;Pragma &quot; content=&quot;no-cache &quot; /&gt;
&lt;!--自动刷新--&gt;
&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2&quot; URL=&quot;http://www.a.com&quot; /&gt;
&lt;!--网页过期删 Cookie--&gt;
&lt;meta
  http-equiv=&quot;Set-cookie&quot;
  content=&quot;name=value expires=Sat Sep 27 16:12:33 CST 2009,path=/&quot;
/&gt;
</code></pre>
<h3 id="23-h5-对标签功能的扩展"><a class="header" href="#23-h5-对标签功能的扩展">2.3 H5 对标签功能的扩展</a></h3>
<p>H5 对标签功能的扩展：</p>
<pre><code class="language-html">&lt;figure&gt;
  &lt;figcaption&gt;这是图片&lt;/figcaption&gt;
  &lt;!--这里会换行--&gt;
  &lt;img src=&quot;./1.jpg&quot; /&gt;
&lt;/figure&gt;
</code></pre>
<h2 id="三-语义化标签"><a class="header" href="#三-语义化标签">三 语义化标签</a></h2>
<h3 id="31-语义化标签的使用"><a class="header" href="#31-语义化标签的使用">3.1 语义化标签的使用</a></h3>
<p>为了表示一个网页结构中的区块相对独立，可以使用 <code>div</code> <code>span</code> 标签来表示，这 2 个标签没有任何意义。但是大量的 div、span 标签在阅读性上有瑕疵，且对搜索引擎的优化支持有限。为了让 div 标签实现可阅读性，往往这样做：</p>
<pre><code class="language-html">&lt;div class=&quot;header&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;nav&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;
</code></pre>
<p>但是这种做法对搜索引擎来说，是没有语义的，H5 推出了更多对引擎收录、代码阅读起到一定语义的标签来替代 div、span：</p>
<pre><code class="language-html">&lt;!--头部标签--&gt;
&lt;header&gt;&lt;/header&gt;
&lt;!--导航标签--&gt;
&lt;nav&gt;&lt;/nav&gt;
&lt;!--内容标签--&gt;
&lt;article&gt;&lt;/article&gt;
&lt;!--区块标签--&gt;
&lt;section&gt;&lt;/section&gt;
&lt;!--侧边栏标签--&gt;
&lt;aside&gt;&lt;/aside&gt;
&lt;!--主要区域标签--&gt;
&lt;main&gt;&lt;/main&gt;
&lt;!--底部标签--&gt;
&lt;footer&gt;&lt;/footer&gt;
</code></pre>
<p>他们在页面中代表了如下区域：
<img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/html/02.png" alt="H5 语义化标签" /></p>
<p>标签语义化方式：</p>
<ul>
<li>尽可能少的使用无语义的标签 div 和 span；</li>
<li>在语义不明显时，既可以使用 div 或者 p 时，尽量用 p, 因为 p 在默认情况下有上下间距，对兼容特殊终端有利；</li>
<li>不要使用纯样式标签，如：b、font、u 等，改用 css 设置。</li>
<li>需要强调的文本，可以包含在 strong 或者 em 标签中 strong 默认样式是加粗（不要用 b），em 是斜体（不用 i）；</li>
</ul>
<h3 id="32-语义化标签在-ie-中的兼容"><a class="header" href="#32-语义化标签在-ie-中的兼容">3.2 语义化标签在 IE 中的兼容</a></h3>
<p>在不支持 HTML5 新标签的浏览器里，会将这些新的标签解析成行内元素 (inline) 对待，所以我们只需要将其转换成块元素 (block) 即可使用。但是在 IE9 版本以下，并不能正常解析这些新标签，但是可以通过<code>document.createElement('footer')</code>创建的自定义标签（创建出来的元素是行内元素，因此一般情况下要给：<code>display:block）</code>。</p>
<p>在实际开发中，一般使用第三方兼容文件 html5shiv 来解决上述问题：</p>
<pre><code class="language-html">&lt;script src=&quot;html5shiv.js&quot;&gt;&lt;/script&gt;
&lt;!--[if lte IE 9]&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;htmlshiv.js&quot;&gt;&lt;/script&gt;
&lt;![endif]--
</code></pre>
<h3 id="33-语义化标签使用规范"><a class="header" href="#33-语义化标签使用规范">3.3 语义化标签使用规范</a></h3>
<p>标题推荐使用 h1、h2、h3，列表使用 ul 或者 ol；</p>
<p>在适当的地方是使用 H5 新元素，如：header、footer、nav、aside；</p>
<p>正文文本内容推荐使用 p 标签，内容结构化推荐使用 H5 新元素或 div；</p>
<p>修改文字样式时，em 和 string 要比 i 和 b 语义更明显；</p>
<p>form 中要包含 label 元素，input 元素要有 type、placeholder 以及其他必要属性，即使值为空都可以；</p>
<p>尽量减少无意义标签，如：span、div；</p>
<p>尽量不使用标签本身的 css 属性，例如 b、font、s 等标签，使用 css 来添加。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="013-html-常见标签"><a class="header" href="#013-html-常见标签">01.3-HTML-常见标签</a></h1>
<h2 id="一-标签分类"><a class="header" href="#一-标签分类">一 标签分类</a></h2>
<p>网页的内容都是由大量的 HTML 标签构成，按照标签的开合可以将标签分为分类：</p>
<ul>
<li>单标签：只有开始没有结束，如：<code>&lt;hr&gt; &lt;!-- --&gt; &lt;br&gt; &lt;hr&gt;</code></li>
<li>双标签：有开始有结束，如：<code>&lt;p&gt;&lt;/p&gt; &lt;em&gt;&lt;/em&gt;</code></li>
</ul>
<h2 id="二-区域类标签"><a class="header" href="#二-区域类标签">二 区域类标签</a></h2>
<p>区域类标签只是笔者自己将一些类似作用的标签划分到了一起。这些标签不会对内容的样式产生较大影响，仅仅可以用来包裹一些网页结构。</p>
<p>div 与 span 是最常见的该类型标签，他们没有任何修饰意义：</p>
<pre><code class="language-html">&lt;!-- 代表块区 --&gt;
&lt;div&gt;div 内容&lt;/div&gt;
&lt;!-- 代表文本区 --&gt;
&lt;span&gt;span 内容&lt;/span&gt;
</code></pre>
<h2 id="三-常用标签"><a class="header" href="#三-常用标签">三 常用标签</a></h2>
<h3 id="31-标题标签"><a class="header" href="#31-标题标签">3.1 标题标签</a></h3>
<p>标题用于显著展示内容，一般是文章的题目等，总计有六个，从上往下字体大小依次缩小：</p>
<pre><code class="language-txt">&lt;h1&gt;标题 1&lt;h1&gt;
&lt;h2&gt;标题 2&lt;h2&gt;
&lt;h3&gt;标题 3&lt;h3&gt;
&lt;h4&gt;标题 4&lt;h4&gt;
&lt;h5&gt;标题 5&lt;h5&gt;
&lt;h6&gt;标题 6&lt;h6&gt;
</code></pre>
<h3 id="32-段落标签"><a class="header" href="#32-段落标签">3.2 段落标签</a></h3>
<pre><code class="language-txt">&lt;p&gt;
被格式化的 段 落
被格式化的 段 落
&lt;/p&gt;
&lt;pre&gt;
被格式化的 段 落
被格式化的 段 落
&lt;/pre&gt;
</code></pre>
<h3 id="33-换行标签"><a class="header" href="#33-换行标签">3.3 换行标签</a></h3>
<p><code>&lt;br&gt;</code> 标签用来强制换行，但是一般场景中会使用文档流自动换行。该标签是单标签。</p>
<h3 id="34-图片标签"><a class="header" href="#34-图片标签">3.4 图片标签</a></h3>
<p>图片标签 img 示例：</p>
<pre><code class="language-html">&lt;img src=&quot;1.jpg&quot; atl=&quot;我是图片&quot; title=&quot;图片标题&quot; width=&quot;200&quot; height=&quot;300&quot; /&gt;
</code></pre>
<p>img 标签常用属性：</p>
<pre><code class="language-txt">alt：当图片无法显示时显示 alt 内的文字
src：图片路径，可以是绝对路径（/开头）或者相对路径（./开头，可以省略./）
</code></pre>
<p>图片的格式的不同是有区别的，理论环境下：</p>
<ul>
<li>gif 文件较大，且不清晰，但是支持动画</li>
<li>jpg 格式则更加清晰，且文件更小，网页中的大图推荐使用 jpg</li>
<li>png 是无损压缩，可以保持图片的星系，但是其文件较大，小图适合使用 png（比如 LOGO），当然小图标使用字体图标更加优秀。此外 png 还能支持图片透明。</li>
</ul>
<h3 id="35-链接标签"><a class="header" href="#35-链接标签">3.5 链接标签</a></h3>
<p>a 链接示例：</p>
<pre><code class="language-html">&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt;
</code></pre>
<p>a 标签常用属性：</p>
<pre><code class="language-txt">href：值为#时不能跳转，值为一个文件时则可以实现下载功能
title：鼠标划过时显示的文字
target：网页打开方式，常见打开方式有：_self：默认值，在当前页打开，_blank：在新窗口中打开
</code></pre>
<p>锚链接位置跳转演示：</p>
<pre><code class="language-html">&lt;p id=&quot;test&quot;&gt;你好&lt;/p&gt;
&lt;a href=&quot;#test&quot;&gt;查看问候语&lt;/a&gt;
</code></pre>
<p>a 链接特殊写法：可以制造点击不执行，一般在 tab 栏切换中使用</p>
<pre><code class="language-html">&lt;a href=&quot;”javascript:;”&quot;&gt;&lt;/a&gt; &lt;a href=&quot;”javascript:void(0);”&quot;&gt;&lt;/a&gt;
</code></pre>
<h3 id="36-列表标签"><a class="header" href="#36-列表标签">3.6 列表标签</a></h3>
<p>无序列表 ul：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;新闻 1&lt;/li&gt;
  &lt;li&gt;新闻 2&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>无序列表，默认无任何显示样式，但是可以添加一些样式：</p>
<pre><code class="language-txt">type=&quot;square&quot;：列表样式为小方块
type=&quot;circle&quot;：列表样式为小圆圈
</code></pre>
<p>有序列表 ol:</p>
<pre><code class="language-html">&lt;ol type=&quot;a&quot; start=&quot;3&quot;&gt;
  &lt;li&gt;新闻 1&lt;/li&gt;
  &lt;li&gt;新闻 2&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p>有序列表的样式：</p>
<pre><code class="language-txt">A,a：分别以 A 或者 a 字幕顺序排序
I,i：分别以大小写罗马数字排列
start=&quot;3&quot; ：li 前面的显示从第几个开始计数
</code></pre>
<p>自定义列表 dl：</p>
<pre><code class="language-html">&lt;dl&gt;
  &lt;dt&gt;新闻汇总&lt;/dt&gt;
  &lt;dd&gt;新闻 1&lt;/dd&gt;
  &lt;dd&gt;新闻 2&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>
<h2 id="四-表格标签-table"><a class="header" href="#四-表格标签-table">四 表格标签 table</a></h2>
<p>表格标签在以前用来作为布局使用，现在已经被淘汰，只作为纯表格使用。</p>
<h3 id="41-table-组成"><a class="header" href="#41-table-组成">4.1 table 组成</a></h3>
<pre><code class="language-html">&lt;table
  border=&quot;1&quot;
  width=&quot;300&quot;
  height=&quot;100&quot;
  cellspacing=&quot;0&quot;
  cellpadding=&quot;5&quot;
  align=&quot;center&quot;
  bgcolor=&quot;pink&quot;
&gt;
  &lt;tr&gt;
    &lt;th&gt;姓名&lt;/th&gt;
    &lt;th&gt;性别&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;111&lt;/td&gt;
    &lt;td&gt;122&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;211&lt;/td&gt;
    &lt;td&gt;222&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>表格结构:thead（表头）、tbody（主体）、tfoot（结尾）</p>
<pre><code class="language-txt">cellspacing：用来设置单元格与单元格的距离（td），默认值为 2
cellpadding：设置内容距边框的距离（文字距离 td 左侧）
align：设置对齐方式，包括 left、right、center
</code></pre>
<p>注意：table 标签的标题标签是 caption，不能使用 title。td 内容垂直对齐使用 valign。</p>
<pre><code class="language-html">&lt;!-- valign 的其他值有 top middle bottom --&gt;
&lt;td valign=&quot;bottom&quot;&gt;123&lt;/td&gt;
</code></pre>
<h3 id="42-合并单元格"><a class="header" href="#42-合并单元格">4.2 合并单元格</a></h3>
<ul>
<li>横向合并 colspan：设置 td 的横向合并</li>
<li>纵向合并 rowspan：设置 td 的纵向合并</li>
</ul>
<pre><code class="language-html">&lt;table width=&quot;300&quot; height=&quot;200&quot; cellspacing=&quot;0&quot; border=&quot;1&quot;&gt;
  &lt;tr&gt;
    &lt;td colspan=&quot;2&quot;&gt;111&lt;/td&gt;
    &lt;td&gt;122&lt;/td&gt;
    &lt;td&gt;133&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;211&lt;/td&gt;
    &lt;td&gt;222&lt;/td&gt;
    &lt;td rowspan=&quot;2&quot;&gt;233&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;311&lt;/td&gt;
    &lt;td&gt;322&lt;/td&gt;
    &lt;td&gt;333&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<h2 id="五-h5-新增的多媒体标签"><a class="header" href="#五-h5-新增的多媒体标签">五 H5 新增的多媒体标签</a></h2>
<h3 id="51-新增多媒体标签---音频标签"><a class="header" href="#51-新增多媒体标签---音频标签">5.1 新增多媒体标签 - 音频标签</a></h3>
<p>H5 支持在网页中直接嵌入多媒体标签。</p>
<p>音频标签为 <code>&lt;audio&gt;</code>，由于版权原因，各大浏览器支持播放格式为：</p>
<pre><code class="language-txt">IE9：       MP3
Firefox：   Ogg、Wav
Chrome：    Ogg、MP3
Safari：    MP3、Wav
</code></pre>
<p>音屏标签常见属性：</p>
<pre><code class="language-txt">autoplay：值为 autoplay，自动播放
controls：值为 controls，向用户显示控件，如播放按钮
loop：值为 loop，当银屏结束时重新播放
src：值为 资源地址
</code></pre>
<p>为了兼容，往往这样写：</p>
<pre><code class="language-html">&lt;audio controls=&quot;controls&quot;&gt;
  &lt;source src=&quot;demo.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;
  &lt;source src=&quot;demo.ogg&quot; type=&quot;audio/ogg&quot; /&gt;
  您的浏览器不兼容该音频格式
&lt;/audio&gt;
</code></pre>
<h3 id="52-新增多媒体标签---视频标签"><a class="header" href="#52-新增多媒体标签---视频标签">5.2 新增多媒体标签 - 视频标签</a></h3>
<p>视频标签为 <code>&lt;video&gt;</code>，视频格式的版权限制如下：</p>
<pre><code class="language-txt">IE9：       MP4
Firefox：   Ogg、WebM
Chrome：    MP4、Ogg、WebM
Safari：    MP4
</code></pre>
<p>视频标签的常用属性：</p>
<pre><code class="language-txt">autoplay：值为 autoplay，自动播放
controls：值为 controls，向用户显示控件，如播放按钮
loop：值为 loop，当银屏结束时重新播放
src：值为 资源地址
width、height
preload：值为 auto 代表预先加载视频，值为 none 则不预加载
poster：值为 图片地址，加载等待时的图片
muted：值为 muted，静音播放
</code></pre>
<p>贴士：</p>
<ul>
<li>Chrome 将多媒体的自动播放禁止了</li>
<li>音频无法实现自定义播放</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="014-html-表单标签"><a class="header" href="#014-html-表单标签">01.4-HTML-表单标签</a></h1>
<h2 id="一-表单标签"><a class="header" href="#一-表单标签">一 表单标签</a></h2>
<h3 id="11-表单标签简介"><a class="header" href="#11-表单标签简介">1.1 表单标签简介</a></h3>
<p>表单用来收集信息，是前台与后台进行交互的最常见的地方。构成包含：</p>
<ul>
<li>表单域：<code>form</code> 标签即代表包裹了一个表单域</li>
<li>表单控件：<code>input</code> 等</li>
</ul>
<p>如下所示：</p>
<pre><code class="language-html">&lt;!--  action:用来处理表单数据 method:表单提交得方式 --&gt;
&lt;form action=&quot;&quot; method=&quot;&quot;&gt;
  &lt;label&gt;账户：&lt;/label&gt;
  &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;请输入账户&quot; /&gt;
  &lt;label&gt;密码：&lt;/label&gt;
  &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;
&lt;/form&gt;
</code></pre>
<h3 id="12-表单优化写法"><a class="header" href="#12-表单优化写法">1.2 表单优化写法</a></h3>
<p>为了提升用户体验，点击 label 标签的文字应该让焦点也到达 label 标签后续的表单控件，for 属性就是这个用途：</p>
<pre><code class="language-html">&lt;!-- for 中填写对应要获取焦点的 id 即可 --&gt;
&lt;form action=&quot;&quot; method=&quot;&quot;&gt;
  &lt;label for=&quot;account&quot;&gt;账户：&lt;/label&gt;
  &lt;input type=&quot;text&quot; id=&quot;account&quot; name=&quot;username&quot; /&gt;
  &lt;label for=&quot;pass&quot;&gt;密码：&lt;/label&gt;
  &lt;input type=&quot;password&quot; id=&quot;pass&quot; name=&quot;password&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p>当然也可以使用 label 包裹 表单控件的方式，此时无需利用 for 与 id 属性即可实现自动获取焦点：</p>
<pre><code class="language-html">&lt;form action=&quot;&quot; method=&quot;&quot;&gt;
  &lt;label&gt;
    账户：
    &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
  &lt;/label&gt;
  &lt;label&gt;
    密码：
    &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;
  &lt;/label&gt;
&lt;/form&gt;
</code></pre>
<h3 id="13-表单控件"><a class="header" href="#13-表单控件">1.3 表单控件</a></h3>
<p>只有位于表单域中的数据才能被提交，这些数据存放于 input 标签（表单控件）中。</p>
<p>input 标签的 type 可以指定控件的类型为文本、密码、单选框、邮箱等等多种类型，而且不同的 type，浏览器默认会有不同的校验，比如当类型有邮箱时，输入的数据不是邮箱，就无法提交。</p>
<p>注意：<code>type=&quot;submit&quot;</code> 是用于提交表单的按钮。</p>
<h3 id="14-表单控件属性"><a class="header" href="#14-表单控件属性">1.4 表单控件属性</a></h3>
<p>表单控件的常见属性有：</p>
<pre><code class="language-txt">maxlength=&quot;6&quot;             限制输入字符长度
readonly=&quot;readonly&quot;       将输入框设置为只读状态（不能编辑）
disabled=&quot;disabled&quot;       输入框未激活状态
name=&quot;username&quot;           输入框的名称
value=&quot;大前端&quot;             为当前控件设置默认值，将输入框的内容传给处理文件
placeholder=&quot;请输入密码&quot;    提示信息属性
require                   强制填写
autocomplete=&quot;on&quot;         开启历史输入数据提示
</code></pre>
<h2 id="二-常用表单控件"><a class="header" href="#二-常用表单控件">二 常用表单控件</a></h2>
<pre><code class="language-html">&lt;!-- 文本框--&gt;
&lt;input type=&quot;text&quot; /&gt;

&lt;!-- 密码框：密码输入框的属性与文本输入框一致--&gt;
&lt;input type=&quot;password&quot; /&gt;

&lt;!-- 单选框：表单控件一般都有 name 属性，单选框如果没有 name，就不能实现单选，checked=&quot;checked&quot;，表示默认选中--&gt;
&lt;input type=&quot;radio&quot; name=&quot;a&quot; /&gt;
男
&lt;input type=&quot;radio&quot; name=&quot;a&quot; /&gt;
女

&lt;!-- 多选框 checked 代表默认选中--&gt;
&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;
喝酒

&lt;!--普通按钮，长与 JavaScript 配合使用--&gt;
&lt;input type=&quot;button&quot; vulue=&quot;登录&quot; /&gt;

&lt;!--提交按钮，用来完成内容提交--&gt;
&lt;input type=&quot;submit&quot; /&gt;

&lt;!-- 重置按钮：该按钮将页面中的表单控件中的值恢复到默认值 --&gt;
&lt;input type=&quot;reset&quot; /&gt;

&lt;!-- 上传文件：此时需要设置  form 的 enctype=&quot;multipart/form-data&quot;--&gt;
&lt;!-- 上传多个可以使用 name=&quot;image[]&quot; 上传限制：accpet=&quot;image/png,image/jpeg --&gt;
&lt;input type=&quot;file&quot; name=&quot;image&quot; /&gt;

&lt;!-- 数据提示 --&gt;
&lt;inpyt type=&quot;search&quot; name=&quot;searchList&quot; list=&quot;lesson&quot; /&gt;
&lt;datalist id=&quot;lsesson&quot;&gt;
  &lt;option value=&quot;html&quot;&gt;html&lt;/option&gt;
  &lt;option value=&quot;css&quot;&gt;css&lt;/option&gt;
  &lt;option value=&quot;js&quot;&gt;js&lt;/option&gt;
&lt;/datalist&gt;

&lt;!-- 下拉列表：属性 multiple=&quot;multiple&quot;可以实现多选--&gt;
&lt;select&gt;
  &lt;option&gt;河北&lt;/option&gt;
  &lt;option selected=&quot;selected&quot;&gt;河南&lt;/option&gt;
&lt;/select&gt;
&lt;!-- 下拉还可以有更深的子级嵌套： --&gt;
&lt;select&gt;
  &lt;optgroup label=&quot;河南&quot;&gt;
    &lt;option&gt;南阳&lt;/option&gt;
    &lt;option&gt;洛阳&lt;/option&gt;
  &lt;/optgroup&gt;
&lt;/select&gt;

&lt;!-- 分组控件 --&gt;
&lt;fieldset&gt;
  &lt;legend&gt;用户注册信息&lt;/legend&gt;
&lt;/fieldset&gt;

&lt;!-- 多行文本域 cols  控制输入字符的长度，rows  控制输入的行数--&gt;
&lt;textarea&gt;&lt;/textarea&gt;
</code></pre>
<h2 id="三-h5-中表单的改变"><a class="header" href="#三-h5-中表单的改变">三 H5 中表单的改变</a></h2>
<h3 id="31-新增表单类型"><a class="header" href="#31-新增表单类型">3.1 新增表单类型</a></h3>
<p>H5 的表单增加了很多类型：</p>
<pre><code class="language-txt">email       输入 email 格式
tel         手机号码，移动设备上得到焦点后会弹出键盘
url         只能输入 url 格式
number      只能输入数字，此时有属性 min  max  step 等
search      搜索框，输入内容时候会出现清除按钮
range       范围滑动条
color       拾色器
time        时间，可控制时间，且有增减按钮
date        日期，可控制日期，且有日期控件！
month       月份，同上
week        星期，同上
datetime    时间日期
</code></pre>
<p>部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用，比如：</p>
<pre><code class="language-js">&lt;form&gt;
    &lt;label&gt;
        邮箱：&lt;input type=&quot;email&quot; name=&quot;email&quot; class=&quot;email&quot;&gt;
    &lt;/label&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>上述表单类型设置为 email 后，可以验证邮箱书写的合法性。</p>
<h3 id="32-新增表单属性"><a class="header" href="#32-新增表单属性">3.2 新增表单属性</a></h3>
<pre><code class="language-txt">placeholder     占位符
autofocus       获取焦点
multiple        文件上传多选或多个邮箱地址
autocomplete    自动完成，用于表单元素，也可用于表单自身 (on/off)
form            指定表单项属于哪个 form，处理复杂表单时会需要
novalidate      关闭验证，可用于&lt;form&gt;标签
required        必填项
pattern         正则表达式 验证表单

autocapitalize  iOS 独有属性，设置为 off 关闭首字母大写
autocorrect     iOS 独有属性，设置为 off 关闭输入自动修正
</code></pre>
<h3 id="33-新增表单事件"><a class="header" href="#33-新增表单事件">3.3 新增表单事件</a></h3>
<pre><code class="language-txt">oninput         用户输入内容时触发，可用于移动端输入字数统计
oninvalid       验证不通过时触发
</code></pre>
<h3 id="34-表单自动联想"><a class="header" href="#34-表单自动联想">3.4 表单自动联想</a></h3>
<pre><code class="language-html">&lt;input type=&quot;text&quot; list=&quot;data&quot; /&gt;
&lt;datalist id=&quot;data&quot;&gt;
  &lt;option&gt;男&lt;/option&gt;
  &lt;option&gt;女&lt;/option&gt;
&lt;/datalist&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-css-基础-css-基本使用"><a class="header" href="#021-css-基础-css-基本使用">02.1-CSS 基础-CSS 基本使用</a></h1>
<h2 id="一-css-简介"><a class="header" href="#一-css-简介">一 CSS 简介</a></h2>
<p>CSS 即层叠样式表/级联样式表（Cascading Style Sheets），用来描述网页结构（HTML）的样式。</p>
<p>CSS 目前的主流版本是 CSS2.1，该版本于 2002 年发布，是 CSS2.0 的补丁版本，并于 2011 年成为推荐版本。</p>
<p>CSS3 在 CSS2 基础上，增强或新增了许多特性，尤其是动画方面。目前浏览器支持程度差，需要添加私有前缀，但是移动端支持率较高。</p>
<p>CSS 是渐进推进的，其实不存在所谓的 CSS3，CSS3 只是一些级别独立的模块。</p>
<h2 id="二-css-书写位置"><a class="header" href="#二-css-书写位置">二 CSS 书写位置</a></h2>
<p>CSS 代码有三种书写位置：行内式（不推荐）、内嵌式（偶尔使用）、外联式（推荐方式）。</p>
<p>行内式：通过给标签直接设置 style 属性来设置样式，样式与结构未分离，代码耦合严重，且会出现大量的代码冗余。</p>
<pre><code class="language-html">&lt;div style=&quot;color:pink; font-size:18px;&quot;&gt;Hello&lt;/div&gt;
</code></pre>
<p>内嵌式：在 head 标签内定义 style 标签，用来书写 CSS，初步实现了样式与结构分离，但只能控制一个页面。</p>
<pre><code class="language-html">&lt;head&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    /* type=&quot;text/css&quot; 在 CSS3 中可以省略 */
    div {
      color: pink;
      font-size: 18px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;Hello&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>外联式：在 head 标签内定义 link 标签，引入一个 css 文件，可以实现多页面样式的通用性！</p>
<pre><code class="language-html">&lt;head&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;./1.css&quot; /&gt;
&lt;/head&gt;
</code></pre>
<p>外联式的第二种方式是利用 @import：</p>
<pre><code class="language-html">&lt;style&gt;
  /*@import 必须位于样式表开头*/
  @import url(base.css) all;
  @import './base.css' div {
    background-color: blue;
  } ;
&lt;/style&gt;
</code></pre>
<p>link 与 @import 的区别：</p>
<ul>
<li>功能多样性不同：link 标签功能更多，可以加载 css、定义 rss、rel 等属性，@import 只能加载 CSS</li>
<li>加载书序不同：link 引入的内容与当前文档同时被加载，@import 引入的 css 将会在页面加载完毕后加载</li>
<li>link 的样式权重大于 @import 的权重</li>
</ul>
<h2 id="三-性能问题"><a class="header" href="#三-性能问题">三 性能问题</a></h2>
<p>将 CSS 的引入放置在 网页底部，即 body 末尾，可以制造延迟加载效果，但是这种方式只适合 JS 文件的引入，绝不适合 CSS。</p>
<p><strong>浏览器只有掌握了所有 CSS，才能知道把页面渲染成什么样子，从而一次性绘制！绝对不能一边加载新样式一边重新绘制页面，这会导致重排、重绘，引发严重性能问题</strong>。</p>
<h2 id="四-厂商前缀"><a class="header" href="#四-厂商前缀">四 厂商前缀</a></h2>
<p>厂商前缀即 CSS 样式前额外添加了标注，如：<code>-o-border-image</code>，表示 border-image 这个属性目前没被普遍接受，只在该 opera 浏览器下进行测试。</p>
<p>常用前缀有：</p>
<ul>
<li><code>-epub</code>：国际数字出版社论坛定制 ePub 格式</li>
<li><code>-moz-</code>：firefox 前缀</li>
<li><code>ms</code>：微软 IE 前缀</li>
<li><code>-o-</code>：Opera 前缀</li>
<li><code>-webkit-</code>：基于 Webkit 的浏览器的前缀</li>
</ul>
<h2 id="五-css-注释"><a class="header" href="#五-css-注释">五 CSS 注释</a></h2>
<p>CSS 注释只能使用 <code>/* */</code> 编写。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="022-css-基础-选择器"><a class="header" href="#022-css-基础-选择器">02.2-CSS 基础-选择器</a></h1>
<h2 id="一-常见选择器"><a class="header" href="#一-常见选择器">一 常见选择器</a></h2>
<pre><code class="language-css">/* CSS2 */
*                   /* 通配符选择器 */
#div                /* id 选择器 */
.box                /* 类名选择器 */
div                 /* 标签选择器 */
div p               /* 后代选择器：所有后代 */
div.box             /* 交集选择器 */
div,p,span          /* 并集选择器 */

/* CSS3 */
div&gt;p               /* 子代选择器：直接后代 */
div+p               /* 选中 div 后同级第一个 p */
div~p               /* 选中 div 后同级所有 p */
</code></pre>
<h2 id="二-属性选择器"><a class="header" href="#二-属性选择器">二 属性选择器</a></h2>
<p>通过属性来选择元素，具体有以下 5 种形式：</p>
<pre><code class="language-css">/* CSS2 */
E[attr]               /* 属性名=attr 的 div */
E[attr=&quot;value&quot;]       /* 属性 attr 值=value 的 div */

/* CSS3 */
E[attr~=&quot;value&quot;]      /* 属性值包含 value 字符 */
E[attr*=&quot;value&quot;]      /* 属性值包含 value 字符并且在 任意 位置 */
E[attr^=&quot;value&quot;]      /* 属性值包含 value 字符并且在 开始 位置 */
E[attr$=&quot;value&quot;]      /* 属性值包含 value 字符并且在 结束 位置 */
E[attr|=&quot;value&quot;]      /* 属性值是 value 或以 value- 开头的值（比如说 zh-cn） */
</code></pre>
<p>示例：选择以 icon 开头的</p>
<pre><code class="language-html">&lt;style&gt;
  div[class=^'icon'] {
    color: red;
  }
&lt;/style&gt;
</code></pre>
<h2 id="三-伪类选择器"><a class="header" href="#三-伪类选择器">三 伪类选择器</a></h2>
<p>伪类选择器的作用是为一些元素添加特殊效果，这些效果一般会根据用户的行为而进行动态改变：</p>
<pre><code class="language-css">E:link {
} /* 超链接默认状态，与 a{}一样 */
E:visited {
} /* 超链接访问过后的样式 */
E:hover {
} /* 鼠标放到超链接上的样式 */
E:active {
} /* 超链接激活状态下的样式 */

E:focus {
} /* 获取焦点的时候的样式 */
</code></pre>
<p>示例：</p>
<pre><code class="language-css">/* 链接伪类的书写顺序最好为：lvha */
a:link:hover {
  color: red;
}
</code></pre>
<p>CSS3 添加了一些新的伪类，如 input 相关，target 伪类，取反伪类。</p>
<p>表单相关伪类（结合锚点进行使用，处于当前锚点的元素会被选中）：</p>
<pre><code class="language-css">E:required
E:enabled
E:disabled
E:checked

/* 示例，选择 &lt;input type=&quot;text&quot; required&gt;*/
input:required {
}
</code></pre>
<p><code>:target</code> 伪类匹配的元素需要有 id 属性，用来匹配浏览器中的哈希值</p>
<pre><code class="language-css">/* 网址为：demo.com/#blue 此时选中 .div 的标签中 id=&quot;blue&quot; 的元素 */
.div:target {
}
</code></pre>
<p><code>:not</code> 伪类用来取反：</p>
<pre><code class="language-js">div:not(.box) {
     background-color: #2aabd2;
}
</code></pre>
<h2 id="四-结构伪类选择器"><a class="header" href="#四-结构伪类选择器">四 结构伪类选择器</a></h2>
<p>CSS3 中新增的结构伪类选择器以某元素相对于其父元素或兄弟元素的位置来获取元素。</p>
<pre><code class="language-css">/* CSS2 */
E:first-child           /* 第一个子元素 */
E:last-child            /* 最后一个子元素 */

/* CSS3 */
E:nth-child(n)          /* E 元素的所有子元素，n 为第几个 */
E:nth-last-child(n)     /* 同 E:nth-child(n) 相似，只是倒着计算 */

E:nth-of-type(n)        /* E 元素的所有子元素中，所在类型的第 n 个元素 */
E:nth-last-of-type(n)   /* 同上，从后向前计算 */

E:empty                 /* 没有任何子节点（包括空格）的 E 元素，(子节点包含文本节点) */
</code></pre>
<p>注意：</p>
<ul>
<li>n 遵循线性变化，其取值是：0、1、2、3、4....。n&lt;=0 时选取无效。</li>
<li>n 可以是多种形式：<code>nth-child(2n)</code>、<code>nth-child(2n+1)</code>、<code>nth-child(-1n+5)</code>、<code>nth-last-child(-1n+5)</code>(后五个) 等；</li>
<li>n 可以是特殊字符：<code>even</code>(偶数)、<code>odd</code>(奇数)</li>
</ul>
<p>示例：</p>
<pre><code class="language-html">&lt;style&gt;
  div span:nth-of-type(1) {
    background-colr: pink;
  }
&lt;/style&gt;

&lt;div&gt;
  &lt;p&gt;第一个&lt;/p&gt;
  &lt;span&gt;111&lt;/span&gt;
  &lt;span&gt;222&lt;/span&gt;
  &lt;span&gt;333&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<h2 id="五-伪元素选择器"><a class="header" href="#五-伪元素选择器">五 伪元素选择器</a></h2>
<p>伪元素选择器用于在选中元素的前、后插入一个行内元素！！该选择器用于不想给页面添加 HTML 标记的场景，示例：</p>
<pre><code class="language-html">&lt;style&gt;
  div::before {
    content: '你';
  }
&lt;/style&gt;

&lt;div&gt;好&lt;/div&gt;
</code></pre>
<p>在上述示例中，浏览器会显示：&quot;你好&quot;。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="023-css-基础-文字与文本"><a class="header" href="#023-css-基础-文字与文本">02.3-CSS 基础-文字与文本</a></h1>
<h2 id="一-字体样式"><a class="header" href="#一-字体样式">一 字体样式</a></h2>
<h3 id="11-字体大小"><a class="header" href="#11-字体大小">1.1 字体大小</a></h3>
<p>示例：<code>font-size: 16px;</code></p>
<p>文字大小单位常用的有 em、px（像素，最常用），尽量使用偶数字字号，ie6 等老式浏览器支持奇数会有 bug。</p>
<p>Chrome 默认文字大小为 16px，由于不同浏览器标准不一，一般统一设置：body{ font-size: 16px}</p>
<h3 id="12-字体加粗"><a class="header" href="#12-字体加粗">1.2 字体加粗</a></h3>
<p>示例：<code>font-weight:700</code></p>
<p>字体加粗值为数字，在 100-900 之间，必须是 100 的整数，正常显示值为 400。
CSS 提供了一些固定的英文值：normal（正常显示，即值为 400）、bold（加粗，即值为 700）</p>
<h3 id="13-字体倾斜"><a class="header" href="#13-字体倾斜">1.3 字体倾斜</a></h3>
<p>示例：<code>font-style:normal</code></p>
<p>字体风格是文字的样式，常见值：normal（正常显示）、italic（斜体显示）</p>
<h3 id="14-字体选择"><a class="header" href="#14-字体选择">1.4 字体选择</a></h3>
<p>示例：<code>font-family:Arial,&quot;宋体&quot;,&quot;Microsoft YaHei&quot;;</code></p>
<p>字体可以选择一到多个，浏览器不支持第一个字体，则会依次尝试下一个，如果都不支持，那么使用系统默认的字体。</p>
<p>英文字体无需引号，多个单词组命名的字体、中文字体、字体名中包含空格、#、$等符号则需要加引号，英文字体名必须位于中文字体名之前。</p>
<p>中文字体在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。</p>
<p>xp 系统不支持类似微软雅黑的中文，可以使用英文代替：<code>font-family:&quot;Microsoft Yahei&quot;</code>， 或者使用 Unicode 编码：<code>font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;</code>。</p>
<h3 id="15-引入字体"><a class="header" href="#15-引入字体">1.5 引入字体</a></h3>
<pre><code class="language-css">@font-face {
  font-family: ‘myziti’; /*字体名*/
  src: url('111-webfont.eot');
  src: url('111-webfont.eot?#iefix') format('embedded-opentype'), url('111-webfont.woff')
      format('woff'), url('111-webfont.ttf') format('truetype'), url('111-webfont.svg#untitledregular')
      format('svg');
  font-weight: normal;
  font-style: normal;
}

/* 使用 */
p {
  font-family: 'myziti';
}
</code></pre>
<h2 id="二-文本样式"><a class="header" href="#二-文本样式">二 文本样式</a></h2>
<h3 id="21-常见样式"><a class="header" href="#21-常见样式">2.1 常见样式</a></h3>
<p>常见文本样式有：</p>
<ul>
<li><code>color</code>：文本颜色，支持颜色单词、十六进制、rgb 等方式</li>
<li><code>text-decoration</code>：文字下划线，</li>
<li><code>text-aligin</code>：文字水平对齐位置，如：left（默认）、center、right</li>
<li><code>vertical-align</code>：文本垂直对齐方式，如：top、bottom、middle，也可以使用具体的值，如 -30px</li>
<li><code>text-transform</code>：文字大小写</li>
<li><code>text-indent: 2em;</code>：推荐使用 em 单位，1em 即 1 个字体大小，2em 即缩进 2 个字符</li>
<li><code>letter-spacing</code>：字符间距</li>
<li><code>word-spacing</code>：单词间距</li>
<li><code>writing-mode</code>：文本排版样式，默认从上往下排版，即 <code>horizontal-tb</code></li>
</ul>
<h3 id="22-溢出文字处理"><a class="header" href="#22-溢出文字处理">2.2 溢出文字处理</a></h3>
<pre><code class="language-css">/* 一定要先强制一行显示，然后配合 overflow 使用 */
text-overflow: clip; /* 不显示省略标记，而是简单的裁剪 */
text-overflow: ellopsis; /* 当对象内文本溢出时显示省略号  */
</code></pre>
<h3 id="23-文本空白处理"><a class="header" href="#23-文本空白处理">2.3 文本空白处理</a></h3>
<pre><code class="language-css">white-space: normal; /* 默认处理方式 */
white-space: nowrap; /* 强制在一行内显示所有文本，直到文本结束或者遇到 br 标签才换行 */
</code></pre>
<h3 id="24-文本阴影"><a class="header" href="#24-文本阴影">2.4 文本阴影</a></h3>
<pre><code class="language-txt">案例一：
    text-shadow: 3px 4px 5px #ccc
        3px     水平偏移量。正值向右 负值向左
        4px     垂直偏移量。正值向下 负值向上
        5px     模糊度，模糊度不能为负值，值越大越模糊
        #ccc    设置对象阴影的颜色。
案例二：
    text-shadow:2px 2px 0px red, 2px 2px 4px green;
        阴影叠加：先渲染后面的，再渲染前面的
</code></pre>
<h2 id="三-字体属性连写"><a class="header" href="#三-字体属性连写">三 字体属性连写</a></h2>
<p>字体属性连写：</p>
<pre><code class="language-txt">语法：选择器{font: font-style  font-weight  font-size/line-height  font-family;}
示范：p {  font: italic 700 30px 宋体; }
注意：文字样式属性联写必须有 font-size 和 font-family，且顺序不能更换，其他属性若不存在可以不写。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="024-css-基础-背景与颜色"><a class="header" href="#024-css-基础-背景与颜色">02.4-CSS 基础-背景与颜色</a></h1>
<h2 id="一-background-属性"><a class="header" href="#一-background-属性">一 background 属性</a></h2>
<h3 id="10-background-属性简写"><a class="header" href="#10-background-属性简写">1.0 background 属性简写</a></h3>
<p>background 属性其实是以下八个属性的简写：</p>
<ul>
<li>background-image——指定一个文件或者生成的颜色渐变作为背景图片。</li>
<li>background-position——设置背景图片的初始位置。</li>
<li>background-size——指定元素内背景图片的渲染尺寸。</li>
<li>background-repeat——决定在需要填充整个元素时，是否平铺图片。</li>
<li>background-origin——决定背景相对于元素的边框盒、内边距框盒（初始值）或内容盒子来定位。</li>
<li>background-clip——指定背景是否应该填充边框盒（初始值）、内边距框盒或内容盒子。</li>
<li>background-attachment——指定背景图片是随着元素上下滚动（初始值），还是固定在视口区域。注意，使用 fixed 值会对页面性能产生负面影响。</li>
<li>background-color——指定纯色背景，渲染到背景图片下方。</li>
</ul>
<p>使用简写属性（ background）可以设置指定的值，同时把其他属性重置为初始值。因此，在需要用到多个属性时，我往往使用单独的属性。</p>
<p>示例：没有数量限制和先后顺序限制</p>
<pre><code class="language-css">background: url('1.png') red no-repeat 30px 40px;
</code></pre>
<h3 id="11-background-color"><a class="header" href="#11-background-color">1.1 background-color</a></h3>
<pre><code class="language-css">div {
  background-color: red;
  /* background-color: rgba(255, 0, 0, 0.5); */
  /* background-color:hsla(0, 23%, 56%, 1) */
}
</code></pre>
<p>CSS3 新增了 RGBA、HSLA 模式，其中的 A 表示透明度通道，即可以设置颜色值的透明度，取值范围是 0~1。如<strong>背景透明度</strong>：<code>background: rgba(0, 0, 0, 0.3);</code>。最后一个值 0.3 代表透明度，取值范围为 0-1，数值越小，越透明。0.3 经常会被简写为.2。</p>
<p>RGBA：R、G、B 取值范围是 0~255。</p>
<ul>
<li>Red：红色</li>
<li>Green：绿色</li>
<li>Blue：蓝色</li>
</ul>
<p>HSLA</p>
<ul>
<li>H：色调，取值范围 0~360，0/360 表示红色、120 表示绿色、240 表示蓝色</li>
<li>S：饱和度，取值范围 0%~100%。</li>
<li>L：亮度，取值范围 0%~100%</li>
</ul>
<p>透明度的三种表示：</p>
<pre><code class="language-txt">opacity
    只能针对整个盒子设置透明度，子盒子及内容会继承父盒子的透明度；

background-color: transparent;
    不可调节透明度，始终完全透明

background-color:rgba()
    使用 rgba 来控制颜色，相对 opacity，不具有继承性
</code></pre>
<h3 id="12-background-image"><a class="header" href="#12-background-image">1.2 background-image</a></h3>
<p>背景图：背景图只会在元素的最底层显示，img 标签则不会。</p>
<pre><code class="language-css">div {
  background-image: url(../iamges/1.jpg); /* 插入了背景图一定要设置高度与宽度！ */
  width: 200px;
  height: 200px;
}
</code></pre>
<h3 id="13-ackground-repead"><a class="header" href="#13-ackground-repead">1.3 ackground-repead</a></h3>
<p>背景平铺：平铺有四种方式，默认为平铺 repeat，还有其他值：<code>no-repeat</code>（不平铺）、<code>repeat-x</code>(横向平铺)、<code>repeat-y</code>(纵向平铺)</p>
<pre><code class="language-css">div {
  background-repead: repeat;
}
</code></pre>
<h3 id="14-background-position"><a class="header" href="#14-background-position">1.4 background-position</a></h3>
<p>背景位置：背景位置的两个值分别是 x、y 轴的坐标，若只给定一个值，则该值代表 x 轴位置。</p>
<pre><code class="language-css">div {
  background-position: 100px 200px;
}
</code></pre>
<p>注意：背景位置的值也支持方位名词 left| right| top| bottom| center，方位名词的顺序不会影响图片平铺效果，且可以和坐标值混合使用。</p>
<pre><code class="language-css">/* 一般在网站中，超大背景图使用该方式进行展示：`background-position: top center; */
background-position: right top; /* 右上角对其 */
background-position: right; /* 水平向右对其，没写的默认为居中 */
background-position: top; /* 垂直向上对其，没写的默认为居中 */
</code></pre>
<h3 id="15-background-attachment"><a class="header" href="#15-background-attachment">1.5 background-attachment</a></h3>
<p>背景附着：即表示背景图是否跟随滚动条滚动</p>
<pre><code class="language-css">background-attachment: fixed; /* fixed：图片固定。scroll：滚动（默认）  */
</code></pre>
<h3 id="16-c3-background-size"><a class="header" href="#16-c3-background-size">1.6 C3 background-size</a></h3>
<p><strong>背景控制</strong>：控制背景大小，也可以是百分比，也可以是规定的词。</p>
<pre><code class="language-css">background-size: 500px 500px;

/*
固定的词：
cover 会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。整个背景图片完整显示在背景区域。
contain 会自动调整缩放比例，保证图片始终完整显示在背景区域。
*/
</code></pre>
<p>注意：背景图默认从 padding 就开始平铺了，为了让背景从内容盒子才开始平铺显示，可以设置背景原点，<code>backgound-origin:padding-box</code>，将默认值改为：content-box。</p>
<p>背景原点的值有：</p>
<ul>
<li>border-box：从 border 区域开始显示背景。</li>
<li>padding-box：从 padding 区域开始显示背景。</li>
<li>content-box：从 content 区域开始显示背景。</li>
</ul>
<h3 id="17-background-clip"><a class="header" href="#17-background-clip">1.7 background-clip</a></h3>
<p>背景剪裁：背景图片超出元素部分如果需要裁切，则可以使用该属性，而且可以设置哪些超出的部分裁切。</p>
<pre><code class="language-css">/* 超出 padding-box 的裁剪，同理有 border-box，content-box */
background-clip: padding-box;
</code></pre>
<h2 id="二-背景的应用示例"><a class="header" href="#二-背景的应用示例">二 背景的应用示例</a></h2>
<p>多背景：</p>
<pre><code class="language-css">background: url() no-repeat left top, url() no-repeat left top;
</code></pre>
<p>遮罩：</p>
<pre><code class="language-css">.box {
  width: 800px;
  height: 600px;
  background: url(***.jpg) no-repeat;
  background-size: 100% 100%;
  border: 10px solid #000;
  -webkit-mask: url(mask.png) no-repeat;
  transition: 1s;
}
.box:hover {
  -webkit-mask-position: 100% 100%;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="025-css-基础-层叠性与继承性"><a class="header" href="#025-css-基础-层叠性与继承性">02.5-CSS 基础-层叠性与继承性</a></h1>
<p>CSS 的本质是规则的声明，即在各种条件作用下，产生相应的效果。在许多规则作用下，如何能正确设置想要的显示结果，则需要利用 CSS 的特性：层叠性、继承性。</p>
<h2 id="一-层叠性"><a class="header" href="#一-层叠性">一 层叠性</a></h2>
<h3 id="11-层叠性概念"><a class="header" href="#11-层叠性概念">1.1 层叠性概念</a></h3>
<blockquote>
<p>层叠性：某个元素同时出现了多个同级样式，那么书写在后面的样式将会覆盖之前的样式，也可以理解为 CSS 的样式采取就近原则。</p>
</blockquote>
<p>层叠性触发的条件是：元素相同、属性相同、优先级相同。当声明出现冲突后，层叠会依据三个条件来依次解决冲突：</p>
<ul>
<li>1、样式的来源：样式源自浏览器默认样式还是开发者自定义样式；</li>
<li>2、选择器优先级；</li>
<li>3、样式声明顺序。</li>
</ul>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/css-06.svg" alt="" /></p>
<p>层叠就是上图所示一系列解决冲突的规则，当到达最后一层仍然拥有相同的属性声明，则之前的该属性的声明的信息都会被层叠掉，直接使用最后出现的样式。</p>
<h3 id="12-层叠第一步查找样式表来源"><a class="header" href="#12-层叠第一步查找样式表来源">1.2 层叠第一步：查找样式表来源</a></h3>
<p>一个网页中可能有多个样式表来源，比如：浏览器默认样式、开发者自己声明的样式、开发者引用的外部库样式表等。</p>
<p>浏览器默认样式（用户代理样式）优先级最低，比如：为 H 标签添加上下外边距，为 ul 标签添加左侧内边距，为 a 标签添加链接颜色等等。</p>
<p>浏览器应用了默认样式后，会使用开发者自己声明的样式表，这时候指定的相同声明就会覆盖默认样式。我们经常会创建一个 <code>reset.css</code> 样式表文件用来去除浏览器默认样式，如：</p>
<pre><code class="language-css">body {
  margin: 0;
  padding: 0;
}

ul,
ol {
  list-style: none;
}
</code></pre>
<h3 id="13-层叠第二步查找优先级"><a class="header" href="#13-层叠第二步查找优先级">1.3 层叠第二步：查找优先级</a></h3>
<p>如果样式表来源无法解决冲突声明，比如开发者使用多个选择器作用于同一个元素，则浏览器会检查这些声明的优先级。</p>
<p>优先级由选择器、行内样式决定，一般来说：行内样式具有最高的优先级。如下所示：</p>
<pre><code class="language-txt">声明方式：!important &gt; 行内样式 &gt;  id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 默认样式
权重数值：1000以上      1000       100       10       1           0
</code></pre>
<p>贴士：伪类选择器（如:hover）和属性选择器（如<code>[type=&quot;input&quot;]</code>）与类选择器的优先级相同。通用选择器<code>*</code>和组合器<code> &gt;、 +、 ~</code>对优先级没有影响。</p>
<p>先看示例，假设下列两个样式规则都选中了同一个 h2，但是样式不同：</p>
<pre><code class="language-html">&lt;style&gt;
  h2 {
    font-family: serif;
  }

  #main {
    font-family: sans-serif;
  }

  .nav {
    font-family: monospace;
  }
&lt;/style&gt;

&lt;h2 id=&quot;main&quot; class=&quot;nav&quot;&gt;hi&lt;/h2&gt;
</code></pre>
<p>此时按照图中所示，style 中第二个声明生效，字体显示了 <code>sans-serif</code> 这个值。</p>
<p>注意：</p>
<ul>
<li>权重可以叠加，如 选择器 <code>div ul li</code> 其权重为 0,0,0,3，选择器 <code>.nav ul li</code>，其权重为 0,0,1,2。权重叠加是没有进位这种说法的。</li>
<li>权重计算结果相同，则采用就近原则</li>
<li>继承的权重为 0；</li>
<li>left 比 right 权重高，有 left 又有 right 的时候，执行 left 的值。</li>
<li>top 比 bottom 权重高，有 top 又有 bottom 的时候，执行 top 的值。</li>
</ul>
<p>如下所示面试题：</p>
<pre><code class="language-html">&lt;style&gt;
  #father {
    color: red;
  }
  p {
    color: blue;
  }
&lt;/style&gt;

&lt;div id=&quot;father&quot;&gt;
  &lt;p&gt;文字颜色是：blue，因为选择器中 p 选择器是选中的，#father 只是继承权重&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p><code>!important</code> 标记声明会被当做更高的优先级来源：</p>
<pre><code class="language-css">color: red !important;
</code></pre>
<h3 id="14-层叠第三步使用源码顺序"><a class="header" href="#14-层叠第三步使用源码顺序">1.4 层叠第三步：使用源码顺序</a></h3>
<p>如果两个声明的来源和优先级相同，其中一个声明在样式表中出现较晚，或者位于页面较晚引入的样式表中，则该声明胜出。通俗来说，就是：优先级相同时，后出现的样式会覆盖先出现的样式。如果一个元素同时处于两个或者更多状态，最后一个状态就能覆盖其他状态。</p>
<p>层叠性的典型就是 a 的伪类选择器需要遵循 <code>lvhfa</code>顺序。如果用户将鼠标悬停在一个访问过的链接上，悬停效果会生效。如果用户在鼠标悬停时激活了链接（即点击了它），激活的样式会生效。</p>
<h3 id="15-开发规范"><a class="header" href="#15-开发规范">1.5 开发规范</a></h3>
<ul>
<li>1、在选择器中尽量不要使用 ID。就算只用一个 ID，也会大幅提升优先级。当需要覆盖这个选择器时，通常找不到另一个有意义的 ID，于是就会复制原来的选择器，然后加上另一个类，让它区别于想要覆盖的选择器。</li>
<li>2、不过一般不推荐使用 <code>!important</code> ，因为在当前元素中使用了该标记，那么以后其他地方还需要对这个元素提升优先级，就会无限重复需要添加 <code>!important</code>。</li>
</ul>
<h2 id="二-继承性"><a class="header" href="#二-继承性">二 继承性</a></h2>
<h3 id="21-继承性概念"><a class="header" href="#21-继承性概念">2.1 继承性概念</a></h3>
<p>如果一个元素的某个属性没有层叠值，则可能会继承某个祖先元素的值。比如通常会给<code>&lt;body&gt;</code>元素加上 font-family，里面的所有祖先元素都会继承这个字体，就不必给页面的每个元素明确指定字体了。</p>
<h3 id="22-能够被继承的属性"><a class="header" href="#22-能够被继承的属性">2.2 能够被继承的属性</a></h3>
<p>默认情况下，主要是跟文本、列表、表格边框相关的属性才能被继承：</p>
<pre><code class="language-txt"># 文本属性
color
font、font-family、font-size、font-weight、font-variant、font-style
line-height、
letter-spacing、
text-align、text-indent、text-transform
white-space
word-spacing

# 列表属性
list-style、list-style-type、list-style-position、list-style-image

# 表格边框属性
border-collapse
border-spacing
</code></pre>
<p>注意：a 标签不能继承父元素文字颜色，h 标签不能继承父元素文字大小，因为他们都被层叠掉了。</p>
<h2 id="三-控制层叠性"><a class="header" href="#三-控制层叠性">三 控制层叠性</a></h2>
<h3 id="31-关键字-inherit"><a class="header" href="#31-关键字-inherit">3.1 关键字 inherit</a></h3>
<p>inherit 会将元素的属性值设置为与其父元素一致，即：用继承替代了层叠值。inherit 还能强制继承一个通常不会被继承的属性，比如边框和内边距，通
常在实践中很少这么做。</p>
<p>示例：通常我们需要全局为 a 链接添加字体颜色，由于继承性这个自己添加的颜色也会作用于 footer 页脚中，而页脚中的链接往往是灰色的，需要覆盖颜色值。</p>
<pre><code class="language-html">&lt;style&gt;
  a:link {
    color: blue; /* 全局的链接颜色 */
  }

  footer {
    color: #666;
  }

  footer a {
    color: inherit; /* 从页脚继承文本颜色 */
  }
&lt;/style&gt;

&lt;body&gt;
  &lt;a href=&quot;#&quot;&gt;普通链接&lt;/a&gt;
  &lt;footer&gt;
    &lt;a href=&quot;#&quot;&gt; 页脚链接&lt;/a&gt;
  &lt;/footer&gt;
&lt;/body&gt;
</code></pre>
<h3 id="32-关键字-initial"><a class="header" href="#32-关键字-initial">3.2 关键字 initial</a></h3>
<p>关键字 initial 可以撤销某个元素的样式。每一个 CSS 属性都有初始（默认）值。如果将 initial 值赋给某个属性，那么就会有效地将其重置为默认值，这种操作相当于硬复位了该值。</p>
<p>举例：在大多数浏览器中，黑色是 color 属性的初始值，所以 <code>color: initial</code> 等价于 <code>color: black</code>。</p>
<p>这么做的好处是不需要思考太多。如果想删除一个元素的边框，设置 <code>border: initial</code> 即可。如果想让一个元素恢复到默认宽度，设置 <code>width: initial</code> 即可。要注意的是：width 的默认值就是 auto，但 auto 不是所有属性的默认值，比如 border-width: auto 和 padding: auto 是非法的。</p>
<p>声明 <code>display: initial</code> 等价于 <code>display: inline</code>，这是因为 initial 重置为属性的初始值，而不是元素的初始值， inline 才是 display 属性的初始值。</p>
<h3 id="33-关键字-unset"><a class="header" href="#33-关键字-unset">3.3 关键字 unset</a></h3>
<p>如果属性是可继承的，那么 unset 与 inherit 作用一致，如果属性不可继承，则 unset 与 initial 作用一致</p>
<h3 id="34-属性连写"><a class="header" href="#34-属性连写">3.4 属性连写</a></h3>
<p>属性连写时，如果一些属性被忽略掉了，则忽略掉的属性会被隐式地设置为初始值！！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="031-盒模型-盒模型使用"><a class="header" href="#031-盒模型-盒模型使用">03.1-盒模型-盒模型使用</a></h1>
<h2 id="一-盒模型"><a class="header" href="#一-盒模型">一 盒模型</a></h2>
<h3 id="11-盒模型简介"><a class="header" href="#11-盒模型简介">1.1 盒模型简介</a></h3>
<p>盒模型主要用来网页布局，如图所示蓝色区块为真正显示的内容，但是内容是由盒子来包裹的：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/css-02.png" alt="盒模型" /></p>
<p>如上所示，盒子由四部分组成：</p>
<ul>
<li>内容：包括文字、图片等，真正显示给用户观看的部分</li>
<li>边框 (border)：即盒子的厚度</li>
<li>内边距（padding）：内容与边框的距离</li>
<li>外边距（margin）：盒子与盒子之间的距离</li>
</ul>
<p>贴士：元素还有一个与边框类似的属性-轮廓线（outline），该属性可以在盒子的外围画出一条不影响盒子布局、模型的线。</p>
<h3 id="12-盒模型"><a class="header" href="#12-盒模型">1.2 盒模型</a></h3>
<p>元素的 <code>box-sizing</code> 属性可以改变计算盒子大小的方式，其值有：</p>
<ul>
<li><code>content-box</code>：默认值，即宽度值表示内容宽度，而不是整个盒模型的宽度</li>
<li><code>border-box</code>：宽度将包括边框、内边距</li>
</ul>
<p><code>border-box</code> 可以保证盒子的大小不受到内边距的影响，适用于一些响应式场景，也称为怪异盒模型。</p>
<h2 id="二-盒模型的三个要素"><a class="header" href="#二-盒模型的三个要素">二 盒模型的三个要素</a></h2>
<h3 id="21-边框-border"><a class="header" href="#21-边框-border">2.1 边框 border</a></h3>
<p>常见边框属性：</p>
<pre><code class="language-css">/* 边框宽度 */
border-width: 20px;

/* 边框样式：默认为 none(无样式），其他：solid 实线、dotted 点线、dashed 虚线 */
border-style: none;

/* 边框颜色 */
border-color: red;
</code></pre>
<p>border 书写方式：</p>
<ul>
<li>只写边框的一边：<code>border-left: 1px solid green;</code></li>
<li>只写边框的一边的一个属性：<code>border-top-color:green;</code></li>
<li>属性联写：<code>border: solid 1px red;</code>，border 属性联写没有先后顺序限制，边框颜色、宽度可以不写。</li>
</ul>
<p>border 的实战：</p>
<pre><code class="language-css">.div {
  /* 只有少数边框要设计时，往往先将所有边框样式清空 */
  border: none;
  border-botto,: 1px dashed red;
}
</code></pre>
<h3 id="22-内边距-padding"><a class="header" href="#22-内边距-padding">2.2 内边距 padding</a></h3>
<p>内边距设置内容距离盒子边框之间的距离：</p>
<ul>
<li>padding-left:左边距</li>
<li>padding-right:右边距</li>
<li>padding-top:上边距</li>
<li>padding-bottom:下边距</li>
</ul>
<p>属性联写：</p>
<pre><code class="language-txt">padding: 10px;                  上，右，下，左的距离为 10px
padding: 10px 20px;             上下 10px，左右 20px
padding: 10px 20px 30px;        上 10px  左右 20px   下 30px
padding: 10px 20px 30px 40px;   上，右，下，左
</code></pre>
<p>示例：制作导航时，由于导航内容往往是不固定的，不能直接设置宽度，需要由 padding 撑开：</p>
<pre><code class="language-css">.nav {
  height: 41px;
  border-top: 3px solid #ff8500;
  border-bottom: 3px solid #edeef0;
}

.nav a {
  display: inline-block;
  height: 41px;
  /* 不能给宽度，因为内容的大小不一，必须使用 padding 撑开 */
  padding: 0 20px;
  line-height: 41px;
}
</code></pre>
<p><strong>注意</strong>：如果没有给一个盒子指定宽度，盒子的 padding 不会撑开盒子！！！如下所示：</p>
<pre><code class="language-css">&lt;div class='div' &gt; &lt;p &gt; aaa&lt;/p &gt; &lt;/div &gt; .div {
  height: 100px;
  width: 100px;
  background-color: pink;
}

.div p {
  /* p 没有给定宽度，padding 生效了，但是并不会撑开盒子！ */
  padding-left: 30px;
  background-color: powderblue;
}
</code></pre>
<p>注意：作为内边距，最小值一般是 0，所以 padding 不能为负值。</p>
<h3 id="23-外边距-margin"><a class="header" href="#23-外边距-margin">2.3 外边距 margin</a></h3>
<p>外边距设置盒子与盒子之间的距离，属性同 padding。</p>
<p>注意：</p>
<ul>
<li>当两个盒子垂直显示的时候，外边距以最大的一个值为准</li>
<li>行内元素只有左右 margin，没有上下 margin，同理也只有左右 padding，没有上下 padding。为了照顾不同元素的兼容性，行内元素尽量只设置左右内外边距，无需设置上下内外边距（在 Chrome 中不生效，在低版本 IE 中会生效）</li>
</ul>
<p>注意：作为外边距，margin 的值可以是负数。</p>
<h2 id="三-标准盒模型与怪异盒模型"><a class="header" href="#三-标准盒模型与怪异盒模型">三 标准盒模型与怪异盒模型</a></h2>
<h3 id="31-标准盒模型"><a class="header" href="#31-标准盒模型">3.1 标准盒模型</a></h3>
<p>在标准盒模型中，如果给盒子设置了 width、height，其实是给 content box（内容部分）设置的宽高，即元素的 width 和 height 指 <strong>内容盒子</strong>。所以盒子的宽高是由内容、边框、内边距一起决定的。</p>
<p>那么标准盒模型盒子的大小公式为：</p>
<pre><code class="language-txt">盒子实际宽度(高度) = 内容宽度(高度) + 左右边框宽度(高度) + 左右内边距大小(高度)
</code></pre>
<p>贴士：</p>
<ul>
<li><strong>子盒子在父盒子宽度范围内，父盒子的 padding 不会影响子盒子大小</strong>。</li>
<li>最大值、最小值可以限定盒模型的最大、最小伸缩度，其属性名为：<code>max-width</code>、<code>min-width</code>，同理 height 也有对应属性。</li>
</ul>
<h2 id="32-盒模型的自适应特性"><a class="header" href="#32-盒模型的自适应特性">3.2 盒模型的自适应特性</a></h2>
<p>如果我们要维持整个元素的大小，一旦元素盒子设置了内边距，那么就需要将内容部分作出相应的增减。即当一个块级元素设置了宽度后，就意味着其内容部分（content）的大小就是该宽度固定了，我们再额外设置 padding、margin、border 都不会影响其内容的大小，反而会将盒子变大。</p>
<pre><code class="language-html">&lt;!--css--&gt;
&lt;style&gt;
  .box1 {
    width: 300px;
    height: 200px;
    background-color: lightcoral;
  }
  .box2 {
    width: 300px;
    height: 100px;
    background-color: yellowgreen;
    padding: 10px;
    border: 10px solid;
    margin: 10px;
  }
&lt;/style&gt;

&lt;!--html--&gt;
&lt;div class=&quot;box1&quot;&gt;
  &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>我们会发现新增 padding 等属性后， box2 溢出了 box1 的范围。为了不让其溢出，可以修改 width 为：<code>300-20-20-20=240</code>。</p>
<p>如果不设置 box2 的宽度，则给 box2 新增 padding 等属性时则不会溢出 box1 的范围，而是其内部 content 部分缩小了，而且其内容宽度正好是上述修改后的 240。</p>
<h3 id="33-怪异盒模型"><a class="header" href="#33-怪异盒模型">3.3 怪异盒模型</a></h3>
<p>怪异盒模型来自于 IE 的一些设计理念，在怪异盒模型中，所有宽度都是可见宽度，那么内容宽度其实是宽度减去边框和填充部分。</p>
<p>怪异盒模型可以让一些场景中的样式的设计更加简单，比如：一个输入框，我们需要给其设定 padding，就会导致输入框变大溢出，这时候可以使用怪异盒模型：</p>
<pre><code class="language-css">input {
  width: 100%;
  padding: 10px;
  box-sizing: border-box;
}
</code></pre>
<h2 id="四-标准盒模型常见问题"><a class="header" href="#四-标准盒模型常见问题">四 标准盒模型常见问题</a></h2>
<h3 id="41-清除盒子的内外边距"><a class="header" href="#41-清除盒子的内外边距">4.1 清除盒子的内外边距</a></h3>
<p>对元素而言，没编剧、边框、外边距都不是必须的，但是浏览器往往有自己自带的 margin、padding。为了通用，需要将浏览器自带的 margin 清除：</p>
<pre><code class="language-css">* {
  margin: 0;
  padding: 0;
}
</code></pre>
<h3 id="42-外边距塌陷"><a class="header" href="#42-外边距塌陷">4.2 外边距塌陷</a></h3>
<p>对于嵌套的盒子，子盒子设置了 <code>margin-top</code> 会存在外边距塌陷的情况，如下所示：</p>
<pre><code class="language-html">&lt;!--css--&gt;
&lt;style&gt;
  .father {
    width: 300px;
    height: 300px;
    background-color: lightcoral;
  }
  .son {
    width: 100px;
    height: 100px;
    background-color: yellowgreen;
    margin-top: 100px;
  }
&lt;/style&gt;

&lt;!--html--&gt;
&lt;div&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>此时，虽然子盒子存在外边距，但是却没有变化，子元素的 <code>margin-top</code> 传递给父元素，反而是父盒子自己向下偏移了 100px。</p>
<p>解决办法：</p>
<ul>
<li>1、可以使用 padding-top 来设置子元素的位置，但是需要处理子元素位置</li>
<li>2、可以给父元素添加边框，即可解决外边距塌陷问题</li>
<li>3、BFC 格式化上下文</li>
<li>4、使用现代布局：弹性布局、网格布局，不会存在该问题。</li>
</ul>
<h3 id="43-margin-叠加现象"><a class="header" href="#43-margin-叠加现象">4.3 margin 叠加现象</a></h3>
<p>同级别的盒子，垂直方向的外边距会取其最大的值：</p>
<pre><code class="language-html">&lt;!--css--&gt;
&lt;style&gt;
  .box1 {
    width: 300px;
    height: 300px;
    background-color: lightcoral;
    margin-bottom: 30px;
  }
  .box2 {
    width: 100px;
    height: 100px;
    background-color: yellowgreen;
    margin-top: 70px;
  }
&lt;/style&gt;

&lt;!--html--&gt;
&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;
</code></pre>
<p>示例中盒子 1 和盒子 2 的距离本应该是 100px，但是却取了其最大值：70px。</p>
<p>外边距叠加解决方案：</p>
<ul>
<li>1、BFC 格式化上下文</li>
<li>2、使用现代布局：弹性布局、网格布局，不会存在该问题</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="032-盒模型-元素转换"><a class="header" href="#032-盒模型-元素转换">03.2-盒模型-元素转换</a></h1>
<h2 id="一-元素三种类型"><a class="header" href="#一-元素三种类型">一 元素三种类型</a></h2>
<h3 id="10-css-元素类型"><a class="header" href="#10-css-元素类型">1.0 CSS 元素类型</a></h3>
<p>CSS 中广泛使用两种元素（盒子）：</p>
<ul>
<li>块级元素（block box）：也称为块级盒子</li>
<li>行内元素（inline box）：也称呼内联盒子</li>
</ul>
<p>部分划分中也包括行内块元素。</p>
<h3 id="11-块级元素"><a class="header" href="#11-块级元素">1.1 块级元素</a></h3>
<p><strong>块级元素</strong>常见的有：<code>div</code>、<code>p</code>、<code>li</code>、<code>h1</code> 等。其特性是：</p>
<ul>
<li>块级元素独占一行显示</li>
<li>块级元素本身不写宽度时，元素宽度继承自父亲。比如：body 下的 div 不给宽度会直接占满一行。</li>
<li>块级元素支持所有 CSS 命令，可以设置宽度、高度、内边距、外边距等</li>
<li>块级元素内部可以包含块级元素、行内元素，但是 p、h1、dt 等文字类 标签中不能放置 div 等块级元素。</li>
</ul>
<p>从上看出块级元素适合做布局。</p>
<h3 id="12-行内元素"><a class="header" href="#12-行内元素">1.2 行内元素</a></h3>
<p><strong>行内元素</strong>常见的有：<code>span</code>、<code>a</code>、<code>font</code>、<code>strong</code> 等，也称为内联元素。其特性有：</p>
<ul>
<li>行内元素可以在同一行上显示，且相邻元素之间会有空隙</li>
<li>行内元素宽高由元素自身内容撑开，即使设置了宽高也没有意义</li>
<li>行内元素不支持上下 margin</li>
<li>行内元素内部只能放置行内元素</li>
</ul>
<p>此外，行内元素的形状并不一定是个矩形，比如几行文字，且行内元素标签之间会有空隙，代码换行也会被解析。</p>
<p>所以行内元素问题很多，不适合做布局，一般用于放置文字类数据。</p>
<h3 id="13-行内块元素"><a class="header" href="#13-行内块元素">1.3 行内块元素</a></h3>
<p><strong>行内块元素</strong>常见的有：<code>image</code>、<code>input</code>、<code>td</code> 等</p>
<ul>
<li>元素不独占一行，可以在同一行上显示，相邻元素之间会有空隙</li>
<li>设置了宽度，则按照宽度显示，没有宽度，则由内容撑开</li>
<li>可以设置宽高</li>
</ul>
<p>贴士：行内块元素可以当做文字来处理，如下所示：</p>
<pre><code class="language-html">&lt;div style=&quot;text-align:center&quot;&gt;
  &lt;span&gt;111&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>注意：背景色会平铺到非 margin 的区域，所以边框也会受到背景色影响。</p>
<h2 id="二-元素类型转换"><a class="header" href="#二-元素类型转换">二 元素类型转换</a></h2>
<p>标签有自己默认的类型，但是也可以使用下列 css 命令转换为别的类型：</p>
<ul>
<li><code>display: block</code>：将元素转化为块元素</li>
<li><code>display: inline</code>：转化为行内元素</li>
<li><code>display：inline-block</code>：转化行内块元素</li>
</ul>
<p>应用：导航栏中链接转换为行内块元素，因为 a 为 行内元素，但是还要能够设置宽高</p>
<pre><code class="language-html">&lt;style&gt;
  a {
    display: inline-block;
    width: 100px;
    height: 30px;
    background-color: pink;
    text-align: center;
    text-decoration: none;
  }
  a:hover {
    background-color: orange;
  }
&lt;/style&gt;

&lt;a href=&quot;#&quot;&gt;新闻&lt;/a&gt;
&lt;a href=&quot;#&quot;&gt;体育&lt;/a&gt;
&lt;a href=&quot;#&quot;&gt;汽车&lt;/a&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="041-布局技术-浮动与-bfc"><a class="header" href="#041-布局技术-浮动与-bfc">04.1-布局技术-浮动与 BFC</a></h1>
<h2 id="一-文档流"><a class="header" href="#一-文档流">一 文档流</a></h2>
<p>元素默认的显示方式（如块级元素独占一行）就是标准文档流，但是有些操作可以让盒子脱离标准文档流，如：</p>
<ul>
<li>浮动：让盒子从普通流中浮起来，可以让多个块级元素在同一行显示</li>
<li>定位：将盒子定在浏览器的某一个位置</li>
</ul>
<p>简单理解：<strong>标准流在最底层，浮动的盒子在中间，定位的盒子在最上层</strong></p>
<h2 id="二-浮动"><a class="header" href="#二-浮动">二 浮动</a></h2>
<h3 id="21-浮动与浮动设计目的"><a class="header" href="#21-浮动与浮动设计目的">2.1 浮动与浮动设计目的</a></h3>
<p>元素默认都是没有浮动的，即<code>float:none</code>，一旦将该属性值修改为 left/right，便会引起浮动。浮动最早是用来解决文字环绕图片问题，也可用来制作导航栏、网页布局：</p>
<pre><code class="language-html">&lt;style&gt;
  .box1 {
    width: 100px;
    height: 100px;
    background-color: lightcoral;
    float: left;
  }
  .box2 {
    width: 200px;
    height: 200px;
    background-color: yellowgreen;
  }
&lt;/style&gt;

&lt;div class=&quot;box1&quot;&gt;11111&lt;/div&gt;
&lt;div class=&quot;box2&quot;&gt;2222222&lt;/div&gt;
</code></pre>
<h3 id="22-浮动用于布局"><a class="header" href="#22-浮动用于布局">2.2 浮动用于布局</a></h3>
<p>浮动用于布局时可以让块级元素在一行显示，如：两个块级元素需要让其在同一行显示，一个位于左边，一个位于右边，则可以这样做：</p>
<pre><code class="language-css">.div1 {
  float: left;
}

.div2 {
  float: right;
}
</code></pre>
<p>浮动类似于改变了元素的 display 属性值为：inline-block，这里不将块级元素转换为行内块来实现一行显示的原因是：行内块元素之间会有缝隙。</p>
<h3 id="23-浮动后盒子盒子特性"><a class="header" href="#23-浮动后盒子盒子特性">2.3 浮动后盒子盒子特性</a></h3>
<p>浮动后的盒子具备了块级元素、行内元素特性的特性：</p>
<ul>
<li>类似块级元素：支持多数样式，同事脱标，即不占原来的位置。在多数实际场景中，元素浮动后，会造成其后续元素升起。</li>
<li>类似行内元素：宽度由内容决定。</li>
<li>子盒子的浮动是参照父盒子来对齐的，不会超过父盒子的内边距、边框</li>
<li>浮动的元素如果在一行放不下，则会自动换行</li>
</ul>
<pre><code class="language-css">/* 浮动后可以对span设置宽高 */
span {
  width: 300px;
  height: 100px;
  background-color: yellowgreen;
  float: left;
}
</code></pre>
<h2 id="三-清除浮动"><a class="header" href="#三-清除浮动">三 清除浮动</a></h2>
<h3 id="30-浮动问题"><a class="header" href="#30-浮动问题">3.0 浮动问题</a></h3>
<p>浮动后，后续的盒子会浮上来，会对布局造成影响，为了避免这种影响，有两种方式：</p>
<ul>
<li>方式一：浮动的元素都被包裹在一个透明的父盒子中，父盒子只要拥有自己的宽高，那么就不会对整体布局造成影响。</li>
<li>方式二：清除浮动。清除浮动并不是清除了浮动的效果，而是清除浮动带来的布局的影响！</li>
</ul>
<h3 id="31-clear-属性清除浮动"><a class="header" href="#31-clear-属性清除浮动">3.1 clear 属性清除浮动</a></h3>
<p>清除浮动的使用场景：很多场景中，父盒子是没有高度的，由子盒子撑起来，但是子元素若设置了浮动，父盒子就无法被撑开，也就不会显示了！</p>
<p>清除浮动方式方式一：给最后一个浮动元素末尾添加一个类名为 clearfix 的空标签，使用属性 clear:left| right | both。该方式是 W3C 推荐的方式，但是添加了额外的标签，实际开发中不推荐使用。</p>
<pre><code class="language-html">    &lt;style&gt;
        #div1 {
            width: 500px;
            background-color: red;
        }
        #div2 {
            width: 200px;
            height: 200px;
            background-color: green;
            float:right;
        }
        .clearfix {
            clear: both;        /* both 表示清除左右浮动 */
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;div1&quot;&gt;
    &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>贴士：clear 的值有 left、rigth、both 等，表示清除浮动的方向。</p>
<h3 id="32-overflow-触发-bfc-清除浮动"><a class="header" href="#32-overflow-触发-bfc-清除浮动">3.2 overflow 触发 BFC 清除浮动</a></h3>
<p>清除浮动方式方式二：给父盒子设置 <code>overflow:hidde</code>n，此属性用来触发 bfc。但是有些场合不推荐该方式清除浮动，如果父盒子中有定位的元素，子盒子中的元素如果超出了父盒子的高度，超出部分会被切掉。</p>
<h3 id="33-after-伪元素清除浮动"><a class="header" href="#33-after-伪元素清除浮动">3.3 after 伪元素清除浮动</a></h3>
<p>清除浮动方式方式三：使用 after 伪元素清除浮动，该方式是最为流行的方式。其本质与方式一没有太大差别，利用 <code>content</code> <code>after</code> 自动添加了一个空内容标签，接着空内容标签设置 <code>clear</code> 属性。</p>
<pre><code class="language-html">&lt;style&gt;
  .div1 {
    width: 500px;
    background-color: red;
  }
  .div2 {
    width: 200px;
    height: 200px;
    background-color: green;
    float: right;
  }

  /* 清除浮动 */
  .clearfix:after {
    /* 选中容器末尾的伪元素 */
    content: ' '; /* 必须添加：*/
    display: block; /* 必须添加：将伪元素的 display 设置为非 inline，并给定一个 content 值，以便让伪元素出现在文档中 */
    clear: both; /* 必须添加 让伪元素清除容器中的所有浮动 */
    height: 0;
    line-height: 0;
    visibility: hidden;
  }
  .clearfix {
    *zoom: 1; /*兼容 IE*/
  }
&lt;/style&gt;

&lt;div class=&quot;div1 clearfix&quot;&gt;
  &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>淘宝、小米使用了双伪元素清除浮动，但是 IE 支持不好，这个版本的清除浮动可以让其包含所有的外边距：</p>
<pre><code class="language-css">/* 让::before 和::after伪元素都显示出来 */
.clearfix:before,
.clearfix:after {
  display: table; /* 防止伪元素的外边距折叠 */
  content: ' ';
}

/* 只有::after 伪元素需要清除浮动 */
.clearfix:after {
  clear: both;
}

.clearfix {
  *zoom: 1;
}
</code></pre>
<p>这个版本使用 <code>display: table</code> 而不是 <code>display: block</code>。给::before 和::after 伪元素都加上这一属性，所有子元素的外边距都会包含在容器的顶部和底部之间。在清除浮动时使用 <code>display: table</code> 能够包含外边距，是因为利用了 CSS 的一些特性。创建一个 <code>display: table</code> 元素（或者是本例的伪元素），也就在元素内隐式创建了一个表格行和一个单元格。因为外边距无法通过单元格元素折叠（参见第 3 章），所以也无法通过设置了 <code>display: table</code> 的伪元素折叠。</p>
<p>看起来似乎使用 <code>display: table-cell</code> 也能达到相同的效果， 但是 clear 属性只能对块级元素生效。表格是块级元素，但是单元格并不是。因此， clear 属性无法跟 <code>display:table-cell</code> 一起使用。所以要用 <code>display: table</code> 来清除浮动，同时利用隐式创建单元格来包含外边距。</p>
<h2 id="四-浮动陷阱"><a class="header" href="#四-浮动陷阱">四 浮动陷阱</a></h2>
<p>如下所示浮动的盒子会出现对齐错误：</p>
<pre><code class="language-html">&lt;style&gt;
  main {
    width: 280px;
    height: 300px;
    border: 1px solid orange;
  }
  div {
    float: left;
  }
  div:nth-child(1) {
    height: 130px;
    width: 100px;
    background-color: yellowgreen;
  }
  div:nth-child(2) {
    height: 100px;
    width: 100px;
    background-color: pink;
  }
  div:nth-child(3) {
    height: 100px;
    width: 100px;
    background-color: red;
  }
&lt;/style&gt;

&lt;main&gt;
  &lt;div&gt;111&lt;/div&gt;
  &lt;div&gt;222&lt;/div&gt;
  &lt;div&gt;333&lt;/div&gt;
&lt;/main&gt;
</code></pre>
<p>因为盒子 2 比盒子 1 矮，所以它下面有多余的空间给盒子 3。盒子 3 会“抓住”盒子 1，而不是清除盒子 1 的浮动。因此盒子 3 不会浮动到最左边，而是浮动到盒子 1 的右下角。这种行为本质上取决于每个浮动块的高度。即使高度相差 1px，也会导致这个问题。相反，如果盒子 1 比盒子 2 矮，盒子 3 就没法抓住盒子 1 的边缘。除非以后内容改变导致元素高度发生变化，否则就不会看到这种现象。</p>
<p>修复方案：清除第三个浮动元素上面的浮动。或者用更通用的做法：清除每行的第一个元素上面的浮动。由于已知每行有两个盒子， 因此只需要清除每行的第奇数个元素上面那行的浮动即可。</p>
<pre><code class="language-css">div:nth-child(odd) {
  clear: left;
}
</code></pre>
<p>即使以后给页面添加更多元素，这段代码仍然有效。它作用于第一、第三、第五个元素，等等。如果每行需要三个元素，则可以通过.media:nth-child(3n+1)来每隔两个元素选一个元素。</p>
<h2 id="五-bfc"><a class="header" href="#五-bfc">五 BFC</a></h2>
<h3 id="50-bfc-浮动的文字环绕问题"><a class="header" href="#50-bfc-浮动的文字环绕问题">5.0 BFC 浮动的文字环绕问题</a></h3>
<p>如果要让下面包围图片的文字位于右侧展示，有如下代码：</p>
<pre><code class="language-html">&lt;style&gt;
  .media {
    float: left;
    margin: 0 1.5em 1.5em 0;
    width: calc(50% - 1.5em);
    padding: 1.5em;
    background-color: #eee;
    border-radius: 0.5em;
  }
  .media:nth-child(odd) {
    clear: left;
  }
  .media-image {
    float: left;
  }
  .media-body {
    margin-top: 0;
  }
  .media-body h4 {
    margin-top: 0;
  }
&lt;/style&gt;

&lt;div class=&quot;media&quot;&gt;
  &lt;img class=&quot;media-image&quot; src=&quot;shoes.png&quot; /&gt;
  &lt;div class=&quot;media-body&quot;&gt;
    &lt;h4&gt;Change it up&lt;/h4&gt;
    &lt;p&gt;
      Don't run the same every time you hit the road. Vary your pace, and vary
      the distance of your runs. Don't run the same every time you hit the road.
      Vary your pace, and vary the distance of the distance of your runs.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>会发现这里文字是环绕图片的，无法实现文字在右侧展示，图片在左侧展示，这里可以利用 BFC。</p>
<h3 id="51-bfc-概念"><a class="header" href="#51-bfc-概念">5.1 BFC 概念</a></h3>
<p>BFC：块级格式化上下文（ block formatting context，BFC）。BFC 是网页的一块区域，元素基于这块区域布局。虽然 BFC 本身是环绕文档流的一部分，
但它将内部的内容与外部的上下文隔离开。</p>
<p>这种隔离为创建 BFC 的元素做出了以下 3 件事情。</p>
<ul>
<li>包含了内部所有元素的上下外边距。它们不会跟 BFC 外面的元素产生外边距折叠。</li>
<li>包含了内部所有的浮动元素。</li>
<li>不会跟 BFC 外面的浮动元素重叠。</li>
</ul>
<p>简而言之， BFC 里的内容不会跟外部的元素重叠或者相互影响。如果给元素增加 clear 属性，它只会清除自身所在 BFC 内的浮动。如果强制给一个元素生成一个新的 BFC，它不会跟其他 BFC 重叠。</p>
<p>给元素添加以下的任意属性值都会创建 BFC。</p>
<ul>
<li>float： left 或 right，不为 none 即可。</li>
<li>overflow： hidden、 auto 或 scroll，不为 visible 即可。</li>
<li>display： inline-block、 table-cell、 table-caption、 flex、 inline-flex、grid 或 inline-grid。拥有这些属性的元素称为块级容器（ block container）。</li>
<li>position： absolute 或 position: fixed。</li>
</ul>
<p>贴士：网页的根元素也创建了一个顶级的 BFC。</p>
<h3 id="52-bfc-实现布局"><a class="header" href="#52-bfc-实现布局">5.2 BFC 实现布局</a></h3>
<p>5.0 案例只要给媒体正文创建 BFC，网页的布局就会符合预期（如图 4-15 所示）。通常是给元素设置 overflow 值——hidden 或者 auto。</p>
<pre><code class="language-css">.media-image {
  float: left;
  /*给图片添加一个外边距，让它与正文中间出现间隔*/
  margin-right: 1.5em;
}
.media-body {
  /* 创建一个新的 BFC，这样正文就不会跟浮动的图片重叠*/
  overflow: auto;
  margin-top: 0;
}
</code></pre>
<p>使用 overflow: auto 通常是创建 BFC 最简单的一种方式。</p>
<p>注意：使用浮动或者 inline-block 方式创建 BFC 的元素宽度会变成 100%，因此需要限制一下元素的宽度，防止因为过宽而换行，导致内容移动到浮动图片的
下面。</p>
<p>相反，使用 table-cell 方式显示的元素，其宽度只会刚好容纳其中的内容，因此需要设置一个较大的宽度，强制使其填满剩余空间。</p>
<p>某些情况下， BFC 中的内容可能还会与别的 BFC 的内容重叠。比如，内容溢出了容器（比如内容太宽）或者因为负外边距导致内容被拉到容器外面。</p>
<p>总结： BFC 有 3 个好处：包含浮动元素，防止外边距折叠，防止文档流围绕浮动元素排列。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="042-布局技术-定位与层级"><a class="header" href="#042-布局技术-定位与层级">04.2-布局技术-定位与层级</a></h1>
<h2 id="一-定位-position-介绍"><a class="header" href="#一-定位-position-介绍">一 定位 position 介绍</a></h2>
<h3 id="11-定位作用"><a class="header" href="#11-定位作用">1.1 定位作用</a></h3>
<p>定位用于将盒子定在某一个位置，自由的漂浮在其他盒子上面，可以理解为漂浮在标准流上的布局！</p>
<p>定位的应用很多，如：轮播图中左右控制按钮，比如某个区域内的不断变换的小图标，都可以使用定位实现。</p>
<p>定位写法：</p>
<pre><code class="language-css">postion: relative; /* 定位模式 */
top: 100px;
left: 100px; /* 边偏移 */
</code></pre>
<p>边偏移：left, right,top,bottom（分别代表相对于父元素的左右上下距离）。</p>
<p>定位模式：</p>
<ul>
<li>static：静态定位，也称为自动定位，是元素的默认定位方式，即按照元素标准流的显示方式，所以也没有边偏移。</li>
<li>relative：相对定位，没有脱离标准文档流</li>
<li>absolute：绝对定位，脱离了标准文档流</li>
<li>fixed：固定定位，脱离了标准文档流</li>
<li>sticky：黏性定位，脱离了标准文档流</li>
</ul>
<h2 id="二-定位的使用"><a class="header" href="#二-定位的使用">二 定位的使用</a></h2>
<h3 id="21-静态定位"><a class="header" href="#21-静态定位">2.1 静态定位</a></h3>
<p>静态定位是元素的默认定位方式，即按照元素标准流的显示方式，没有偏移，无需特殊处理。</p>
<h3 id="22-固定定位-fixed"><a class="header" href="#22-固定定位-fixed">2.2 固定定位 fixed</a></h3>
<p>固定定位与绝对定位特性相似，也脱离了标准文档流，但是固定定位会将元素固定在可视区，也不会受到祖先元素的影响。设置了固定定位的元素，具备了行内块元素的特性，支持设定宽度，内容也可以撑开宽度。</p>
<p>固定定位实现模态框：</p>
<pre><code class="language-html">&lt;style&gt;
  body {
    font-family: Helvetica, Arial, sans-serif;
    min-height: 200vh; /* 设置网页高度，让页面出现滚动条（只是为了演示） */
    margin: 0;
  }
  button {
    padding: 0.5em 0.7em;
    border: 1px solid #8d8d8d;
    background-color: white;
    font-size: 1em;
  }
  .top-banner {
    padding: 1em 0;
    background-color: #ffd698;
  }
  .top-banner-inner {
    width: 80%;
    max-width: 1000px;
    margin: 0 auto;
  }
  /* 默认隐藏模态框,当要打开模态框的时候 */
  .modal {
    display: none;
  }
  /* 当打开模态框时，用半透明的蒙层遮挡网页剩余内容 */
  .modal-backdrop {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: rgba(0, 0, 0, 0.5);
  }
  /* 给模态框的主体定位 */
  .modal-body {
    position: fixed;
    top: 3em;
    bottom: 3em;
    right: 20%;
    left: 20%;
    padding: 2em 3em;
    background-color: white;
    overflow: auto; /*允许模态框主体在需要时滚动*/
  }
  .modal-close {
    cursor: pointer;
  }
&lt;/style&gt;
&lt;body&gt;
  &lt;header class=&quot;top-banner&quot;&gt;
    &lt;div class=&quot;top-banner-inner&quot;&gt;
      &lt;p&gt;
        Find out what's going on at Wombat Coffee each month. Sign up for our
        newsletter:
        &lt;button id=&quot;open&quot;&gt;Sign up&lt;/button&gt;
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/header&gt;
  &lt;div class=&quot;modal&quot; id=&quot;modal&quot;&gt;
    &lt;div class=&quot;modal-backdrop&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;modal-body&quot;&gt;
      &lt;button class=&quot;modal-close&quot; id=&quot;close&quot;&gt;close&lt;/button&gt;
      &lt;h2&gt;Wombat Newsletter&lt;/h2&gt;
      &lt;p&gt;Sign up for our monthly newsletter. No spam. We promise!&lt;/p&gt;
      &lt;form&gt;
        &lt;p&gt;
          &lt;label for=&quot;email&quot;&gt;Email address:&lt;/label&gt;
          &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;
        &lt;/p&gt;
        &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    var button = document.getElementById('open')
    var close = document.getElementById('close')
    var modal = document.getElementById('modal')
    button.addEventListener('click', function (event) {
      event.preventDefault()
      modal.style.display = 'block'
    })
    close.addEventListener('click', function (event) {
      event.preventDefault()
      modal.style.display = 'none'
    })
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>因为固定元素从文档流中移除了，所以它不再影响页面其他元素的位置。别的元素会跟随正常文档流，就像固定元素不存在一样。也就是说它们通常会在固定元素下面排列，视觉上被遮挡。这对于模态框来说没问题，因为我们希望模态框出现在最前面的中间位置，直到用户关闭它。</p>
<p>而对于其他固定元素，比如侧边导航栏，就需要注意不要让其他内容出现在它下面。通常给其他内容加一个外边距就能解决该问题。比如，将所有内容放在容器里，容器设置 right-margin:20%。外边距会流到固定元素下面，内容就不会跟导航栏重叠。</p>
<h3 id="23-绝对定位-absolute"><a class="header" href="#23-绝对定位-absolute">2.3 绝对定位 absolute</a></h3>
<p>绝对定位 absolute：相对于父盒子或者浏览器左上角位置进行 left、top 调整，该元素类似浮动不再占据位置（脱标）。</p>
<pre><code class="language-html">&lt;style&gt;
  .box1 {
    width: 200px;
    height: 200px;
    background-color: yellowgreen;
  }
  .box2 {
    width: 200px;
    height: 200px;
    background-color: red;
    position: absolute;
    left: 50px;
  }
  .box3 {
    width: 200px;
    height: 200px;
    background-color: green;
  }
&lt;/style&gt;

&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;
</code></pre>
<p>贴士：</p>
<ul>
<li>设置了绝对定位的盒子具备了行内元素的特性：宽度默认由内容决定。</li>
<li>设置了绝对定位的盒子也具备了块级元素的特性：宽度可以由 width 决定。</li>
</ul>
<p>绝对定位的基准原则：</p>
<ul>
<li>给单独的元素设置绝对定位，以可视区为基准（一般是浏览器左上角，即 body）</li>
<li>若父盒子（祖先盒子）有非 static 定位，则以父盒子左上角为基准</li>
</ul>
<p>一般情况下：子元素设置绝对定位，父元素会设置相对定位（子绝父相，也要看情况）。</p>
<p>让 2.2 的示例的关闭按钮绝对定位：</p>
<pre><code class="language-css">.modal-close {
  position: absolute;
  top: 0.3em;
  right: 0.3em;
  padding: 0.3em;
  cursor: pointer;
  font-size: 2em;
  /* 让按钮美化变成一个小方形 */
  height: 1em;
  width: 1em;
  text-indent: 10em;
  overflow: hidden; /* 让元素里的文字溢出并隐藏 */
  border: 0;
}
.modal-close::after {
  position: absolute;
  line-height: 0.5;
  top: 0.2em;
  left: 0.1em;
  text-indent: 0;
  content: '\00D7'; /*添加 Unicode 字*/
}
</code></pre>
<h3 id="24-相对定位-relative"><a class="header" href="#24-相对定位-relative">2.4 相对定位 relative</a></h3>
<p>相对定位 relative：相对于自身原本位置进行 left、top 调整，调整后该元素在 CSS 中仍然是占据着原来的位置。</p>
<p>从这里可以看出，相对定位没有脱离文档流，不会影响其他元素的布局。</p>
<pre><code class="language-html">&lt;style&gt;
  .box1 {
    width: 100px;
    height: 100px;
    background-color: yellowgreen;
  }
  .box2 {
    width: 100px;
    height: 100px;
    background-color: red;
    position: relative;
  }
  .box3 {
    width: 100px;
    height: 100px;
    background-color: green;
  }
&lt;/style&gt;

&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;
</code></pre>
<p>相对定位制作下拉菜单示例：</p>
<pre><code class="language-html">&lt;style&gt;
  .container {
    width: 80%;
    max-width: 1000px;
    margin: 1em auto;
  }
  /* 创建包含块 */
  .dropdown {
    display: inline-block;
    position: relative;
  }
  .dropdown-label {
    padding: 0.5em 1.5em;
    border: 1px solid #ccc;
    background-color: #eee;
  }
  .dropdown-menu {
    display: none; /*最初隐藏菜单*/
    position: absolute;
    left: 0;
    top: 2.1em; /*将菜单移动到下拉菜单下面*/
    min-width: 100%;
    background-color: #eee;
  }
  /* 鼠标悬停时显示菜单 */
  .dropdown:hover .dropdown-menu {
    display: block;
  }
  .submenu {
    padding-left: 0;
    margin: 0;
    list-style-type: none;
    border: 1px solid #999;
  }
  .submenu &gt; li + li {
    border-top: 1px solid #999;
  }
  .submenu &gt; li &gt; a {
    display: block;
    padding: 0.5em 1.5em;
    background-color: #eee;
    color: #369;
    text-decoration: none;
  }
  .submenu &gt; li &gt; a:hover {
    background-color: #fff;
  }

  /* ::after 伪元素来画三角形 */
  .dropdown-label {
    padding: 0.5em 2em 0.5em 1.5em;
    border: 1px solid #ccc;
    background-color: #eee;
  }
  .dropdown-label::after {
    content: '';
    position: absolute;
    right: 1em;
    top: 1em;
    border: 0.3em solid;
    border-color: black transparent transparent;
  }
  .dropdown:hover .dropdown-label::after {
    top: 0.7em;
    border-color: transparent transparent black;
  }
&lt;/style&gt;

&lt;body&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;nav&gt;
      &lt;div class=&quot;dropdown&quot;&gt;
        &lt;div class=&quot;dropdown-label&quot;&gt;Main Menu&lt;/div&gt;
        &lt;div class=&quot;dropdown-menu&quot;&gt;
          &lt;ul class=&quot;submenu&quot;&gt;
            &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/coffees&quot;&gt;Coffees&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/brewers&quot;&gt;Brewers&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/specials&quot;&gt;Specials&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;About us&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/nav&gt;
    &lt;h1&gt;Wombat Coffee Roasters&lt;/h1&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>上述示例在用户鼠标悬停的时候用了一个:hover 伪类打开菜单，这样做不完整。通常情况下，更稳健的方式是使用 JavaScript 添加和移除一个控制菜单开关的类名。这样就能在打开和关闭菜单之前添加适当的延迟，防止用户在鼠标快速滑过时无意间触发:hover。</p>
<p>另外，虽然这个例子用鼠标能正常生效，但在触屏设备上会无效（只有一部分触屏设备会在轻触的时候触发:hover 状态）。该例子也没有解决用屏幕阅读器或者用键盘切换时的可访问性问题。更严谨的做法是增强下拉菜单的功能，确保能用触屏控制，并且当用户使用 Tab 键切换菜单项的时候保持菜单打开。</p>
<p>实现这些功能的 JavaScript 代码不在本书的讨论范围内，但是如果你很擅长 JavaScript，就可以写代码解决以上问题。你也可以借助实现了下拉功能的第三方库，然后用 CSS 来定制菜单的样式。</p>
<h3 id="24-黏性定位-sticky"><a class="header" href="#24-黏性定位-sticky">2.4 黏性定位 sticky</a></h3>
<p>黏性定位可以认为是相对定位与固定定位的混合：元素在跨越特定阈值前为相对定位，之后为固定定位。正常情况下，元素会随着页面滚动，当到达屏幕的特定位置时，如果用户继续滚动，它就会“锁定”在这个位置。最常见的用例是侧边栏导航。</p>
<pre><code class="language-html">&lt;style&gt;
  body {
    height: 2000px;
  }
  p {
    margin-top: 30px;
  }
  div {
    position: sticky;
    top: 0;
  }
&lt;/style&gt;

&lt;p&gt;11111111&lt;/p&gt;
&lt;p&gt;11111111&lt;/p&gt;
&lt;p&gt;11111111&lt;/p&gt;
&lt;p&gt;11111111&lt;/p&gt;
&lt;div&gt;黏性导航&lt;/div&gt;
&lt;p&gt;11111111&lt;/p&gt;
&lt;p&gt;11111111&lt;/p&gt;
&lt;p&gt;11111111&lt;/p&gt;
&lt;p&gt;11111111&lt;/p&gt;
&lt;p&gt;11111111&lt;/p&gt;
</code></pre>
<h2 id="三-定位造成的一些改变"><a class="header" href="#三-定位造成的一些改变">三 定位造成的一些改变</a></h2>
<h3 id="31-绝对定位盒子的居中"><a class="header" href="#31-绝对定位盒子的居中">3.1 绝对定位盒子的居中</a></h3>
<p>绝对定位无法使用 <code>margin: auto</code> 让盒子水平居中，需要使用：</p>
<pre><code class="language-css">.div {
  position: absolute;
  left: 50%; /* 先让盒子自身距离左侧增加 50% */
  margin-left: -100px; /* 再让盒子离左侧距离减少宽度一半 */
}
</code></pre>
<h3 id="32-绝对定位造成的元素转换"><a class="header" href="#32-绝对定位造成的元素转换">3.2 绝对定位造成的元素转换</a></h3>
<p>绝对定位和固定定位也会转换元素，默认转换为行内块，所以一个行内元素如果需要设定宽高，可以进行三种方式：</p>
<ul>
<li>inline-block 直接修改元素为行内块元素</li>
<li>浮动转换，但是会造成脱标</li>
<li>绝对定位、固定定位转换，会造成脱标</li>
</ul>
<p>注意：绝对定位、浮动都不会触发外边距合并！</p>
<h3 id="33-定位盒子层级关系-z-index"><a class="header" href="#33-定位盒子层级关系-z-index">3.3 定位盒子层级关系 z-index</a></h3>
<p>后定位的盒子的层级要高于前面定位的盒子的层级，使用 z-index 设置定位盒子之间的层级关系。</p>
<p>贴士：</p>
<ul>
<li>只有定位的盒子（除了 static）才有 z-index</li>
<li>如果都是绝对定位，他们默认的 z-index 都是 0</li>
<li>z-index 可以取负数</li>
</ul>
<p>注意：不同层级的之间的盒子也可以进行 z-index 比较，如下所示：</p>
<pre><code class="language-html">&lt;style&gt;
  .father {
    position: absolute;
    z-index: 1;
  }

  .son {
    width: 100px;
    height: 100px;
    background-color: aquamarine;
    position: absolute;
    left: 0;
    top: 0;
    z-index: 3;
  }
  .box {
    width: 100px;
    height: 100px;
    background-color: red;
    position: absolute;
    left: 50px;
    top: 50px;
    z-index: 2;
  }
&lt;/style&gt;

&lt;div class=&quot;father&quot;&gt;
  &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p>示例中，box 盒子会在界面的上方，这是因为 box 会优先于 father 进行比较，当 father 不存在 z-index，才会与其内部的 son 元素比较。</p>
<p>所有层叠上下文内的元素会按照以下顺序，从后到前叠放：</p>
<ul>
<li>层叠上下文的根</li>
<li>z-index 为负的定位元素（及其子元素）</li>
<li>非定位元素</li>
<li>z-index 为 auto 的定位元素（及其子元素）</li>
<li>z-index 为正的定位元素（及其子元素）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="043-布局技术-弹性布局"><a class="header" href="#043-布局技术-弹性布局">04.3-布局技术-弹性布局</a></h1>
<h2 id="一-认识-flex-伸缩布局"><a class="header" href="#一-认识-flex-伸缩布局">一 认识 Flex 伸缩布局</a></h2>
<h3 id="11-flex-布局概念"><a class="header" href="#11-flex-布局概念">1.1 Flex 布局概念</a></h3>
<p>Flex（Flexible Box）即弹性布局（也称为伸缩布局），是一种按行、按列进行元素布局的方法，元素可以膨胀以填充额外的空间，或者收缩以适应更小的空间。整体布局方式采用弹性伸缩机制后，<strong>子元素也不再依赖于 float、clear、vertical-align 等属性</strong>，这些属性也会相应失效。</p>
<p>弹性布局为盒模型提供了最大的灵活性，任何一个容器都可以指定为 flex 布局，使用起来便利性更好，可以轻松解决困扰我们许久的垂直居中和等高列问题。</p>
<p>通过过给父盒子添加 flex 属性，就可以额控制子盒子的位置和排列方式：</p>
<pre><code class="language-html">&lt;style&gt;
  div {
    width: 500px;
    height: 500px;
    display: flex;
    background-color: aquamarine;
  }
  div &gt; span {
    /*父元素 flex 后，子元素无需浮动，也不区分行内元素、块元素*/
    width: 100px;
    height: 100px;
    font-size: 20px;
    background-color: burlywood;
  }
&lt;/style&gt;

&lt;div&gt;
  &lt;span&gt;1&lt;/span&gt;
  &lt;span&gt;2&lt;/span&gt;
  &lt;span&gt;3&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>被设置为 flex 的的盒子称呼为容器（flext container），<strong>其直接子元素都会自动成为弹性子元素，即：相互平等的容器成员（flext item，flex 项目）</strong>。弹性子元素高度相等（由内容决定），默认是在同一行按照从左到右的顺序并排排列。</p>
<h3 id="12-flex-布局特点"><a class="header" href="#12-flex-布局特点">1.2 Flex 布局特点</a></h3>
<p>与 <code>inline</code>、<code>inline-block</code>等设置只会影响到应用了该样式的元素不同，flex 能控制内部元素的布局：</p>
<ul>
<li>当我们增加子项时，会发现子项内容并不会出现换行、溢出盒子效果，会随着子项目数目变化而出现自动伸缩，这就是伸缩布局，只有当平均最小宽度无法容纳子元素时才会出现溢出情况。</li>
<li>在不给子元素设置宽度时，宽度由内容撑开</li>
<li>在不给自元素设置高度时，高度会自适应父容器</li>
</ul>
<p>贴士：Flex 布局适合移动端，在 PC 端 IE10 以上才能得到部分支持。还可以用 display: inline-flex。它创建了一个弹性容器， 行为类似于 inline-block 元素。它会跟其他行内元素一起流式排列，但不会自动增长到 100%的宽度。内部的弹性子元素跟使用 display: flex 创建的 Flexbox 里的弹性子元素行为一样。在实际开发时，很少用到 display: inline-flex。</p>
<p>Flexbox 的一个重要特性在于如何基于弹性子元素的数量和其中的内容量（及大小）来计算容器的大小。但是如果网页很大，或者加载很慢时可能会产生奇怪的行为。当浏览器加载内容时，它渐进渲染到了屏幕，即使此时网页的剩余内容还在加载。假设有一个使用弹性盒子（ flex-direction: row）实现的三列布局。如果其中两列的内容加载了，浏览器可能会在加载完第三列之前就渲染这两列。然后等到剩余内容加载完，浏览器会重新计算每个弹性子元素的大小，重新渲染网页。用户会短暂地看到两列布局，然后列的大小改变（可能改变特别大），并出现第三列。</p>
<h3 id="13-示例使用-felx-布局实现导航栏"><a class="header" href="#13-示例使用-felx-布局实现导航栏">1.3 示例：使用 felx 布局实现导航栏</a></h3>
<p>网页结构如下：</p>
<pre><code class="language-html">&lt;nav&gt;
  &lt;ul class=&quot;site-nav&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;nav-right&quot;&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
</code></pre>
<p>基础样式：</p>
<pre><code class="language-css">ul,
li,
a {
  list-style: none;
  text-decoration: none;
}

.site-nav {
  /* display: flex; */
  padding: 0.5em;
  border-radius: 0.2em;
}
.site-nav &gt; li {
  margin-top: 0;
}

/*  padding加在a上不在li上是因为用户点击的是a */
.site-nav &gt; li &gt; a {
  display: block; /* 变为块级元素才能撑开父元素的高度 */
  padding: 0.5em 1em;
}
</code></pre>
<p>此时我们添加 flex 布局：</p>
<pre><code class="language-css">.site-nav {
  display: flex;
  padding: 0.5em;
  border-radius: 0.2em;
}
</code></pre>
<p>对样式进行优化：</p>
<pre><code class="language-css">/* 除了第一项之外都增加一个外边距 */
.site-nav &gt; li + li {
  margin-left: 1.5em;
}

/* flexbox可以使用 margin: auto 来填充弹性子元素之间的可用空间，会将最后一个元素移动到右侧 */
.site-nav &gt; .nav-right {
  margin-left: auto;
}
</code></pre>
<h2 id="二-flex-属性定义子项大小"><a class="header" href="#二-flex-属性定义子项大小">二 flex 属性定义子项大小</a></h2>
<h3 id="21-flex-使用示例"><a class="header" href="#21-flex-使用示例">2.1 flex 使用示例</a></h3>
<p>使用 flex 属性给两列子项分别赋以 2/3 和 1/3 的宽度：</p>
<pre><code class="language-html">&lt;style&gt;
  .bg {
    padding: 1.5em;
    background-color: #fff;
  }

  .flex-box {
    display: flex;
  }
  /* 去掉顶部外边距，给每个弹性子元素之间加上间隔 */
  .flex-box &gt; * + * {
    margin-top: 0;
    margin-left: 1.5em;
  }

  /* flex设置列宽：占满宽度的情况下分配2/3,1/3宽度 */
  .column-main {
    flex: 2;
  }
  .column-sidebar {
    flex: 1;
  }
&lt;/style&gt;

&lt;main class=&quot;flex-box&quot;&gt;
  &lt;div class=&quot;column-main bg&quot;&gt;
    &lt;h1&gt;左侧文章标题&lt;/h1&gt;
    &lt;p&gt;文章内容文章内容文章内容文章内容文章内容&lt;/p&gt;
  &lt;/div&gt;

  &lt;div class=&quot;column-sidebar&quot;&gt;
    &lt;div class=&quot;bg&quot;&gt;
      &lt;form action=&quot;&quot; class=&quot;login-form&quot;&gt;
        &lt;h3&gt;右侧信息&lt;/h3&gt;
        &lt;p&gt;
          &lt;label for=&quot;username&quot;&gt;账户&lt;/label&gt;
          &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt;
        &lt;/p&gt;
        &lt;p&gt;
          &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;
          &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; /&gt;
        &lt;/p&gt;
        &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;

    &lt;div class=&quot;centered bg&quot;&gt;
      &lt;small&gt;起始点&lt;/small&gt;
      &lt;div class=&quot;cost&quot;&gt;
        &lt;span class=&quot;cost-currency&quot;&gt;$&lt;/span&gt;
        &lt;span class=&quot;cost-dollars&quot;&gt;20&lt;/span&gt;
        &lt;span class=&quot;cost-cents&quot;&gt;.00&lt;/span&gt;
      &lt;/div&gt;
      &lt;a class=&quot;cta-button&quot; href=&quot;#&quot;&gt;&lt;/a&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/main&gt;
</code></pre>
<p>贴士：推荐使用简写属性 flex， 而不是分别声明 flex-grow、 flex-shrink、flex-basis。与大部分简写属性不一样，如果在 flex 中忽略某个子属性，那么子属性的值并不会被置为初始值。相反，如果某个子属性被省略，那么 flex 简写属性会给出有用的默认值： flex-grow 为 1、 flex-shrink 为 1、 flex-basis 为 0%。这些默认值正是大多数情况下所需要的值。</p>
<h3 id="22-flex-用于布局"><a class="header" href="#22-flex-用于布局">2.2 flex 用于布局</a></h3>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/flex-useful.svg" alt="" /></p>
<p>其中第 3 个例子展示的是“圣杯”布局。众所周知，用 CSS 实现这种布局非常困难。该布局中，两个侧边栏宽度固定，而中间的列是“流动的”，即它会自动填充可用空间。重点是，三列的高度相等，该高度取决于它们的内容。尽管浮动也能实现这种布局，但需要用一些既晦涩又脆弱的技巧。你可以使用不同的弹性子元素，想出很多不同的方式来组合以上的布局。</p>
<h3 id="23-flex-basis-属性"><a class="header" href="#23-flex-basis-属性">2.3 flex-basis 属性</a></h3>
<p>flex-basis 定义了元素大小的基准值，即一个初始的“主尺寸”。 flex-basis 属性可以设置为任意的 width 值，包括 px、 em、百分比：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/flex-01.svg" alt="felx-basis" /></p>
<p>flex-basis 的初始值是 auto，此时浏览器会检查元素是否设置了 width 属性值。如果有，则使用 width 的值作为 flex-basis 的值；如果没有，则用元素内容自身的大小。如果 flex-basis 的值不是 auto， width 属性会被忽略。</p>
<p>每个弹性子元素的初始主尺寸确定后，它们可能需要在主轴方向扩大或者缩小来适应（或者填充）弹性容器的大小。这时候就需要 flex-grow 和 flex-shrink 来决定缩放的规则。</p>
<h3 id="24-flex-grow-属性"><a class="header" href="#24-flex-grow-属性">2.4 flex-grow 属性</a></h3>
<p>每个弹性子元素的 flex-basis 值计算出来后，它们（加上子元素之间的外边距）加起来会占据一定的宽度。加起来的宽度不一定正好填满弹性容器的宽度，多出来的留白（或剩余宽度）会按照 flex-grow（增长因子）的值分配给每个弹性子元素，flex-grow 的值为非负整数。如果一个弹性子元素的 flex-grow 值为 0，那么它的宽度不会超过 flex-basis 的值；如果某个弹性子元素的增长因子非 0，那么这些元素会增长到所有的剩余空间被分配完，也就意味着弹性子元素会填满容器的宽度。</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/flex-02.svg" alt="felx-basis" /></p>
<p>flex-grow 的值越大，元素的“权重”越高，也就会占据更大的剩余宽度。一个 flex-grow:2 的子元素增长的宽度为 flex-grow: 1 的子元素的两倍：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/flex-03.svg" alt="felx-basis" /></p>
<p>2.1 示例中声明 flex: 2 和 flex: 1 设置了一个弹性基准值为 0%，因此容器宽度的 100%都是剩余宽度（减去两列之间 1.5em 的外边距）。剩余宽度会分配给两列：第一列得到 2/3 的宽度，第二列得到 1/3 的宽度。</p>
<h3 id="25-使用-flex-shrink-属性"><a class="header" href="#25-使用-flex-shrink-属性">2.5 使用 flex-shrink 属性</a></h3>
<p>flex-shrink 属性与 flex-grow 遵循相似的原则。计算出弹性子元素的初始主尺寸后，它们的累加值可能会超出弹性容器的可用宽度。如果不用 flex-shrink，就会导致溢出：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/flex-04.svg" alt="felx-basis" /></p>
<p>每个子元素的 flex-shrink 值代表了它是否应该收缩以防止溢出。如果某个子元素为 flex-shrink: 0，则不会收缩；如果值大于 0，则会收缩至不再溢出。按照 flex-shrink 值的比例，值越大的元素收缩得越多。</p>
<p>用 flex-shrink 也能实现上述页面中两列的宽度。首先将两列的 flex-basis 指定为理想的比例（ 66.67%和 33.33%）。它们的宽度之和加上 1.5em 的间隔就会比容器宽度多出 1.5em。然后将两列的 flex-shrink 设置为 1，这样就会从每列的宽度减掉 0.75em，于是容器就能容纳两列了：</p>
<pre><code class="language-css">.column-main {
  flex: 66.67%; /* 等价与flex:1 1  66.67% */
}
.column-sidebar {
  flex: 33.33%; /* 等价与flex:1 1  33.33% */
}
</code></pre>
<p>这种解决方案跟前面得到的结果一样，两者都能满足该页面的需求。但是有细微的差别，是因为 column-main 有内边距，而 column-sidebar 没有。当 flex-basis 为 0%时，内边距会改变弹性子元素的初始主宽度计算的方式。因此原始代码 的 column-main 比代码清单 5-8 的要宽 3em，即左右内边距的大小。如果想要精确的结果，那么要么保证两列有相同的内边距，要么用上述新的的方式设置弹性基准值。</p>
<h2 id="三-弹性方向"><a class="header" href="#三-弹性方向">三 弹性方向</a></h2>
<h3 id="31-弹性方向属性"><a class="header" href="#31-弹性方向属性">3.1 弹性方向属性</a></h3>
<p>在 flex 布局中，<strong>元素会跟着主轴进行排列</strong>，通过 flex-direction 来设置主轴是哪个轴（方向），设置了主轴之后，另外一个就是侧轴，元素是跟着主轴进行排列的！</p>
<ul>
<li>主轴：默认是 x 轴，水平向右</li>
<li>侧轴：默认是 y 轴，水平向下</li>
</ul>
<p>如图所示：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/flex-05.svg" alt="主轴与侧轴" /></p>
<h3 id="32-弹性方向示例"><a class="header" href="#32-弹性方向示例">3.2 弹性方向示例</a></h3>
<p>1.3 示例中右侧的两个板块已经按照上下顺序排列了，但是当左侧的内容过多高度变高后，两边就无法等高了：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/flex-06.png" alt="主轴与侧轴" /></p>
<p>想要填满高度要将右边栏（ column-sidebar）改为弹性容器，并设置 flex-direction: column。然后给里面的两个板块设置非 0 的 flex-grow 值：</p>
<pre><code class="language-css">/* 登录央视 */
.login-form h3 {
  margin: 0;
  font-size: 0.9em;
  font-weight: bold;
  text-align: right;
  text-transform: uppercase;
}
.login-form input:not([type='checkbox']):not([type='radio']) {
  display: block;
  width: 100%;
  margin-top: 0;
}
.login-form button {
  margin-top: 1em;
  border: 1px solid #cc6b5a;
  background-color: white;
  padding: 0.5em 1em;
  cursor: pointer;
}

/* 底部 */
.column-main {
  flex: 2;
}
.column-sidebar {
  flex: 1;
  display: flex; /*让子级伸缩布局*/
  flex-direction: column;
}
.column-sidebar &gt; .bg {
  flex: 1;
}

.centered {
  margin-top: 10px;
}
</code></pre>
<p>以上代码创建了一个嵌套的弹性盒子。对外层的弹性盒子来说， <code>&lt;div class=&quot;columnsidebar&quot;&gt;</code> 是弹性子元素，对内部的弹性盒子来说，它就是弹性容器。</p>
<p>内部的弹性盒子的弹性方向为 column，因此主轴发生了旋转，现在变成了从上到下（副轴变成了从左到右）。也就是对于弹性子元素而言， flex-basis、 flex-grow 和 flex-shrink 现在作用于元素的高度而不是宽度。由于指定了 flex: 1，因此在必要的时候子元素的高度会扩展到填满容器。无论哪边更高，主板块的底部和右边第二个小板块的底部都会对齐。</p>
<p>水平弹性盒子的大部分概念同样适用于垂直的弹性盒子（ column 或 column-reverse），但是有一点不同：在 CSS 中处理高度的方式与处理宽度的方式在本质上不一样。弹性容器会占据 100%的可用宽度，而高度则由自身的内容来决定。即使改变主轴方向，也不会影响这一本质。</p>
<p>弹性容器的高度由弹性子元素决定，它们会正好填满容器。在垂直的弹性盒子里，子元素的 flex-grow 和 flex-shrink 不会起作用，除非有“外部限制”(从外层弹性盒子计算出来的高度)强行改变弹性容器的高度。</p>
<h2 id="四-父元素的常见属性"><a class="header" href="#四-父元素的常见属性">四 父元素的常见属性</a></h2>
<h3 id="41-flex-direction"><a class="header" href="#41-flex-direction">4.1 flex-direction</a></h3>
<p>设置主要轴与方向：</p>
<pre><code class="language-css">flex-direction: row;
/*
  row：默认值，设置 x 轴为主轴，即沿着 x 轴从左到右排列
  row-reverse：沿着 x 轴从右到左排列
  column：设置 y 轴为主轴，即沿着 y 轴从上往下排列
  column-reverse：着 y 轴从下往上排列
*/
</code></pre>
<h3 id="42-flex-wrap"><a class="header" href="#42-flex-wrap">4.2 flex-wrap</a></h3>
<p>设置子元素是否换行：</p>
<pre><code class="language-css">flex-wrap: nowrap;
/*
  nowrap：默认不换行，会在主轴上排成一条线。如果一行容纳不下子元素，会缩小子盒子宽度，直到最小宽度小于盒子宽度时会溢出
  wrap：换行，若父元素装不下子元素，会换行
  wrap-reverse：换行，但是换行会从反向开始

  注意：换行后，行与行之间的间距要在父容器内等分！！如果容器没有高度，换行后则所有行就贴在一起
*/
</code></pre>
<h3 id="43-justify-content"><a class="header" href="#43-justify-content">4.3 justify-content</a></h3>
<p>设置主轴的子元素排列方式：</p>
<pre><code class="language-css">justify-content: flex-start;
/*
  flex-start：默认值，在主轴上从头到尾排列，即若主轴为 x 轴则元素贴着左侧对齐
  flex-end：在主轴上从尾到头排列，即若主轴为 x 轴则元素贴着右侧对齐
  center：在主轴方向居中对齐，若主轴是 x 轴则水平居中
  space-evenly：完全平分剩余空间，各个子项之间的间距相等
  space-around：平分剩余空间，子项的左右两边间距相等
  space-between：先两边贴边，再平分剩余空间！！！
*/
</code></pre>
<h3 id="44-flex-flow"><a class="header" href="#44-flex-flow">4.4 flex-flow</a></h3>
<p>复合属性：相当于同时设置了 flex-direction 和 flex-wrap</p>
<pre><code class="language-css">flex-flow: row nowrap;
</code></pre>
<h3 id="45-align-items"><a class="header" href="#45-align-items">4.5 align-items</a></h3>
<p><strong>单行时</strong>，设置侧轴上的子元素排列方式：</p>
<pre><code class="language-css">align-items: flex-start;
/*
  stretch：默认值，沿着侧轴拉伸，此时子盒子无需设置高度，因为会直接拉伸满直到达到父盒子高度 
  flex-start：从上到下
  flex-end：从下到上
  center：挤在一起居中对齐
  baseline：
*/
</code></pre>
<h3 id="46-align-content"><a class="header" href="#46-align-content">4.6 align-content</a></h3>
<p><strong>允许换行时</strong>，设置侧轴上的子元素排列方式，适用于子项出现换行的情况：</p>
<pre><code class="language-css">align-content: stretch;
/*
  stretch：默认值，设置子项元素高度平分父元素高度
  flex-start：从侧轴的头部开始排列
  flex-end：从侧轴的尾部开始排列
  center：在侧轴的中间显示
  space-around：子项在侧轴平分剩余空间
  space-evenly：完全平分剩余空间，各个子项之间的间距相等
  space-around：平分剩余空间，子项的左右两边间距相等
  space-between：先两边贴边，再平分剩余空间！！！
*/
</code></pre>
<h2 id="五-子元素常见属性"><a class="header" href="#五-子元素常见属性">五 子元素常见属性</a></h2>
<h3 id="51-align-self"><a class="header" href="#51-align-self">5.1 align-self</a></h3>
<p>控制子项在侧轴上的排列方式：</p>
<pre><code class="language-css">align-self: auto;
/*
  auto：默认值为。表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch

  该属性允许某一单个子项与其他子项对齐方式不同，可以覆盖 align-items
*/
</code></pre>
<h3 id="52-order"><a class="header" href="#52-order">5.2 order</a></h3>
<p>定义子项的前后顺序，数值越小越靠前：</p>
<pre><code class="language-css">order: 0;
/*
  0：默认值
*/
</code></pre>
<h3 id="43-flex-grow"><a class="header" href="#43-flex-grow">4.3 flex-grow</a></h3>
<p>扩展子元素宽度：</p>
<pre><code class="language-css">flex-grow: 0;
/*
  0：默认值，不占用剩余空间
  1：占满剩余空间（子元素的宽度被扩展，视觉上达到父容器的宽度）
  可取 0-1内的值，当比值大于1时，都会占满剩余空间
  当多个兄弟子元素之间存在flex-grow属性，则进行按比例分配，比如2个子元素分为为2,1，则占据2/3，1/3
*/
</code></pre>
<h3 id="53-flex-shrink"><a class="header" href="#53-flex-shrink">5.3 flex-shrink</a></h3>
<p>容器空间不足时，元素的收缩比例：</p>
<pre><code class="language-css">flex-shrink: 1;
/*
  1：默认值。溢出部分直接被裁剪，子元素与容器大小相同
  0：不让子元素收缩，维持原有大小
  0~1：不完全收缩，溢出部分按比例收缩
  注意：收缩的比例与当前子元素的宽度有关
*/
</code></pre>
<h3 id="54-flex-basis"><a class="header" href="#54-flex-basis">5.4 flex-basis</a></h3>
<p>指定 flex 元素在主轴方向上的长度：</p>
<pre><code class="language-css">flex-basis: auto;
/**
  auto：默认值。
  0：最小空间，相当于没有宽度，当有内容时会有最小宽度，内容换行显示。
  可设置任意像素大小，作用是用来修改在主轴上的长度！比如主轴是x轴时，则修改其宽度，主轴是y轴时，则修改其高度
  注意：值也可以是百分比
*/
</code></pre>
<h3 id="55-flex"><a class="header" href="#55-flex">5.5 flex</a></h3>
<p>flex 是定义子项目分配剩余空间的份数，是 <code>flex-grow</code>，<code>flex-shrink</code>，<code>flex-basis</code> 的缩写：</p>
<pre><code class="language-css">flex: 0;
/*
  0：默认值，即  flex-grow:0; flex-shrink:1; flex-basis:0%;
  1：表示剩余空间被分为 1 份，即  flex-grow:1; flex-shrink:1; flex-basis:0%;
  auto：即  flex-grow:1; flex-shrink:1; flex-basis:auto;
  也支持直接属性连写：flex: 1 0 50%;
*/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="044-布局技术-网格布局"><a class="header" href="#044-布局技术-网格布局">04.4-布局技术-网格布局</a></h1>
<h2 id="一-网格布局介绍"><a class="header" href="#一-网格布局介绍">一 网格布局介绍</a></h2>
<h3 id="11-网格布局简介"><a class="header" href="#11-网格布局简介">1.1 网格布局简介</a></h3>
<p>网格布局（Grid Layout）将网页划分成一个个网格，通过组合不同的网格，制作出不同的布局效果。</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/mobile-02.png" alt="网格布局" /></p>
<p>网格布局与弹性布局较为相似，都是作用于两级的 DOM 结构。设置为 display: grid 的元素将成为一个网格容器（ grid container）。它的子元素则变成网格元素（ grid items）。网格布局同样也可以使用<code>align-items</code>,<code>justify-content</code>等属性。但是 Flex 布局适合在一行上进行布局，在多列自适应处理上有点捉襟见肘，不如栅格布局。</p>
<h3 id="12-网格示例"><a class="header" href="#12-网格示例">1.2 网格示例</a></h3>
<p>制作一个 <code>3*3</code> 的网格示例如下：</p>
<pre><code class="language-html">&lt;style&gt;
  .box {
    width: 300px;
    height: 300px;
    background-color: skyblue;
    display: grid;
    /* 网格容器控制大小 */
    /* 设置三列的宽度 */
    grid-template-columns: 50px 50px 50px;
    /* 设置三行的高度 */
    grid-template-rows: 100px 100px 100px;
  }
  .box div {
    /* 子项无需加大小，大小由网格控制 */
    background-color: yellowgreen;
  }
&lt;/style&gt;

&lt;div class=&quot;box&quot;&gt;
  &lt;div&gt;1&lt;/div&gt;
  &lt;div&gt;2&lt;/div&gt;
  &lt;div&gt;3&lt;/div&gt;
  &lt;div&gt;4&lt;/div&gt;
  &lt;div&gt;5&lt;/div&gt;
  &lt;div&gt;6&lt;/div&gt;
  &lt;div&gt;7&lt;/div&gt;
  &lt;div&gt;8&lt;/div&gt;
  &lt;div&gt;9&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>使用 display: grid 定义一个网格容器。容器会表现得像一个块级元素， 100%填充可用宽度。也可以使用 inline-grid，这样元素就会在行内流动，且宽度只能够包含子元素，不过 inline-grid 的使用频率不高。</p>
<p>网格容器中的两个属性：<code>grid-template-columns</code> 、 <code>grid-template-rows</code> 定义了网格每行每列的大小。其值也可以使用了一种新单位 fr
代表每一列（或每一行）的分数单位（ fraction unit）。这个单位跟 Flexbox 中 flex-grow 因子的表现一样，下列表示三列等宽：</p>
<pre><code class="language-css">grid-template-columns: 1fr 1fr 1fr;
</code></pre>
<h3 id="13-网格布局包含的几个概念"><a class="header" href="#13-网格布局包含的几个概念">1.3 网格布局包含的几个概念</a></h3>
<p>除了网格容器和网格元素外，网格布局还包括四个重要概念：</p>
<ul>
<li>网格线：<code>grid line</code> 水平与垂直的网格线构成了网格的整体结构，如果指定了 grid-gap 的话，它就位于网格线上。</li>
<li>网格轨道： <code>grid track</code> 是两条相邻网格线之间的空间。网格有水平轨道（行）和垂直轨道（列）。</li>
<li>网格单元： <code>grid cell</code> 是网格上的单个空间，水平和垂直的网格轨道交叉重叠的部分。</li>
<li>网格区域： <code>grid area</code> 是网格上的矩形区域，由一个到多个网格单元组成。</li>
</ul>
<p>构建网格布局时会涉及这些组成部分。比如声明 grid-template-columns: 1fr 1fr 1fr 就会定义三个等宽且垂直的网格轨道，同时还定义了四条垂直的网格线：一条在网格最左边，两条在每个网格轨道之间，还有一条在最右边。</p>
<h3 id="14-网格拆分一个网页"><a class="header" href="#14-网格拆分一个网页">1.4 网格拆分一个网页</a></h3>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/grid-02.png" alt="grid" /></p>
<p>拆分代码示例：</p>
<pre><code class="language-css">/* 页面中的整个父容器 */
.container {
  display: grid;
  grid-template-columns: 2fr 1fr;
  grid-template-rows: repeat(4, auto);
  grid-gap: 1.5em;
  max-width: 1080px;
  margin: 0 auto;
}

/* 从1号垂直网格线跨越到 3 号垂直网格线 */
header,
nav {
  grid-column: 1 / 3;
  grid-row: span 1;
}

.main {
  /* 从1号垂直网格线跨越到 2 号垂直网格线 */
  grid-column: 1 / 2;
  grid-row: 3 / 5;
}

/* 从2号垂直网格线跨越到 3 号垂直网格线 */
.sidebar-top {
  grid-column: 2 / 3;
  grid-row: 3 / 4;
}

/* 从2号垂直网格线跨越到 3 号垂直网格线 */
.sidebar-bottom {
  grid-column: 2 / 3;
  grid-row: 4 / 5;
}
</code></pre>
<p>代码首先设置了网格容器，并用 grid-template-columns 和 grid-template-rows 定义了网格轨道。因为列的分数单位分别是 2fr 和 1fr，所以第一列的宽度是第二列的两倍。定义行的时候用到了一个新方法： repeat()函数。它在声明多个网格轨道的时候提供了简写方式。</p>
<p>grid-template-rows: repeat(4, auto);定义了四个水平网格轨道，高度为 auto，这等价于 grid-template-rows: auto auto auto auto。轨道大小设置为 auto，轨道会根据自身内容扩展。</p>
<p>用 repeat()符号还可以定义不同的重复模式，比如 repeat(3, 2fr 1fr)会重复三遍这个模式，从而定义六个网格轨道，重复的结果是 2fr 1fr 2fr 1fr 2fr 1fr。</p>
<p>grid-column 可以让网格元素占满网格的宽度，其实还可以用一个特别的关键字 span 来指定 grid-row 和 grid-column 的值（这里用在了 grid-row 上）。这个关键字告诉浏览器元素需要占据一个网格轨道。因为这里没有指出具体是哪一行，所以会根据网格元素的布局算法（ placement algorithm） 自动将其放到合适的位置。布局算法会将元素放，在网格上可以容纳该元素的第一处可用空间，如本例第一行和第二行。</p>
<h2 id="二-网格与-flex-配合"><a class="header" href="#二-网格与-flex-配合">二 网格与 flex 配合</a></h2>
<p>网格与 flex 是互补的，并不冲突：</p>
<ul>
<li>Flexbox 本质上是一维的，而网格是二维的，所以它很适合用在相似的元素组成的行（或列）上。虽然可以 flex-wrap 换行，但是没法让上一行元素跟下一行元素对齐。</li>
<li>Flexbox 是以内容为切入点由内向外工作的，而网格是以布局为切入点从外向内工作的</li>
</ul>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/grid-03.svg" alt="" /></p>
<p>1.4 示例的拆分中，顶部的导航链接由于是水瓶对齐，所以可以在网格布局基础上，使用 flex：</p>
<pre><code class="language-css">.site-nav {
  display: flex;
  margin: 0;
  padding: 0.5em;
  background-color: #5f4b44;
  list-style-type: none;
  border-radius: 0.2em;
}
.site-nav &gt; li {
  margin-top: 0;
}
.site-nav &gt; li &gt; a {
  display: block;
  padding: 0.5em 1em;
  background-color: #cc6b5a;
  color: white;
  text-decoration: none;
}
.site-nav &gt; li + li {
  margin-left: 1.5em;
}
.site-nav &gt; .nav-right {
  margin-left: auto;
}
</code></pre>
<p>总结：</p>
<pre><code class="language-txt">当设计要求元素在两个维度上都对齐时，使用网格；
当只关心一维的元素排列时，使用Flexbox。

在实践中，这通常意味着：
网格更适合用于整体的网页布局；
Flexbox 更适合对网格区域内的特定元素布局。
</code></pre>
<h2 id="三-网格命名"><a class="header" href="#三-网格命名">三 网格命名</a></h2>
<h3 id="31-网格线命名编号"><a class="header" href="#31-网格线命名编号">3.1 网格线命名编号</a></h3>
<p>有时候记录所有网格线的编号实在太麻烦了，尤其是在处理很多网格轨道时。为了能简单点，可以给网格线命名，并在布局时使用网格线的名称而不是编号。声明网格轨道时，可以在中括号内写上网格线的名称，如下代码片段所示。</p>
<pre><code class="language-css">grid-template-columns: [start] 2fr [center] 1fr [end];
</code></pre>
<p>这条声明定义了两列的网格，三条垂直的网格线分别叫作 start、 center 和 end。之后定义网格元素在网格中的位置时，可以不用编号而是用这些名称来声明：</p>
<pre><code class="language-css">grid-column: start / center;
</code></pre>
<p>这条声明将网格元素放在 1 号网格线（ start）到 2 号网格线（ center）之间的区域。还可以给同一个网格线提供多个名称，比如下面的声明（为了可读性，这里将代码换行了）：</p>
<pre><code class="language-css">grid-template-columns:
  [left-start] 2fr
  [left-end right-start] 1fr
  [right-end];
</code></pre>
<p>示例：</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-columns:
    [left-start] 2fr
    [left-end right-start] 1fr
    [right-end];
  grid-template-rows: repeat(4, [row] auto);
  grid-gap: 1.5em;
  max-width: 1080px;
  margin: 0 auto;
}
header,
nav {
  grid-column: left-start / right-end;
  grid-row: span 1;
}
.main {
  grid-column: left;
  grid-row: row 3 / span 2;
}
.sidebar-top {
  grid-column: right;
  grid-row: 3 / 4;
}
.sidebar-bottom {
  grid-column: right;
  grid-row: 4 / 5;
}
</code></pre>
<h3 id="32-网格区域命名"><a class="header" href="#32-网格区域命名">3.2 网格区域命名</a></h3>
<p>网格容器的 grid-template 属性和网格元素的 grid-area 属性支持下，可以不用计算或者命名网格线，直接用命名的网格区域将元素定位
到网格中。</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-areas:
    'title title'
    'nav nav'
    'main aside1'
    'main aside2';
  grid-template-columns: 2fr 1fr;
  grid-template-rows: repeat(4, auto);
  grid-gap: 1.5em;
  max-width: 1080px;
  margin: 0 auto;
}
header {
  grid-area: title;
}
nav {
  grid-area: nav;
}
.main {
  grid-area: main;
}
.sidebar-top {
  grid-area: aside1;
}
.sidebar-bottom {
  grid-area: aside2;
}
</code></pre>
<p>每个命名的网格区域必须组成一个矩形。不能创造更复杂的形状，比如 L 或者 U 型。还可以用句点（ .）作为名称，这样便能空出一个网格单元。比如，以下代码定义了四个网格区域，中间围绕着一个空的网格单元。</p>
<pre><code class="language-css">grid-template-areas:
  'top top right'
  'left . right'
  'left bottom bottom';
</code></pre>
<h2 id="四-显式网格与隐式网格"><a class="header" href="#四-显式网格与隐式网格">四 显式网格与隐式网格</a></h2>
<h3 id="41-隐式网格使用场景"><a class="header" href="#41-隐式网格使用场景">4.1 隐式网格使用场景</a></h3>
<p>在某些场景下，你可能不清楚该把元素放在网格的哪个位置上。如：当处理大量的网格元素时，挨个指定元素的位置未免太不方便。当元素是从数据库获取时，元素的个数可能是未知的。在这些情况下，以一种宽松的方式定义网格可能更合理，剩下的交给布局算法来放置网格元素。</p>
<p>这时需要用到隐式网格（ implicit grid）。使用 <code>grid-template-*</code> 属性定义网格轨道时，创建的是显式网格（ explicit grid），但是有些网格元素仍然可以放在显式轨道外面，此时会自动创建隐式轨道以扩展网格，从而包含这些元素。</p>
<p>隐式网格轨道默认大小为 auto，也就是它们会扩展到能容纳网格元素内容。可以给网格容器设置 grid-auto-columns 和 grid-auto-rows，为隐式网格轨道指定一个大小。</p>
<p>贴士：在指定网格线的时候，隐式网格轨道不会改变负数的含义。负的网格线编号仍然是从显式网格的右下开始的。</p>
<h3 id="42-照片墙示例"><a class="header" href="#42-照片墙示例">4.2 照片墙示例</a></h3>
<p>照片墙示例：在这个布局中，将设置列的网格轨道，但是网格行是隐式创建的。这样网页不必关心照片的数量，它能适应任意数量的网格元素。只要照片需要换行显示，就会隐式创建新的一行。（flex 和浮动很难实现）</p>
<pre><code class="language-html">&lt;div class=&quot;portfolio&quot;&gt;
  &lt;!-- 每个&lt;figure&gt;都是一个网格元素：将图片和标题封装在其中 --&gt;
  &lt;!-- featured 类让某些图片更大 --&gt;
  &lt;figure class=&quot;featured&quot;&gt;
    &lt;img src=&quot;images/monkey.jpg&quot; alt=&quot;monkey&quot; /&gt;
    &lt;figcaption&gt;Monkey&lt;/figcaption&gt;
  &lt;/figure&gt;
  &lt;figure&gt;
    &lt;img src=&quot;images/eagle.jpg&quot; alt=&quot;eagle&quot; /&gt;
    &lt;figcaption&gt;Eagle&lt;/figcaption&gt;
  &lt;/figure&gt;
  &lt;figure class=&quot;featured&quot;&gt;
    &lt;img src=&quot;images/bird.jpg&quot; alt=&quot;bird&quot; /&gt;
    &lt;figcaption&gt;Bird&lt;/figcaption&gt;
  &lt;/figure&gt;
  &lt;figure&gt;
    &lt;img src=&quot;images/bear.jpg&quot; alt=&quot;bear&quot; /&gt;
    &lt;figcaption&gt;Bear&lt;/figcaption&gt;
  &lt;/figure&gt;
  &lt;figure class=&quot;featured&quot;&gt;
    &lt;img src=&quot;images/swan.jpg&quot; alt=&quot;swan&quot; /&gt;
    &lt;figcaption&gt;Swan&lt;/figcaption&gt;
  &lt;/figure&gt;
  &lt;figure&gt;
    &lt;img src=&quot;images/elephants.jpg&quot; alt=&quot;elephants&quot; /&gt;
    &lt;figcaption&gt;Elephants&lt;/figcaption&gt;
  &lt;/figure&gt;
  &lt;figure&gt;
    &lt;img src=&quot;images/owl.jpg&quot; alt=&quot;owl&quot; /&gt;
    &lt;figcaption&gt;Owl&lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;
</code></pre>
<p>css：</p>
<pre><code class="language-css">body {
  background-color: #709b90;
  font-family: Helvetica, Arial, sans-serif;
}
.portfolio {
  display: grid;
  /* 将最小列宽设置为 200px，自动填充网格 */
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  /* 将隐式水平网格轨道的大小设置为 1fr */
  grid-auto-rows: 1fr;
  grid-gap: 1em;
}

.portfolio &gt; figure {
  /* 覆盖浏览器默认的外边距 */
  margin: 0;
}
.portfolio img {
  max-width: 100%;
}
.portfolio figcaption {
  padding: 0.3em 0.8em;
  background-color: rgba(0, 0, 0, 0.5);
  color: #fff;
  text-align: right;
}
</code></pre>
<p>有时候我们不想给一个网格轨道设置固定尺寸，但是又希望限制它的最小值和最大值。这时候需要用到 minmax()函数。它指定两个值：最小尺寸和最大尺寸。浏览器会确保网格轨道的大小介于这两者之间。（如果最大尺寸小于最小尺寸，最大尺寸就会被忽略。）通过指定 <code>minmax(200px, 1fr)</code>，浏览器确保了所有的轨道至少宽 200px。repeat()函数里的 auto-fill 关键字是一个特殊值。设置了之后，只要网格放得下，浏览器就会尽可能多地生成轨道，并且不会跟指定大小（ minmax()值）的限制产生冲突。</p>
<p>auto-fill 和 minmax(200px, 1fr)加在一起，就会让网格在可用的空间内尽可能多地产生网格列，并且每个列的宽度不会小于 200px。因为所有轨道的大小上限都为 1fr（最大值），所以所有的网格轨道都等宽。</p>
<p>在上述示例中，视口能容纳四个 200px 宽的列，因此一行有四个网格轨道。如果屏幕变宽，就能放下更多轨道。如果屏幕变窄，产生的轨道数也会变少。如果网格元素不够填满所有网格轨道， auto-fill 就会导致一些空的网格轨道。如果不希望出现空的网格轨道，可以使用 auto-fit 关键字代替 auto-fill。它会让非空的网格轨道扩展，填满可用空间。</p>
<p>具体选择 auto-fill 还是 auto-fit 取决于你是想要确保网格轨道的大小，还是希望整个网格容器都被填满。一般推荐 auto-fit。</p>
<h3 id="43-添加变化"><a class="header" href="#43-添加变化">4.3 添加变化</a></h3>
<p>如何让特定图片变大？</p>
<p>现在每个网格元素都占据了 1×1 的区域，将特定图片的尺寸增加到 2×2 的网格区域。可以用 featured 类选择这些元素，让它们在水平和垂直方向上都占据两个网格轨道。</p>
<p>由于元素按顺序排列，增加某些网格元素的大小会导致网格中出现空白区域，因为空间容不下，就会下降到下一个网格轨道。</p>
<p>当不指定网格上元素的位置时，元素会按照其布局算法自动放置。默认情况下，布局算法会按元素在标记中的顺序将其逐列逐行摆放。当一个元素无法在某一行容纳（也就是说该元素占据了太多网格轨道）时，算法会将它移动到下一行，寻找足够大的空间容纳它。</p>
<p>网格布局模块规范提供了另一个属性 grid-auto-flow，它可以控制布局算法的行为。它的初始值是 row，上一段描述的就是这个值的行为。如果值为 column，它就会将元素优先放在网格列中，只有当一列填满了，才会移动到下一行。</p>
<p>还可以额外加一个关键字 dense（比如， grid-auto-flow: column dense）。它让算法紧凑地填满网格里的空白，尽管这会改变某些网格元素的顺序。加上这个关键字，小元素就会“回填”大元素造成的空白区域。</p>
<pre><code class="language-css">.portfolio {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  grid-auto-rows: 1fr;
  grid-gap: 1em;
  /* 开启紧凑的网格布局算法 */
  grid-auto-flow: dense;
}
.portfolio .featured {
  grid-row: span 2;
  grid-column: span 2;
}
</code></pre>
<p>这段代码使用了 grid-auto-flow: dense，等价于 grid-auto-flow: row dense。（前面的写法里隐含了 row，因为初始值就是 row。）然后选择特定的图片，将其设置为在水平和垂直方向上各占据两个网格轨道。注意，本例只用了 span 关键字，没有明确地将任何一个网格元素放到某个网格轨道上。</p>
<p>在你的屏幕上看到的效果可能跟示例不完全一致，这取决于视口的大小。因为这里用 auto-fill 决定垂直的网格轨道的数量，所以大屏幕可以容纳更多的轨道，小屏幕则容纳得较少。我截图的时候视口宽度是 1000px，有四个网格轨道。调整浏览器宽度到不同的大小，看看网格自动生成多少轨道来填充可用空间。</p>
<p>需要注意的是，紧凑的 auto-flow 方式会导致元素出现的顺序跟 HTML 里不一致。当使用键盘（ Tab 键）或者使用以源码顺序而非以显示顺序为准的屏幕阅读器来浏览网页时，用户可能会感到困惑。</p>
<h3 id="44-让网格元素填满网格轨道"><a class="header" href="#44-让网格元素填满网格轨道">4.4 让网格元素填满网格轨道</a></h3>
<p>较大的图片没有完全填满网格单元，在图片下面留了一片小小的空白。理想情况下，每个元素的顶部和底部都应该跟同一网格轨道上的元素对齐。</p>
<p>默认情况下，每个网格元素都会扩展并填满整个网格区域，但是子元素不会，因此网格区域出现了多余的高度。一个简单的解决办法是用 Flexbox。在代码清单 6-11 里，设置每个 <code>&lt;figure&gt;</code>为弹性容器，方向为 column，元素会从上到下垂直排列。然后给图片标签加上 flex-grow，强制拉伸图片填充空白区域。</p>
<p>但是拉伸图片并不可取，因为这会改变图片的宽高比，导致图片变形。好在 CSS 为控制这一行为提供了一个特殊属性 object-fit。默认情况下，一个<code>&lt;img&gt;</code>的 object-fit 属性值为 fill，也就是说整个图片会缩放，以填满<code>&lt;img&gt;</code>元素。你也可以设置其他值改变默认行为。比如， object-fit 属性的值还可以是 cover 和 contain（如图 6-17 所示）。这些值告诉浏览器，在渲染盒子里改变图片的大小，但是不要让图片变形。</p>
<ul>
<li>cover：扩展图片，让它填满盒子（导致图片一部分被裁剪）。</li>
<li>contain：缩放图片，让它完整地填充盒子（导致盒子里出现空白）</li>
</ul>
<p>这里有两个概念要区分清楚：盒子（由<code>&lt;img&gt;</code>元素的宽和高决定）和渲染的图片。默认情况下，这二者大小相等。 object-fit 属性让我们能在盒子内部控制渲染图片的大小，同时保持盒子的大小不变。</p>
<p>因为用 flex-grow 属性拉伸了图片，所以应该给它加上 object-fit: cover 防止渲染的图片变形。作为妥协，图片的边缘会被裁掉一部分</p>
<pre><code class="language-css">/* 让每个网格元素都成为垂直的 Flexbox */
.portfolio &gt; figure {
  display: flex;
  flex-direction: column;
  margin: 0;
}
.portfolio img {
  /* 用弹性拉伸，让图片填充弹性容器的可用空间 */
  flex: 1;
  /* 让渲染的图片填充盒子并且不被拉伸（而是裁掉边缘） */
  object-fit: cover;
  max-width: 100%;
}
</code></pre>
<h2 id="五-网格常用属性"><a class="header" href="#五-网格常用属性">五 网格常用属性</a></h2>
<h3 id="51-子项小于单元格时的定义元素对齐方式"><a class="header" href="#51-子项小于单元格时的定义元素对齐方式">5.1 子项小于单元格时的定义元素对齐方式</a></h3>
<p>子项的设定的 columns、row 小于容器时：</p>
<pre><code class="language-css">/* 子项在自己的单元格内水平方向对齐方式 */
justify-items: center;
/* 垂直方向 */
align-items: start;

/* 这 2 个属性可以复合简写为 */
palce-items: start center;
</code></pre>
<p>示例：</p>
<pre><code class="language-html">&lt;!--容器宽300px，3个单元格宽均为100px--&gt;
&lt;style&gt;
  .box {
    width: 300px;
    height: 300px;
    background-color: skyblue;
    display: grid;
    grid-template-columns: 100px 100px 100px;
    grid-template-rows: 100px 100px 100px;
    justify-items: center;
  }
  .box div {
    width: 50px;
    height: 50px;
    background-color: yellowgreen;
  }
&lt;/style&gt;

&lt;div class=&quot;box&quot;&gt;
  &lt;div&gt;1&lt;/div&gt;
  &lt;div&gt;2&lt;/div&gt;
  &lt;div&gt;3&lt;/div&gt;
  &lt;div&gt;1&lt;/div&gt;
  &lt;div&gt;2&lt;/div&gt;
  &lt;div&gt;3&lt;/div&gt;
  &lt;div&gt;1&lt;/div&gt;
  &lt;div&gt;2&lt;/div&gt;
  &lt;div&gt;3&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>子项的设定的 columns、row 大于容器时使用：</p>
<pre><code class="language-css">align-content: end;
justify-content: space-evenly;

/* 这 2 个属性可以复合简写为 */
palce-content: end space-evenly;
</code></pre>
<p>示例：</p>
<pre><code class="language-html">&lt;style&gt;
  .box {
    width: 500px;
    height: 500px;
    background-color: skyblue;
    display: grid;
    grid-template-columns: 100px 100px 100px;
    grid-template-rows: 100px 100px 100px;
    justify-content: center;
  }
  .box div {
    width: 50px;
    height: 50px;
    background-color: yellowgreen;
  }
&lt;/style&gt;

&lt;div class=&quot;box&quot;&gt;
  &lt;div&gt;1&lt;/div&gt;
  &lt;div&gt;2&lt;/div&gt;
  &lt;div&gt;3&lt;/div&gt;
  &lt;div&gt;1&lt;/div&gt;
  &lt;div&gt;2&lt;/div&gt;
  &lt;div&gt;3&lt;/div&gt;
  &lt;div&gt;1&lt;/div&gt;
  &lt;div&gt;2&lt;/div&gt;
  &lt;div&gt;3&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="52-设置间隙"><a class="header" href="#52-设置间隙">5.2 设置间隙</a></h3>
<pre><code class="language-css">/* 行间距 */
grid-row-gap: 20px;
/* 列间隙 */
grid-column-gap: 10px;

/* 简写 */
grid-gap: 20px 10px;
</code></pre>
<p>贴士：这里推荐使用 <code>row-gap</code>、<code>colunm-gap</code>、<code>gap</code>，因为弹性布局也可以使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="051-移动-web-移动-web-问题"><a class="header" href="#051-移动-web-移动-web-问题">05.1-移动 Web-移动 Web 问题</a></h1>
<h2 id="一-单位问题"><a class="header" href="#一-单位问题">一 单位问题</a></h2>
<h3 id="11-常见单位"><a class="header" href="#11-常见单位">1.1 常见单位</a></h3>
<p>长度单位可以分为：</p>
<ul>
<li>绝对长度单位：px(像素)</li>
<li>相对长度单位：em、rem</li>
</ul>
<p>像素单位（px）是绝对单位，即 5px 放在哪里都一样大。CSS 支持几种绝对长度单位，最常用、最基础的是像素 px。像素是一个具有误导性的名称， CSS 像素并不严格等于显示器的像素，尤其在高清屏（视网膜屏）下。尽管 CSS 单位会根据浏览器、操作系统或者硬件适当缩放，在某些设备或者用户的分辨率设置下也会发生变化，但是 96px 通常等于一个物理英寸的大小。</p>
<p>相对单位，如 em 和 rem，其值会根据外部因素发生变化，比如， 2em 的具体值会根据它作用到的元素（有时甚至是根据属性）而变化。</p>
<h3 id="12-反模式"><a class="header" href="#12-反模式">1.2 反模式</a></h3>
<p>将网页根元素的字号设置为 0.625em 或者 62.5%是一种反模式，如下所示：</p>
<pre><code class="language-css">html {
  font-size: 0.625em;
}
</code></pre>
<p>将浏览器的默认字号 16px 缩小为 10px。这的确能简化计算：如果设计师希望字号为 14px，那么只需要默默在心里除以 10，写上 1.4rem 就可以了，而且还使
用了相对单位。</p>
<p>一开始，这会很方便，但是开发者会被迫写很多重复的代码，比如：10px 对大部分文字来说太小了，所以需要覆盖它，最后就需要给段落、导航、侧边栏都再设置一次 1.4rem，以后需要改动时改动的地方很多。而且这种做法仍然是一种“像素思维”，表面上是在使用 rem，其实计算的结果仍然是 px 为导向。</p>
<h3 id="13-设置合理的默认字号"><a class="header" href="#13-设置合理的默认字号">1.3 设置合理的默认字号</a></h3>
<p>如果希望默认字号是 14px，就不能将默认字体设置为 10px 后再覆盖一遍，而是直接将根元素字号设置为想要的值，将想要的值除以继承值（在这种情况下为浏览器默认值）是
14/16，等于 0.875，最后可以根据屏幕尺寸，用媒体查询改变根元素的字号。这样就能够基于不同用户的屏幕尺寸，渲染出不同大小的面板：</p>
<pre><code class="language-html">&lt;style&gt;
  :root {
    font-size: 0.75em;
  }
  @media (min-width: 800px) {
    :root {
      font-size: 0.875em;
    }
  }
  @media (min-width: 1200px) {
    :root {
      font-size: 1em;
    }
  }
  .panel {
    padding: 1em;
  }
  .panel &gt; h2 {
    margin-top: 0;
    font-size: 0.8rem;
    font-weight: bold;
    text-transform: uppercase;
  }
  .panel &gt; .small {
    border: 1px solid #999;
    border-radius: 0.5em;
  }
&lt;/style&gt;

&lt;div class=&quot;panel&quot;&gt;
  &lt;h2&gt;Single-origin&lt;/h2&gt;
  &lt;div class=&quot;small&quot;&gt;small...&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>如果需要让同一个组件在页面的某些部分显示不同的大小，可以用 em 来单独缩放一个组件，如面板加上一个 large 类： <code>&lt;div class=&quot;panel large&quot;&gt;</code>：</p>
<pre><code class="language-html">&lt;style&gt;
  :root {
    font-size: 0.75em;
  }
  @media (min-width: 800px) {
    :root {
      font-size: 0.875em;
    }
  }
  @media (min-width: 1200px) {
    :root {
      font-size: 1em;
    }
  }
  .panel {
    /* 给组件设置一个可预测的字号*/
    font-size: 1rem;
    padding: 1em;
  }
  .panel &gt; h2 {
    margin-top: 0;
    font-size: 0.8rem;
    font-weight: bold;
    text-transform: uppercase;
  }
  .panel &gt; .small {
    border: 1px solid #999;
    border-radius: 0.5em;
  }
  .panel &gt; .large {
    border: 1px solid #999;
    border-radius: 0.5em;
    font-size: 1.2rem;
  }
&lt;/style&gt;

&lt;div class=&quot;panel&quot;&gt;
  &lt;h2&gt;Single-origin&lt;/h2&gt;
  &lt;div class=&quot;small&quot;&gt;small...&lt;/div&gt;
  &lt;div class=&quot;large&quot;&gt;large...&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="二-分辨率与-retina"><a class="header" href="#二-分辨率与-retina">二 分辨率与 Retina</a></h2>
<h3 id="21-分辨率"><a class="header" href="#21-分辨率">2.1 分辨率</a></h3>
<p>移动设备与 PC 设备的最大差异在于屏幕的大小，包含两个关键因素：</p>
<ul>
<li>屏幕尺寸：屏幕对角线的长度，一般使用英寸来度量</li>
<li>屏幕分辨率：屏幕水平和垂直方向的像素数，一般使用 px 来度量</li>
</ul>
<p>手机屏幕大小如 4.7、5.0、6.0 这些其实是其对角线的长度，单位一般是英寸：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/moblie-01.png" alt="屏幕大小" /></p>
<p>屏幕分辨率即屏幕纵向、横向上的像素点数，单位是 px，一般使用 <code>宽 x 高</code> 的方式表示，如：分辨率 <code>320x480</code> 表示水平方向 320 个像素，垂直方向 480 个像素。</p>
<p>英寸是一个绝对长度的单位，但是像素却是一个相对长度单位，如：iPhone3G/S 和 iPhone4/S 的屏幕尺寸都是 3.5 英寸 (in)，但是其分辨率却分别为 <code>330x480</code>、<code>640x960</code>，所以像素其实是一个相对长度单位。</p>
<h3 id="22-设备的像素"><a class="header" href="#22-设备的像素">2.2 设备的像素</a></h3>
<p>对于物理设备来说，有两个设备像素：</p>
<ul>
<li><strong>物理像素</strong>：指物理分辨率，即设备屏幕实际拥有的像素点，比如 iPhone6 的像素是：<code>750x1334</code>，其实就是其在高度上有 1334 个像素点，在宽度上有 750 个像素点，其总共拥有的像素点是：<code>1334*750</code>。</li>
<li><strong>设备独立像素</strong>：指逻辑分辨率，即当前设备能容纳的 CSS 像素。如：手机在 300-400 之间，10 寸平板在 700-800 之间，13 寸笔记本长边是 1280。Chrome 上的模拟器大小即是独立像素。如：iPhone5 的 CSS 像素是 320*568，在竖屏时，如果一个 div 的宽度是 320px，那么正好是屏幕的 100%宽度。</li>
</ul>
<p>像素密度 PPI 用来表示设备每英寸所拥有的物理像素数，数值越高，屏幕越清晰，但是 PPI 超过一定数值时，人的肉眼就无法分辨其中的单独像素了。苹果定义：电脑 PPI 高于 200，平板 PPI 高于 260，移动设备 PPI 高于 300 的屏幕为 Retina 屏。</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/pix-01.svg" alt="" /></p>
<p>设备独立像素和物理像素往往是成比例的。当像素比为 1：1 时，1 个物理像素就用来显示 1 个设备独立像素，当像素比为 2：1 时，就需要使用 4 个物理像素显示 1 个设备独立像素（长 2 倍，宽 2 倍，即 2 倍屏）。像素比并不能决定屏幕的清晰度，PPI 才是核定屏幕清晰的最好评判方式（大于 320 即高清），不过<strong>人眼能够识别的 dpr 最大是 2！</strong>。</p>
<p>像素比获取方式：</p>
<pre><code class="language-txt">// js 获取
window.devicePixelRatio
// css 获取
device-pixel-ratio
min-device-pixel-ratio
max-device-pixel-ratio
</code></pre>
<p>通过上述方式结果媒体查询可以对不同像素比的设备进行适配。在 PC 端，一般 1px 就代表 1 个物理像素，但是在移动端，二者有可能不相等，而是按照一定的比例进行显式。CSS 中 1px 并不等于设备的 1px，因为在 Retina 屏中，分辨率提高了一倍，但是屏幕尺寸未发生变化，即同样大小的屏幕下，Retina 屏像素多了一倍，这时，1 个 CSS 像素即是 4 个物理像素。</p>
<p><strong>开发中，iphone678 设计稿的常见宽度为 750px，4.7~5 寸的安卓设备为 720px，一般均以 750px 为常见 CSS 像素宽度。</strong>。</p>
<h2 id="三-视口"><a class="header" href="#三-视口">三 视口</a></h2>
<h3 id="31-布局视口"><a class="header" href="#31-布局视口">3.1 布局视口</a></h3>
<p>PC 端的页面直接放置在手机端显示，由于页面过大无法显示全，就会出现滚动条，为了解决该问题，引入了<strong>视口</strong>。视口其实就是浏览器窗口里网页可见部分的边框区域。它不包括浏览器的地址栏、工具栏、状态栏。</p>
<blockquote>
<p>视口：viewport，即浏览器 显示页面内容的<strong>屏幕区域</strong>，默认为 980px
获取方式： document.documentElement.clientWidth document.documentElement.clientHeight</p>
</blockquote>
<p>默认情况下，为了在移动设备上正常显示 PC 端针对浏览器设计的页面，移动浏览器会把自己默认的 view-port 设为 980px，就可以将网页内的所有内容全部显示在手机上了，但是手机的屏幕真实大小毕竟远小于网页实际大小，那么就会造成页面中的文字等元素看起来变小了，需要手动放大才能显示完全，这样的用户体验就会变得很糟糕。</p>
<p>视口示意图：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/viewport-01.svg" alt="视口" /></p>
<p>一般把上面这个默认视口称为布局视口，此外还有：</p>
<ul>
<li><strong>布局视口</strong>（layout viewport）</li>
<li><strong>视觉视口</strong>(visual viewport)</li>
<li><strong>理想视口</strong>(ideal viewport)</li>
</ul>
<h3 id="32-视觉视口"><a class="header" href="#32-视觉视口">3.2 视觉视口</a></h3>
<p><strong>视觉视口</strong>(visual viewport)：用户在手机端能看到的页面区域，它相当于在计算自身的 1 像素可以显示多少像素的页面内容，因此视觉视口会随着用户的缩放而变化。</p>
<p>视觉视口获取方式：</p>
<pre><code class="language-js">window.innerWidth
window.innerHeight
</code></pre>
<h3 id="33-理想视口"><a class="header" href="#33-理想视口">3.3 理想视口</a></h3>
<p><strong>理想视口</strong>(ideal viewport)：如果能够在视觉视口内显示一个完整的页面，又不会像布局视口那样大需要手指捏着屏幕看，这便是理想视口。简单来说：设备有多宽，布局视口就有多宽！</p>
<p>在代码上，理想视口所做的页面不再是默认 980px，而是与设备的视口宽度相同，需要手动进行设置：</p>
<pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
</code></pre>
<p>content 常见属性：</p>
<pre><code class="language-txt">width：视口宽度，如果不加则默认按照 980px 显示，页面元素就会变得很小，一般设置为 device-width，即理想视口
user-scalable：是否允许用户缩放，默认为 no
initial-scale：最初的缩放比例，比如值为 2，则页面一打开，缩放为默认大小的 2 倍显示，一般为 1
maximum-scale：最大允许缩放比例，一般为 1.0
minimum-scale：最小允许缩放比例，一般为 1.0
</code></pre>
<h3 id="35-视口的相对单位"><a class="header" href="#35-视口的相对单位">3.5 视口的相对单位</a></h3>
<p>视口的相对单位有：</p>
<ul>
<li>vh：视口高度的 1/100。</li>
<li>vw：视口宽度的 1/100。</li>
<li>vmin：视口宽、高中较小的一方的 1/100（ IE9 中叫 vm，而不是 vmin）。</li>
<li>vmax：视口宽、高中较大的一方的 1/100（本书写作时 IE 和 Edge 均不支持 vmax）</li>
</ul>
<p>示例：50vw 等于视口宽度的一半， 25vh 等于视口高度的 25%。 vmin 取决于宽和高中较小的一方，这可以保证元素在屏幕方向变化时适应屏幕。在横屏时， vmin 取决于高度；在竖屏时，则取决于宽度。当一个元素的宽和高为 固定 vmin 时，不管视口的大小或者方向是什么，总会显示成一个稍小于视口的正方形</p>
<p>视口相对长度非常适合展示一个填满屏幕的大图。我们可以将图片放在一个很长的容器里，然后设置图片的高度为 100vh，让它等于视口的高度。</p>
<p>vw 设置字号很实用，比如：font-size: 2vw 会发生什么？在一个 1200px 的桌面显示器上，计算值为 24px（ 1200 的 2%）。在一个 768px 宽的平板上，计算值约为 15px（ 768 的 2%）。 这样做的好处在于元素能够在这两种大小之间平滑地过渡，这意味着不会在某个断点突然改变。当视口大小改变时，元素会逐渐过渡.</p>
<p>但是 24px 在大屏上来说太大了。更糟糕的是，在 iPhone 6 上会缩小到只有 7.5px。如果能够保留这种缩放的能力，但是让极端情况缓和一些就更棒了。 CSS 的 calc()函数可以提供帮助。</p>
<p>用 calc()结合 em 和 vh 两种单位定义 font-size：</p>
<pre><code class="language-css">:root {
  font-size: calc(0.5em + 1vw);
}
</code></pre>
<p>现在打开网页，慢慢缩放浏览器，字体会平滑地缩放。 0.5em 保证了最小字号， 1vw 则确保了字体会随着视口缩放。这段代码保证基础字号从 iPhone 6 里的 11.75px 一直过渡到 1200px 的浏览器窗口里的 20px。可以按照自己的喜好调整这个值。</p>
<p>我们不用媒体查询就实现了大部分的响应式策略。省掉三四个硬编码的断点，网页上的内容也能根据视口流畅地缩放。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="052-移动-web-移动端布局方案"><a class="header" href="#052-移动-web-移动端布局方案">05.2-移动 Web-移动端布局方案</a></h1>
<h2 id="一-移动端开发方案"><a class="header" href="#一-移动端开发方案">一 移动端开发方案</a></h2>
<h3 id="11-常见开发方案"><a class="header" href="#11-常见开发方案">1.1 常见开发方案</a></h3>
<p>网页如果要在移动端通过浏览器、APP 内嵌页显示，则需要考虑移动端的适配问题。目前有两种选型方案：</p>
<ul>
<li><strong>独立页面</strong>：移动端页面与单独开发，与 PC 端页面脱离关系，是目前的主流方案，如 <code>m.jd.com</code>。</li>
<li><strong>响应式页面</strong>：PC 与移动端共用一个网页，根据屏幕宽度进行响应式适配，开发难度较大，适合一些小型订阅网站。</li>
</ul>
<h3 id="12-响应式布局"><a class="header" href="#12-响应式布局">1.2 响应式布局</a></h3>
<p>移动端浏览器内核一般为 webkit 内核，无论是单独制作页面，还是响应式页面，都可以较大范围的使用 C3 技术，所以像弹性布局、媒体查询等技术都可以使用，常见的移动端响应式布局往往依赖以下一种或者多种非暗杆实现：流式布局、rem、flex 布局、栅格布局等。</p>
<h3 id="13-响应式布局原理"><a class="header" href="#13-响应式布局原理">1.3 响应式布局原理</a></h3>
<p>响应式布局是指网页能够依据屏幕宽度自动做出相应的适配调整，以为不同的中断用户提供更友好的用户体验。响应式布局并不能完全说是一种页面的真实布局方式，而是针对不同设备提出的布局思路，即：同一个网页在不同设备上自动调整其界面布局方式。</p>
<p>响应式开发原理：首先制作一个父级元素作为布局的容器，在不同屏幕下，通过媒体查询改变这个布局容器的大小，再改变其子元素的排列方式和大小，从而实现对屏幕的适配。</p>
<p>常见的响应式尺寸划分：</p>
<ul>
<li>超小屏幕：宽度设置为 100%，一般是手机，小于 768px</li>
<li>小型屏幕：宽度设置为 750px，一般是平板，大于等于 768px</li>
<li>中等屏幕：宽度设置为 970px，一般是桌面显示器，大于等于 992px</li>
<li>大型屏幕：宽度设置为 1200px，一般是大桌面显示器，大于等于 1200px</li>
</ul>
<p>示例：</p>
<pre><code class="language-html">&lt;style&gt;
  * {
    margin: 0;
    padding: 0;
  }

  li {
    list-style: none;
  }

  #container {
    height: 150px;
    margin: 0 auto;
    background-color: paleturquoise;
  }
  @media screen and (max-width: 767px) {
    #container {
      width: 100%;
    }
  }
  @media screen and (min-width: 768px) {
    #container {
      width: 750px;
    }
  }
  @media screen and (min-width: 992px) {
    #container {
      width: 970px;
    }
  }
  @media screen and (min-width: 1200px) {
    #container {
      width: 1170px;
    }
  }

  #container ul li {
    width: 93.75px;
    height: 30px;
    float: left;
    background-color: palevioletred;
  }
&lt;/style&gt;

&lt;div id=&quot;container&quot;&gt;
  &lt;ul&gt;
    &lt;li&gt;菜单 1&lt;/li&gt;
    &lt;li&gt;菜单 2&lt;/li&gt;
    &lt;li&gt;菜单 3&lt;/li&gt;
    &lt;li&gt;菜单 4&lt;/li&gt;
    &lt;li&gt;菜单 5&lt;/li&gt;
    &lt;li&gt;菜单 6&lt;/li&gt;
    &lt;li&gt;菜单 7&lt;/li&gt;
    &lt;li&gt;菜单 8&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<h3 id="14-媒体查询语法"><a class="header" href="#14-媒体查询语法">1.4 媒体查询语法</a></h3>
<p>媒体查询（Media Query）是 CSS3 引入的新技术，可以针对不同的屏幕尺寸设置不同的样式，在重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面！示例：</p>
<pre><code class="language-css">/*
声明媒体查询：@media
参数一：mediatype，媒体类型，值有：
        all：用于所有设备
        print：用于打印机和打印预览
        screen：用于电脑、平板、手机等

参数二：用于连接参数 1 与参数二，为 and not only 等值
        and：可以将多个媒体特性连接到一起，即：且
        not：排除某个媒体类型，即：非，可以省略
        only：指定某个特性的特性，可以省略
参数三：media feature 特性，必须有小括号包含
        width: 可视区宽度
        min-width：可视区最小宽度
        max-width：可视区最大宽度
*/
@media screen and (max-width: 800px) {
  /* 在屏幕中，且设置最大宽度为 800px */
  body {
    background-color: pink;
  }
}

@media screen and (max-width: 500px) {
  body {
    background-color: green;
  }
}
</code></pre>
<p>贴士：推荐媒体查询写在底部，用于覆盖样式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="053-移动-web-rem-适配"><a class="header" href="#053-移动-web-rem-适配">05.3-移动 Web-rem 适配</a></h1>
<h2 id="一-rem-的使用"><a class="header" href="#一-rem-的使用">一 rem 的使用</a></h2>
<p>在不同的设备上，如果一个图形大小一样，页面就会出现拉伸效果，比例也会出现问题，解决办法其实是在大设备上等比放大、在小设备上等比缩小，PX 由于是绝对单位，即是一个实际的像素大小，要实现这种等比变化，就需要使用 JS 控制，比较麻烦。而 rem（root em）、em 都是相对大小，就可以实现这个要求：</p>
<ul>
<li>em：相对于当前元素的字体大小，比如当前元素字体为 10px，则当前元素的其他属性设置为 2em，其绝对值是 20px。当前元素没有设定字体大小，则相对于父级的字体大小。</li>
<li>rem：相对于 html 根元素字体大小（默认为 16px）。比如 html 设置了 <code>font-size=10px</code>，若某个非根元素设置 <code>width:2rem;</code> 换算为 px 就是 20px。</li>
</ul>
<p>em 的最大问题是在多级列表嵌套时，字体会被缩小：</p>
<pre><code class="language-html">&lt;style&gt;
  body {
    font-size: 16px;
  }
  ul {
    font-size: 0.8em;
  }
&lt;/style&gt;

&lt;body&gt;
  &lt;ul&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt;&lt;/li&gt;&lt;ul&gt;
&lt;/body&gt;
</code></pre>
<p>当使用 rem (root em)作为单位时，只要 html 元素中的字体大小发生改变，那么整体的布局就会相应发生改变，其适配的核心方案是随着屏幕的变化，字体发生相应变化，界面进行等比例缩放。从这里看出，与 em 相比，rem 降低了复杂性，而且结合了 px 和 em 的优点，既保留了相对单位的优势，又简单易用。</p>
<p>当然 rem 也不是万金油，一般会用 rem 设置字号，用 px 设置边框，用 em 设置其他大部分属性，尤其是内边距、外边距和圆角（不过我有时用百分比设置容器宽度）。这样字号是可预测的，同时还能在其他因素改变元素字号时，借助 em 缩放内外边距。用 px 定义边框也很好用，尤其是想要一个好看又精致的线时。这些是我在设置各种属性时常用的单位，但它们仅仅是工具，在某些情况下，用其他工具会更好。</p>
<p>贴士：拿不准的时候，用 rem 设置字号，用 px 设置边框，用 em 设置其他大部分属性。</p>
<p>rem 可以用来解决布局中一些大小问题，如：</p>
<ul>
<li>传统布局、flex 布局中，文字都不能随着屏幕大小变化而变化</li>
<li>流式布局和 flex 布局主要针对宽度进行布局，高度不能很好的定义</li>
<li>在屏幕发生变化时，元素的宽高不能很好的进行等比例缩放</li>
</ul>
<p>这里就涉及 html 标签的 font-size 大小动态设置问题：</p>
<pre><code class="language-txt">通常会将屏幕划分为 15 等份，根据需求也可以设置为 10 等份，20 等份，用页面元素大小除以不同的 html 字体大小，会发现其比例相同：

在设计稿为 750px 时，其 html 字体的大小为：750/15=50px
在设备中为 320px 时，其 html 字体的大小为：320/15=21.33px

现在假设有一个 100*100px 的页面元素：
在 750 屏幕下，html 字体大小为 50.00px，转换为 rem：100/50.00，即：2rem*2rem，宽高比例是 1 比 1
在 320 屏幕下，rem 值上面已经写好是 2*2，但是其字体是：21.33px，实际像素 2rem 即：42.66px * 42.66px，宽高比例没变！
</code></pre>
<p>由上得出：<strong><code>rem 值</code> = <code>页面元素 px</code> / <code>html 的 font-size</code></strong>。</p>
<p>贴士：如果不设置字体大小，1rem=16px</p>
<h2 id="二-rem-布局的方案"><a class="header" href="#二-rem-布局的方案">二 rem 布局的方案</a></h2>
<h3 id="21-rem-实现方式一js-控制"><a class="header" href="#21-rem-实现方式一js-控制">2.1 rem 实现方式一：js 控制</a></h3>
<p>现在的核心问题就是根据屏幕自动计算 rem 的值，下面的脚本可以实现自动改变字体大小。有了该脚本，只需要将设计稿（750px）量出的像素值除以 100 即可得到 rem 的值。这里要注意，html 根元素的字体大小改变会引起一个 bug：图片与文件间距会出现变化，可以为 body 设置固定大小即可：</p>
<pre><code class="language-html">&lt;style&gt;
  * {
    margin: 0;
    padding: 0;
  }
  body {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 16px;
  }

  .header {
    background: #ff5555;
    height: 0.82rem;
    width: 100%;
  }
&lt;/style&gt;

&lt;body&gt;
  &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;

  &lt;script&gt;
    ;(function (doc, win) {
      let docElement = doc.documentElement
      let resizeEvent =
        'orientationchange' in window ? 'orientationchange' : 'resize'

      let recalc = function () {
        let clientWidth = docElement.clientWidth
        if (!clientWidth) return

        // 设计稿基准为 750px
        if (clientWidth &gt;= 750) {
          docElement.style.fontSize = '100px'
        } else {
          docElement.style.fontSize = 100 * (clientWidth / 750) + 'px'
        }
      }

      if (!doc.addEventListener) return
      win.addEventListener(resizeEvent, recalc, false)
      doc.addEventListener('DOMContentLoaded', recalc, false)
    })(document, window)
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="22-rem-适配方式二媒体查询动态计算-font-size"><a class="header" href="#22-rem-适配方式二媒体查询动态计算-font-size">2.2 rem 适配方式二：媒体查询动态计算 font-size</a></h3>
<p>不同屏幕设备上，手动动态设置 html 标签 font-size 大小步骤：</p>
<pre><code class="language-txt">1）假设设计稿是 750px
2）假设屏幕被划分为 15 等份（也可以是 10，20）
3）每一份作为 html 字体大小，就是 50px
4）在 320px 设备上，字体大小就是 320/15=21.33px
5）以此类推，480px 设备，字体大小就是 480/15=32px

6）用页面元素大小除以不同的 html 字体大小，其比例相同，比如 750px 设计稿下：
  100*100 像素的页面，在 750px 屏幕下，就是 100/50，专为为 rem 是 2rem * 2rem 比例是 1 比 1
  320px 屏幕下，html 字体大小为 21.33，则 2rem=42.66px，此时宽高都是 42.66，比例仍然是 1 比 1

最后页面元素的 rem 值 = 页面元素的 px 值 / html 的 font-size 大小
</code></pre>
<p>常见需要配置的：</p>
<pre><code class="language-css">html {
  font-size: 50px;
}

@media screen and (min-width: 320px) {
  html {
    font-size: 21.3333px;
  }
}

@media screen and (min-width: 360px) {
  html {
    font-size: 24px;
  }
}

/* iphone678 */
@media screen and (min-width: 375px) {
  html {
    font-size: 25px;
  }
}

/* 其他需要设置的常见屏幕：384 400 414 424 480 540 720 750 */
</code></pre>
<p>当样式繁多时，使用媒体查询引入资源可以更好的实现移动端布局：</p>
<pre><code class="language-html">/* 针对不同的屏幕尺寸，引入不同的 css 资源 */
&lt;link
  rel=&quot;stylesheet&quot;
  href=&quot;./small.css&quot;
  media=&quot;screen and (min-width:320px)&quot;
/&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;./big.css&quot; media=&quot;screen and (min-width:640px)&quot; /&gt;
</code></pre>
<h3 id="23-rem-实现方式三vw-动态计算-font-size"><a class="header" href="#23-rem-实现方式三vw-动态计算-font-size">2.3 rem 实现方式三：vw 动态计算 font-size</a></h3>
<p>vw 方式 js 控制的方式更加简单，性能更高，无需对字体大小进行控制，但是只兼容 iOS8、Android4.4 以上系统。</p>
<p>vw 布局是将屏幕划分为 100 份，即屏幕是： <code>100vw * 100vh</code>（也即 vw 是 1% 的屏幕宽度）：</p>
<pre><code class="language-css">.box {
  width: 50vw;
  height: 50vh;
  background-color: yellowgreen;
}
</code></pre>
<p>换算到 750px 宽度的设计稿中就是 <code>750px=100vw</code>，即 1px 就是 <code>0.2666666667vw</code>。为了方便计算，font-size 取 100px：</p>
<pre><code class="language-html">&lt;style&gt;
  html {
    font-size: 26.66666667vw; /* iPhone6是375px宽，此时在iPhone6下换算得到100px */
  }

  /* 1rem就是一个font-size大小，此时在IP6下就是100px的宽高 */
  .box {
    width: 1rem;
    height: 1rem;
    background-color: yellowgreen;
  }
&lt;/style&gt;
</code></pre>
<p>由于 vw 布局是自己将屏幕等份划分，所以也就不再依赖与 JS 脚本、媒体查询来控制字体大小，开发更方便。但是由于 html 设置了文本大小，实际开发我们需要重设：</p>
<pre><code class="language-css">html {
  font-size: 26.66666667vw; /* iPhone6是375px宽，此时在iPhone6下换算得到100px */
}
body {
  font-size: 1rem; /*也即在iPhone6下是 16px*/
}
.box {
  width: 1rem;
  height: 1rem;
  background-color: yellowgreen;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="054-移动-web-流式布局"><a class="header" href="#054-移动-web-流式布局">05.4-移动 Web-流式布局</a></h1>
<h2 id="一-流式布局"><a class="header" href="#一-流式布局">一 流式布局</a></h2>
<h3 id="11-流式布局简介"><a class="header" href="#11-流式布局简介">1.1 流式布局简介</a></h3>
<p>流式布局即百分比布局，采用非固定像素的方式进行布局，是目前较为常见的移动 Web 布局方式。</p>
<p>流式布局现方案是：将盒子的宽度设置成百分比，依据屏幕的宽度进行自动伸缩，内容向两侧填充。</p>
<p>简单示例：</p>
<pre><code class="language-html">&lt;!--实现两个子盒子平均分割--&gt;
&lt;section&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;div&gt;&lt;/div&gt;
&lt;/section&gt;

&lt;style&gt;
  * {
    margin: 0;
    padding: 0;
  }

  section {
    width: 100%;
  }

  section div {
    float: left;
    width: 50%;
    height: 400px;
  }

  section div:nth-child(1) {
    background-color: cadetblue;
  }
  section div:nth-child(2) {
    background-color: chocolate;
  }
&lt;/style&gt;
</code></pre>
<h3 id="12-body-设置"><a class="header" href="#12-body-设置">1.2 body 设置</a></h3>
<p>如果要实现整个页面在移动端的百分比适配，可以对 body 进行设置，即控制页面伸缩的最大比例，防止无限制放大、缩小造成的影响：</p>
<pre><code class="language-css">body {
  margin: 0 auto;
  width: 100%;
  /* 在合理的范围内 100% 宽度 */
  min-width: 320px;
  max-width: 640px;
  font-family: -apple-system, 'Helvetica Neue', sans-serif;
  font-size: 14px;
  line-height: 1.5;
  background-color: #fff;
}
</code></pre>
<p>在 body 内部，每行的元素进行在该行上的内部百分比划分。</p>
<h3 id="13-自动伸缩"><a class="header" href="#13-自动伸缩">1.3 自动伸缩</a></h3>
<p>流式布局中有一个常见的场景：盒子的宽度随着页面宽度的增大而增大，如输入框。</p>
<p>这种自适应效果可以通过设置盒子的 margin、padding 来实现：</p>
<pre><code class="language-css">/* 不设置宽度 */
div {
  height: 44px;
  margin-left: 40px;
  margin-right: 40px;
  background-color: aqua;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="055-移动-web-栅格布局"><a class="header" href="#055-移动-web-栅格布局">05.5-移动 Web-栅格布局</a></h1>
<h2 id="一-栅格系统"><a class="header" href="#一-栅格系统">一 栅格系统</a></h2>
<p>网格系统是 CSS 库基于浏览器现有技术实现的一套完整的布局，与 CSS 标准中的网格布局并不是一回事，这里只是简单介绍网格系统。</p>
<p>网格系统的思想是：在一个容器 ILIKE 放置一个或多个列容器，由列容器的类决定每列的宽度，这样以提高代码的可复用性。
目前大部分流行的 CSS 框架都包含自己的网格系统，最经典的则莫过于 BootsStrap。</p>
<p>一般网格系统的每行被划分为固定数量的列，常见值是 12 个列，每行的子元素宽度可能等于 1~12 个列的宽度，如下图所示：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/grid-01.svg" alt="网格列" /></p>
<p>这里有 2 行，第一行和第二行都是总计 12 小列，但是每行根据需求进行了列合并。选取 12 作为列数是因为它能够被 2、 3、 4、 6 整除，组合起来足够灵活。比如可以很容易地实现一个 3 列布局（ 3 个 4 列宽的元素）或者一个 4 列布局（ 4 个 3 列宽的元素）。还可以实现非对称的布局，比如一个 9 列宽的主元素和一个 3 列宽的侧边栏。</p>
<h2 id="二-bootstrap"><a class="header" href="#二-bootstrap">二 Bootstrap</a></h2>
<h3 id="21-bootstrap-简介"><a class="header" href="#21-bootstrap-简介">2.1 Bootstrap 简介</a></h3>
<p>Bootstrap 是 Twitter 公司基于 HTML、CSS、JavaScript 开发的响应式前端框架，且提供了大量的默认响应式组件。</p>
<p>三个相关网站：</p>
<ul>
<li>官网：<a href="https://getbootstrap.com/">https://getbootstrap.com/</a></li>
<li>中文网：<a href="https://www.bootcss.com/">https://www.bootcss.com/</a></li>
<li>第三方资料：<a href="https://bootstrap.css88.com">https://bootstrap.css88.com</a></li>
</ul>
<p>Bootstrap 里的 containe 在不同屏幕下宽度不同，但值是固定的，随着屏幕或视口尺寸的增加，自动分配最多 12 列，若大于 12 列，多余的列将被作为一个整体另起一行排列。</p>
<p>贴士：Bootstrap 每一列默认有 15px 的 padding。</p>
<h3 id="22-bootstrap-的基础使用"><a class="header" href="#22-bootstrap-的基础使用">2.2 Bootstrap 的基础使用</a></h3>
<p>Bootstrap 使用 行（row）与列（column）组合来布局页面，如下所示：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/bootstrap-1.png" alt="bootstrap" /></p>
<p>贴士：</p>
<ul>
<li>row 必须放在 container 布局容器中</li>
<li>列必须平均换分，并添加类前缀</li>
<li>xs-extra small:超小；sm-small:小；md-medium:中等；lg-large:大</li>
<li>可以同时为一列指定多个设备类名，以划分不同的份数，如：<code>class=&quot;colo-md-4 col-sm-6&quot;</code></li>
</ul>
<p>示例：</p>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
  &lt;!--col-lg-3 col-md-4 表示大屏幕下占 3 等份，中屏占 4 等份--&gt;
  &lt;!--如果子元素相加小于 12，则无法占满一行--&gt;
  &lt;!--如果子元素相加为 12，则正好可以占满一行--&gt;
  &lt;!--如果子元素相加大于 12，超过部分的元素另起一行--&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-lg-3 col-md-4&quot;&gt;1&lt;/div&gt;
    &lt;div class=&quot;col-lg-3 col-md-4&quot;&gt;2&lt;/div&gt;
    &lt;div class=&quot;col-lg-3 col-md-4&quot;&gt;3&lt;/div&gt;
    &lt;div class=&quot;col-lg-3 col-md-4&quot;&gt;4&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-lg-6&quot;&gt;1&lt;/div&gt;
    &lt;div class=&quot;col-lg-2&quot;&gt;2&lt;/div&gt;
    &lt;div class=&quot;col-lg-2&quot;&gt;3&lt;/div&gt;
    &lt;div class=&quot;col-lg-1&quot;&gt;4&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>对嵌套的支持：</p>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-md-4&quot;&gt;
      &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-6&quot;&gt;A&lt;/div&gt;
        &lt;div class=&quot;col-md-6&quot;&gt;a&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-md-4&quot;&gt;2&lt;/div&gt;
    &lt;div class=&quot;col-md-4&quot;&gt;3&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>对列偏移支持：即为元素之间增加一定的偏移量：</p>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-md-4&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>针对不同屏幕可以快速设置隐藏、显示：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/bootstrap-2.png" alt="bootstrap" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="056-移动-web-移动网页示例"><a class="header" href="#056-移动-web-移动网页示例">05.6-移动 Web-移动网页示例</a></h1>
<h2 id="一-移动-web-常见问题"><a class="header" href="#一-移动-web-常见问题">一 移动 web 常见问题</a></h2>
<h3 id="11-移动端的-css-reset-文件"><a class="header" href="#11-移动端的-css-reset-文件">1.1 移动端的 CSS reset 文件</a></h3>
<p>初始化移动端的 css，推荐使用第三方库:<code>normalize.css</code>，网址为：<a href="https://github.com/necolas/normalize.css">https://github.com/necolas/normalize.css</a>。该库保留了一些有价值的默认值，修改了一部分浏览器 bug，且具备模块化开发方案！</p>
<h3 id="12-retina-屏图片模糊问题"><a class="header" href="#12-retina-屏图片模糊问题">1.2 Retina 屏图片模糊问题</a></h3>
<p>1 个位图像素就是图像的最小数据单元，在实际页面中，当 1 个位图像素等于 1 个物理像素时，图片是清晰的，但是在 Retina 屏下，一个位图像素中对应了多个物理像素，就会导致位图像素中的色彩值不够分，多出来的物理像素只能就近取色，导致了图片模糊。</p>
<p>解决方案就是：参考 DRP 值，将图片原本的尺寸放大到一定的倍数。比如设备的 DPR 都是 2，将视觉稿放大两倍设计即可。</p>
<h3 id="13-背景缩放"><a class="header" href="#13-背景缩放">1.3 背景缩放</a></h3>
<p>图片可以缩放，背景在 C3 中也可以实现缩放，<code>background-size</code>属性可以设置背景图像的尺寸：</p>
<pre><code class="language-css">/* 分别是背景图宽度 高度的缩放 */
background-size: 100px 200px;

/* 只写一个参数则是 宽度缩放，高度则会按照等比例缩放 */
background-size: 100px;

/* 相当于父盒子进行比例缩放 */
background-size: 20%;

/* cover: 将图像沿着两个方先无限拉伸盖住盒子，图片会出现被遮挡部分 */
background-size: cover;

/* contain: 将图像等比例拉伸，宽度或者高度有一个铺满盒子，图片会完整显示，但是可能不会完全覆盖为背景 */
background-size: contain;
</code></pre>
<h3 id="14-特殊样式"><a class="header" href="#14-特殊样式">1.4 特殊样式</a></h3>
<pre><code class="language-css">/* 点击后背景出现高亮，比如 a 标签。设置 transparent 完成透明， */
a {
  -webkit-tap-highligj-color: transparent;
}

/* iOS 上如果要对按钮、输入框等自定义样式，需要额外设置属性 appearance */
button,
input {
  -webkit-appearance: none;
}

/* 禁用长按页面时的弹出菜单 */
img,
a {
  -webkit-touch-callout: none;
}
</code></pre>
<p>在移动端，body 一般要设计好自己样式，如下所示：</p>
<pre><code class="language-css">body {
  margin: 0 auto;
  width: 100%; /*有了 rem，可以设置为 15rem*/
  /* 在合理的范围内 100% 宽度 */
  min-width: 320px;
  max-width: 640px;
  font-family: -apple-system, 'Helvetica Neue', sans-serif;
  font-size: 14px;
  line-height: 1.5;
  background-color: #fff;
}
</code></pre>
<h2 id="二-移动居中与背景图留白问题"><a class="header" href="#二-移动居中与背景图留白问题">二 移动居中与背景图留白问题</a></h2>
<p>PC 网页一般限定在 1000px 内，这是为了避免不让页面再 1024 像素分辨率的电脑中出现横向滚动条。移动端的网页一方面要考虑 Retina 屏的清晰度，基于主流 iPhone 型号或者 Android 设备的独立像素的两倍值，一方面要注意测试不同分辨率设备下，页面两边的背景图留白问题。</p>
<p>举例：视觉稿画布宽度是 1000px，有一张 <code>1000*500</code> 的背景图，内容限定在 640px，logo 尺寸是 <code>200*100</code>，并且居中显示，在前端重构时所有元素尺寸都得缩小 1 倍：</p>
<pre><code class="language-html">&lt;div class=&quot;wrapper&quot;&gt;
  &lt;div class=&quot;bg&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;h1 class=&quot;logo&quot;&gt;&lt;a href=&quot;#&quot;&gt;logo&lt;/a&gt;&lt;/h1&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
  body {
    min-width: 302px;
  }
  .wrapper {
    position: relative;
    width: 100%;
    overflow: hidden;
  }
  .bg {
    background: url('./shoes.png') no-repeat 50% 0;
    position: absolute;
    top: 0;
    left: 50%;
    width: 500px;
    height: 250px;
    margin: 0 0 0 -250px;
    background-size: 100% auto;
    z-index: 1;
  }
  .container {
    position: relative;
    width: 320px;
    margin: 0 auto;
    z-index: 2;
  }
  .logo {
    margin: 0 auto;
    width: 100px;
    height: 50px;
  }
  .log a {
    display: block;
    width: 100%;
    height: 100%;
    text-indent: -9999px;
    background: url('./1.png') no-repeat 50% 50%;
    background-size: contain;
  }
&lt;/style&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="061-基础效果-渐变"><a class="header" href="#061-基础效果-渐变">06.1-基础效果-渐变</a></h1>
<h2 id="一-线性渐变渐变"><a class="header" href="#一-线性渐变渐变">一 线性渐变渐变</a></h2>
<h3 id="11-渐变简介"><a class="header" href="#11-渐变简介">1.1 渐变简介</a></h3>
<p>渐变实际上就是背景图片，渐变本身不会影响元素的大小。linear-gradient 函数使用三个参数来定义行为：角度、起始颜色和终止颜色。这里角度
值是 to right，意思是渐变从元素的左侧开始（这里是白色），平滑过渡到右侧（这里是蓝色）。也可以使用其他的颜色表示法，比如 hex（ #0000ff）、 RGB（ rgb(0, 0, 255)）或者 transparent 关键字。</p>
<pre><code class="language-html">&lt;style&gt;
  .fade {
    height: 200px;
    width: 400px;
    background-image: linear-gradient(to right, white, blue);
  }
&lt;/style&gt;

&lt;div class=&quot;fade&quot;&gt;&lt;/div&gt;
</code></pre>
<p>贴士：除了 too right，当然也可以使用 to top 或者 to bottom。甚至可以指定某个对角，比如 to bottom right，这样的话，渐变会从元素的左上角开始，逐渐过渡到右下角。</p>
<p>可以使用更确切的单位（比如度），更精确地控制角度。值 0deg 代表垂直向上（相当于 to top），更大的值会沿着顺时针变化，因此 90deg 代表向右渐变， 180deg 代表向下渐变，360deg 又会代表向上渐变：</p>
<pre><code class="language-css">.fade {
  height: 200px;
  width: 400px;
  /* 90deg 相当于to right */
  background-image: linear-gradient(90deg, white, blue);
}
</code></pre>
<p>度是最常用的单位，还有一些其他单位可以用来表示角度，如下所示：</p>
<ul>
<li>rad—：弧度（ radian）。一个完整的圆是 2π，大概是 6.2832 弧度。</li>
<li>turn：代表环绕圆周的圈数。一圈相当于 360 度（ 360deg）。可以使用小数来表示不足一圈，比如 0.25turn 相当于 90deg。</li>
<li>grad：百分度（ gradian）。一个完整的圆是 400 百分度（ 400grad）， 100grad 相当于 90deg。</li>
</ul>
<h3 id="12-使用多个颜色节点"><a class="header" href="#12-使用多个颜色节点">1.2 使用多个颜色节点</a></h3>
<p>大部分渐变只需要两个颜色，从一个颜色过渡到另一个。也可以定义包含多个颜色的渐变，其中每个颜色可以称为一个颜色节点（ color stop）。</p>
<pre><code class="language-css">.fade {
  height: 200px;
  width: 400px;
  background-image: linear-gradient(90deg, red, white, blue);
}
</code></pre>
<p>一个渐变可以接受任意数量的颜色节点，节点之间通过逗号分隔。渐变会自动均匀地平铺这些颜色节点。在本例中，最左侧（ 0%）从红色开始，过渡到中间（ 50%）的白色，到最右侧的蓝色（ 100%）。我们也可以在渐变函数中为每个颜色节点明确指定位置。例子代码等价于：</p>
<pre><code class="language-css">.fade {
  height: 200px;
  width: 400px;
  background-image: linear-gradient(90deg, red 0%, white 50%, blue 100%);
}
</code></pre>
<h3 id="13-条纹"><a class="header" href="#13-条纹">1.3 条纹</a></h3>
<p>如果在同一个位置设置两个颜色节点，那么渐变会直接从一个颜色变换到另一个，而不是平滑过渡：</p>
<pre><code class="language-css">.fade {
  height: 200px;
  width: 400px;
  background-image: linear-gradient(
    90deg,
    red 40%,
    white 40%,
    white 60%,
    blue 60%
  );
}
</code></pre>
<h3 id="14-重复渐变"><a class="header" href="#14-重复渐变">1.4 重复渐变</a></h3>
<p>repeating-linear-gradient()函数和函数 linear-gradient 的效果基本相同，唯一的区别就是前者会重复。对于重复渐变，最好使用特定的长度而不是百分比，因为设置的值决定了要重复的图片大小。</p>
<pre><code class="language-css">.fade {
  height: 1em;
  width: 400px;
  background-image: repeating-linear-gradient(
    -45deg,
    #57b,
    #57b 10px,
    #148 10px,
    #148 20px
  );
  border-radius: 0.3em;
}
</code></pre>
<h2 id="二-径向渐变"><a class="header" href="#二-径向渐变">二 径向渐变</a></h2>
<p>线性渐变是从元素的一端开始，沿着直线过渡到另一端，而径向渐变不同，它是从一个点开始，全方位向外扩展。</p>
<pre><code class="language-css">/* 从中心的白色过渡到边缘的蓝色 */
.fade {
  height: 200px;
  width: 400px;
  background-image: radial-gradient(white, blue);
}
</code></pre>
<p>默认情况下，渐变在元素中是从中心开始，平滑过渡到边缘。渐变整体呈椭圆形，跟随元素大小进行变化（也就是说，较宽的元素，其径向渐变也较宽，反之亦然）。</p>
<p>跟线性渐变一样，径向渐变同样支持颜色节点。你可以提供多个节点，使用百分比或者长度单位指定节点位置。你也可以把径向渐变设置为圆形而非椭圆，甚至可以指定渐变中心点的位置。repeating-radial-gradient()函数可以重复生成图样，形成同心圆环。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="062-基础效果-阴影"><a class="header" href="#062-基础效果-阴影">06.2-基础效果-阴影</a></h1>
<h2 id="一-阴影"><a class="header" href="#一-阴影">一 阴影</a></h2>
<p>阴影是另一种可以为网页增加立体感的特效。有两个属性可以创建阴影， box-shadow 可以为元素盒子生成阴影， text-shadow 可以为渲染后的文字生成阴影。</p>
<pre><code class="language-css">.box {
  box-shadow: 1em 1em black;
}
</code></pre>
<p>示例中 1em 代表偏移量，如果偏移量都设置为 0，那么阴影会直接渲染在元素下方。 black 指明了阴影的颜色。</p>
<p>默认情况下，阴影与元素的大小和尺寸相同。如果元素设置了 border-radius，那么阴影相应地也会有圆角。阴影的水平偏移量（ x）、垂直偏移量（ y）和颜色都不可或缺。还有两个值是可选的：模糊半径和扩展半径。</p>
<pre><code class="language-txt">box-shadow:水平偏移x 垂直偏移y 模糊半径 扩展半径 颜色
</code></pre>
<p>模糊半径用来控制阴影边缘模糊区域的大小，可以为阴影生成一个更柔和、有点透明的边缘。扩展半径用来控制阴影的大小，设置为正值可以使阴影全方位变大，设为负值则会变小。</p>
<h2 id="二-使用渐变和阴影形成立体感"><a class="header" href="#二-使用渐变和阴影形成立体感">二 使用渐变和阴影形成立体感</a></h2>
<pre><code class="language-html">&lt;style&gt;
  .button {
    padding: 1em;
    border: 0;
    font-size: 0.8rem;
    color: white;
    border-radius: 0.5em;
    background-image: linear-gradient(to bottom, #57b, #148);
    box-shadow: 0.1em 0.1em 0.5em #124;
  }
  .button:active {
    box-shadow: inset 0 0 0.5em #124, inset 0 0.5em 1em rgba(0, 0, 0, 0.4);
  }
&lt;/style&gt;

&lt;button class=&quot;button&quot;&gt;Sign up now&lt;/button&gt;
</code></pre>
<p>在 Chrome 浏览器中点击按钮时，你会发现按钮周围环绕了一个浅蓝色的光圈，这是浏览器为按钮的:focus 状态默认添加的轮廓线。可以通过设置.button:focus{ outline: none; }来移除轮廓线。建议你在移除轮廓线的同时，添加一些其他特效来代替，这样当用户使用键盘导航的时候，就可以看到当前焦点状态在哪里。</p>
<h2 id="三-扁平化设计"><a class="header" href="#三-扁平化设计">三 扁平化设计</a></h2>
<pre><code class="language-css">.button {
  padding: 1em;
  border: 0;
  color: white;
  background-color: #57b;
  font-size: 1rem;
  padding: 0.8em;
  box-shadow: 0 0.2em 0.2em rgba(0, 0, 0, 0.15);
}
.button:hover {
  background-color: #456ab6;
}
.button:active {
  background-color: #148;
}
</code></pre>
<p>这里的盒阴影有一些改变，只有垂直方向上的偏移，这样就只有向下的阴影，跟之前看上去很自然的阴影角度不一样；同时使用了 RGBA 颜色表示法，其中红色、绿色和蓝色的值都是 0（生成黑色）， alpha 值是 0.15（几乎完全透明）。鼠标悬停和激活状态的外观也是扁平化的，只是把背景颜色变成了暗一点儿的蓝色。同时字号也增加了一些，这是扁平化设计兴起以来的另一种流行趋势。</p>
<p>设计一个样式：激活状态时，按钮向下方移动了少量像素的距离，看上去就像按钮陷进了页面里，如同被按下去一样：</p>
<pre><code class="language-css">.button {
  padding: 0.8em;
  border: 0;
  font-size: 1rem;
  color: white;
  border-radius: 0.5em;
  background-color: #57b;
  box-shadow: 0 0.4em #148;
  text-shadow: 1px 1px #148;
}
.button:active {
  background-color: #456ab5;
  transform: translateY(0.1em);
  box-shadow: 0 0.3em #148;
}
</code></pre>
<h2 id="四-混合模式"><a class="header" href="#四-混合模式">四 混合模式</a></h2>
<h3 id="41-混合模式概念"><a class="header" href="#41-混合模式概念">4.1 混合模式概念</a></h3>
<p>大部分情况下，不论是使用真正的图片还是渐变，元素一般只会使用一张背景图片。但某些情况下你可能想要使用两张或者更多的背景图片， CSS 是支持这么做的。</p>
<p>background-image 属性可以接受任意数量的值，相互之间以逗号分隔，如下所示。</p>
<pre><code class="language-css">background-image: url(bear.jpg), linear-gradient(to bottom, #57b, #148);
</code></pre>
<p>使用多个背景图片时，列表中排在前面的图片会渲染到排序靠后的图片上面。假如一个图片会遮盖在线性渐变之上，渐变就会不可见。而如果我们使用两张背景图片，那么一般是希望第二张图片也可以透视显示。这时就可以使用混合模式（ blend mode）。</p>
<p>如果熟悉图片编辑软件，那你可能见过混合模式。混合模式用来控制叠放的图片怎样融合在一起，有些模式的命名有点让人摸不着头脑，比如滤色（ screen）、颜色加深（ color-burn）、强光（ hard-light）等。图 11-13 中演示的例子，是两张背景图片以正片叠底（ multiply）混合模式组合生成的。两个背景使用了同一张图片，但是背景位置不同。</p>
<p>最终呈现的效果很有意思，两张图片的副本虽然叠放在一起，但都清晰可见。而且混合模式不会冲淡或者削弱整体的颜色，这跟普通的调整透明度的做法还不一样。</p>
<pre><code class="language-css">.blend {
  min-height: 400px;
  /* 使用逗号隔开的两张背景图片 */
  background-image: url(images/bear.jpg), url(images/bear.jpg);
  /* 设置一个值，应用到两张背景图片上 */
  background-size: cover;
  background-repeat: no-repeat;
  /* 为每张背景图片设置，不同的初始位置 */
  background-position: -30vw, 30vw;
  /* 应用混合模式 */
  background-blend-mode: multiply;
}
</code></pre>
<p>大部分背景相关的属性可以接受多个值，以逗号分隔。 background-position 就使用了两个值，第一个值会应用到第一张背景图片上，第二个值会应用到第二张背景图片上。</p>
<p>background-size 和 background-repeat 属性也可以接受多个值，但如果只设置一个值，就会应用到所有的背景图片上。这里使用了 min-height 属性，是为了确保元素不会显示成高度为 0（因为是空元素）。</p>
<p>background-size 属性接受了两个特殊的关键字值，分别是 cover 和 contain。使用 cover 值可以调整背景图片的大小，使其填满整个元素，这样会导致图片的边缘被裁切掉一部分；使用 contain 值可以保证整个背景图片可见，尽管这可能导致元素的一些地方不会被背景图片覆盖，该属性也可以接受长度值，用来明确设置背景图片的宽度和高度。尝试修改混合模式的其他值，查看它们有哪些不同效果，比如 color-burn 或者 difference。
这很有趣，但你可能会疑惑这些混合模式到底有什么实用性。这里列举一些实际应用：</p>
<ul>
<li>使用某种颜色或者渐变为图片着色；</li>
<li>为图片添加纹理效果，比如划痕或者老胶片放映时的颗粒感等；</li>
<li>缓和、加深或者减小图片的对比度，使图片上的文字更具可读性；</li>
<li>在图片上覆盖了一条文字横幅，但是还想让图片完整显示。</li>
</ul>
<h3 id="42-示例-为图片添加纹理"><a class="header" href="#42-示例-为图片添加纹理">4.2 示例 为图片添加纹理</a></h3>
<p>混合模式的另一个应用场景就是为图片添加纹理效果。比如你有一张富有现代气息的清晰图片，但有时候出于样式考虑，你想让图片与众不同。这时候就可以使用灰度图为图片手动添加胶片噪点效果或者其他纹理。</p>
<p>下面的示例混合了一张纹理图片以后，就呈现出类似于粗制帆布的效果。这种类型的效果可以通过对比混合模式 overlay、hard-light 或 soft-light 来实现。这个例子中，我们不希望更改图片的色相，因此使用一张灰度图片来提供纹理，这样就保留了原始颜色。</p>
<pre><code class="language-css">.blend {
  min-height: 400px;
  /* 将纹理图片覆盖在主图片之上 */
  background-image: url('images/scratches.png'), url('images/bear.jpg');
  /* 每 200px 平铺一张纹理图片 */
  background-size: 200px, cover;
  background-repeat: repeat, no-repeat;
  background-position: center center;
  /* 使用柔光混合模式 */
  background-blend-mode: soft-light;
}
</code></pre>
<p>纹理图片的背景大小设置为 200px，同时允许背景图片重复，这样就可以使纹理图片平铺填满整个元素。同时，第二张图片的背景大小设置为 cover，且不允许重复，这样就不会平铺。</p>
<h3 id="43-使用融合混合模式"><a class="header" href="#43-使用融合混合模式">4.3 使用融合混合模式</a></h3>
<p>虽然 background-blend-mode 属性可以实现多张图片的混合，但只能局限于元素的背景颜色或者背景图片使用。还有一个属性 mix-blend-mode，可以融合多个元素。这样不仅可以混合图片，还可以把元素的文本和边框与容器的背景图片混合在一起。使用融合混合模式，可以把标题显示在图片上方，但遮住的图片部分依然可以显示出来：</p>
<pre><code class="language-html">&lt;style&gt;
  .blend {
    background-image: url('images/bear.jpg');
    background-size: cover;
    background-position: center;
    padding: 5em 0 10em;
  }
  .blend &gt; h1 {
    margin: 0;
    font-family: Helvetica, Arial, sans-serif;
    font-size: 6rem;
    text-align: center;
    mix-blend-mode: hard-light;
    background-color: #c33;
    color: #808080;
    border: 0.1em solid #ccc;
    border-width: 0.1em 0;
  }
&lt;/style&gt;
&lt;div class=&quot;blend&quot;&gt;
  &lt;h1&gt;Ursa Major&lt;/h1&gt;
&lt;/div&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="071-css3-特效-过渡"><a class="header" href="#071-css3-特效-过渡">07.1-CSS3 特效-过渡</a></h1>
<h2 id="一-过渡-transition-概念"><a class="header" href="#一-过渡-transition-概念">一 过渡 transition 概念</a></h2>
<p>过渡是 CSS3 中具有颠覆性的特性之一，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。</p>
<blockquote>
<p>补间动画：自动完成从起始状态到终止状态的过渡，不用管中间的状态
帧动画：扑克牌切换，通过一帧帧的画面按照顺序和速度播放，如电影</p>
</blockquote>
<p>过渡使用 transition 属性，示例：</p>
<pre><code class="language-css">&lt;style&gt;
    div {
        height: 100px;
        width: 100px;
        background-color: #5cb85c;
    }
    div:hover {
        height: 500px;
        width: 500px;
        transition: height 2s, width 3s,background-color 5s;
    }
&lt;/style&gt;
</code></pre>
<p>注意：过渡最大的好处是不会对页面布局造成影响！</p>
<h2 id="二-过渡常用属性"><a class="header" href="#二-过渡常用属性">二 过渡常用属性</a></h2>
<p>过渡属性简写格式：</p>
<pre><code class="language-txt">transition: 过渡属性  花费时间  运动曲线  何时开始;
</code></pre>
<p>transition 是下列四个属性的简写：</p>
<ul>
<li>transition-property：要运动的样式名，还支持一些专有名词：all || [attr] || none</li>
<li>transition-duration：过渡花费时间，默认是 0</li>
<li>transition-timing-function：过渡的时间曲线
<ul>
<li>ease：逐渐变慢，是默认值</li>
<li>linear：匀速</li>
<li>ease-in：加速</li>
<li>ease-out：减速</li>
<li>ease-in-out：先加速后减速</li>
</ul>
</li>
<li>transition-delay 过渡效果何时开始，默认是 0</li>
</ul>
<h2 id="三-贝塞尔曲线"><a class="header" href="#三-贝塞尔曲线">三 贝塞尔曲线</a></h2>
<h3 id="31-曲线定义函数"><a class="header" href="#31-曲线定义函数">3.1 曲线定义函数</a></h3>
<p>定时函数是基于数学定义的贝塞尔曲线（ Bézier curve）。浏览器使用贝塞尔曲线作为随时间变化的函数，来计算某个属性的值。</p>
<p>这些贝塞尔曲线都是从左下方开始，持续延伸到右上方。时间是从左向右递进的，曲线代表某个值在到达最终值的过程中是如何变化的。linear 定时函数在整个过渡期间是个稳定的过程，呈现为一条直线。其他定时函数有弯曲的地方，代表加速或者减速：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/transition-01.svg" alt="" /></p>
<p>实际开发中，不应该局限在这五种关键字贝塞尔曲线上。我们可以定义自己的三次贝塞尔曲线（ ubic Bézier curve），实现更温和或者更强烈的过渡效果，甚至可以添加一点“弹跳”效果。</p>
<p>贴士：在 chrome 开发者工具样式面板中的定时函数旁边有一个小小的标志符号。点击标志符号会打开一个弹窗，可以在弹窗中修改定时函数的曲线。曲线的每个末端都有一条短直线——控制柄（ handles），直线上有小圆点，称为控制点（ control points）。点击并拖动小圆点可以改变曲线的形状，注意控制柄的长度和方向是如何“牵引”曲线的。</p>
<p>在 CSS 中，曲线可以通过类似 <code>cubic-bezier(0.45, 0.05, 0.55, 0.95)</code> 来定义，实现从一个值到另一个值的基于贝塞尔曲线的流畅过渡，其中的四个参数分别代表两个控制柄的控制点的 x 和 y 坐标。</p>
<h3 id="32-阶跃"><a class="header" href="#32-阶跃">3.2 阶跃</a></h3>
<p>定时函数 steps()可以实现非连续性的瞬时“阶跃”（ steps）。阶跃函数需要两个参数：阶跃次数和一个用来表示每次变化发生在阶跃的开始还是结束的关键词（ start 或者 end）。</p>
<pre><code class="language-css">.box {
  position: absolute;
  left: 0;
  height: 30px;
  width: 30px;
  background-color: hsl(130, 50%, 50%);
  transition: all 1s steps(3);
}
</code></pre>
<p>现在就不是一秒内（过渡持续时间）流畅地从左到右移动了，时间被分成了三等份，或者说三步。每一步时，盒子分别出现在开始的位置、三分之一的位置、三分之二的位置，最后在 1s 的时刻移动到最终位置。</p>
<p>贴士：默认情况下，属性值在每一步结束的时候改变，因此过渡不会立即开始。添加 start 关键字 steps(3, start)就可以改变这种行为，这样过渡就会发生在每步开始的时候，而不是结束。</p>
<h2 id="四-过渡的注意事项"><a class="header" href="#四-过渡的注意事项">四 过渡的注意事项</a></h2>
<h3 id="41-end-事件"><a class="header" href="#41-end-事件">4.1 end 事件</a></h3>
<p>transition 中，如果绑定了 end 事件，每改变一次样式，都会触发一次 end 事件，该事件绑定方式：</p>
<ul>
<li>Webkit 内核： <code>obj.addEventListener('webkitTransitionEnd',function(){},false);</code></li>
<li>firefox 内核： <code>obj.addEventListener('transitionend',function(){},false);</code></li>
</ul>
<h3 id="42-一些不可添加动画效果的属性"><a class="header" href="#42-一些不可添加动画效果的属性">4.2 一些不可添加动画效果的属性</a></h3>
<p>不是所有属性都可以添加动画效果， display 属性就是其中之一。你可以在 display: none 和 display: block 之间切换，但不能在这两个值之间过渡，因此，任何应用到 display 上的过渡属性都会被忽略。</p>
<p>background-color 属性只有一个颜色值的时候才可以添加动画，意思是从一个颜色过渡到另一个颜色（这就意味着属性必须设置为单一颜色值）。</p>
<p>其他属性参见 MDN。</p>
<h2 id="五-一些效果实现"><a class="header" href="#五-一些效果实现">五 一些效果实现</a></h2>
<h3 id="51-淡入淡出"><a class="header" href="#51-淡入淡出">5.1 淡入淡出</a></h3>
<pre><code class="language-css">.dropdown__drawer {
  position: absolute;
  background-color: white;
  width: 10em;
  opacity: 0; /*使用 opacity: 0 替换display: none*/
  transition: opacity 0.2s linear; /*为透明度添加过渡效果 */
}
/* 菜单打开时，设置可见和完全不透明 */
.dropdown.is-open .dropdown__drawer {
  opacity: 1; /* 使用 opacity: 1 替换display: block */
  visibility: visible;
  transition-delay: 0s; /*添加 is-open 类时移除过渡延迟*/
}
</code></pre>
<h3 id="52-过渡到自动高度"><a class="header" href="#52-过渡到自动高度">5.2 过渡到自动高度</a></h3>
<p>通过高度的过渡来滑动打开和关闭菜单，菜单打开时，会从高度为 0 过渡到正常高度（ auto）。菜单关闭时，又会过渡回 0。</p>
<p>下面的代码无法实现：</p>
<pre><code class="language-css">.dropdown__drawer {
  position: absolute;
  background-color: white;
  width: 10em;
  height: 0;
  overflow: hidden; /*闭状态下高度为 0，overflow 为 hidden*/
  transition: height 0.3s ease-out; /*为高度添加过渡 */
}
/* 打开状态下的高度由内容决定 */
.dropdown.is-open .dropdown__drawer {
  height: auto;
}
</code></pre>
<p>设置 overflow 为 hidden，是为了在关闭或者过渡过程中截断抽屉的内容。代码不起作用是因为一个值不能从长度（ 0）过渡到 auto。</p>
<p>可以明确设置一个高度值，比如 120px，但问题是没办法知道高度到底是多少。因为只有当内容在浏览器中渲染完成之后才能确定高度，所以需要使用 JavaScript 来获取。页面加载完成后，我们访问 DOM 元素的 scrollHeight 属性，就可以获取到高度值。然后就可以把元素的高度修改为获取到的值。</p>
<pre><code class="language-js">;(function () {
  var toggle = document.getElementsByClassName('dropdown**toggle')[0]
  var dropdown = toggle.parentElement
  var drawer = document.getElementsByClassName('dropdown**drawer')[0]
  var height = drawer.scrollHeight
  toggle.addEventListener('click', function (e) {
    e.preventDefault()
    dropdown.classList.toggle('is-open')
    if (dropdown.classList.contains('is-open')) {
      drawer.style.setProperty('height', height + 'px')
    } else {
      drawer.style.setProperty('height', '0')
    }
  })
})()
</code></pre>
<p>现在，除了触发 is-open 类，我们还为元素的高度指定了精确的像素值，这样就可以过渡到正确的高度。然后在关闭的时候把高度值重新设置为 0，这样菜单又可以过渡回去。</p>
<p>注意：如果一个元素使用 display: none 隐藏起来，那它的 scrollHeight 属性等于 0。遇到这种情况的时候， 可以先把 display 属性设置为 block（ el.style.display ='block'）， 获取到 scrollHeight， 然后重置 display 的值（ el.style.display = 'none'）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="072-css3-特效-2d-转换"><a class="header" href="#072-css3-特效-2d-转换">07.2-CSS3 特效-2D 转换</a></h1>
<h2 id="一-转换transform概念"><a class="header" href="#一-转换transform概念">一 转换（transform）概念</a></h2>
<p>转换是 C3 颠覆性特性之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，可以简单理解为变形。转换配合 C3 其他的特性：过渡、动画，能够取代以前 flash 实现的特效。</p>
<p>转换的实现：通过 transform 实现 2D、3D 转换，其中 2D 有：缩放、移动、旋转。</p>
<p>转换通过 transform 实现：</p>
<pre><code class="language-css">div {
  height: 200px;
  width: 200px;
  background-color: aqua;
  transform: translate(200px, 300px);
}
</code></pre>
<p>常见的转换函数有：</p>
<ul>
<li>旋转（ Rotate） ——元素绕着一个轴心转动一定角度。</li>
<li>平移（ Translate） ——元素向上、下、左、右各个方向移动（有点类似于相对定位）。</li>
<li>缩放（ Scale） ——缩小或放大元素。</li>
<li>倾斜（ Skew） ——使元素变形，顶边滑向一个方向，底边滑向相反的方向。</li>
</ul>
<p>转换的应用场景案例：在一些商城网站中，鼠标移入宝贝图片，图片向上移动一定距离，但不会影响图片下方其他元素的位置。</p>
<p>使用变换的时候要注意一件事情，虽然元素可能会被移动到页面上的新位置，但它不会脱离文档流。你可以在屏幕范围内以各种方式平移元素，其初始位置不会被其他元素占用。当旋转某元素的时候，它的一角可能会移出屏幕边缘，同样也可能会遮住旁边其他元素的部分内容。</p>
<p>某些情况下，为变换元素或者所有元素设置较大的外边距，有助于避免不必要的重叠。警告 变换不能作用在<code>&lt;span&gt;</code>或者<code>&lt;a&gt;</code>这样的行内元素上。若确实要变换此类元素，要么改变元素的 display 属性， 替换掉 inline（比如 inline-block）， 要么把元素改为弹性子元素或者网格项目（为父元素应用 display: flex 或者 display: grid）。</p>
<h2 id="二-2d-转换"><a class="header" href="#二-2d-转换">二 2D 转换</a></h2>
<h3 id="21-位移-transform-translate"><a class="header" href="#21-位移-transform-translate">2.1 位移 <code>transform: translate()</code></a></h3>
<p>translate 移动效果类似定位，用来给元素实现移动效果。</p>
<pre><code class="language-css">/* x 轴向右移动 200px，y 轴向下移动 300px */
div {
  height: 200px;
  width: 200px;
  background-color: aqua;
  transform: translate(200px, 300px);
}
</code></pre>
<p>注意：</p>
<ul>
<li>在 CSS 中坐标系是以浏览器左上角为原点的！</li>
<li>支持负值、零值（0，无单位不能省略）</li>
<li>支持百分比格式，比 X 轴移动 50%，代表了移动了其自身宽度的 50%！</li>
<li>translate 对行内元素无效</li>
</ul>
<p>如果只想移动 X 轴、Y 轴，那么可以使用：<code>translateX()</code>,<code>translateY()</code>。</p>
<p>改变元素的位置有：margin、定位、转换三种方式，但是定位会脱标，而<strong>转换不会影响其他元素的位置</strong>。</p>
<h3 id="22-旋转-transform-rotate"><a class="header" href="#22-旋转-transform-rotate">2.2 旋转 <code>transform: rotate()</code></a></h3>
<pre><code class="language-css">div {
  height: 200px;
  width: 200px;
  background-color: aqua;
  /* 配合过渡 */
  transition: all 0.3s;
}

div:hover {
  /* 旋转：度数 */
  transform: rotate(45deg);
}
</code></pre>
<p>参数度数的的单位为 deg，如旋转 45 度则为 45deg。支持负值，代表逆时针旋转。</p>
<blockquote>
<p>延伸：如果给一个正方形进行宣传，然后遮住其对角线分开的一半，可以实现一个三角！</p>
</blockquote>
<h3 id="23-缩放-transform-scale"><a class="header" href="#23-缩放-transform-scale">2.3 缩放 <code>transform: scale()</code></a></h3>
<p>缩放示例：</p>
<pre><code class="language-css">div {
  height: 200px;
  width: 200px;
  background-color: aqua;
  transition: all 0.3s;
}

div:hover {
  transform: scale(0.5, 2);
}
</code></pre>
<p>注意：</p>
<ul>
<li>scale 的参数 x、y 使用逗号隔开</li>
<li><code>scale(1,1)</code>是宽高各放大一倍，相当于没有改变！</li>
<li>如果只传入一个参数，代表第二个参数和第一个参数一样</li>
<li>参数支持小数，代表缩小！</li>
</ul>
<p>直接改变宽高也可以让元素实现缩放，但是 <strong>C3 转换中的缩放不会影响其他元素的位置</strong>！</p>
<h3 id="24-设置转换中心点-transform-origin"><a class="header" href="#24-设置转换中心点-transform-origin">2.4 设置转换中心点 transform-origin</a></h3>
<p>变换是围绕基点（ point of origin）发生的。基点是旋转的轴心，也是缩放或者倾斜开始的地方。这就意味着元素的基点是固定在某个位置上，元素的剩余部分围绕基点变换（但 translate()是个例外，因为平移过程中元素整体移动）。</p>
<p>默认情况下，基点就是元素的中心，通过 transform-origin 属性改变基点位置：</p>
<pre><code class="language-css">div {
  height: 200px;
  width: 200px;
  background-color: aqua;
  transition: all 0.3s;
}

div:hover {
  transform: rotate(45deg);
  /* 左下角旋转 */
  transform-origin: left bottom;
}
</code></pre>
<p>注意：</p>
<ul>
<li>转换中的参数 x 和 y 是用空格隔开的</li>
<li>转换的默认值是元素中心点，即<code>(50% 50%)</code></li>
<li>支持值为像素、方位名词，如<code>top bottom left center</code></li>
</ul>
<p>左侧的元素绕基点旋转，其基点设置为 transform-origin: right bottom；中间的元素向着基点（ right top）缩放；右侧元素的倾斜方式是，基点（ left top）保持不动，元素其他部分向远处延伸。</p>
<p>基点也可以指定为百分比，从元素左上角开始测量。下面的两句声明是等价的：</p>
<pre><code class="language-css">transform-origin: right center;
transform-origin: 100% 50%;
</code></pre>
<h3 id="25-2d-多重变换连写"><a class="header" href="#25-2d-多重变换连写">2.5 2D 多重变换连写</a></h3>
<p>同时使用多个转换，空格隔开即可：</p>
<pre><code class="language-css">div {
  transform: translate(100px, 100px) rotate(45deg) scale(0.5);
}
</code></pre>
<p>注意：<strong>连写中顺序的不同，也会造成转换效果的不同，一般推荐位移放在最前面！</strong></p>
<h2 id="三-运动中的变换"><a class="header" href="#三-运动中的变换">三 运动中的变换</a></h2>
<h3 id="31-实现侧列导航菜单"><a class="header" href="#31-实现侧列导航菜单">3.1 实现侧列导航菜单</a></h3>
<p>实现一个左侧的导航菜单。最初，菜单只有四个纵向排列的图标；鼠标一悬停，菜单文字就出现了。这个示例包含多个过渡和一对变换：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;style&gt;
      html {
        box-sizing: border-box;
      }
      *,
      *::before,
      *::after {
        box-sizing: inherit;
      }
      body {
        background-color: hsl(200, 80%, 30%);
        background-image: radial-gradient(
          hsl(200, 80%, 30%),
          hsl(210, 80%, 20%)
        );
        color: white;
        font-family: Raleway, Helvetica, Arial, sans-serif;
        line-height: 1.4;
        margin: 0;
        /* 确保 body 元素填满整个视窗，这样渐变就会填满屏幕 */
        min-height: 100vh;
      }
      h1,
      h2,
      h3 {
        font-family: Alfa Slab One, serif;
        font-weight: 400;
      }
      main {
        display: block;
      }
      img {
        max-width: 100%;
      }
      .page-header {
        margin: 0;
        /* 在移动视窗上为头部设置稍小的内边距 */
        padding: 1rem;
      }
      @media (min-width: 30em) {
        /* 在较大的屏幕上为头部设置稍大的内边距 */
        .page-header {
          padding: 2rem 2rem 3rem;
        }
      }

      /* 仅在大中型屏幕上应用样式 */
      @media (min-width: 30em) {
        .main-nav {
          position: fixed;
          top: 8.25rem;
          left: 0;
          z-index: 10; /* 确保导航显示在网页后续新增内容的前面 */
          background-color: transparent; /*开始时保持背景颜色透明*/
          transition: background-color 0.5s linear; /*为背景颜色添加过渡效果*/
          border-top-right-radius: 0.5em;
          border-bottom-right-radius: 0.5em;
        }
        .main-nav:hover {
          background-color: rgba(
            0,
            0,
            0,
            0.6
          ); /*为鼠标悬停状态设置深色半透明背景*/
        }
      }

      /* 使用 Flexbox 在屏幕水平方向上展开导航项目 */
      .nav-links {
        display: flex;
        justify-content: space-between;
        margin-top: 0;
        margin-bottom: 1rem;
        padding: 0 1rem;
        list-style: none;
      }
      .nav-links &gt; li + li {
        margin-left: 0.8em;
      }
      .nav-links &gt; li &gt; a {
        display: block;
        padding: 0.8em 0;
        color: white;
        font-size: 0.8rem;
        text-decoration: none;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }
      .nav-links__icon {
        height: 1.5em;
        width: 1.5em;
        vertical-align: -0.2em; /*把图标向下稍微移动，与文本标签对齐*/
      }
      .nav-links &gt; li &gt; a:hover {
        color: hsl(40, 100%, 70%);
      }

      /* 覆盖移动样式中的 Flexbox，使链接纵向排列 */
      @media (min-width: 30em) {
        .nav-links {
          display: block;
          padding: 1em;
          margin-bottom: 0;
        }
        .nav-links &gt; li + li {
          margin-left: 0;
        }
        .nav-links__label {
          margin-left: 1em;
        }
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;nav class=&quot;main-nav&quot;&gt;
      &lt;ul class=&quot;nav-links&quot;&gt;
        &lt;li&gt;
          &lt;a href=&quot;/&quot;&gt;
            &lt;span class=&quot;nav-links__label&quot;&gt;Home&lt;/span&gt;
          &lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href=&quot;/events&quot;&gt;
            &lt;span class=&quot;nav-links__label&quot;&gt;Events&lt;/span&gt;
          &lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href=&quot;/members&quot;&gt;
            &lt;span class=&quot;nav-links__label&quot;&gt;Members&lt;/span&gt;
          &lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href=&quot;/about&quot;&gt;
            &lt;span class=&quot;nav-links__label&quot;&gt;About&lt;/span&gt;
          &lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;
  &lt;/body&gt;
&lt;/html&gt;

position: fixed 声明把菜单放入并固定在一个位置，页面滚动也不会受到影响。
display: block 规则覆盖掉移动样式中的 display:flex，使得菜单项叠放在一起。
</code></pre>
<p>接着完成以下三件事情：</p>
<ul>
<li>(1) 鼠标划过链接的时候，放大图标尺寸。</li>
<li>(2) 隐藏链接标签，当用户使用鼠标悬停在菜单上时，让它们通过淡入过渡特效全部显示出来。</li>
<li>(3) 使用平移为链接标签添加“飞入”效果，与淡入一起使用</li>
</ul>
<h3 id="32-放大图标"><a class="header" href="#32-放大图标">3.2 放大图标</a></h3>
<pre><code class="language-css">@media (min-width: 30em) {
  .nav-links {
    display: block;
    padding: 1em;
    margin-bottom: 0;
  }
  .nav-links &gt; li + li {
    margin-left: 0;
  }
  .nav-links__label {
    margin-left: 1em;
  }
  .nav-links__icon {
    transition: transform 0.2s ease-out;
  }
  .nav-links a:hover &gt; .nav-links__icon,
  .nav-links a:focus &gt; .nav-links__icon {
    transform: scale(1.3);
  }
}
</code></pre>
<h3 id="33-创建飞入的标签"><a class="header" href="#33-创建飞入的标签">3.3 创建“飞入”的标签</a></h3>
<p>菜单的标签没有必要一直保持可见状态。默认情况下可以把它们隐藏，只在相应位置保留图标，告诉用户菜单的位置。当用户移动鼠标到菜单或者导航元素上时，再把标签以淡入的方式展示出来。这样的话，用户的鼠标一靠近图标，整个菜单就显现了。这个过程中一次性使用了多种特效，背景和标签都使用了淡入，标签从它们最终位置偏左一点开始过渡：整个特效中，标签需要同时使用两个不同的过渡效果：一个针对透明度，另一个针对 translate()变换：</p>
<pre><code class="language-css">@media (min-width: 30em) {
  .nav-links {
    display: block;
    padding: 1em;
    margin-bottom: 0;
  }
  .nav-links &gt; li + li {
    margin-left: 0;
  }
  .nav-links__label {
    display: inline-block;
    margin-left: 1em;
    padding-right: 1em;
    opacity: 0;
    transform: translate(-1em);
    transition: transform 0.4s cubic-bezier(0.2, 0.9, 0.3, 1.3), opacity 0.4s
        linear;
  }
  .nav-links:hover .nav-links__label,
  .nav-links a:focus &gt; .nav-links__label {
    opacity: 1;
    transform: translate(0);
  }
  .nav-links__icon {
    transition: transform 0.2s ease-out;
  }
  .nav-links a:hover &gt; .nav-links__icon,
  .nav-links a:focus &gt; .nav-links__icon {
    transform: scale(1.3);
  }
}
</code></pre>
<h3 id="34-交错显示过渡"><a class="header" href="#34-交错显示过渡">3.4 交错显示过渡</a></h3>
<p>用 transitiondelay 属性，为每个菜单项设置不同的延迟时间。这样就可以使每段动画交错飞入显示，不再一次性全部展示出来，就像翻滚的“波浪”：</p>
<pre><code class="language-css">.nav-links:hover .nav-links__label,
.nav-links a:focus &gt; .nav-links__label {
  opacity: 1;
  transform: translate(0);
}
.nav-links &gt; li:nth-child(2) .nav-links__label {
  transition-delay: 0.1s;
}
.nav-links &gt; li:nth-child(3) .nav-links__label {
  transition-delay: 0.2s;
}
.nav-links &gt; li:nth-child(4) .nav-links__label {
  transition-delay: 0.3s;
}
.nav-links &gt; li:nth-child(5) .nav-links__label {
  transition-delay: 0.4s;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="073-css3-特效-3d-转换"><a class="header" href="#073-css3-特效-3d-转换">07.3-CSS3 特效-3D 转换</a></h1>
<h2 id="一-3d-转换概念"><a class="header" href="#一-3d-转换概念">一 3D 转换概念</a></h2>
<p>三维坐标系：</p>
<ul>
<li>X 轴：水平向右，X 轴原点的右边是正值，左边是负值</li>
<li>Y 轴：垂直向下，Y 轴原点的下方是正值，上边是负值</li>
<li>Z 轴：垂直屏幕，Z 轴原点向外面是正值，向里面是负值</li>
</ul>
<p>如图所示：
<img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/3d01.png" alt="3d 坐标系" /></p>
<h2 id="二-3d-转换常用方式"><a class="header" href="#二-3d-转换常用方式">二 3D 转换常用方式</a></h2>
<h3 id="20-透视"><a class="header" href="#20-透视">2.0 透视</a></h3>
<p>如果要从视觉上感觉到 Z 轴的变化，需要加上透视。</p>
<blockquote>
<p>透视：人的眼睛到屏幕的距离，也称为视距。距离视觉点跃进街的在电脑平面中成像越大，距离越远成像越小，透视的单位也是像素。</p>
</blockquote>
<p>在 CSS3 中，透视要写在被观察元素的父盒子上。</p>
<h3 id="21-3d-位移-translate3d"><a class="header" href="#21-3d-位移-translate3d">2.1 3D 位移 <code>translate3d</code></a></h3>
<p>示例：</p>
<pre><code class="language-css">body {
  /* 透视 */
  perspective: 500px;
}

div {
  height: 200px;
  width: 200px;
  background-color: aqua;
  /* transform: translateX(100px) translateY(100px) translateZ(200px); */
  /* 简写 */
  transform: translate3d(400px, 100px, 200px);
}
</code></pre>
<p>注意：translateZ 一般使用单位为 px，不能像 translateX 和 translateY 那样使用百分比。</p>
<h3 id="22-3d-旋转-rotate3d"><a class="header" href="#22-3d-旋转-rotate3d">2.2 3D 旋转 <code>rotate3d</code></a></h3>
<p>2D 旋转只能使用角度旋转，3D 旋转则是可以围绕 X、Y、Z 轴进行旋转。</p>
<p>语法：</p>
<ul>
<li><code>transform: rotateX(45deg)</code></li>
<li><code>transform: rotateY(45deg)</code></li>
<li><code>transform: rotateZ(45deg)</code></li>
<li><code>transform: rotate3d(x,y,z,deg)</code>：沿着自定义轴旋转，deg 为角度</li>
</ul>
<pre><code class="language-css">div {
  height: 200px;
  width: 200px;
  background-color: aqua;
  /* transform: rotateX(45deg) rotateY(45deg) rotateZ(45deg); */
  /* 简写 */
  transform: translate3d(45deg, 45deg, 45deg);
}
</code></pre>
<h2 id="三-3d-呈现-transform-style"><a class="header" href="#三-3d-呈现-transform-style">三 3D 呈现 <code>transform-style</code></a></h2>
<p><code>transform-style</code> 用来控制子元素是否开启三维环境，默认值为 <code>flat</code>，不开启，若要开启，设置其值为 <code>preserve-3d</code>。</p>
<p>注意：<code>transform-style</code>的设置要写给父盒子，但是影响的是其子盒子。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="074-css3-特效-动画"><a class="header" href="#074-css3-特效-动画">07.4-CSS3 特效-动画</a></h1>
<h2 id="一-c3-动画概念"><a class="header" href="#一-c3-动画概念">一 C3 动画概念</a></h2>
<p>动画 animation 是 CSS3 中颠覆性特性之一，可以通过设置多个节点来精确控制一个、一组动画。相比过渡，动画可以实现更多的变化、更多的控制、连续自动播放等效果。过渡是直接从一个地方变换到另一个地方，相比之下，我们可能希望某个元素的变化过程是迂回的路径。有时，我们可能需要元素在动画运动后再回到起始的地方。这些事情无法使用过渡来实现。</p>
<p>动画基本使用示例：</p>
<pre><code class="language-css">/* 定义一个名为 move 的动画 */
@keyframes move {
  0% {
    transform: translate(0px);
  }

  100% {
    transform: translateX(1000px);
  }
}

div {
  height: 200px;
  width: 200px;
  background-color: aqua;
  /* 调用动画 */
  animation: move;
  /* 动画持续时间 */
  animation-duration: 5s;
}
</code></pre>
<p>注意：多个动画用逗号隔开。</p>
<h2 id="二-关键帧"><a class="header" href="#二-关键帧">二 关键帧</a></h2>
<h3 id="21-关键帧概念"><a class="header" href="#21-关键帧概念">2.1 关键帧概念</a></h3>
<p>为了对页面变化有更加精确的控制， CSS 提供了关键帧动画。关键帧（ keyframe）是指动画过程中某个特定时刻。我们定义一些关键帧，浏览器负责填充或者插入这些关键帧之间的帧图像：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/transform-01.svg" alt="" /></p>
<p>从原理上看，过渡其实和关键帧动画类似：我们定义第一帧（起始点）和最后一帧（结束点），浏览器计算所有中间值，使得元素可以在这些值之间平滑变换。但使用关键帧动画，我们就不再局限于只定义两个点，而是想加多少加多少。浏览器负责填充一个个点与点之间的值，直到最后一个关键帧，最终生成一系列无缝衔接的过渡。</p>
<h3 id="22-关键帧的使用"><a class="header" href="#22-关键帧的使用">2.2 关键帧的使用</a></h3>
<p>CSS 中的动画包括两部分：用来定义动画的@keyframes 规则和为元素添加动画的 animation 属性。</p>
<pre><code class="language-css">/* 为动画命名 */
@keyframes over-and-back {
  /* 第一个关键帧声明 */
  0% {
    background-color: hsl(0, 50%, 50%);
    transform: translate(0);
  }
  /* 第二个关键帧发生于动画进行到一半时 */
  50% {
    transform: translate(50px);
  }
  /* 最后一个关键帧 */
  100% {
    background-color: hsl(270, 50%, 90%);
    transform: translate(0);
  }
}

/* 为元素应用动画 */
.box {
  width: 100px;
  height: 100px;
  background-color: green;
  animation: over-and-back 1.5s linear 3;
}
</code></pre>
<p>关键帧动画都需要名称，示例中的动画被命名为 over-and-back。动画中使用百分比定义了三个关键帧。这些百分比代表每个关键帧发生于动画过程中的哪些时刻：一个在动画的开始（ 0%），一个在中间（ 50%），一个在终点（ 100%）。每个关键帧块内的声明定义了当前关键帧的样式。</p>
<p>示例中 transform 把元素从初始位置移动到右侧，然后再移回原位，但 background-color 在 50%的关键帧中并没有指定。这意味着元素会从红色（ 0%的位置）过渡到淡紫色（ 100%的位置）。在 50%的位置，背景颜色恰好是这两个颜色的中间值。</p>
<h3 id="23-动画属性"><a class="header" href="#23-动画属性">2.3 动画属性</a></h3>
<p>属性简写：<code>animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束状态</code>：</p>
<ul>
<li>animation-name：代表动画名称，就像@keyframes 规则定义的那样。</li>
<li>animation-duration：——代表动画持续时间，在本例中是 1.5s。</li>
<li>animation-timing-function：代表定时函数，用来描述动画如何加速和/或减速。可以是贝塞尔曲线或者关键字值，就像过渡使用的定时函数一样（ ease-in、ease-out，等等）。</li>
<li>animation-iteration-count： ——代表动画重复的次数。初始值默认是 1。</li>
</ul>
<p>属性汇总：</p>
<pre><code class="language-txt">@keyframes                  规范动画
animation                   所有动画属性的简写，撤了 animation-play-state
animation-name              动画名称，必填属性
animation-duration          动画一个周期花费时间，默认是 0，必填属性
animation-timing-function   动画的速度曲线，默认是 ease
animation-delay             动画何时开始，默认是 0
animation-iteration-count   动画播放次数，默认是 1，还有 infinite
animation-direction         动画下一周期是否逆向播放，默认是 normal，还有 alternate
animation-play-state        动画是否正在运行或者暂停，默认是 running，还有 pause
animation-fill-mode         动画结束后状态，保持当前状态是 forwards，回到起始状态 backwards
</code></pre>
<p>animation-timing-function 用来规定动画的速度曲线：</p>
<pre><code class="language-txt">ease            默认值，动画以低速开始，然后加快，在结束前变慢
linear          动画速度一直相同，即匀速
ease-in         动画以低速开始
ease-out        动画以低速结束
ease-in-out     动画以低速开始和结束
steps()         设定多少步，指定时间函数中的间隔数量（步长）
</code></pre>
<p>示例：</p>
<pre><code class="language-css">/* 动画在 5 秒内，出现 5 次（step）变化！ */
div {
  height: 200px;
  width: 200px;
  background-color: aqua;
  animation: move 5s forwards;
  animation-timing-function: steps(5);
}
</code></pre>
<h2 id="三-为-3d-变换添加动画"><a class="header" href="#三-为-3d-变换添加动画">三 为 3D 变换添加动画</a></h2>
<h3 id="31-示例布局"><a class="header" href="#31-示例布局">3.1 示例布局</a></h3>
<pre><code class="language-html">&lt;main class=&quot;flyin-grid&quot;&gt;
  &lt;div class=&quot;flyin-grid__item card&quot;&gt;
    &lt;img src=&quot;images/chicken1.jpg&quot; alt=&quot;a chicken&quot; /&gt;
    &lt;h4&gt;Mrs. Featherstone&lt;/h4&gt;
    &lt;p&gt;
      She may be a bit frumpy, but Mrs Featherstone gets the job done. She lays
      her largish cream-colored eggs on a daily basis. She is gregarious to a
      fault.
    &lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&quot;flyin-grid__item card&quot;&gt;
    &lt;img src=&quot;images/chicken2.jpg&quot; alt=&quot;a chicken&quot; /&gt;
    &lt;h4&gt;Hen Solo&lt;/h4&gt;
    &lt;p&gt;
      Though the most recent addition to our flock, Hen Solo is a fast favorite
      among our laying brood.
    &lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&quot;flyin-grid__item card&quot;&gt;
    &lt;img src=&quot;images/chicken3.jpg&quot; alt=&quot;a chicken&quot; /&gt;
    &lt;h4&gt;Cluck Norris&lt;/h4&gt;
    &lt;p&gt;
      Every brood has its brawler. Cluck Norris is our feistiest hen, frequently
      picking fights with other hens about laying territory and foraging space.
    &lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&quot;flyin-grid__item card&quot;&gt;
    &lt;img src=&quot;images/chicken4.jpg&quot; alt=&quot;a chicken&quot; /&gt;
    &lt;h4&gt;Peggy Schuyler&lt;/h4&gt;
    &lt;p&gt;
      Peggy was our first and friendliest hen. She is the most likely to greet
      visitors to the yard, and frequently to be found nesting in the coop.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/main&gt;
</code></pre>
<pre><code class="language-css">.flyin-grid {
  margin: 0 1rem;
}

@media (min-width: 30em) {
  .flyin-grid {
    display: flex;
    flex-wrap: wrap;
    margin: 0 5rem;
  }
  .flyin-grid__item {
    flex: 1 1 300px;
    margin-left: 0.5em;
    margin-right: 0.5em;
    max-width: 600px;
  }
  @supports (display: grid) {
    .flyin-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      grid-gap: 2em;
    }
    .flyin-grid__item {
      max-width: initial;
      margin: 0;
    }
  }
}

.card {
  margin-bottom: 1em;
  padding: 0.5em;
  background-color: white;
  color: hsl(210, 15%, 20%);
  box-shadow: 0.2em 0.5em 1em rgba(0, 0, 0, 0.3);
}
.card &gt; img {
  width: 100%;
}
</code></pre>
<h3 id="32-示例添加动画"><a class="header" href="#32-示例添加动画">3.2 示例添加动画</a></h3>
<pre><code class="language-css">.flyin-grid {
  margin: 0 1rem;
  perspective: 500px;
}
.flyin-grid__item {
  animation: fly-in 600ms ease-in;
}
@keyframes fly-in {
  0% {
    transform: translateZ(-800px) rotateY(90deg);
    opacity: 0;
  }
  56% {
    transform: translateZ(-160px) rotateY(87deg);
    opacity: 1;
  }
  100% {
    transform: translateZ(0) rotateY(0);
  }
}
</code></pre>
<h3 id="33-动画延迟和填充模式"><a class="header" href="#33-动画延迟和填充模式">3.3 动画延迟和填充模式</a></h3>
<p>错开动画开始时间，把每个元素的动画开始时间设置得比前一个稍晚一点：</p>
<pre><code class="language-css">.flyin-grid__item {
  animation: fly-in 600ms ease-in;
  /* 动画开始之前应用第一帧上的动画样式 */
  animation-fill-mode: backwards;
}
.flyin-grid__item:nth-child(2) {
  animation-delay: 0.15s;
}
.flyin-grid__item:nth-child(3) {
  animation-delay: 0.3s;
}
.flyin-grid__item:nth-child(4) {
  animation-delay: 0.45s;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="075-css3-特效-性能问题"><a class="header" href="#075-css3-特效-性能问题">07.5-CSS3 特效-性能问题</a></h1>
<h2 id="零-考虑特效的性能问题"><a class="header" href="#零-考虑特效的性能问题">零 考虑特效的性能问题</a></h2>
<p>有些变换看上去好像没有存在的必要。比如平移变换的结果，通常也可以使用相对定位来实现；对图片或者 SVG 做缩放变换，其实也可以通过设置宽高来完成，这样甚至更直观。</p>
<p>实际上，变换在浏览器中的性能要好得多。如果我们要对元素的定位使用动画（比如为 left 属性添加过渡效果），可以明显感受到性能很差。对复杂元素使用动画或者在页面内一次性对多个元素使用动画，问题尤其明显。这种性能问题在过渡和动画上都有体现。</p>
<p>如果我们要实现过渡或动画，无论什么类型，包括定位或大小操作，都应该尽可能考虑使用变换。首先要理解为什么需要这样做，我们需要先看看浏览器是如何渲染页面的。</p>
<h2 id="一-浏览器渲染过程"><a class="header" href="#一-浏览器渲染过程">一 浏览器渲染过程</a></h2>
<h3 id="11-渲染路径"><a class="header" href="#11-渲染路径">1.1 渲染路径</a></h3>
<p>渲染路径：浏览器计算好了页面上哪些样式应用于哪些元素上之后，需要把这些样式转化成屏幕上的像素，这个过程叫作渲染（ rending）。</p>
<p>渲染可以分为三个阶段：</p>
<pre><code class="language-txt">布局 --&gt; 绘制 --&gt; 合成
</code></pre>
<h3 id="12-第一阶段布局"><a class="header" href="#12-第一阶段布局">1.2 第一阶段：布局</a></h3>
<p>在第一个阶段布局中，浏览器需要计算每个元素将在屏幕上占多大空间。因为文档流的工作方式，所以一个元素的大小和位置可以影响页面上无数其他元素的大小和位置。这个阶段会解决这个问题。</p>
<p>任何时候改变一个元素的宽度或高度，或者调整位置属性（比如 top 或者 left），元素的布局都会重新计算。如果使用 JavaScript 在 DOM 中插入或者移除元素，也会重新计算布局。一旦布局发生改变，浏览器就必须重排（ reflow）页面，重新计算所有其他被移动或者缩放的元素
的布局。</p>
<h3 id="13-第二阶段绘制"><a class="header" href="#13-第二阶段绘制">1.3 第二阶段：绘制</a></h3>
<p>布局之后是绘制。这个过程就是填充像素：描绘文本，着色图片、边框和阴影。这不会真正显示在屏幕上，而是在内存中绘制。页面各部分生成了很多的图层（ layers）。</p>
<p>如果改变某个元素的背景颜色，就必须重新绘制它。但因为更改背景颜色不会影响到页面上任何元素的位置和大小，所以这种变化不需要重新计算布局。改变背景颜色比改变元素大小需要的计算操作要少。</p>
<p>某些条件下，页面元素会被提取到自己的图层。这时候，它会从页面的其他图层中独立出来单独绘制。浏览器把这个图层发送到计算机的图形处理器（ graphics processing unit， GPU）进行绘制，而不是像主图层那样使用主 CPU 绘制。这样安排是有好处的，因为 GPU 经过了充分的优
化，比较适合做这类计算。</p>
<p>这就是我们经常提到的硬件加速（ hardware acceleration），因为需要依赖于计算机上的某些硬件来推进渲染速度。多个图层就意味着需要消耗更多的内存，但好处是可以加快渲染。</p>
<h3 id="14-第三阶段合成"><a class="header" href="#14-第三阶段合成">1.4 第三阶段：合成</a></h3>
<p>在合成（ composite）阶段，浏览器收集所有绘制完成的图层，并把它们提取为最终显示在屏幕上的图像。合成过程需要按照特定顺序进行，以确保图层出现重叠时，正确的图层显示在其他图层之上。</p>
<p>opacity 和 transform 这两个属性如果发生改变，需要的渲染时间就会非常少。当我们修
改元素的这两个属性之一时，浏览器就会把元素提升到其自己的绘制图层并使用 GPU 加速。因
为元素存在于自己的图层，所以整个图像变化过程中主图层将不会发生变化，也无须重复的重绘。
如果只是对页面做一次性修改，那么通常不会感觉出这种优化可以带来明显的差异。但如果
修改的是动画的一部分，屏幕需要在一秒内发生多达几十次的更新，这种情况下渲染速度就很重
要了。大部分的屏幕每秒钟会刷新 60 次。理想情况下，动画中每次变化所需的重新计算也要至
少这么快，才能在屏幕上生成最流畅的运动轨迹。浏览器在每次重新计算的时候需要做的事情越
多，越难达到这种速度。</p>
<h2 id="二-使用-will-change-控制绘制图层"><a class="header" href="#二-使用-will-change-控制绘制图层">二 使用 will-change 控制绘制图层</a></h2>
<p>浏览器会尽可能把一些元素划归到不同的图层，这已经在优化渲染流程上取得了明显的进步。如果你对一个元素的 transform 或者 opacity 属性设置动画，现代浏览器为了使动画过程更加流畅，通常会基于包括系统资源在内的一系列因素，做出最佳处理，但有时候你可能会遇到突变或闪烁的动画。</p>
<p>如果碰到这种情况，你可以使用一个叫作 will-change 的属性对渲染图层添加控制。这个属性可以提前告知浏览器，元素的特定属性将改变。这通常意味着元素将被提升到自己的绘制图层。例如，设置了 will-change: transform 就表示我们将要改变元素的 transform 属性。</p>
<p>除非遇到性能问题，否则不要盲目添加该属性到页面，因为它会占用很多的系统资源。前后测试一下，在性能表现好时再在样式表中保留 will-change。如果想要更加深入了解该属性如何工作和是否应该使用它，可以查看 Sara Soueidan 的优秀文章 Everything You Need to KnowAbout the CSS will-change Property。</p>
<p>注意：文中表示只有 3D 变换会提升元素到自己的图层，现在已经不是这样了，最新的浏览器对 2D 变换也可以使用 GPU 加速。</p>
<p>贴士：处理过渡或者动画的时候，尽量只改变 transform 和 opacity 属性。如果有需要，可以修改那些只导致重绘而不会重新布局的属性。只有在没有其他替代方案的时候，再去修改那些影响布局的属性，并且密切关注动画中是否存在性能问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="081-css-实践-规范与实践"><a class="header" href="#081-css-实践-规范与实践">08.1-CSS 实践-规范与实践</a></h1>
<h2 id="一-css-推荐规范"><a class="header" href="#一-css-推荐规范">一 CSS 推荐规范</a></h2>
<h3 id="11-书写规范"><a class="header" href="#11-书写规范">1.1 书写规范</a></h3>
<p>多个 CSS 属性，推荐按照下列顺序进行书写：</p>
<ul>
<li>布局相关：display(最优先)、position（优先）、float（优先）、clear、visibility、overflow</li>
<li>自身属性：width、height、margin、padding、border、background</li>
<li>其他属性：CSS3 相关等</li>
</ul>
<p>示例：</p>
<pre><code class="language-css">.div {
  display: block;
  position: relative;
  float: left;
  width: 100px;
  height: 100px;
  margin: 0 10px;
  padding: 20px 0;
  font-family: Arial, 'Helavetica Neue', Helavetica, sans-serif;
}
</code></pre>
<h2 id="12-布局规范"><a class="header" href="#12-布局规范">1.2 布局规范</a></h2>
<p>p 元素用来放置文字，不推荐用来布局，因为默认 p 标签有 margin 和其他样式；</p>
<p>尽量使用 block 元素、css 的 diplay 属性实现换行，文字内容可以用 br 换行（但很少这样用）；</p>
<p>不要滥用 div，当没有其他元素可用时才用 div。比如：如果想让 link、img 这类元素在结尾换行，可以使其转换为 block 元素，这样做比放入 div、使用 br 换行要好很多；</p>
<p>margin 的规范：通常情况下，margin 都是天价在元素的 bottom 和 right，有时可以是 top 或 left。尽量避免同时在 bottom 和 top，或者 right 和 left 天假 margin，可以用 last-of-type 选择器来去掉最后一个字元素的 margin。</p>
<h3 id="13-盒模型规范"><a class="header" href="#13-盒模型规范">1.3 盒模型规范</a></h3>
<p>贴实际开发中，布局应该优先考虑标准流，规避脱标，最后才会考虑浮动和定位，比如：</p>
<ul>
<li>如果要让一个元素实现模式转化：优先使用 display</li>
<li>如果想让一个块级元素移动到另一侧：margin-left: auto;</li>
</ul>
<h2 id="二-渐进增强与优雅降级"><a class="header" href="#二-渐进增强与优雅降级">二 渐进增强与优雅降级</a></h2>
<h3 id="21-渐进增强"><a class="header" href="#21-渐进增强">2.1 渐进增强</a></h3>
<blockquote>
<p>渐进增强：在开发页面时，针对低版本的浏览器保障其基本功能，针对高级浏览器，增加效果、交互，以达到更好的体验。</p>
</blockquote>
<p>渐进增强即每一层增强代码都只在浏览器支持的情况下才被应用！比如：
<code>&lt;input type=&quot;email&quot;&gt;</code>,<code>email</code>这种类型在低版本的浏览器无法识别，会被视为 <code>text</code>。</p>
<p>一些新特性，往往会加上厂商前缀，用来告知浏览器属性适合哪个浏览器：<code>-webkit-transform: translate(0, 10px)</code>。</p>
<p>CSS3 也提供了条件规则，用来检查括号内的声明，当浏览器支持该声明，则启用块中的规则：</p>
<pre><code class="language-css">@supports (display: grid) {
  /* 若浏览器支持网格布局，则启用下面的代码块 */
}
</code></pre>
<h3 id="22-优雅降级"><a class="header" href="#22-优雅降级">2.2 优雅降级</a></h3>
<blockquote>
<p>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
</blockquote>
<p>渐进增强是向上兼容，优雅降级是向下兼容。在当下互联网快速发展的阶段，没有必要再时刻想着低版本浏览器了，而是一开始就构建完整的效果，根据实际情况，修补低版本浏览器问题。</p>
<h3 id="23-html-与-css-的验证"><a class="header" href="#23-html-与-css-的验证">2.3 HTML 与 CSS 的验证</a></h3>
<p>HTML 兼容性验证地址：<a href="http://validator.w3.org">http://validator.w3.org</a>
CSS 兼容性验证地址：<a href="http://jigsaw.w3.org/css-validator">http://jigsaw.w3.org/css-validator</a></p>
<h2 id="三-一些制作案例"><a class="header" href="#三-一些制作案例">三 一些制作案例</a></h2>
<h3 id="31-logo-的写法"><a class="header" href="#31-logo-的写法">3.1 Logo 的写法</a></h3>
<p>Logo 最好使用背景图片：</p>
<pre><code class="language-html">&lt;style&gt;
  .logo a {
    display: block;
    width: 100%;
    height: 56px;
    background: url(../img/logo.png) no-repeat;
    text-indent: -999px;
    overflow: hidden;
  }
&lt;/style&gt;

&lt;div class=&quot;logo&quot;&gt;
  &lt;h1&gt;&lt;a href=&quot;./index.html&quot;&gt;XX 网站&lt;/a&gt;&lt;/h1&gt;
&lt;/div&gt;
</code></pre>
<p>使用 a 连接是为了方便用户点击 logo 返回，使用 h1 标签是为了提升搜索引擎收录的权重。当然也可以不采用 <code>text-indent</code> 的方式，也可以将 <code>font-size:0</code> 也能隐藏不必要的 logo 说明文字。</p>
<h2 id="32-制作三角形"><a class="header" href="#32-制作三角形">3.2 制作三角形</a></h2>
<p>如下所示，盒子没有宽高，但是设置了边框后，会出现三角形组成的图案：</p>
<pre><code class="language-css">    div {
        width: 0;
        height: 0;
        border-top: 1px solid blue;
        border-right: 1px solid red;
        border-bottom: 1px solid green;
        border-;eft: 1px solid pink;
    }
</code></pre>
<p>那么现在制作一个三角形可以如下书写：</p>
<pre><code class="language-css">    p {
        width: 0;
        height: 0;
        border-style: solid;
        border-widthL 10px;
        border-color: red transparent transparent transparent;      /* 需要哪个方向的三角形就设置哪个方向为非透明 */

        /* 兼容性 */
        font-size: 0;
        line-height: 0;
    }
</code></pre>
<h3 id="33-精灵图"><a class="header" href="#33-精灵图">3.3 精灵图</a></h3>
<p>多个 UI 图标的请求会明显减少网页性能，精灵图（也称呼为雪碧图）是将这些 UI 按照一定的位置合并为一张图片，将多个图片请求减小为一张图片请求，在前端，不同的图片使用坐标即可。</p>
<p>示例：</p>
<pre><code class="language-css">.icon {
  width: 23px;
  height: 23px;
  /* 浏览器坐标系为圆点往右为正，圆点往上移动为负。 */
  background: url(./images/icon.icon) no-repeat -100px -120px;
}
</code></pre>
<h3 id="34-滑动门"><a class="header" href="#34-滑动门">3.4 滑动门</a></h3>
<p>导航标签可以依据文字多少实现背景图的自动伸缩，这里需要用到滑动门技术。</p>
<p>示例：</p>
<pre><code class="language-html">&lt;style&gt;
  a {
    display: inline-block;
    height: 34px;
    background: url(images/to.png) no-repeat; /* 背景图左对齐 */
    padding-left: 15px;
  }
  a span {
    display: inline-block;
    height: 34px;
    background: url(images/to.png) no-repeat right top;
    /* 背景图右对齐 */
    padding-right: 15px;
  }
&lt;/style&gt;

&lt;!--
        a 设置导航栏某个标签的左侧背景：需要敞开盒子，所以要转换为行内块
        span 设置右侧背景。
        由于导航栏都是链接，所以 a 要包含 span
--&gt;
&lt;a href=&quot;#&quot;&gt;&lt;span&gt;首页&lt;/span&gt;&lt;/a&gt;
&lt;a href=&quot;#&quot;&gt;&lt;span&gt;联系我&lt;/span&gt;&lt;/a&gt;
</code></pre>
<h3 id="35-字体图标"><a class="header" href="#35-字体图标">3.5 字体图标</a></h3>
<p>一些 UI 最好不使用图片表示，会有很多问题：</p>
<ul>
<li>图片体积较大</li>
<li>图片也会额外增加请求数量</li>
<li>图片放大会出现失真</li>
</ul>
<p>如果图片改用字体来制作，那么就不会有上述问题，这便是字体图标。字体图标由于受到文字样式控制，可以很容易实现大小改变、阴影等特效，字体图标是移动 Web 开发的优秀适配工具。</p>
<p>字体图标制作流程：</p>
<pre><code class="language-txt">一：制作 svg 格式的图片
二：将图片转换为字体，在线转换的网站有：icommon.io   iconfont.cn
</code></pre>
<h2 id="四-伪元素与-overflow"><a class="header" href="#四-伪元素与-overflow">四 伪元素与 overflow</a></h2>
<pre><code class="language-css">*,
::before,
::after {
  box-sizing: border-box;
}
</code></pre>
<p>将这段代码放到样式表开头已是普遍做法了。但是，如果在网页中使用了带样式的第三方组件，就可能会因此破坏其中一些组件的布局，尤其是当第三方组件在开发 CSS 的过程中没有考虑到使用者会修改盒模型时。因为全局设置 border-box 时使用的通用选择器会选中第三方组件内的每个元素，修改盒模型可能会有问题，所以最终需要写另外的样式将组件内的元素恢复为 content-box。</p>
<p>用 overflow 属性可以控制溢出内容的行为，该属性支持以下 4 个值。</p>
<ul>
<li>visible：默认值，所有内容可见，即使溢出容器边缘。</li>
<li>hidden：溢出容器内边距边缘的内容被裁剪，无法看见。</li>
<li>scroll：容器出现滚动条，用户可以通过滚动查看剩余内容。在一些操作系统上，会出现水平和垂直两种滚动条，即使所有内容都可见（不溢出）。不过，在这种情况下，滚动条不可滚动（置灰）。</li>
<li>auto：只有内容溢出时容器才会出现滚动条</li>
</ul>
<p>请谨慎地使用滚动条。浏览器给网页最外层加上了滚动条，如果网页内部再嵌套滚动区域，用户就会很反感。如果用户使用鼠标滚轮滚动网页，当鼠标到达一个较小的滚动区域，滚轮就会停止滚动网页，转而滚动较小的区域。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="082-css-实践-2-可见性与居中"><a class="header" href="#082-css-实践-2-可见性与居中">08.2-CSS 实践-2-可见性与居中</a></h1>
<h2 id="一-css-可见性"><a class="header" href="#一-css-可见性">一 CSS 可见性</a></h2>
<h3 id="11-显示与隐藏的设置方式"><a class="header" href="#11-显示与隐藏的设置方式">1.1 显示与隐藏的设置方式</a></h3>
<p>元素显示与隐藏的多种设置方式：</p>
<pre><code class="language-txt">display: none;              隐藏元素（block 为显示），不占位置！！！一般使用该方式进行元素显示/隐藏
visibility:hidden           盒子不可见，占据位置，使用较少

overflow:hidden             将容器中超出部分隐藏
opacity:0                   盒子透明，占据位置
position/top/left/...-999px 盒子定位到非可视区，占据位置
text-indent:                文本缩进，可以实现内容移除效果
</code></pre>
<h3 id="12-overflow"><a class="header" href="#12-overflow">1.2 overflow</a></h3>
<p>overfllow 是溢出的意思，对超出容器的部分进行设置：</p>
<pre><code class="language-txt">overfllow:visible;          默认值，内容不会被修剪，会超出元素框
overfllow:hidden;           内容被修剪，超出隐藏，用来清除浮动，还可以保证盒子里的内容不会超出盒子范围
overfllow:scroll;           内容被修剪，超出以滚动条查看
overfllow:auto;             如果内容出现修剪，则滚动条查看
</code></pre>
<h2 id="二-居中"><a class="header" href="#二-居中">二 居中</a></h2>
<h3 id="21-水平居中文本行内元素行内块元素在块级父元素中的对齐"><a class="header" href="#21-水平居中文本行内元素行内块元素在块级父元素中的对齐">2.1 水平居中：文本、行内元素、行内块元素，在块级父元素中的对齐</a></h3>
<pre><code class="language-html">&lt;!--
    优点：简单优雅，兼容性好
    缺点：只对行内内容有效，且子元素宽度若大于父元素，则无效！！
--&gt;
&lt;style&gt;
  #father {
    width: 500px;
    height: 500px;
    background-color: aqua;
    text-align: center;
  }

  #son {
    background-color: cadetblue;
  }
&lt;/style&gt;

&lt;div id=&quot;father&quot;&gt;
  &lt;span id=&quot;son&quot;&gt;水平居中&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<h3 id="22-单个块级元素水平居中"><a class="header" href="#22-单个块级元素水平居中">2.2 单个块级元素水平居中</a></h3>
<pre><code class="language-html">&lt;!--
    优点：简单优雅，兼容性好
    缺点：子元素宽度要小于父元素！子元素宽度必须为定宽，值不能为 auto
--&gt;
&lt;style&gt;
  #father {
    width: 500px;
    height: 500px;
    background-color: aqua;
  }

  #son {
    margin: 0 auto;
    width: 200px;
    height: 200px;
    background-color: cadetblue;
  }
&lt;/style&gt;

&lt;div id=&quot;father&quot;&gt;
  &lt;div id=&quot;son&quot;&gt;水平居中&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="23-多个块级元素在父元素内水平居中"><a class="header" href="#23-多个块级元素在父元素内水平居中">2.3 多个块级元素在父元素内水平居中</a></h3>
<pre><code class="language-html">&lt;!--
    优点：简单，兼容性好
    缺点：多个块级元素转换为行内块之后，元素之间存在间距！解决方案：父元素设置 font-size:0，子元素单独设置字体大小
    --&gt;
&lt;style&gt;
  #father {
    width: 500px;
    height: 500px;
    background-color: aqua;
    text-align: center;
  }

  #son {
    display: inline-block;
    background-color: cadetblue;
  }
&lt;/style&gt;

&lt;div id=&quot;father&quot;&gt;
  &lt;div id=&quot;son1&quot;&gt;水平居中 1&lt;/div&gt;
  &lt;div id=&quot;son2&quot;&gt;水平居中 2&lt;/div&gt;
  &lt;div id=&quot;son3&quot;&gt;水平居中 3&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="24-绝对定位实现水平居中"><a class="header" href="#24-绝对定位实现水平居中">2.4 绝对定位实现水平居中</a></h3>
<pre><code class="language-html">&lt;!--
    优点：margin-left 兼容性更好，且块级、行内都可以实现。
    缺点：C3 的使用更便捷，但是兼容性不好
    --&gt;
&lt;style&gt;
  #father {
    position: relative;
    width: 500px;
    height: 500px;
    background-color: aqua;
  }

  #son {
    position: absolute;
    top: 0;
    left: 50%;
    /* 自身宽度一半：margin-left:-50px */
    transform: translateX(-50%);
    width: 200px;
    height: 200px;
    background-color: cadetblue;
  }
&lt;/style&gt;

&lt;div id=&quot;father&quot;&gt;
  &lt;div id=&quot;son&quot;&gt;水平居中 1&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="25-flex-实现水平居中"><a class="header" href="#25-flex-实现水平居中">2.5 flex 实现水平居中</a></h3>
<pre><code class="language-html">&lt;!--
    优点：简单
    缺点：兼容性不好，适合在手机端使用
    --&gt;
&lt;style&gt;
  #father {
    display: flex;
    justify-content: center;
    width: 500px;
    height: 500px;
    background-color: aqua;
  }

  #son {
    width: 200px;
    height: 200px;
    background-color: cadetblue;
  }
&lt;/style&gt;

&lt;div id=&quot;father&quot;&gt;
  &lt;div id=&quot;son&quot;&gt;水平居中 1&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="三-行高-line-height"><a class="header" href="#三-行高-line-height">三 行高 line-height</a></h2>
<h3 id="31-认识行高"><a class="header" href="#31-认识行高">3.1 认识行高</a></h3>
<p>在上述导航案例中，只实现了文字的垂直居中，水平居中依赖于行高的设置。在 CSS 中的文字，有四条线来控制文字的高度：</p>
<p><img src="%E9%99%84%E5%BD%95-HTML%E4%B8%8ECSS/../images/css/css-01.png" alt="行高" /></p>
<p>行高：两行文本中基线的距离！！</p>
<h3 id="32-单行文本垂直居中"><a class="header" href="#32-单行文本垂直居中">3.2 单行文本垂直居中</a></h3>
<p>在 CSS 中，一个容器（元素）其高度为：<code>内容高度 + 上间距 + 下间距</code>，显然文字容器的高度为：<code>文字大小 + 上间距 + 下间距</code>。</p>
<p>行高若等于容器高度，即：<code>行高 = 文字大小 + 上间距 + 下间距</code>，则文字水平居中。</p>
<p>Chrome 默认的行高为 18px。</p>
<p>上述案例中，容器上下边距都是 0，若要实现导航的垂直居中：</p>
<pre><code class="language-css">a {
  display: inline-block;
  width: 100px;
  height: 30px;
  line-height: 30px;
  background-color: pink;
  text-align: center;
  text-decoration: none;
}
</code></pre>
<p>行高越大，证明文字距离上边距越远，文字就会被挤到下方，反之亦然。</p>
<h3 id="33-行高特性"><a class="header" href="#33-行高特性">3.3 行高特性</a></h3>
<p>当给一个独立的元素设置行高值的时候，除了以 px 为单位的行高值与文字大小无关，其他都与文字大小有关（与文字大小的积）。</p>
<p>行高可以继承。当父元素设置了行高值（不带单位除外），子元素的行高值都是父元素行高值乘以父元素文字大小。</p>
<p>总结图表：
| 给父元素设置行高 | 子元素行高结果 |
| :------| ------: |
| px | 行高=父元素行高|
| em | 行高=父元素文字大小<em>行高|
| % | 行高=父元素文字大小</em>行高 |
| 不带单位 | 行高=子元素文字大小*行高|</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-编程思想-声明式与命令式"><a class="header" href="#011-编程思想-声明式与命令式">01.1-编程思想-声明式与命令式</a></h1>
<h2 id="一-函数式编程概念"><a class="header" href="#一-函数式编程概念">一 函数式编程概念</a></h2>
<h3 id="11-数学函数"><a class="header" href="#11-数学函数">1.1 数学函数</a></h3>
<p>函数式编程其实是数学函数及其思想在编程领域的实践。在数学概念中，函数可以写成如下形式：</p>
<pre><code class="language-js">// 函数f，以X为参数，输出Y
f(x) = Y
</code></pre>
<p>数学的函数包含以下几个关键点：</p>
<ul>
<li>函数必须总是接收一个参数</li>
<li>函数必须总是返回一个值</li>
<li>韩式应该一句接收到的参数运行，而不是一句外部环境运行</li>
<li>对于一个给定的 X，只会输出一个 Y</li>
</ul>
<p>下面的函数不符合数学函数的定义，因为 increment 的返回值依赖了外部环境，即 counter 变量，counter 发生了变化，则函数的返回值也会受到影响，这种现象可以称为 <strong>副作用</strong>：</p>
<pre><code class="language-js">let counter = 0
function increment() {
  return counter++
}
</code></pre>
<p>经过如下修改，将 counter 转换为参数，则消除了副作用，可以符合数学概念：</p>
<pre><code class="language-js">function increment(counter) {
  return counter++
}
</code></pre>
<h3 id="12-命令式与声明式"><a class="header" href="#12-命令式与声明式">1.2 命令式与声明式</a></h3>
<p>函数式编程是一种<strong>声明式</strong>编程范式，以此建立的函数能够摆脱依赖输入就可以完成函数逻辑（函数体），这样可以保证函数无副作用，且在多次调用时能返回相同的结果。简单来说就是该范式描述了一系列操作，但并不会暴露他们是如何实现的，或者数据流是如何穿过他们的。</p>
<p>假设要将一个数组中所有数转化为对应的平方，命令式编程的步骤是：</p>
<pre><code class="language-js">const arr = [0, 1, 2, 3, 4]

for (let i = 0; i &lt; arr.length; i++) {
  arr[i] = Math.pow(arr[i], 2)
}

console.log(arr)
</code></pre>
<p>声明式编程的步骤是：</p>
<pre><code class="language-js">const arr = [0, 1, 2, 3, 4]

arr.map((num) =&gt; {
  return Math.pow(num, 2)
})

console.log(arr)
</code></pre>
<p>由上可见，命令式编程很具体的告诉了计算机如何执行某个任务，而声明式编程是将程序的描述与求值分离开的，只关注各种表达式来描述程序逻辑，而不一定知名其控制流或状态的改变。示例中将循环计数器、数组索引等问题都交给了抽象好的 map 函数去处理，向开发者隐藏了细节。</p>
<h3 id="13-理解程序控制流"><a class="header" href="#13-理解程序控制流">1.3 理解程序控制流</a></h3>
<p>在函数式编程中，一切都是函数，甚至是控制流语句也可以演变为函数。</p>
<p>命令式程序的控制流存在大量的循环和分支，如下所示：</p>
<pre><code class="language-js">let loop = optC()
while (loop) {
  let condition = optA()
  if (condition) {
    optB1()
  } else {
    optB2()
  }
  loop = optC()
}
optD()
</code></pre>
<p><img src="%E9%99%84%E5%BD%95-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/../images/funcs/funcs-03.svg" alt="流程" /></p>
<p>如果使用函数式开发风格操作数据结构，则会将数据与控制流视为一些高级组建的简单链接，代码类似：</p>
<pre><code class="language-js">optA().optB().optC().optD()
</code></pre>
<p><img src="%E9%99%84%E5%BD%95-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/../images/funcs/funcs-04.svg" alt="流程" /></p>
<h2 id="二-函数式编程中函数的特性"><a class="header" href="#二-函数式编程中函数的特性">二 函数式编程中函数的特性</a></h2>
<h3 id="21-纯函数"><a class="header" href="#21-纯函数">2.1 纯函数</a></h3>
<p>1.1 中的第一个示例读取并修改了外部变量，即对外部资源产生了副作用，此外还有类似 Date.now() 这样的方法，其结果永远不会一致，因为它总是依赖于一个不断变化的因素--时间。而通过将 counter 参数化则让 increment 消除了副作用。像这种没有副作用和状态变化的函数，也称为<strong>纯函数</strong>。</p>
<p>纯函数具备的特性有：</p>
<ul>
<li>仅取决于提供的输入，而不依赖于任何在函数求值期间、调用间隔时可能变化的隐藏状态和外部状态</li>
<li>不会造成超出其作用域的变化，例如：修改全局对象或引用传递的参数</li>
</ul>
<p>函数式编程提倡使用纯函数，旨在尽可能的提高代码的无状态性、不变性，因为无状态的代码不会改变或者破坏全局的状态。</p>
<p>下列行为都会产生副作用：</p>
<ul>
<li>改变一个全局的变量、属性或数据结构 。</li>
<li>改变一个函数参数的原始值。</li>
<li>处理用户输入。</li>
<li>抛出一个异常，除非它又被当前函数捕获了 ．</li>
<li>屏幕打印或记录日志 。</li>
<li>查询 HTML 丈档、浏览器的 cookie 或访问数据库 。</li>
</ul>
<p>下面是 showStudent() 方法，该方法通过伪数据库 db 可以查询到学生信息，并将学生信息显示在浏览器上：</p>
<pre><code class="language-js">const db = {
  list: [
    { id: 1, name: 'lisi' },
    { id: 2, name: 'ww' },
    { id: 3, name: 'zs' },
  ],
  get: (id) =&gt; {
    let res = null
    db.list.map((item) =&gt; {
      if (item.id === id) {
        res = item
      }
    })
    return res
  },
}

let elementID = 'box'
function showStudent(id) {
  const s = db.get(id)
  if (s === null) {
    throw new Error('Student not found')
  }

  document.querySelector(`#${elementID}`).innerHTML = `${s.id},
        ${s.name}
        `
}

showStudent(1)
</code></pre>
<p>showStudent 函数将一些副作用暴露到了作用域之外：</p>
<ul>
<li>该函数与一个外部变量 db 进行了交互，而该函数签名中并没有声明 db 参数。 一旦 db 引用为 null 或在调用间改变，就会导致完全不同的结果</li>
<li>全局变量 elementid 可能随时改变，难以控制 。</li>
<li>HTML 元素被直接修改了。 HTML 文档（ DOM ）本身是一个可变的、共享全局资源。</li>
<li>如果没有找到学生，该函数可能会抛出一个异常，这将导致整个程序的找回退并突然结束。</li>
</ul>
<p>上述函数一方面函数依赖了外部资源，使得代码很不灵活，很难维护并且难以测试。另一方面，使用纯函数才能让其函数签名对所描述的所有形参（输入集）都有明确的约定，使其更易于理解和使用。</p>
<p>如果我们要将上述函数修改为纯函数，则方案为：</p>
<ul>
<li>将这个长函数分离成多个具有单一职责的短函数。</li>
<li>显式地将完成功能所需的依赖都定义为函数参数，以减少副作用的数量 。</li>
</ul>
<pre><code class="language-js">const db = {
  list: [
    { id: 1, name: 'lisi' },
    { id: 2, name: 'ww' },
    { id: 3, name: 'zs' },
  ],
  get: (id) =&gt; {
    let res = null
    db.list.map((item) =&gt; {
      if (item.id === id) {
        res = item
      }
    })
    return res
  },
}
let elementID = 'box'

const append = (elementID) =&gt; {
  return (template) =&gt; {
    document.querySelector(`#${elementID}`).innerHTML = template
  }
}

const find = (db) =&gt; {
  return (id) =&gt; {
    const obj = db.get(id)
    if (obj === null) {
      throw new Error('obj not found')
    }
    return obj
  }
}

const csv = (s) =&gt; {
  return `${s.id},
    ${s.name}
    `
}

const run = (appendEd, csv, findEd) =&gt; {
  return (id) =&gt; {
    const s = findEd(id)
    appendEd(csv(s))
  }
}

const showStudent = run(append('box'), csv, find(db))

showStudent(1)
</code></pre>
<p>尽管这个程序只有些许的改进，但是它开始展现出许多的优势。</p>
<ul>
<li>它灵活了很多，因为现在有三个可以被重用的组件 。</li>
<li>这种细粒度函数的重用是提高 工作效率的 一种手段，因为你可以大大减少需要主动维护的代码量 。</li>
<li>声明式的代码风格提供了程序需要执行的那些高阶步骤的 一个清晰视图 ，增强了代码的可读性 。</li>
<li>更重要的是，与 HTML 对象的文互被移动到一个羊拙的函数中，将纯函数从不纯的行为中分离出来。</li>
</ul>
<h3 id="22-引用透明"><a class="header" href="#22-引用透明">2.2 引用透明</a></h3>
<p>如果一个函数对于相同的输入始终产生相同的结果，那么它就是<strong>引用透明</strong>（referential transparency）的。</p>
<p>下面的示例中，由于受到外部全局作用域的影响，counter 发生变化，那么函数返回值也会发生变化，不会固定，那么该函数就 不是引用透明的：</p>
<pre><code class="language-js">let counter = 0

// 引用不透明
// function increment() {
//   return counter++
// }

// 引用透明
function increment(counter) {
  return counter++
}
</code></pre>
<p>2.1 的程序仍然有一些枝节问题需要解决，但减少副作用能够在修改各种外部条件时使程序不那么脆弱。如果仔细看一下 find 函数，就会发现它有一个可以产生异常的检查 null 值的分支。</p>
<p>由于函数的逻辑不受全局变量影响，引用透明可以实现替换模型（substitution model），可以直接替换函数结果，如下所示：</p>
<pre><code class="language-js">// 定义一个纯函数
const identity = (i) =&gt; {
  return i
}

// 其他地方使用该纯函数
sum(4, 5) + identity(1)
// 根据引用透明，可以直接替换
sum(4, 5) + 1
</code></pre>
<p>凭借替换模型，可以在<strong>并发代码</strong>、<strong>可缓存代码</strong>中发挥重要作用：</p>
<ul>
<li>凭借替换模型，可以轻松的运用多线程运行上述代码，无需同步操作。因为同步的原因是线程在并发运行时依赖了全局数据。</li>
<li>因为函数为给定的输入返回了相同的值，实际上也缓存了它，这在计算类似阶乘的函数中可以应用到。</li>
</ul>
<h3 id="23-可缓存性"><a class="header" href="#23-可缓存性">2.3 可缓存性</a></h3>
<p>在实践中我们可能会处理大量的数据，例如根据日期，得到当日相关的数据，并处理成前端能够使用的数据。 假设我们封装了一个 process 方法来处理每天的数据，而这个处理过程会很复杂。 如果不缓存处理结果，那么每次想要得到当天的数据时，就不得不从原始数据再转换一次。当数据的处理足够复杂时，那么很可能不是性能最优的解决方案。而纯函数的特点是，相同的输入总能得到相同的输出，因此如果将处理过的每一天的数据都缓存起来，那么当第二次或者更多次的想要得到当天的数据时，就不用经历复杂的处理过程了。</p>
<pre><code class="language-js">const withPross = (base) =&gt; {
  const cache = {}
  return function (params) {
    let date = arguments[0]
    if (cache[date]) {
      return cache[date]
    }
    return base.apply(base, arguments)
  }
}

// 传入日期，获取当天数据
const process = (data) =&gt; {
  let result = ''

  // 其他业务处理

  return result
}
// 经过上面一句代码处理之后，就可以使用 ＿process 来获取我们想要的数据了
// 如采数据存在 ， 就返回缓存中的数据；如果不存在，则调用 process 方法重新获
const p = withPross(process)
console.log(p('2023-01-01'))
console.log(p('2023-02-03'))
console.log(p('2023-03-05'))
</code></pre>
<h2 id="三-一些术语"><a class="header" href="#三-一些术语">三 一些术语</a></h2>
<h3 id="31-高阶函数"><a class="header" href="#31-高阶函数">3.1 高阶函数</a></h3>
<p>在 JavaScript 中，函数是一等公民，也可以被看做数据类型，所以函数可以赋值给变量，作为参数传递，也可以被其他函数返回，简单来说：函数即是数据。</p>
<p>能够让基础函数获得额外能力的函数就是高阶函数（其实就是接收了一个函数为参数的函数），本质上是一个封装公共逻辑的过程，比如数组的一些方法：some、sort、map。</p>
<h3 id="32-一元函数二元函数"><a class="header" href="#32-一元函数二元函数">3.2 一元函数、二元函数</a></h3>
<p>一元函数是只接受一个参数（unary）的函数，同理，二元函数是接收两个参数的函数，依次类推。</p>
<h3 id="33-变参函数"><a class="header" href="#33-变参函数">3.3 变参函数</a></h3>
<p>接收可变数量参数的函数是变参函数，JavaScript 中 arguments 对象可以捕获到该函数的额外参数，ES6 后可以使用扩展运算符：</p>
<pre><code class="language-js">const fn = (a, b, ...variadic) =&gt; {
  console.log(variadic)
}
fn(1, 2, 3, 4) // [3,4]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="012-编程思想-函数式编程范式"><a class="header" href="#012-编程思想-函数式编程范式">01.2-编程思想-函数式编程范式</a></h1>
<h2 id="一-函数式编程操作总结"><a class="header" href="#一-函数式编程操作总结">一 函数式编程操作总结</a></h2>
<p>函数式编程是指为了创建不可变程序，通过消除外部可见的富足用，来对纯函数的声明式的求值过程。</p>
<p>JavaScript 应用很容易出现严重依赖外部共享变量的地方，也容易写出存在很多分支、没有清晰结构的大函数，即使是一些由很多文件组成的模块化应用，也会形成一种共享的可变全局数据网，导致难以跟踪和调试。尝试思考 <strong>纯</strong> 的操作，将函数看做永不会修改数据的 <strong>闭合功能单元</strong>，可以在很大程度上减少潜在 BUG 的出现。</p>
<p>函数式编程的操作总结：</p>
<ul>
<li>促使开发者将任务分解成简单的函数</li>
<li>使用流式的调用链来处理数据</li>
<li>通过响应式范式降低时间驱动代码的复杂性</li>
</ul>
<h2 id="二-函数式编程范式"><a class="header" href="#二-函数式编程范式">二 函数式编程范式</a></h2>
<h3 id="21-分解组合任务"><a class="header" href="#21-分解组合任务">2.1 分解、组合任务</a></h3>
<p>从宏观上看，函数式编程实际上是分解和组合之间的相互作用：</p>
<ul>
<li>将程序拆分为小片段</li>
<li>将小片段连接到一起</li>
</ul>
<p>函数式编程这种二元性，才让程序变得模块化、高效，模块化单元也即是函数本身，这与单一职责原则息息相关。</p>
<p>下面是查询学生信息程序的分解：</p>
<p><img src="%E9%99%84%E5%BD%95-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/../images/funcs/funcs-01.svg" alt="分解任务" /></p>
<p>run() 函数是用来组合各种函数的，最终实现整个程序，这涉及到了函数式编程的一个重要技术：<strong>组合</strong>。两个函数组合为一个新的函数，它拿到一个函数的输出，并将其传递到另外一个函数中：</p>
<pre><code class="language-js">// f 组合上 g
f · g = f(g(x))
</code></pre>
<p>两个函数能组合的条件的是：它们必须在参数数目及参数类型上形成一致：</p>
<pre><code class="language-js">const showStudent = run(append('box'), csv, find(db))

showStudent(1)
</code></pre>
<p><img src="%E9%99%84%E5%BD%95-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/../images/funcs/funcs-02.svg" alt="组合任务" /></p>
<p>函数的组合可以提高抽象的层次，用来清晰地够了代码的所有步骤，但又不暴露任何底层细节。run() 函数接收函数为参数，被称为 <strong>高阶函数</strong>。</p>
<h3 id="22-流式链处理数据"><a class="header" href="#22-流式链处理数据">2.2 流式链处理数据</a></h3>
<p>链其实是一连串函数的调用，类似 jQuery 的代码，共享一个通用的对象返回值（$/jQuery）。</p>
<p>与组合类似，链也有助于写出简明扼要的代码，常用于函数式、响应式 JavaScript 类库。</p>
<p>假设已知选课数据，计算选了多门课的学生的平均成绩，命令式的实现是：</p>
<pre><code class="language-js">const data = [
  { enrolled: 1, result: 90 },
  { enrolled: 2, result: 78 },
  { enrolled: 1, result: 63 },
]

let totalResults = 0
let totalStudents = 0

for (let i = 0; i &lt; data.length; i++) {
  let s = data[i]
  if (s !== null) {
    if (s.enrolled &gt; 1) {
      totalResults += s.result
      totalStudents++
    }
  }
}

let average = totalResults / totalStudents
console.log(average) // 78
</code></pre>
<p>如果现在使用函数式编程思维解决问题，则有三个步骤：</p>
<ul>
<li>选择选课数大于 1 的学生</li>
<li>获取他们的成绩</li>
<li>计算他们的呢平均成绩</li>
</ul>
<p>函数链是一种惰性计算程序，这意味着当需要时才会执行。这对程序性能是有利的，因为可以避免执行可能包含一些永不会使用的内容的整个代码序列，节省宝贵的 CPU 计算周期，最终有模拟了其他函数式语言的按需调用的行为：</p>
<pre><code class="language-js">// lodash
const data = [
  { enrolled: 1, result: 90 },
  { enrolled: 2, result: 78 },
  { enrolled: 1, result: 63 },
]

_.chain(
  data
    .filter((student) =&gt; student.enrolled &gt; 1)
    .pluck('result')
    .average()
    .value()
)
</code></pre>
<p>与命令式程序比较，循环、条件语句被消除了，而且一些错误处理也被略过了。</p>
<h3 id="23-复杂异步应用中的响应式范式"><a class="header" href="#23-复杂异步应用中的响应式范式">2.3 复杂异步应用中的响应式范式</a></h3>
<p>响应式范式可以提高代码的抽象级别，对优化类似 Ajax 这种异步场景、事件驱动程序代码有恩达的帮助。</p>
<p>下面是命令式代码，通过按键获取学生信息：</p>
<pre><code class="language-js">let valid = false
let elem = document.querySelector('#stu')
elem.onkeyup = function () {
  let val = elem.value
  if (vla !== null &amp;&amp; val.length !== 0) {
    val = val.replace(/^\s*|\s*$|\-s/g, '')
    if (val.length === 9) {
      console.log(`Valid id: ${val}!`)
      valid = true
    }
  } else {
    console.log('Invalid id: ${val}!')
  }
}
</code></pre>
<p>使用响应式编程范式里的 observable 订阅一个数据流，就可以通过组合、链式操作优雅的处理数据：</p>
<pre><code class="language-js">Rx.Observable.fromEvent(document.querySelector('#stu'), 'keyup')
  .map((input) =&gt; input.srcElement.value)
  .filter((id) =&gt; id !== null &amp;&amp; id.length !== 0)
  .map((id) =&gt; id.replace(/^\s*|\s*$|\-s/g, ''))
  .skipWhile((id) =&gt; id.length !== 9)
  .subscribe((validID) =&gt; console.log('Invalid id: ${validID}!'))
</code></pre>
<h2 id="三-面向对象编程与函数式编程区别"><a class="header" href="#三-面向对象编程与函数式编程区别">三 面向对象编程与函数式编程区别</a></h2>
<blockquote>
<p>面向对象编程（ OO ）通过封装变化使得代码更易理解 。
函数式编程（ FP ）通过最小化变化使得代码更易理解。</p>
</blockquote>
<p>函数式与面向对象在一定层面上都是为了：提升代码复用率，实现抽象、封装。但是面向对象的应用大多是命令式的，所以在很大程度上依赖封装来保护自身和继承可变状态的完整性，只能通过实例方法来暴露、修改这些状态。这样做就会导致对象的数据与其具体行为以一种内聚的包裹形式紧紧耦合在一起。不过这正是面向对象程序的目的，即：对象是抽象的核心。</p>
<p>函数式编程不需要隐藏数据，通常使用一些更小的且简单的数据类型。由于一切都是不可变的，对象都是可以直接拿来使用的，而且是通过定义在对象作用域外的函数来实现的。即：数据与行为是松耦合的，函数是抽显得主要形式。</p>
<p>面向对象的程序设计通过特定的行为将很多数据类型逻辑地连接在一起，函数式编程则关注如何在这些数据类型之上通过组合来连接各种操作。 因此存在一个两种编程范式
都可以被有效利用的平衡点。 需要把对象视为不可变的实体或值，并将它们的功能拆分成可应用在该对象上的函数，如下的一个 Person 中的方法：</p>
<pre><code class="language-js">class Person {
  get fullname() {
    return [this.firstname, this.lastname].join(' ')
  }
}

// 修改为：
let fullname = (person) =&gt; [person.firstname, person.lastname].join(' ')
</code></pre>
<p>上述示例可以避免使用 this 引用来访问对象的数据。因为 this 是有缺点的：this 给与超出方法作用域的实例层级的数据访问能力，导致了副作用。</p>
<p>下面的示例演示了使用面向对象方式找到同一地址的人、同一地址且同一学校的人的两个方法：</p>
<pre><code class="language-js">class Person {
  constructor(firstname, lastname, id) {
    this.firstname = firstname
    this.lastname = lastname
    this.id = id
    this.address = null
  }

  // 找到同一地址的人
  findSameAddress(friends) {
    const result = []
    for (let idx in friends) {
      if (this.address === friends[idx].address) {
        result.push(friends[idx])
      }
    }
    return result
  }
}

class Student extends Person {
  constructor(firstname, lastname, id, school) {
    super(firstname, lastname, id)
    this.school = school
  }
  // 找到同一地址同一学校的人
  findSameAddressAndSchool(friends) {
    const closeFrineds = super.findSameAddress(friends)
    const result = []
    for (let idx in closeFrineds) {
      if (this.school === closeFrineds[idx].school) {
        result.push(closeFrineds[idx])
      }
    }
    return result
  }
}

const p1 = new Student('张', '三', 1, '育新小学')
p1.address = '中国'
const p2 = new Student('李', '四', 2, '育才小学')
p2.address = '中国'
const p3 = new Student('王', '五', 3, '育新小学')
p3.address = '中国'
const p4 = new Student('James', 'Jackson', 4, '育才小学')
p4.address = '美国'
const p5 = new Student('Gem', 'Green', 5, '佐治亚小学')
p5.address = '美国'

// 找到和 p1 一个地址的人
let r1 = p1.findSameAddress([p2, p3, p4, p5])
console.log(r1)

// 找到和p1 一个地址、一个学校的人
let r2 = p1.findSameAddressAndSchool([p2, p3, p4, p5])
console.log(r2)
</code></pre>
<p>现在改为函数式：</p>
<pre><code class="language-js">const selector = (address, school) =&gt; {
  return (student) =&gt; {
    return student.address === address &amp;&amp; student.school === school
  }
}

const findStudent = (friends, selector) =&gt; {
  return friends.filter(selector)
}

let res = findStudent([p1, p2, p3, p4, p5], selector('中国', '育新小学'))
console.log(res)
</code></pre>
<p>由上可见，面向对象的设计着重于数据与数据之间的关系，函数式则着重于操作如何执行，即行为。二者区别如下：</p>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>函数式</th><th>面向对象</th></tr></thead><tbody>
<tr><td>组合单元</td><td>函数</td><td>对象</td></tr>
<tr><td>编程风格</td><td>声明式</td><td>命令式</td></tr>
<tr><td>数据行为</td><td>独立且怂耦合的纯函数</td><td>与方法紧耦合类</td></tr>
<tr><td>状态管理</td><td>将对象视为不可变的值</td><td>通过实例方法改变对象</td></tr>
<tr><td>流程控制</td><td>函数与递归</td><td>循环与条件</td></tr>
<tr><td>封装性</td><td>一切不可变，没有封装必要</td><td>需要保护数据的完整性</td></tr>
<tr><td>现成安全</td><td>可并发编程</td><td>实现困难</td></tr>
</tbody></table>
</div>
<p>尽管它们之间存在差异，但有效构建应用程序的方法是混合两种范式。一方面，可以使用 与组成类型之间存在自然关系的富领域模型；另一方面，可以拥有一组能够应用于这些类型之上的纯函数。其中界限的确定取决于代码编写者是否对任一编程范式应用自如。由于 JavaScript 既是面向对象的，又是函数式的，因此在编写函数式代码时，需要特别注意控制状态的变化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="021-函数式实现-lambda"><a class="header" href="#021-函数式实现-lambda">02.1-函数式实现-lambda</a></h1>
<h2 id="一-lambda-表达式"><a class="header" href="#一-lambda-表达式">一 lambda 表达式</a></h2>
<p>lambda 演算（Lamda calculus）是一套数理逻辑体系，由可计算的基础函数建立一套形式体系，从而对一些有关计算的基础性数学问题进行表述、研究。</p>
<p>lambda 演算是函数式编程的理论基础。一门编程语言能否被用来进行函数式编程，关键是看其中的函数能不能充当 lambda 表达式，类似 Haskell 这样的编程语言，函数天生就是 lambda 表达式，而 Java 这样的语言不具备这样的能力，采用后来引入的 lambda 功能模拟了表达式的功能。</p>
<p>JavaScript 的语言基因较多，支持多种编程范式：</p>
<ul>
<li>命令式编程：函数是静态创建的功能单元</li>
<li>面向对象编程：函数以方法的形式从属于对象</li>
<li>事件驱动编程：函数用作传递预定义事件的处理逻辑</li>
</ul>
<p>JavaScript 中的函数可以做到任何 lambda 表达式能做的事，具备先天的函数式编程基因。所以在诸多语言加入 lambda 表达式特性时，JavaScript 并未单独引入，而是将类似的语法称为 箭头函数：</p>
<pre><code class="language-js">const name = (p) =&gt; p.fullname
console.log(name(p1))
</code></pre>
<p>采用箭头函数更加简洁短小，且取消了一些面向对象特性，比如：取消 this 绑定、没有 arguments 内置对象等。不过要注意的是：lambda 表达式的应用对象是 lambda 表达式，得到的结果还是 lambda 表达式，相当于一个函数的参数是函数，返回值也是函数。</p>
<p>常用的 map、filter、reduce 等高阶函数与 lambda 表达式能够很好的配合使用。</p>
<h2 id="二-常用高阶函数"><a class="header" href="#二-常用高阶函数">二 常用高阶函数</a></h2>
<h3 id="21-map实现数据变换"><a class="header" href="#21-map实现数据变换">2.1 map()实现数据变换</a></h3>
<p>如下所示，需要从数据源 data 中获取名字数组，那么命令式的操作如下所示：</p>
<pre><code class="language-js">const data = [
  { id: 1, name: 'zs', age: 10 },
  { id: 2, name: 'ryj', age: 11 },
  { id: 3, name: 'ww', age: 13 },
  null,
  { id: 4, name: 'zs', age: 20 },
]

const result = []
for (let i = 0; i &lt; data.length; i++) {
  if (data[i] !== null &amp;&amp; data[i] !== undefined) {
    result.push(data[i].name)
  } else {
    result.push('')
  }
}
console.log(result)
</code></pre>
<p>高阶函数 map 能够将一个迭代函数有序的应用于数组中每个元素，并返回一个长度相等的数组：</p>
<pre><code class="language-js">// fn是处理数组中元素的函数
const map = (arr, fn) =&gt; {
  let result = []
  for (let index = 0; index &lt; arr.length; index++) {
    result.push(fn(arr[index]))
  }
  return result
}
</code></pre>
<p>上述案例如果使用 map 方式获取，则可以修改为：</p>
<pre><code class="language-js">const result = map(data, (s) =&gt; (s !== null &amp;&amp; s !== undefined ? s.name : ''))
console.log(result)
</code></pre>
<h3 id="22-filter实现数据过滤"><a class="header" href="#22-filter实现数据过滤">2.2 filter()实现数据过滤</a></h3>
<p>使用 filter 可以对数据进行清理，根据传入的函数删除一些指定数据：</p>
<pre><code class="language-js">const filter = (arr, predicate) =&gt; {
  const result = []

  for (let index = 0; index &lt; arr.length; index++) {
    if (predicate(arr[index])) {
      result.push(arr[index])
    }
  }

  return result
}
</code></pre>
<p>如下所示删除掉没有写入国家数据的元素：</p>
<pre><code class="language-js">const data = [
  { id: 1, name: 'zs', address: { country: '中国' } },
  { id: 2, name: 'ryj', address: { country: '中国' } },
  { id: 3, name: 'ww', address: { country: '美国' } },
  { id: 4, name: 'zs', address: {} },
]

const res = filter(data, (item) =&gt;
  item.address.country === undefined ? false : true
)
console.log(res)
</code></pre>
<h3 id="23-reduce收集结果"><a class="header" href="#23-reduce收集结果">2.3 reduce()收集结果</a></h3>
<p>高阶函数 reduce 将一个数组中的元素精简为单一的值，该值是由每个元素与一个累积值通过一个函数计算得出的：</p>
<pre><code class="language-js">const reduce = (arr, fn, accumulator) =&gt; {
  if (!accumulator &amp;&amp; arr.length &gt; 0) {
    accumulator = arr[0]
  }

  for (let index = 0; index &lt; arr.length; index++) {
    accumulator = fn(accumulator, arr[index], index, arr)
  }

  return accumulator
}
</code></pre>
<p>比如统计数据源中各个国家的人的数量：</p>
<pre><code class="language-js">const data = [
  { id: 1, name: 'zs', address: { country: '中国' } },
  { id: 2, name: 'ryj', address: { country: '中国' } },
  { id: 3, name: 'ww', address: { country: '美国' } },
  { id: 4, name: 'zs', address: {} },
]

const fn = (stat, p) =&gt; {
  const country = p.address.country
  stat[country] = stat[country] === undefined ? 1 : stat[country] + 1
  return stat
}
let res = reduce(data, fn, {})
console.log(res)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="022-函数式实现-柯里化函数"><a class="header" href="#022-函数式实现-柯里化函数">02.2-函数式实现-柯里化函数</a></h1>
<h2 id="一-柯里化的使用"><a class="header" href="#一-柯里化的使用">一 柯里化的使用</a></h2>
<h3 id="11-柯里化概念"><a class="header" href="#11-柯里化概念">1.1 柯里化概念</a></h3>
<blockquote>
<p>柯里化：把一个多参函数转化为一个嵌套的一元函数的过程</p>
</blockquote>
<p>通俗的说：柯里化函数其实是接受一个函数作为参数，运行后能够返回一个新函数，新的函数能够处理参数函数的剩余参数！</p>
<p>柯里化要求所有的参数都被明确定义，当使用部分参数调用时，会返回一个新的函数，在真正运行之前等待外部提供其余的参数。</p>
<pre><code class="language-js">// 三个参数的柯里化函数定义
curry(f) :: (a, b, c) -&gt; f(a) -&gt; f(b) -&gt; f(c)
</code></pre>
<p>现在假设有一个函数 A，封装好的柯里化函数 curry：</p>
<pre><code class="language-js">// 普通函数A
const A = (a, b, c) =&gt; {}

// 将A柯里化
const curriedA = curry(A)
// 得到的柯里化函数 curriedA 可以处理A的参数，下面的运行结果是一样的
curriedA(1, 2, 3)
curriedA(1, 2)(3)
curriedA(1)(2, 3)
curriedA(1)(2)(3)
A(1, 2, 3)
</code></pre>
<p>注意：JavaScript 语言原生对柯里化不支持，我们可以看到当一个函数的实参不匹配时，会变为 undefined。</p>
<h3 id="12-二元函数的柯里化"><a class="header" href="#12-二元函数的柯里化">1.2 二元函数的柯里化</a></h3>
<p>二元参数实现手动柯里化：</p>
<pre><code class="language-js">function curry(fn) {
  return function (firstArg) {
    return function (secondArg) {
      return fn(firstArg, secondArg)
    }
  }
}
</code></pre>
<p>可以简写为：</p>
<pre><code class="language-js">const curry = (fn) =&gt; (firstArg) =&gt; (secondArg) =&gt; fn(firstArg, secondArg)
</code></pre>
<p>从上看出：柯里化是一种词法作用域（闭包），其返回的函数只不过是一个接收后续参数的简单嵌套函数包装器。示例如下：</p>
<pre><code class="language-js">// 现在有一个普通的函数
const getName = (last, first) =&gt; {
  return `${first} ${last}`
}

// 将getName柯里化
const getNameCurried = curry(getName)

const res1 = getNameCurried('Gim')('Green')
console.log('res: ', res1) // Green Gim
const res2 = getNameCurried('Curry')
console.log('res: ', res2) // ƒ (secondArg) { return fn(firstArg, secondArg)}
</code></pre>
<p>这里可以学习一个 JavaScript 库：<a href="https://github.com/ramda/ramda">https://github.com/ramda/ramda</a>，Ramda.js 拥有众多可用于连接函数式程序的有用函数，并且对纯函数
式编码风格提供了支持，可以很容易地实现参数柯里化、惰性应用和函数组合（参见本章后面的内容）。</p>
<h3 id="13-二元函数柯里化示例"><a class="header" href="#13-二元函数柯里化示例">1.3 二元函数柯里化示例</a></h3>
<p>下面是没有柯里化的表格函数：</p>
<pre><code class="language-js">const table2 = (y) =&gt; 2 * y
const table3 = (y) =&gt; 3 * y
const table4 = (y) =&gt; 4 * y

// 调用方式
table2(4) // 8
table3(4) // 12
table4(4) // 16
</code></pre>
<p>如果将三个表格制作函数统一为一个函数：</p>
<pre><code class="language-js">const genericTable = (x, y) =&gt; x * y

// 调用方式获取table2
genericTable(2, 2) // 4
genericTable(2, 3) // 6
genericTable(2, 4) // 8
</code></pre>
<p>这时候再采用柯里化方式处理获取 table2：</p>
<pre><code class="language-js">const genericTable = (x, y) =&gt; x * y

const table2 = curry(genericTable)(2)
const table3 = curry(genericTable)(3)
const table4 = curry(genericTable)(4)

// 调用
table2(2) // 4
table2(3) // 6
table2(4) // 8
</code></pre>
<h2 id="二-多元函数柯里化"><a class="header" href="#二-多元函数柯里化">二 多元函数柯里化</a></h2>
<h3 id="21-多元函数柯里化处理"><a class="header" href="#21-多元函数柯里化处理">2.1 多元函数柯里化处理</a></h3>
<p>一个命令式的日志函数如下所示：</p>
<pre><code class="language-js">const logs = (mode, msg, err, line) =&gt; {
  if (mode === 'DEBUG') {
    console.debug(`${msg}, ${err} at line: ${line} `)
  } else if (mode === 'ERROR') {
    console.error(`${msg}, ${err} at line: ${line} `)
  } else if (mode === 'WARN') {
    console.warn(`${msg}, ${err} at line: ${line} `)
  } else {
    throw 'Wrong code'
  }
}
</code></pre>
<p>上述函数中，msg、err 都被重复使用了，而且该函数有四个参数，不能使用之前定义的二元的 curry 函数处理。</p>
<p>对于柯里化函数来说，如果提供了所有参数，那么就需要通过传递这些参数执行真正的函数：</p>
<pre><code class="language-js">// 为了后续优化该代码，修改格式为
const curry = (fn) =&gt; {
  // 传入的参数必须是函数
  if (typeof fn !== 'function') {
    throw new Error('No function provided')
  }

  // apply后 args会指向示例函数中的数组 [1,2,3]
  return function curriedFn(...args) {
    return fn.apply(null, args)
  }
}

// 示例
const multiply = (x, y, z) =&gt; x * y * z
curry(multiply)(1, 2, 3) // 6
</code></pre>
<p>那么对于多参函数来说，转换为嵌套的一元函数，就需要根据函数参数的数量递归下去：</p>
<pre><code class="language-js">const curry = (fn) =&gt; {
  if (typeof fn !== 'function') {
    throw Error('No function provided')
  }

  return function curriedFn(...args) {
    // 如果参数没有收集完
    if (args.length &lt; fn.length) {
      return function () {
        return curriedFn.apply(null, args.concat([].slice.call(arguments)))
      }
    }

    return fn.apply(null, args)
  }
}
</code></pre>
<h3 id="22-示例一日志处理函数优化"><a class="header" href="#22-示例一日志处理函数优化">2.2 示例一：日志处理函数优化</a></h3>
<p>2.1 中的日志函数就可以这样处理：</p>
<pre><code class="language-js">const logs = (mode, msg, err, line) =&gt; {
  if (mode === 'DEBUG') {
    console.debug(`${msg}, ${err} at line: ${line} `)
  } else if (mode === 'ERROR') {
    console.error(`${msg}, ${err} at line: ${line} `)
  } else if (mode === 'WARN') {
    console.warn(`${msg}, ${err} at line: ${line} `)
  } else {
    throw 'Wrong code'
  }
}

// 转变
const ErrorLogger = curry(logs)('ERROR')('Error at index.js')
const DebugLogger = curry(logs)('DEBUG')('Error at index.js')
const WarnLogger = curry(logs)('WARN')('Error at index.js')

// 使用
WarnLogger('警告', 23)
ErrorLogger('出错了', 21)
</code></pre>
<h3 id="23-示例二查找数组内容"><a class="header" href="#23-示例二查找数组内容">2.3 示例二：查找数组内容</a></h3>
<p>定义一个查找数组内容的函数：</p>
<pre><code class="language-js">// 柯里化的正则匹配函数
const match = curry((expr, str) =&gt; str.match(expr))

// 柯里化的filter函数
const filter = curry((f, ary) =&gt; ary.filter(f))

// 具体业务：获取数组中带有数值的元素
const findNumersInArray = filter(match(/[0-9]+/))
// 测试
console.log(findNumersInArray(['javascript', 'number1', 'number2'])) //  ['number1', 'number2']
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="023-函数式实现-偏函数"><a class="header" href="#023-函数式实现-偏函数">02.3-函数式实现-偏函数</a></h1>
<h2 id="一-数据流"><a class="header" href="#一-数据流">一 数据流</a></h2>
<h3 id="11-偏应用"><a class="header" href="#11-偏应用">1.1 偏应用</a></h3>
<p>柯里化函数总是在最后接收数组，这样可以很容易做出类似 findNumersInArray 这样的函数，但是如果函数的参数并未被完全使用呢？</p>
<pre><code class="language-js">setTimeout(() =&gt; console.log('do task '), 10)
setTimeout(() =&gt; console.log('do task '), 10)
</code></pre>
<p>以上示例表示每 10 毫秒执行一组操作，参数 10 重复了，如果想要其在代码中隐藏，柯里化不好做到。因为 curry 函数的应用参数列表的顺序是从左到右的。由于我们想根据需要传递函数，并将 10 保存为常量（参数列表的最右边），所以不能以这种方式使用 curry。</p>
<p>变通方案是封装定时器函数，函数参数变味最右边的一个：</p>
<pre><code class="language-js">const setTimeoutWrapper = (time, fn) =&gt; {
  setTimeout(fn, time)
}

// 通过柯里化函数封装一个10毫秒延时
const delayTen = curry(setTimeoutWrapper)(10)
delayTen(() =&gt; console.log('do task '))
delayTen(() =&gt; console.log('do task '))
</code></pre>
<p>以上方案多了一层 wrapper，也就多了一种开销，像这种存在不是为了柯里化函数而设计的函数，可以使用偏函数。</p>
<h3 id="12-偏函数"><a class="header" href="#12-偏函数">1.2 偏函数</a></h3>
<p>偏函数允许开发者部分的应用函数参数，如下所示：</p>
<pre><code class="language-js">const partial = function (fn, ...partialArgs) {
  let args = partialArgs
  return function (...fulllArgs) {
    let arg = 0
    for (let i = 0; i &lt; args.length &amp;&amp; arg &lt; fulllArgs.length; i++) {
      if (!args[i]) {
        args[i] = fulllArgs[arg++]
      }
    }
    return fn.apply(null, args)
  }
}
</code></pre>
<p>解决 setTimeout 问题</p>
<pre><code class="language-js">let delayTen = partial(setTimeout, undefined, 10)
delayTen(() =&gt; console.log('do task '))
</code></pre>
<p>偏函数可以用于任何含有多个参数的函数。</p>
<h3 id="13-示例json-格式化"><a class="header" href="#13-示例json-格式化">1.3 示例：json 格式化</a></h3>
<p>在 JavaScript 中，经常使用下面的函数执行字符串美化操作：</p>
<pre><code class="language-js">let obj = { foo: 'bar', bar: 'foo' }

console.log(JSON.stringify(obj))
</code></pre>
<p>stringify 的最后 2 个参数可以通过偏函数移除样板代码：</p>
<pre><code class="language-js">let obj = { foo: 'bar', bar: 'foo' }

let prettyJson = partial(JSON.stringify, undefined, null, 2)
console.log(prettyJson(obj))
</code></pre>
<p>贴士：这里有 bug，如果用一个不同的参数再次调用 prettyJson 则不能正常工作，因为用参数替换 undefined 值来修改 partialArgs，数组传递的是引用。</p>
<h2 id="二-柯里化与偏函数的选择"><a class="header" href="#二-柯里化与偏函数的选择">二 柯里化与偏函数的选择</a></h2>
<p>类似 map、filter 这种定义，可以使用 curry。</p>
<p>代码中若存在不是为了 curry 函数而设计的函数，可以使用偏函数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="024-函数式实现-组合函数"><a class="header" href="#024-函数式实现-组合函数">02.4-函数式实现-组合函数</a></h1>
<h2 id="一-程序的输出与输入"><a class="header" href="#一-程序的输出与输入">一 程序的输出与输入</a></h2>
<p>在 01.1 章节中，我们制作了这样的函数：</p>
<pre><code class="language-js">const showStudent = run(append('box'), csv, find(db))
</code></pre>
<p>其实 append、csv、find 这些函数的输出作为了 showStudent 的输入，我们称之为组合函数，其本质是：</p>
<p><strong>每个程序的输出应该是另外一个程序的输入</strong>。</p>
<h2 id="二-组合函数-1"><a class="header" href="#二-组合函数-1">二 组合函数</a></h2>
<h3 id="21-组合函数创建"><a class="header" href="#21-组合函数创建">2.1 组合函数创建</a></h3>
<p>根据组合函数的定义创建一个组合函数，其要求无非是：该函数接收一个函数的输出，并将其用作输入以传递给另外一个函数。</p>
<pre><code class="language-js">const compose = (a, b) =&gt; {
  return (c) =&gt; a(b(c))
}
</code></pre>
<p>compose 函数接收两个参数：函数 a 和函数 b，返回一个接收 c 为参数的函数。compose 函数将用输入 c 调用函数 b，b 的输出作为 a 的输入使用。</p>
<p>贴士：这里可以看出，先执行了 b，再执行了 a，自行的顺序是从右到左。</p>
<h3 id="22-使用示例"><a class="header" href="#22-使用示例">2.2 使用示例</a></h3>
<p>假设现在给定了字符串类型的数据，要对其四舍五入求值，那么可以先转换为浮点型，再调用 round 方法即可：</p>
<pre><code class="language-js">let data = parseFloat('3.14')
let number = Math.round(data)
console.log(number)
</code></pre>
<p>其实我们可以看到 parseFloat 的结果作为输入传递给了 round 方法：</p>
<pre><code class="language-js">let numberComposed = compose(Math.round, parseFloat)
// 等价于 numberComposed = c =&gt; Math.round(parseFloat(c))
let number = numberComposed('3.14')
console.log(number)
</code></pre>
<p>上面的过程就是函数式组合：将两个函数组合在一起构建出一个全新的函数。</p>
<h3 id="23-多参数下引入柯里化或者偏函数"><a class="header" href="#23-多参数下引入柯里化或者偏函数">2.3 多参数下引入柯里化或者偏函数</a></h3>
<p>2.1 给出的组合函数，是仅当接收一个参数时，才能将两个函数组合起来，当参数较多时，需要引入柯里化函数或者偏函数来实现。</p>
<p>获取评分高于 4.5 的图书的标题和作者：</p>
<pre><code class="language-js">const apressBooks = [
  {
    id: 1,
    title: 'title1',
    author: 'author1',
    rating: [4.7],
    reviews: [{ good: 4, excellent: 12 }],
  },
  { id: 2, title: 'title2', author: 'author2', rating: [4.5], reviews: [] },
  { id: 3, title: 'title3', author: 'author3', rating: [4.2], reviews: [] },
  {
    id: 4,
    title: 'title3',
    author: 'author4',
    rating: [4.0],
    reviews: [{ good: 14, excellent: 12 }],
  },
]

// 定义一些过滤图书的小函数
const filterOutStandingBooks = (book) =&gt; book.rating[0] === 5
const filterGoodBooks = (book) =&gt; book.rating[0] &gt; 4.5
const filterBadBooks = (book) =&gt; book.rating[0] &lt; 3.5

// 定义投影函数
const projectTitleAndAuthor = (book) =&gt; {
  return { title: book.title, author: book.author }
}
const projectTitle = (book) =&gt; {
  return { title: book.title }
}
const projectAuthor = (book) =&gt; {
  return { author: book.author }
}

// 获取评分高于4.5的图书的标题和作者
const queryGoodBooks = partial(filter, undefined, filterGoodBooks)
const mapTitleAndAuthor = partial(map, undefined, projectTitleAndAuthor)
const titleAndAuthorForGoodBooks = compose(mapTitleAndAuthor, queryGoodBooks)

console.log(titleAndAuthorForGoodBooks(apressBooks))
</code></pre>
<h2 id="三-组合多个函数"><a class="header" href="#三-组合多个函数">三 组合多个函数</a></h2>
<p>在上一章节中提供的 compose 函数只能处理 2 个给定的函数，如果要处理多个函数，则需要始终记住：把每个函数的输出用作输入发送给另外一个函数。借助 reduce 函数，逐次归约多个函数调用即可：</p>
<pre><code class="language-js">// 通过 reverse反转函数数组，传入函数  (acc, fn) =&gt; fn(acc))
const composeN = (...fns) =&gt; {
  return (value) =&gt; reduce(fns.reverse(), (acc, fn) =&gt; fn(acc), value)
}
</code></pre>
<p>示例：判断一个给定字符串的单词数，是偶数还是奇数。</p>
<pre><code class="language-js">const splitIntoSpaces = (str) =&gt; str.split(' ')
const count = (arr) =&gt; arr.length

// 计算单词数
const countWords = compose(count, splitIntoSpaces)

// 计算单词数示例
let words = 'hello your reading about composition'
console.log(countWords(words)) // 5

// 判断奇偶
const oddOrEven = (ip) =&gt; (ip % 2 === 0 ? 'even' : 'odd')
const oddOrEvenWords = composeN(oddOrEven, count, splitIntoSpaces)

console.log(oddOrEvenWords(words)) // odd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="024-函数式实现-管道"><a class="header" href="#024-函数式实现-管道">02.4-函数式实现-管道</a></h1>
<h2 id="一-管道的概念"><a class="header" href="#一-管道的概念">一 管道的概念</a></h2>
<p>在 Linux 中提供了一个管道操作符 <code>|</code>，还有一个命令 grep 在文本内搜索指定内容并显示内容。首先创建一个 demo.txt，内容如下：</p>
<pre><code class="language-txt">hello
world
order
</code></pre>
<p>现在我们要实现使用 cat 命令读取到 demo.txt ，接着让 grep 来查找并显示这个文本中包含 or 字符串的行，那么命令就是：</p>
<pre><code class="language-shell">cat demo.txt | grep 'or'
</code></pre>
<p>原本如果要在文本中查询 or 字符串的行，使用 grep 的完整命令是： <code>grep 'or' demo.txt</code>，但是上述命令无需输入文本名，这是因为管道操作符左侧之前的 cat 程序读取到了文本，通过管道将其作为输入传递给了 grep 程序，grep 程序已经拿到文本！</p>
<p>甚至可以继续利用管道计算字符串出现的次数：</p>
<pre><code class="language-shell"># wc 用于获取单词数量
cat demo.txt | grep 'or' | wc
</code></pre>
<p>管道操作符其实也传递了这样的信息：<strong>每个程序的输出应该是另外一个程序的输入</strong>。只不过组合函数 compose 的数据流是从右至左的，因为最右侧的函数最先执行，而管道的函数是左侧函数最先执行！</p>
<h2 id="二-管道的使用"><a class="header" href="#二-管道的使用">二 管道的使用</a></h2>
<h3 id="21-管道函数-pipe"><a class="header" href="#21-管道函数-pipe">2.1 管道函数 pipe</a></h3>
<p>pipe 函数其实就是 compose 函数的变体，唯一改动的地方是数据流：</p>
<pre><code class="language-js">const pipe = (...fns) =&gt; {
  return (value) =&gt; reduce(fns, (acc, fn) =&gt; fn(acc), value)
}
</code></pre>
<p>使用管道函数替代组合函数的案例：</p>
<pre><code class="language-js">const splitIntoSpaces = (str) =&gt; str.split(' ')
const count = (arr) =&gt; arr.length

// 计算单词数
const countWords = compose(count, splitIntoSpaces)

// 计算单词数示例
let words = 'hello your reading about composition'
console.log(countWords(words)) // 5

// 判断奇偶
const oddOrEven = (ip) =&gt; (ip % 2 === 0 ? 'even' : 'odd')
const oddOrEvenWords = pipe(splitIntoSpaces, count, oddOrEven)

console.log(oddOrEvenWords(words)) // odd
</code></pre>
<p>贴士： 管道与组合函数我个人认为仅仅风格喜好上的不同。</p>
<h2 id="三-管道函数组合函数与链式操作对比"><a class="header" href="#三-管道函数组合函数与链式操作对比">三 管道函数、组合函数与链式操作对比</a></h2>
<p>在方法链接中，代码类似：</p>
<pre><code class="language-js">_chain(names)
    .filter(isValid)
    .map()
    ...
</code></pre>
<p>这样的链式语法比起命令式极大提高了可读性，但是这些方法都与其所属的对象紧紧耦合在了一起，限制了链中可用的方法数量，也限制了代码的表现力。除了方法链，还可以使用管道的方法来连接函数，相较而言，他们的特点如下：</p>
<ul>
<li>方法链接：紧耦合，表现力有限</li>
<li>管道：松耦合，更加灵活</li>
</ul>
<p>在函数式编程中，函数是输入和输出类型之间的数学映射，假定一个函数 isEmpty，接收一个字符串，返回衣蛾布尔值，使用符号表示则为：</p>
<pre><code class="language-txt">isEmpty :: String -&gt; Boolean
</code></pre>
<p>该函数是是 String 类型输入值到 Boolean 值之间的引用透明映射，其 JavaScript 的 lambda 描述形式为：</p>
<pre><code class="language-js">const isEmpty = (s) =&gt; !s || !s.trim()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="026-函数式实现-函子"><a class="header" href="#026-函数式实现-函子">02.6-函数式实现-函子</a></h1>
<h2 id="一-函子实现"><a class="header" href="#一-函子实现">一 函子实现</a></h2>
<h3 id="11-函子的概念"><a class="header" href="#11-函子的概念">1.1 函子的概念</a></h3>
<blockquote>
<p>函子：函子（Functor）是一个普通对象（或者说一个类），它实现了 map 函数，在遍历每个对象值的时候生成了一个新的对象</p>
</blockquote>
<p>简单来说，函子就是一个持有值的容器，如下所示：</p>
<pre><code class="language-js">class Container {
  constructor(value) {
    this.value = value
  }

  static of(value) {
    return new Container(value)
  }
}
</code></pre>
<p>从上看出，如果要让容器持有值，使用 new 创建实例，或者 of 静态方法即可。甚至来说传入的 value 也是 Container 的另外一个实例。</p>
<p>这种实现了 of 契约接口的函子称为 <strong>Pointed 函子</strong>。of 方法不是用来避免使用 new 关键字的， 而是用来把值放到默认最小化上下文（ default minimalcontext） 中的。</p>
<h3 id="12-函子的-map-方法"><a class="header" href="#12-函子的-map-方法">1.2 函子的 map 方法</a></h3>
<p>简单实现 map 方法，用来处理 Container 中持有的数据：</p>
<pre><code class="language-js">    map(fn) {
        return Container.of(fn(this.value))
    }
</code></pre>
<p>示例：将函子内的数据翻倍：</p>
<pre><code class="language-js">const doubleNum = (num) =&gt; num * 2

let res = Container.of(3).map(doubleNum)

console.log(res) // Container {value: 6}
</code></pre>
<h2 id="二-maybe-函子"><a class="header" href="#二-maybe-函子">二 Maybe 函子</a></h2>
<h3 id="21-maybe-函子概念"><a class="header" href="#21-maybe-函子概念">2.1 Maybe 函子概念</a></h3>
<p>Maybe 既然是一个函子，就意味着他实现了 map，只不过在实现上有所不同，Maybe 函子可以持有任何值，不用担心异常：</p>
<pre><code class="language-js">class MayBe extends Container {
  static of(value) {
    return new MayBe(value)
  }
  isNothing() {
    return this.value === null || this.value === undefined
  }
  map(fn) {
    return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this.value))
  }
}
</code></pre>
<p>我们可以看到 Maybe 函子的 map 与简单函子的 map 很像，只是先检查了容器中的值是否存在，所以 Maybe 函子可以为错误处理提供一个抽象：</p>
<pre><code class="language-js">const upper = (x) =&gt; x.toUpperCase()

// 使用简单函子报错：null上不存在 toUpperCase
// let res = Container.of(null).map(upper)

// 使用Maybe函子后，不会报错
let res = MayBe.of(null).map(upper)
console.log(res) // MayBe {value: null}
</code></pre>
<p>这里如果我们采用链式调用，出现了 null 值也是没有问题的：</p>
<pre><code class="language-js">const upper = (x) =&gt; x.toUpperCase()

let res = MayBe.of('hello ')
  .map(upper)
  .map(() =&gt; null)
  .map((x) =&gt; x + ' WORLD!')
console.log(res) // MayBe {value: null}
</code></pre>
<p>而且我们会发现，即使出现了 null 错误，所有的 map 函数都被调用了。</p>
<h3 id="22-maybe-函子示例"><a class="header" href="#22-maybe-函子示例">2.2 Maybe 函子示例</a></h3>
<p>下面是一个获取一个数据信息的模拟接口，根据传入的类型不同，获取的结果不同：</p>
<pre><code class="language-js">const fetchData = (type) =&gt; {
  if (!type || type != 'new') {
    return new Error('参数错误')
  }

  return {
    kind: 'Listing',
    data: {
      modash: '',
      children: [
        {
          kind: 't3',
          data: {
            url: '/demo.com/2002',
            title: 'JavaScript',
          },
        },
      ],
      after: 't4',
      before: null,
    },
  }
}
</code></pre>
<p>接着使用 MayBe 函子来获取该数据：</p>
<pre><code class="language-js">const getData = (type) =&gt; {
  return MayBe.of(fetchData(type))
    .map((arr) =&gt; arr['data'])
    .map((arr) =&gt; arr['children'])
    .map((arr) =&gt;
      map(arr, (x) =&gt; {
        return {
          title: x['data'].title,
          url: x['data'].url,
        }
      })
    )
}

console.log(getData('new'))
// MayBe{
//     &quot;value&quot;: [
//         {
//             &quot;title&quot;: &quot;JavaScript&quot;,
//             &quot;url&quot;: &quot;/demo.com/2002&quot;
//         }
//     ]
// }
</code></pre>
<p>示例中的优秀之处在于：在逻辑流中处理了可能引发 null、undefined 错误的意外输入，比如：</p>
<pre><code class="language-js">console.log(getData()) //MayBe {value: null}
</code></pre>
<h2 id="三-either-函子"><a class="header" href="#三-either-函子">三 Either 函子</a></h2>
<h3 id="31-either-函子概念"><a class="header" href="#31-either-函子概念">3.1 Either 函子概念</a></h3>
<p>Either 函子能够解决分支脱战问题（branching-out problem），即可以知道在哪个分支环节出了问题。</p>
<pre><code class="language-js">class Nothing extends Container {
  static of(value) {
    return new Nothing(value)
  }

  // 不再执行给定函数
  map(fn) {
    return this
  }
}

class Some extends Container {
  static of(value) {
    return new Some(value)
  }
  map(fn) {
    return Some.of(fn(this.value))
  }
}

const Either = {
  Nothing,
  Some,
}
</code></pre>
<p>直接使用 Nothing 和 Some：</p>
<pre><code class="language-js">console.log(Nothing.of('test').map((x) =&gt; x.toUpperCase())) // Nothing {value: 'test'}
console.log(Some.of('test').map((x) =&gt; x.toUpperCase())) // Some {value: 'TEST'}
</code></pre>
<p>可见 Nothing 未做任何处理，和普通函子类似。</p>
<h3 id="32-either-函子示例"><a class="header" href="#32-either-函子示例">3.2 Either 函子示例</a></h3>
<p>现在使用 Either 函子处理 MayBe 函子中的 fetchData：</p>
<pre><code class="language-js">const fetchData = (type) =&gt; {
  if (!type || type != 'new') {
    return Either.Nothing.of({
      message: '参数错误',
    })
  }

  return Either.Some.of({
    kind: 'Listing',
    data: {
      modash: '',
      children: [
        {
          kind: 't3',
          data: {
            url: '/demo.com/2002',
            title: 'JavaScript',
          },
        },
      ],
      after: 't4',
      before: null,
    },
  })
}

const getData = (type) =&gt; {
  return fetchData(type)
    .map((arr) =&gt; arr['data'])
    .map((arr) =&gt; arr['children'])
    .map((arr) =&gt;
      map(arr, (x) =&gt; {
        return {
          title: x['data'].title,
          url: x['data'].url,
        }
      })
    )
}

console.log(getData('new')) // Some {value: Array(1)}
console.log(getData()) // Nothing {value: {message: '参数错误'} }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="027-函数式实现-monad-函子"><a class="header" href="#027-函数式实现-monad-函子">02.7-函数式实现-Monad 函子</a></h1>
<h2 id="一-monad-函子概念"><a class="header" href="#一-monad-函子概念">一 Monad 函子概念</a></h2>
<p>Monad 函子即是一个含有 chain 方法的函子，我们可以在 MayBe 函子的基础上添加 chain 方法，使其成为 Monad 函子。</p>
<h2 id="二-monad-函子实现"><a class="header" href="#二-monad-函子实现">二 Monad 函子实现</a></h2>
<h3 id="21-传统拼接的实现"><a class="header" href="#21-传统拼接的实现">2.1 传统拼接的实现</a></h3>
<p>假设前一章节的返回结果仍然如下所示：</p>
<pre><code class="language-js">const fetchData = (type) =&gt; {
  if (!type || type != 'new') {
    return {
      message: '参数错误',
    }
  }

  return {
    kind: 'Listing',
    data: {
      modash: '',
      children: [
        {
          kind: 't3',
          data: {
            url: '/demo.com/2002',
            title: 'JavaScript',
            link: '/www.demo2.com/2002',
          },
        },
        {
          kind: 't4',
          data: {
            url: '/demo.com/2003',
            title: 'CSS',
            link: '/www.demo2.com/2003',
          },
        },
      ],
      after: 't4',
      before: null,
    },
  }
}
</code></pre>
<p>我们除了要获取该接口数据，还要根据 children 中每个元素的 link 去获取 comment 列表数据，最终的返回结果如下：</p>
<pre><code class="language-json">{
  &quot;title&quot;: &quot;JavaScript&quot;,
  &quot;comment&quot;: [{}, {}, {}]
}
</code></pre>
<p>这时候拼接方案是：</p>
<pre><code class="language-js">// 根据上述返回的结果的link获取评论数据
const fetchComment = (link) =&gt; {
  if (!link) {
    return {
      message: 'link错误',
    }
  }
  return [{ comment: 'good' }, { comment: 'bad' }]
}

// 合并上述2个请求函数
let mergeMayBe = (id) =&gt; {
  let data = MayBe.of(fetchData(id))
  let ans = data
    .map((arr) =&gt; arr['data'])
    .map((arr) =&gt; arr['children'])
    .map((arr) =&gt;
      map(arr, (x) =&gt; {
        return {
          title: x['data'].title,
          link: x['data'].link,
        }
      })
    )
    .map((obj) =&gt; {
      console.log('obj==', obj)
      return map(obj, (x) =&gt; {
        console.log('x==', x)
        console.log('fecthC==', MayBe.of(fetchComment(x.link)))
        return {
          title: x.title,
          comments: MayBe.of(fetchComment(x.link)),
        }
      })
    })
  return ans
}

console.log(mergeMayBe(1))
//MayBe  {
//     &quot;value&quot;: [
//         {
//             &quot;title&quot;: &quot;JavaScript&quot;,
//             &quot;comments&quot;: {
//                 &quot;value&quot;: [
//                     {
//                         &quot;comment&quot;: &quot;good&quot;
//                     },
//                     {
//                         &quot;comment&quot;: &quot;bad&quot;
//                     }
//                 ]
//             }
//         }
//     ]
// }

console.log(mergeMayBe()) //MayBe {value: null}
</code></pre>
<h3 id="22-join-方法"><a class="header" href="#22-join-方法">2.2 join 方法</a></h3>
<p>2.1 演示的案例，多次调用了 map，使程序变得繁琐。而且在获取结果上也不容易扩展，假设我们只需要获取一条具体的 comment 数据，则还需要在上述 map 之后再次 map。</p>
<p>为 MayBe 函子添加 join 方法，可以方便打开嵌套：</p>
<pre><code class="language-js">    join() {
        return this.isNothing() ? MayBe.of(null) : this.value
    }
</code></pre>
<p>利用将嵌套的结构展开为单一的层级：</p>
<pre><code class="language-js">let demo = MayBe.of(MayBe.of(5))
console.log(demo) //MayBe {value: MayBe}

let demoWithJoin = demo.join()
console.log(demoWithJoin) //MayBe {value: 5}
</code></pre>
<p>假设需要将 demo 中的 value 加 4：</p>
<pre><code class="language-js">let demo = MayBe.of(MayBe.of(5))

let res1 = demo.map((item) =&gt; {
  return item.map((value) =&gt; value + 4)
})
console.log(res1)
// MayBe{
//     &quot;value&quot;: MayBe{
//         &quot;value&quot;: 9
//     }
// }

// 换一个方式
let res2 = demo.join().map((v) =&gt; v + 4)
console.log(res2) // MayBe {value: 9}
</code></pre>
<p>这样代码就很优雅了，返回的结构被打平了。现在修正 mergeMayBe 方法：</p>
<pre><code class="language-js">let mergeMayBeWithJoin = (id) =&gt; {
  let data = MayBe.of(fetchData(id))
  let ans = data
    .map((arr) =&gt; arr['data'])
    .map((arr) =&gt; arr['children'])
    .map((arr) =&gt;
      map(arr, (x) =&gt; {
        return {
          title: x['data'].title,
          link: x['data'].link,
        }
      })
    )
    .map((obj) =&gt; {
      return map(obj, (x) =&gt; {
        return {
          title: x.title,
          comments: MayBe.of(fetchComment(x.link).join()),
        }
      })
    })
    .join()
  return ans
}

console.log(mergeMayBeWithJoin(1))
// [{&quot;title&quot;: &quot;JavaScript&quot;,&quot;comments&quot;: {&quot;value&quot;: &quot;[object Object],[object Object]&quot;} }]
</code></pre>
<h3 id="23-chain-方法"><a class="header" href="#23-chain-方法">2.3 chain 方法</a></h3>
<p>2.2 封装后，总是要在 map 后调用 join，可以对该逻辑进一步封装，制作为 MayBe 函子的 chain 方法：</p>
<pre><code class="language-js">    chain(f) {
        return this.map(f).join()
    }
</code></pre>
<p>获取 comment 的示例使用 chain 改造的结果：</p>
<pre><code class="language-js">let mergeMayBeWithChain = (id) =&gt; {
  let data = MayBe.of(fetchData(id))
  let ans = data
    .map((arr) =&gt; arr['data'])
    .map((arr) =&gt; arr['children'])
    .map((arr) =&gt;
      map(arr, (x) =&gt; {
        return {
          title: x['data'].title,
          link: x['data'].link,
        }
      })
    )
    .chain((obj) =&gt; {
      return map(obj, (x) =&gt; {
        return {
          title: x.title,
          comments: MayBe.of(fetchComment(x.link).join()),
        }
      })
    })

  return ans
}

console.log(mergeMayBeWithChain(1))
// [{&quot;title&quot;: &quot;JavaScript&quot;,&quot;comments&quot;: {&quot;value&quot;: &quot;[object Object],[object Object]&quot;} }]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="011-单例模式"><a class="header" href="#011-单例模式">01.1-单例模式</a></h1>
<h2 id="一-单例模式概念"><a class="header" href="#一-单例模式概念">一 单例模式概念</a></h2>
<blockquote>
<p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
</blockquote>
<p>有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的 window 对象等。在 JavaScript 开发中，单例模式的用途同样非常广泛。比如：当我
们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。</p>
<h2 id="二-单例模式的实现"><a class="header" href="#二-单例模式的实现">二 单例模式的实现</a></h2>
<h3 id="21-简单实现"><a class="header" href="#21-简单实现">2.1 简单实现</a></h3>
<pre><code class="language-js">class Singleton {
  constructor() {
    this.instance = null
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new Singleton()
    }
    return this.instance
  }
}

const s1 = Singleton.getInstance()
const s2 = Singleton.getInstance()

// true
console.log(s1 === s2)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
